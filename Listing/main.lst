L 1 "..\..\User\main.c"
N
N  
N#include "stm32f10x.h"
L 1 "..\..\Libraries\CMSIS\stm32f10x.h" 1
N/**
N  ******************************************************************************
N  * @file    stm32f10x.h
N  * @author  MCD Application Team
N  * @version V3.5.0
N  * @date    11-March-2011
N  * @brief   CMSIS Cortex-M3 Device Peripheral Access Layer Header File. 
N  *          This file contains all the peripheral register's definitions, bits 
N  *          definitions and memory mapping for STM32F10x Connectivity line, 
N  *          High density, High density value line, Medium density, 
N  *          Medium density Value line, Low density, Low density Value line 
N  *          and XL-density devices.
N  *
N  *          The file is the unique include file that the application programmer
N  *          is using in the C source code, usually in main.c. This file contains:
N  *           - Configuration section that allows to select:
N  *              - The device used in the target application
N  *              - To use or not the peripheral’s drivers in application code(i.e. 
N  *                code will be based on direct access to peripheral’s registers 
N  *                rather than drivers API), this option is controlled by 
N  *                "#define USE_STDPERIPH_DRIVER"
N  *              - To change few application-specific parameters such as the HSE 
N  *                crystal frequency
N  *           - Data structures and the address mapping for all peripherals
N  *           - Peripheral's registers declarations and bits definition
N  *           - Macros to access peripheral’s registers hardware
N  *
N  ******************************************************************************
N  * @attention
N  *
N  * THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
N  * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE
N  * TIME. AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY
N  * DIRECT, INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING
N  * FROM THE CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE
N  * CODING INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
N  *
N  * <h2><center>&copy; COPYRIGHT 2011 STMicroelectronics</center></h2>
N  ******************************************************************************
N  */
N
N/** @addtogroup CMSIS
N  * @{
N  */
N
N/** @addtogroup stm32f10x
N  * @{
N  */
N    
N#ifndef __STM32F10x_H
N#define __STM32F10x_H
N
N#ifdef __cplusplus
S extern "C" {
N#endif 
N  
N/** @addtogroup Library_configuration_section
N  * @{
N  */
N  
N/* Uncomment the line below according to the target STM32 device used in your
N   application 
N  */
N
N#if !defined (STM32F10X_LD) && !defined (STM32F10X_LD_VL) && !defined (STM32F10X_MD) && !defined (STM32F10X_MD_VL) && !defined (STM32F10X_HD) && !defined (STM32F10X_HD_VL) && !defined (STM32F10X_XL) && !defined (STM32F10X_CL) 
X#if !0L && !0L && !0L && !0L && !1L && !0L && !0L && !0L 
S  /* #define STM32F10X_LD */     /*!< STM32F10X_LD: STM32 Low density devices */
S  /* #define STM32F10X_LD_VL */  /*!< STM32F10X_LD_VL: STM32 Low density Value Line devices */  
S  /* #define STM32F10X_MD */     /*!< STM32F10X_MD: STM32 Medium density devices */
S  /* #define STM32F10X_MD_VL */  /*!< STM32F10X_MD_VL: STM32 Medium density Value Line devices */  
S  /* #define STM32F10X_HD */     /*!< STM32F10X_HD: STM32 High density devices */
S  /* #define STM32F10X_HD_VL */  /*!< STM32F10X_HD_VL: STM32 High density value line devices */  
S  /* #define STM32F10X_XL */     /*!< STM32F10X_XL: STM32 XL-density devices */
S  /* #define STM32F10X_CL */     /*!< STM32F10X_CL: STM32 Connectivity line devices */
N#endif
N/*  Tip: To avoid modifying this file each time you need to switch between these
N        devices, you can define the device in your toolchain compiler preprocessor.
N
N - Low-density devices are STM32F101xx, STM32F102xx and STM32F103xx microcontrollers
N   where the Flash memory density ranges between 16 and 32 Kbytes.
N - Low-density value line devices are STM32F100xx microcontrollers where the Flash
N   memory density ranges between 16 and 32 Kbytes.
N - Medium-density devices are STM32F101xx, STM32F102xx and STM32F103xx microcontrollers
N   where the Flash memory density ranges between 64 and 128 Kbytes.
N - Medium-density value line devices are STM32F100xx microcontrollers where the 
N   Flash memory density ranges between 64 and 128 Kbytes.   
N - High-density devices are STM32F101xx and STM32F103xx microcontrollers where
N   the Flash memory density ranges between 256 and 512 Kbytes.
N - High-density value line devices are STM32F100xx microcontrollers where the 
N   Flash memory density ranges between 256 and 512 Kbytes.   
N - XL-density devices are STM32F101xx and STM32F103xx microcontrollers where
N   the Flash memory density ranges between 512 and 1024 Kbytes.
N - Connectivity line devices are STM32F105xx and STM32F107xx microcontrollers.
N  */
N
N#if !defined (STM32F10X_LD) && !defined (STM32F10X_LD_VL) && !defined (STM32F10X_MD) && !defined (STM32F10X_MD_VL) && !defined (STM32F10X_HD) && !defined (STM32F10X_HD_VL) && !defined (STM32F10X_XL) && !defined (STM32F10X_CL)
X#if !0L && !0L && !0L && !0L && !1L && !0L && !0L && !0L
S #error "Please select first the target STM32F10x device used in your application (in stm32f10x.h file)"
N#endif
N
N#if !defined  USE_STDPERIPH_DRIVER
X#if !1L
S/**
S * @brief Comment the line below if you will not use the peripherals drivers.
S   In this case, these drivers will not be included and the application code will 
S   be based on direct access to peripherals registers 
S   */
S  /*#define USE_STDPERIPH_DRIVER*/
N#endif
N
N/**
N * @brief In the following line adjust the value of External High Speed oscillator (HSE)
N   used in your application 
N   
N   Tip: To avoid modifying this file each time you need to use different HSE, you
N        can define the HSE value in your toolchain compiler preprocessor.
N  */           
N#if !defined  HSE_VALUE
X#if !0L
N #ifdef STM32F10X_CL   
S  #define HSE_VALUE    ((uint32_t)25000000) /*!< Value of the External oscillator in Hz */
N #else 
N  #define HSE_VALUE    ((uint32_t)8000000) /*!< Value of the External oscillator in Hz */
N #endif /* STM32F10X_CL */
N#endif /* HSE_VALUE */
N
N
N/**
N * @brief In the following line adjust the External High Speed oscillator (HSE) Startup 
N   Timeout value 
N   */
N#define HSE_STARTUP_TIMEOUT   ((uint16_t)0x0500) /*!< Time out for HSE start up */
N
N#define HSI_VALUE    ((uint32_t)8000000) /*!< Value of the Internal oscillator in Hz*/
N
N/**
N * @brief STM32F10x Standard Peripheral Library version number
N   */
N#define __STM32F10X_STDPERIPH_VERSION_MAIN   (0x03) /*!< [31:24] main version */                                  
N#define __STM32F10X_STDPERIPH_VERSION_SUB1   (0x05) /*!< [23:16] sub1 version */
N#define __STM32F10X_STDPERIPH_VERSION_SUB2   (0x00) /*!< [15:8]  sub2 version */
N#define __STM32F10X_STDPERIPH_VERSION_RC     (0x00) /*!< [7:0]  release candidate */ 
N#define __STM32F10X_STDPERIPH_VERSION       ( (__STM32F10X_STDPERIPH_VERSION_MAIN << 24)\
N                                             |(__STM32F10X_STDPERIPH_VERSION_SUB1 << 16)\
N                                             |(__STM32F10X_STDPERIPH_VERSION_SUB2 << 8)\
N                                             |(__STM32F10X_STDPERIPH_VERSION_RC))
X#define __STM32F10X_STDPERIPH_VERSION       ( (__STM32F10X_STDPERIPH_VERSION_MAIN << 24)                                             |(__STM32F10X_STDPERIPH_VERSION_SUB1 << 16)                                             |(__STM32F10X_STDPERIPH_VERSION_SUB2 << 8)                                             |(__STM32F10X_STDPERIPH_VERSION_RC))
N
N/**
N  * @}
N  */
N
N/** @addtogroup Configuration_section_for_CMSIS
N  * @{
N  */
N
N/**
N * @brief Configuration of the Cortex-M3 Processor and Core Peripherals 
N */
N#ifdef STM32F10X_XL
S #define __MPU_PRESENT             1 /*!< STM32 XL-density devices provide an MPU */
N#else
N #define __MPU_PRESENT             0 /*!< Other STM32 devices does not provide an MPU */
N#endif /* STM32F10X_XL */
N#define __NVIC_PRIO_BITS          4 /*!< STM32 uses 4 Bits for the Priority Levels    */
N#define __Vendor_SysTickConfig    0 /*!< Set to 1 if different SysTick Config is used */
N
N/**
N * @brief STM32F10x Interrupt Number Definition, according to the selected device 
N *        in @ref Library_configuration_section 
N */
Ntypedef enum IRQn
N{
N/******  Cortex-M3 Processor Exceptions Numbers ***************************************************/
N  NonMaskableInt_IRQn         = -14,    /*!< 2 Non Maskable Interrupt                             */
N  MemoryManagement_IRQn       = -12,    /*!< 4 Cortex-M3 Memory Management Interrupt              */
N  BusFault_IRQn               = -11,    /*!< 5 Cortex-M3 Bus Fault Interrupt                      */
N  UsageFault_IRQn             = -10,    /*!< 6 Cortex-M3 Usage Fault Interrupt                    */
N  SVCall_IRQn                 = -5,     /*!< 11 Cortex-M3 SV Call Interrupt                       */
N  DebugMonitor_IRQn           = -4,     /*!< 12 Cortex-M3 Debug Monitor Interrupt                 */
N  PendSV_IRQn                 = -2,     /*!< 14 Cortex-M3 Pend SV Interrupt                       */
N  SysTick_IRQn                = -1,     /*!< 15 Cortex-M3 System Tick Interrupt                   */
N
N/******  STM32 specific Interrupt Numbers *********************************************************/
N  WWDG_IRQn                   = 0,      /*!< Window WatchDog Interrupt                            */
N  PVD_IRQn                    = 1,      /*!< PVD through EXTI Line detection Interrupt            */
N  TAMPER_IRQn                 = 2,      /*!< Tamper Interrupt                                     */
N  RTC_IRQn                    = 3,      /*!< RTC global Interrupt                                 */
N  FLASH_IRQn                  = 4,      /*!< FLASH global Interrupt                               */
N  RCC_IRQn                    = 5,      /*!< RCC global Interrupt                                 */
N  EXTI0_IRQn                  = 6,      /*!< EXTI Line0 Interrupt                                 */
N  EXTI1_IRQn                  = 7,      /*!< EXTI Line1 Interrupt                                 */
N  EXTI2_IRQn                  = 8,      /*!< EXTI Line2 Interrupt                                 */
N  EXTI3_IRQn                  = 9,      /*!< EXTI Line3 Interrupt                                 */
N  EXTI4_IRQn                  = 10,     /*!< EXTI Line4 Interrupt                                 */
N  DMA1_Channel1_IRQn          = 11,     /*!< DMA1 Channel 1 global Interrupt                      */
N  DMA1_Channel2_IRQn          = 12,     /*!< DMA1 Channel 2 global Interrupt                      */
N  DMA1_Channel3_IRQn          = 13,     /*!< DMA1 Channel 3 global Interrupt                      */
N  DMA1_Channel4_IRQn          = 14,     /*!< DMA1 Channel 4 global Interrupt                      */
N  DMA1_Channel5_IRQn          = 15,     /*!< DMA1 Channel 5 global Interrupt                      */
N  DMA1_Channel6_IRQn          = 16,     /*!< DMA1 Channel 6 global Interrupt                      */
N  DMA1_Channel7_IRQn          = 17,     /*!< DMA1 Channel 7 global Interrupt                      */
N
N#ifdef STM32F10X_LD
S  ADC1_2_IRQn                 = 18,     /*!< ADC1 and ADC2 global Interrupt                       */
S  USB_HP_CAN1_TX_IRQn         = 19,     /*!< USB Device High Priority or CAN1 TX Interrupts       */
S  USB_LP_CAN1_RX0_IRQn        = 20,     /*!< USB Device Low Priority or CAN1 RX0 Interrupts       */
S  CAN1_RX1_IRQn               = 21,     /*!< CAN1 RX1 Interrupt                                   */
S  CAN1_SCE_IRQn               = 22,     /*!< CAN1 SCE Interrupt                                   */
S  EXTI9_5_IRQn                = 23,     /*!< External Line[9:5] Interrupts                        */
S  TIM1_BRK_IRQn               = 24,     /*!< TIM1 Break Interrupt                                 */
S  TIM1_UP_IRQn                = 25,     /*!< TIM1 Update Interrupt                                */
S  TIM1_TRG_COM_IRQn           = 26,     /*!< TIM1 Trigger and Commutation Interrupt               */
S  TIM1_CC_IRQn                = 27,     /*!< TIM1 Capture Compare Interrupt                       */
S  TIM2_IRQn                   = 28,     /*!< TIM2 global Interrupt                                */
S  TIM3_IRQn                   = 29,     /*!< TIM3 global Interrupt                                */
S  I2C1_EV_IRQn                = 31,     /*!< I2C1 Event Interrupt                                 */
S  I2C1_ER_IRQn                = 32,     /*!< I2C1 Error Interrupt                                 */
S  SPI1_IRQn                   = 35,     /*!< SPI1 global Interrupt                                */
S  USART1_IRQn                 = 37,     /*!< USART1 global Interrupt                              */
S  USART2_IRQn                 = 38,     /*!< USART2 global Interrupt                              */
S  EXTI15_10_IRQn              = 40,     /*!< External Line[15:10] Interrupts                      */
S  RTCAlarm_IRQn               = 41,     /*!< RTC Alarm through EXTI Line Interrupt                */
S  USBWakeUp_IRQn              = 42      /*!< USB Device WakeUp from suspend through EXTI Line Interrupt */    
N#endif /* STM32F10X_LD */  
N
N#ifdef STM32F10X_LD_VL
S  ADC1_IRQn                   = 18,     /*!< ADC1 global Interrupt                                */
S  EXTI9_5_IRQn                = 23,     /*!< External Line[9:5] Interrupts                        */
S  TIM1_BRK_TIM15_IRQn         = 24,     /*!< TIM1 Break and TIM15 Interrupts                      */
S  TIM1_UP_TIM16_IRQn          = 25,     /*!< TIM1 Update and TIM16 Interrupts                     */
S  TIM1_TRG_COM_TIM17_IRQn     = 26,     /*!< TIM1 Trigger and Commutation and TIM17 Interrupt     */
S  TIM1_CC_IRQn                = 27,     /*!< TIM1 Capture Compare Interrupt                       */
S  TIM2_IRQn                   = 28,     /*!< TIM2 global Interrupt                                */
S  TIM3_IRQn                   = 29,     /*!< TIM3 global Interrupt                                */
S  I2C1_EV_IRQn                = 31,     /*!< I2C1 Event Interrupt                                 */
S  I2C1_ER_IRQn                = 32,     /*!< I2C1 Error Interrupt                                 */
S  SPI1_IRQn                   = 35,     /*!< SPI1 global Interrupt                                */
S  USART1_IRQn                 = 37,     /*!< USART1 global Interrupt                              */
S  USART2_IRQn                 = 38,     /*!< USART2 global Interrupt                              */
S  EXTI15_10_IRQn              = 40,     /*!< External Line[15:10] Interrupts                      */
S  RTCAlarm_IRQn               = 41,     /*!< RTC Alarm through EXTI Line Interrupt                */
S  CEC_IRQn                    = 42,     /*!< HDMI-CEC Interrupt                                   */
S  TIM6_DAC_IRQn               = 54,     /*!< TIM6 and DAC underrun Interrupt                      */
S  TIM7_IRQn                   = 55      /*!< TIM7 Interrupt                                       */       
N#endif /* STM32F10X_LD_VL */
N
N#ifdef STM32F10X_MD
S  ADC1_2_IRQn                 = 18,     /*!< ADC1 and ADC2 global Interrupt                       */
S  USB_HP_CAN1_TX_IRQn         = 19,     /*!< USB Device High Priority or CAN1 TX Interrupts       */
S  USB_LP_CAN1_RX0_IRQn        = 20,     /*!< USB Device Low Priority or CAN1 RX0 Interrupts       */
S  CAN1_RX1_IRQn               = 21,     /*!< CAN1 RX1 Interrupt                                   */
S  CAN1_SCE_IRQn               = 22,     /*!< CAN1 SCE Interrupt                                   */
S  EXTI9_5_IRQn                = 23,     /*!< External Line[9:5] Interrupts                        */
S  TIM1_BRK_IRQn               = 24,     /*!< TIM1 Break Interrupt                                 */
S  TIM1_UP_IRQn                = 25,     /*!< TIM1 Update Interrupt                                */
S  TIM1_TRG_COM_IRQn           = 26,     /*!< TIM1 Trigger and Commutation Interrupt               */
S  TIM1_CC_IRQn                = 27,     /*!< TIM1 Capture Compare Interrupt                       */
S  TIM2_IRQn                   = 28,     /*!< TIM2 global Interrupt                                */
S  TIM3_IRQn                   = 29,     /*!< TIM3 global Interrupt                                */
S  TIM4_IRQn                   = 30,     /*!< TIM4 global Interrupt                                */
S  I2C1_EV_IRQn                = 31,     /*!< I2C1 Event Interrupt                                 */
S  I2C1_ER_IRQn                = 32,     /*!< I2C1 Error Interrupt                                 */
S  I2C2_EV_IRQn                = 33,     /*!< I2C2 Event Interrupt                                 */
S  I2C2_ER_IRQn                = 34,     /*!< I2C2 Error Interrupt                                 */
S  SPI1_IRQn                   = 35,     /*!< SPI1 global Interrupt                                */
S  SPI2_IRQn                   = 36,     /*!< SPI2 global Interrupt                                */
S  USART1_IRQn                 = 37,     /*!< USART1 global Interrupt                              */
S  USART2_IRQn                 = 38,     /*!< USART2 global Interrupt                              */
S  USART3_IRQn                 = 39,     /*!< USART3 global Interrupt                              */
S  EXTI15_10_IRQn              = 40,     /*!< External Line[15:10] Interrupts                      */
S  RTCAlarm_IRQn               = 41,     /*!< RTC Alarm through EXTI Line Interrupt                */
S  USBWakeUp_IRQn              = 42      /*!< USB Device WakeUp from suspend through EXTI Line Interrupt */  
N#endif /* STM32F10X_MD */  
N
N#ifdef STM32F10X_MD_VL
S  ADC1_IRQn                   = 18,     /*!< ADC1 global Interrupt                                */
S  EXTI9_5_IRQn                = 23,     /*!< External Line[9:5] Interrupts                        */
S  TIM1_BRK_TIM15_IRQn         = 24,     /*!< TIM1 Break and TIM15 Interrupts                      */
S  TIM1_UP_TIM16_IRQn          = 25,     /*!< TIM1 Update and TIM16 Interrupts                     */
S  TIM1_TRG_COM_TIM17_IRQn     = 26,     /*!< TIM1 Trigger and Commutation and TIM17 Interrupt     */
S  TIM1_CC_IRQn                = 27,     /*!< TIM1 Capture Compare Interrupt                       */
S  TIM2_IRQn                   = 28,     /*!< TIM2 global Interrupt                                */
S  TIM3_IRQn                   = 29,     /*!< TIM3 global Interrupt                                */
S  TIM4_IRQn                   = 30,     /*!< TIM4 global Interrupt                                */
S  I2C1_EV_IRQn                = 31,     /*!< I2C1 Event Interrupt                                 */
S  I2C1_ER_IRQn                = 32,     /*!< I2C1 Error Interrupt                                 */
S  I2C2_EV_IRQn                = 33,     /*!< I2C2 Event Interrupt                                 */
S  I2C2_ER_IRQn                = 34,     /*!< I2C2 Error Interrupt                                 */
S  SPI1_IRQn                   = 35,     /*!< SPI1 global Interrupt                                */
S  SPI2_IRQn                   = 36,     /*!< SPI2 global Interrupt                                */
S  USART1_IRQn                 = 37,     /*!< USART1 global Interrupt                              */
S  USART2_IRQn                 = 38,     /*!< USART2 global Interrupt                              */
S  USART3_IRQn                 = 39,     /*!< USART3 global Interrupt                              */
S  EXTI15_10_IRQn              = 40,     /*!< External Line[15:10] Interrupts                      */
S  RTCAlarm_IRQn               = 41,     /*!< RTC Alarm through EXTI Line Interrupt                */
S  CEC_IRQn                    = 42,     /*!< HDMI-CEC Interrupt                                   */
S  TIM6_DAC_IRQn               = 54,     /*!< TIM6 and DAC underrun Interrupt                      */
S  TIM7_IRQn                   = 55      /*!< TIM7 Interrupt                                       */       
N#endif /* STM32F10X_MD_VL */
N
N#ifdef STM32F10X_HD
N  ADC1_2_IRQn                 = 18,     /*!< ADC1 and ADC2 global Interrupt                       */
N  USB_HP_CAN1_TX_IRQn         = 19,     /*!< USB Device High Priority or CAN1 TX Interrupts       */
N  USB_LP_CAN1_RX0_IRQn        = 20,     /*!< USB Device Low Priority or CAN1 RX0 Interrupts       */
N  CAN1_RX1_IRQn               = 21,     /*!< CAN1 RX1 Interrupt                                   */
N  CAN1_SCE_IRQn               = 22,     /*!< CAN1 SCE Interrupt                                   */
N  EXTI9_5_IRQn                = 23,     /*!< External Line[9:5] Interrupts                        */
N  TIM1_BRK_IRQn               = 24,     /*!< TIM1 Break Interrupt                                 */
N  TIM1_UP_IRQn                = 25,     /*!< TIM1 Update Interrupt                                */
N  TIM1_TRG_COM_IRQn           = 26,     /*!< TIM1 Trigger and Commutation Interrupt               */
N  TIM1_CC_IRQn                = 27,     /*!< TIM1 Capture Compare Interrupt                       */
N  TIM2_IRQn                   = 28,     /*!< TIM2 global Interrupt                                */
N  TIM3_IRQn                   = 29,     /*!< TIM3 global Interrupt                                */
N  TIM4_IRQn                   = 30,     /*!< TIM4 global Interrupt                                */
N  I2C1_EV_IRQn                = 31,     /*!< I2C1 Event Interrupt                                 */
N  I2C1_ER_IRQn                = 32,     /*!< I2C1 Error Interrupt                                 */
N  I2C2_EV_IRQn                = 33,     /*!< I2C2 Event Interrupt                                 */
N  I2C2_ER_IRQn                = 34,     /*!< I2C2 Error Interrupt                                 */
N  SPI1_IRQn                   = 35,     /*!< SPI1 global Interrupt                                */
N  SPI2_IRQn                   = 36,     /*!< SPI2 global Interrupt                                */
N  USART1_IRQn                 = 37,     /*!< USART1 global Interrupt                              */
N  USART2_IRQn                 = 38,     /*!< USART2 global Interrupt                              */
N  USART3_IRQn                 = 39,     /*!< USART3 global Interrupt                              */
N  EXTI15_10_IRQn              = 40,     /*!< External Line[15:10] Interrupts                      */
N  RTCAlarm_IRQn               = 41,     /*!< RTC Alarm through EXTI Line Interrupt                */
N  USBWakeUp_IRQn              = 42,     /*!< USB Device WakeUp from suspend through EXTI Line Interrupt */
N  TIM8_BRK_IRQn               = 43,     /*!< TIM8 Break Interrupt                                 */
N  TIM8_UP_IRQn                = 44,     /*!< TIM8 Update Interrupt                                */
N  TIM8_TRG_COM_IRQn           = 45,     /*!< TIM8 Trigger and Commutation Interrupt               */
N  TIM8_CC_IRQn                = 46,     /*!< TIM8 Capture Compare Interrupt                       */
N  ADC3_IRQn                   = 47,     /*!< ADC3 global Interrupt                                */
N  FSMC_IRQn                   = 48,     /*!< FSMC global Interrupt                                */
N  SDIO_IRQn                   = 49,     /*!< SDIO global Interrupt                                */
N  TIM5_IRQn                   = 50,     /*!< TIM5 global Interrupt                                */
N  SPI3_IRQn                   = 51,     /*!< SPI3 global Interrupt                                */
N  UART4_IRQn                  = 52,     /*!< UART4 global Interrupt                               */
N  UART5_IRQn                  = 53,     /*!< UART5 global Interrupt                               */
N  TIM6_IRQn                   = 54,     /*!< TIM6 global Interrupt                                */
N  TIM7_IRQn                   = 55,     /*!< TIM7 global Interrupt                                */
N  DMA2_Channel1_IRQn          = 56,     /*!< DMA2 Channel 1 global Interrupt                      */
N  DMA2_Channel2_IRQn          = 57,     /*!< DMA2 Channel 2 global Interrupt                      */
N  DMA2_Channel3_IRQn          = 58,     /*!< DMA2 Channel 3 global Interrupt                      */
N  DMA2_Channel4_5_IRQn        = 59      /*!< DMA2 Channel 4 and Channel 5 global Interrupt        */
N#endif /* STM32F10X_HD */  
N
N#ifdef STM32F10X_HD_VL
S  ADC1_IRQn                   = 18,     /*!< ADC1 global Interrupt                                */
S  EXTI9_5_IRQn                = 23,     /*!< External Line[9:5] Interrupts                        */
S  TIM1_BRK_TIM15_IRQn         = 24,     /*!< TIM1 Break and TIM15 Interrupts                      */
S  TIM1_UP_TIM16_IRQn          = 25,     /*!< TIM1 Update and TIM16 Interrupts                     */
S  TIM1_TRG_COM_TIM17_IRQn     = 26,     /*!< TIM1 Trigger and Commutation and TIM17 Interrupt     */
S  TIM1_CC_IRQn                = 27,     /*!< TIM1 Capture Compare Interrupt                       */
S  TIM2_IRQn                   = 28,     /*!< TIM2 global Interrupt                                */
S  TIM3_IRQn                   = 29,     /*!< TIM3 global Interrupt                                */
S  TIM4_IRQn                   = 30,     /*!< TIM4 global Interrupt                                */
S  I2C1_EV_IRQn                = 31,     /*!< I2C1 Event Interrupt                                 */
S  I2C1_ER_IRQn                = 32,     /*!< I2C1 Error Interrupt                                 */
S  I2C2_EV_IRQn                = 33,     /*!< I2C2 Event Interrupt                                 */
S  I2C2_ER_IRQn                = 34,     /*!< I2C2 Error Interrupt                                 */
S  SPI1_IRQn                   = 35,     /*!< SPI1 global Interrupt                                */
S  SPI2_IRQn                   = 36,     /*!< SPI2 global Interrupt                                */
S  USART1_IRQn                 = 37,     /*!< USART1 global Interrupt                              */
S  USART2_IRQn                 = 38,     /*!< USART2 global Interrupt                              */
S  USART3_IRQn                 = 39,     /*!< USART3 global Interrupt                              */
S  EXTI15_10_IRQn              = 40,     /*!< External Line[15:10] Interrupts                      */
S  RTCAlarm_IRQn               = 41,     /*!< RTC Alarm through EXTI Line Interrupt                */
S  CEC_IRQn                    = 42,     /*!< HDMI-CEC Interrupt                                   */
S  TIM12_IRQn                  = 43,     /*!< TIM12 global Interrupt                               */
S  TIM13_IRQn                  = 44,     /*!< TIM13 global Interrupt                               */
S  TIM14_IRQn                  = 45,     /*!< TIM14 global Interrupt                               */
S  TIM5_IRQn                   = 50,     /*!< TIM5 global Interrupt                                */
S  SPI3_IRQn                   = 51,     /*!< SPI3 global Interrupt                                */
S  UART4_IRQn                  = 52,     /*!< UART4 global Interrupt                               */
S  UART5_IRQn                  = 53,     /*!< UART5 global Interrupt                               */  
S  TIM6_DAC_IRQn               = 54,     /*!< TIM6 and DAC underrun Interrupt                      */
S  TIM7_IRQn                   = 55,     /*!< TIM7 Interrupt                                       */  
S  DMA2_Channel1_IRQn          = 56,     /*!< DMA2 Channel 1 global Interrupt                      */
S  DMA2_Channel2_IRQn          = 57,     /*!< DMA2 Channel 2 global Interrupt                      */
S  DMA2_Channel3_IRQn          = 58,     /*!< DMA2 Channel 3 global Interrupt                      */
S  DMA2_Channel4_5_IRQn        = 59,     /*!< DMA2 Channel 4 and Channel 5 global Interrupt        */
S  DMA2_Channel5_IRQn          = 60      /*!< DMA2 Channel 5 global Interrupt (DMA2 Channel 5 is 
S                                             mapped at position 60 only if the MISC_REMAP bit in 
S                                             the AFIO_MAPR2 register is set)                      */       
N#endif /* STM32F10X_HD_VL */
N
N#ifdef STM32F10X_XL
S  ADC1_2_IRQn                 = 18,     /*!< ADC1 and ADC2 global Interrupt                       */
S  USB_HP_CAN1_TX_IRQn         = 19,     /*!< USB Device High Priority or CAN1 TX Interrupts       */
S  USB_LP_CAN1_RX0_IRQn        = 20,     /*!< USB Device Low Priority or CAN1 RX0 Interrupts       */
S  CAN1_RX1_IRQn               = 21,     /*!< CAN1 RX1 Interrupt                                   */
S  CAN1_SCE_IRQn               = 22,     /*!< CAN1 SCE Interrupt                                   */
S  EXTI9_5_IRQn                = 23,     /*!< External Line[9:5] Interrupts                        */
S  TIM1_BRK_TIM9_IRQn          = 24,     /*!< TIM1 Break Interrupt and TIM9 global Interrupt       */
S  TIM1_UP_TIM10_IRQn          = 25,     /*!< TIM1 Update Interrupt and TIM10 global Interrupt     */
S  TIM1_TRG_COM_TIM11_IRQn     = 26,     /*!< TIM1 Trigger and Commutation Interrupt and TIM11 global interrupt */
S  TIM1_CC_IRQn                = 27,     /*!< TIM1 Capture Compare Interrupt                       */
S  TIM2_IRQn                   = 28,     /*!< TIM2 global Interrupt                                */
S  TIM3_IRQn                   = 29,     /*!< TIM3 global Interrupt                                */
S  TIM4_IRQn                   = 30,     /*!< TIM4 global Interrupt                                */
S  I2C1_EV_IRQn                = 31,     /*!< I2C1 Event Interrupt                                 */
S  I2C1_ER_IRQn                = 32,     /*!< I2C1 Error Interrupt                                 */
S  I2C2_EV_IRQn                = 33,     /*!< I2C2 Event Interrupt                                 */
S  I2C2_ER_IRQn                = 34,     /*!< I2C2 Error Interrupt                                 */
S  SPI1_IRQn                   = 35,     /*!< SPI1 global Interrupt                                */
S  SPI2_IRQn                   = 36,     /*!< SPI2 global Interrupt                                */
S  USART1_IRQn                 = 37,     /*!< USART1 global Interrupt                              */
S  USART2_IRQn                 = 38,     /*!< USART2 global Interrupt                              */
S  USART3_IRQn                 = 39,     /*!< USART3 global Interrupt                              */
S  EXTI15_10_IRQn              = 40,     /*!< External Line[15:10] Interrupts                      */
S  RTCAlarm_IRQn               = 41,     /*!< RTC Alarm through EXTI Line Interrupt                */
S  USBWakeUp_IRQn              = 42,     /*!< USB Device WakeUp from suspend through EXTI Line Interrupt */
S  TIM8_BRK_TIM12_IRQn         = 43,     /*!< TIM8 Break Interrupt and TIM12 global Interrupt      */
S  TIM8_UP_TIM13_IRQn          = 44,     /*!< TIM8 Update Interrupt and TIM13 global Interrupt     */
S  TIM8_TRG_COM_TIM14_IRQn     = 45,     /*!< TIM8 Trigger and Commutation Interrupt and TIM14 global interrupt */
S  TIM8_CC_IRQn                = 46,     /*!< TIM8 Capture Compare Interrupt                       */
S  ADC3_IRQn                   = 47,     /*!< ADC3 global Interrupt                                */
S  FSMC_IRQn                   = 48,     /*!< FSMC global Interrupt                                */
S  SDIO_IRQn                   = 49,     /*!< SDIO global Interrupt                                */
S  TIM5_IRQn                   = 50,     /*!< TIM5 global Interrupt                                */
S  SPI3_IRQn                   = 51,     /*!< SPI3 global Interrupt                                */
S  UART4_IRQn                  = 52,     /*!< UART4 global Interrupt                               */
S  UART5_IRQn                  = 53,     /*!< UART5 global Interrupt                               */
S  TIM6_IRQn                   = 54,     /*!< TIM6 global Interrupt                                */
S  TIM7_IRQn                   = 55,     /*!< TIM7 global Interrupt                                */
S  DMA2_Channel1_IRQn          = 56,     /*!< DMA2 Channel 1 global Interrupt                      */
S  DMA2_Channel2_IRQn          = 57,     /*!< DMA2 Channel 2 global Interrupt                      */
S  DMA2_Channel3_IRQn          = 58,     /*!< DMA2 Channel 3 global Interrupt                      */
S  DMA2_Channel4_5_IRQn        = 59      /*!< DMA2 Channel 4 and Channel 5 global Interrupt        */
N#endif /* STM32F10X_XL */  
N
N#ifdef STM32F10X_CL
S  ADC1_2_IRQn                 = 18,     /*!< ADC1 and ADC2 global Interrupt                       */
S  CAN1_TX_IRQn                = 19,     /*!< USB Device High Priority or CAN1 TX Interrupts       */
S  CAN1_RX0_IRQn               = 20,     /*!< USB Device Low Priority or CAN1 RX0 Interrupts       */
S  CAN1_RX1_IRQn               = 21,     /*!< CAN1 RX1 Interrupt                                   */
S  CAN1_SCE_IRQn               = 22,     /*!< CAN1 SCE Interrupt                                   */
S  EXTI9_5_IRQn                = 23,     /*!< External Line[9:5] Interrupts                        */
S  TIM1_BRK_IRQn               = 24,     /*!< TIM1 Break Interrupt                                 */
S  TIM1_UP_IRQn                = 25,     /*!< TIM1 Update Interrupt                                */
S  TIM1_TRG_COM_IRQn           = 26,     /*!< TIM1 Trigger and Commutation Interrupt               */
S  TIM1_CC_IRQn                = 27,     /*!< TIM1 Capture Compare Interrupt                       */
S  TIM2_IRQn                   = 28,     /*!< TIM2 global Interrupt                                */
S  TIM3_IRQn                   = 29,     /*!< TIM3 global Interrupt                                */
S  TIM4_IRQn                   = 30,     /*!< TIM4 global Interrupt                                */
S  I2C1_EV_IRQn                = 31,     /*!< I2C1 Event Interrupt                                 */
S  I2C1_ER_IRQn                = 32,     /*!< I2C1 Error Interrupt                                 */
S  I2C2_EV_IRQn                = 33,     /*!< I2C2 Event Interrupt                                 */
S  I2C2_ER_IRQn                = 34,     /*!< I2C2 Error Interrupt                                 */
S  SPI1_IRQn                   = 35,     /*!< SPI1 global Interrupt                                */
S  SPI2_IRQn                   = 36,     /*!< SPI2 global Interrupt                                */
S  USART1_IRQn                 = 37,     /*!< USART1 global Interrupt                              */
S  USART2_IRQn                 = 38,     /*!< USART2 global Interrupt                              */
S  USART3_IRQn                 = 39,     /*!< USART3 global Interrupt                              */
S  EXTI15_10_IRQn              = 40,     /*!< External Line[15:10] Interrupts                      */
S  RTCAlarm_IRQn               = 41,     /*!< RTC Alarm through EXTI Line Interrupt                */
S  OTG_FS_WKUP_IRQn            = 42,     /*!< USB OTG FS WakeUp from suspend through EXTI Line Interrupt */
S  TIM5_IRQn                   = 50,     /*!< TIM5 global Interrupt                                */
S  SPI3_IRQn                   = 51,     /*!< SPI3 global Interrupt                                */
S  UART4_IRQn                  = 52,     /*!< UART4 global Interrupt                               */
S  UART5_IRQn                  = 53,     /*!< UART5 global Interrupt                               */
S  TIM6_IRQn                   = 54,     /*!< TIM6 global Interrupt                                */
S  TIM7_IRQn                   = 55,     /*!< TIM7 global Interrupt                                */
S  DMA2_Channel1_IRQn          = 56,     /*!< DMA2 Channel 1 global Interrupt                      */
S  DMA2_Channel2_IRQn          = 57,     /*!< DMA2 Channel 2 global Interrupt                      */
S  DMA2_Channel3_IRQn          = 58,     /*!< DMA2 Channel 3 global Interrupt                      */
S  DMA2_Channel4_IRQn          = 59,     /*!< DMA2 Channel 4 global Interrupt                      */
S  DMA2_Channel5_IRQn          = 60,     /*!< DMA2 Channel 5 global Interrupt                      */
S  ETH_IRQn                    = 61,     /*!< Ethernet global Interrupt                            */
S  ETH_WKUP_IRQn               = 62,     /*!< Ethernet Wakeup through EXTI line Interrupt          */
S  CAN2_TX_IRQn                = 63,     /*!< CAN2 TX Interrupt                                    */
S  CAN2_RX0_IRQn               = 64,     /*!< CAN2 RX0 Interrupt                                   */
S  CAN2_RX1_IRQn               = 65,     /*!< CAN2 RX1 Interrupt                                   */
S  CAN2_SCE_IRQn               = 66,     /*!< CAN2 SCE Interrupt                                   */
S  OTG_FS_IRQn                 = 67      /*!< USB OTG FS global Interrupt                          */
N#endif /* STM32F10X_CL */     
N} IRQn_Type;
N
N/**
N  * @}
N  */
N
N#include "core_cm3.h"
L 1 "..\..\Libraries\CMSIS\core_cm3.h" 1
N/**************************************************************************//**
N * @file     core_cm3.h
N * @brief    CMSIS Cortex-M3 Core Peripheral Access Layer Header File
N * @version  V1.30
N * @date     30. October 2009
N *
N * @note
N * Copyright (C) 2009 ARM Limited. All rights reserved.
N *
N * @par
N * ARM Limited (ARM) is supplying this software for use with Cortex-M 
N * processor based microcontrollers.  This file can be freely distributed 
N * within development tools that are supporting such ARM based processors. 
N *
N * @par
N * THIS SOFTWARE IS PROVIDED "AS IS".  NO WARRANTIES, WHETHER EXPRESS, IMPLIED
N * OR STATUTORY, INCLUDING, BUT NOT LIMITED TO, IMPLIED WARRANTIES OF
N * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE APPLY TO THIS SOFTWARE.
N * ARM SHALL NOT, IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL, OR
N * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.
N *
N ******************************************************************************/
N
N#ifndef __CM3_CORE_H__
N#define __CM3_CORE_H__
N
N/** @addtogroup CMSIS_CM3_core_LintCinfiguration CMSIS CM3 Core Lint Configuration
N *
N * List of Lint messages which will be suppressed and not shown:
N *   - Error 10: \n
N *     register uint32_t __regBasePri         __asm("basepri"); \n
N *     Error 10: Expecting ';'
N * .
N *   - Error 530: \n
N *     return(__regBasePri); \n
N *     Warning 530: Symbol '__regBasePri' (line 264) not initialized
N * . 
N *   - Error 550: \n
N *     __regBasePri = (basePri & 0x1ff); \n
N *     Warning 550: Symbol '__regBasePri' (line 271) not accessed
N * .
N *   - Error 754: \n
N *     uint32_t RESERVED0[24]; \n
N *     Info 754: local structure member '<some, not used in the HAL>' (line 109, file ./cm3_core.h) not referenced
N * .
N *   - Error 750: \n
N *     #define __CM3_CORE_H__ \n
N *     Info 750: local macro '__CM3_CORE_H__' (line 43, file./cm3_core.h) not referenced
N * .
N *   - Error 528: \n
N *     static __INLINE void NVIC_DisableIRQ(uint32_t IRQn) \n
N *     Warning 528: Symbol 'NVIC_DisableIRQ(unsigned int)' (line 419, file ./cm3_core.h) not referenced
N * .
N *   - Error 751: \n
N *     } InterruptType_Type; \n
N *     Info 751: local typedef 'InterruptType_Type' (line 170, file ./cm3_core.h) not referenced
N * .
N * Note:  To re-enable a Message, insert a space before 'lint' *
N *
N */
N
N/*lint -save */
N/*lint -e10  */
N/*lint -e530 */
N/*lint -e550 */
N/*lint -e754 */
N/*lint -e750 */
N/*lint -e528 */
N/*lint -e751 */
N
N
N/** @addtogroup CMSIS_CM3_core_definitions CM3 Core Definitions
N  This file defines all structures and symbols for CMSIS core:
N    - CMSIS version number
N    - Cortex-M core registers and bitfields
N    - Cortex-M core peripheral base address
N  @{
N */
N
N#ifdef __cplusplus
S extern "C" {
N#endif 
N
N#define __CM3_CMSIS_VERSION_MAIN  (0x01)                                                       /*!< [31:16] CMSIS HAL main version */
N#define __CM3_CMSIS_VERSION_SUB   (0x30)                                                       /*!< [15:0]  CMSIS HAL sub version  */
N#define __CM3_CMSIS_VERSION       ((__CM3_CMSIS_VERSION_MAIN << 16) | __CM3_CMSIS_VERSION_SUB) /*!< CMSIS HAL version number       */
N
N#define __CORTEX_M                (0x03)                                                       /*!< Cortex core                    */
N
N#include <stdint.h>                           /* Include standard types */
L 1 "F:\Keil_v5\ARM\ARMCC\Bin\..\include\stdint.h" 1
N/* Copyright (C) ARM Ltd., 1999,2014 */
N/* All rights reserved */
N
N/*
N * RCS $Revision$
N * Checkin $Date$
N * Revising $Author: agrant $
N */
N
N#ifndef __stdint_h
N#define __stdint_h
N#define __ARMCLIB_VERSION 5060037
N
N  #ifdef __INT64_TYPE__
S    /* armclang predefines '__INT64_TYPE__' and '__INT64_C_SUFFIX__' */
S    #define __INT64 __INT64_TYPE__
N  #else
N    /* armcc has builtin '__int64' which can be used in --strict mode */
N    #define __INT64 __int64
N    #define __INT64_C_SUFFIX__ ll
N  #endif
N  #define __PASTE2(x, y) x ## y
N  #define __PASTE(x, y) __PASTE2(x, y)
N  #define __INT64_C(x)  __ESCAPE__(__PASTE(x, __INT64_C_SUFFIX__))
N  #define __UINT64_C(x)  __ESCAPE__(__PASTE(x ## u, __INT64_C_SUFFIX__))
N  #if defined(__clang__) || (defined(__ARMCC_VERSION) && !defined(__STRICT_ANSI__))
X  #if 0L || (1L && !0L)
N    /* armclang and non-strict armcc allow 'long long' in system headers */
N    #define __LONGLONG long long
N  #else
S    /* strict armcc has '__int64' */
S    #define __LONGLONG __int64
N  #endif
N
N  #ifndef __STDINT_DECLS
N  #define __STDINT_DECLS
N
N    #undef __CLIBNS
N
N    #ifdef __cplusplus
S      namespace std {
S          #define __CLIBNS std::
S          extern "C" {
N    #else
N      #define __CLIBNS
N    #endif  /* __cplusplus */
N
N
N/*
N * 'signed' is redundant below, except for 'signed char' and if
N * the typedef is used to declare a bitfield.
N */
N
N    /* 7.18.1.1 */
N
N    /* exact-width signed integer types */
Ntypedef   signed          char int8_t;
Ntypedef   signed short     int int16_t;
Ntypedef   signed           int int32_t;
Ntypedef   signed       __INT64 int64_t;
Xtypedef   signed       __int64 int64_t;
N
N    /* exact-width unsigned integer types */
Ntypedef unsigned          char uint8_t;
Ntypedef unsigned short     int uint16_t;
Ntypedef unsigned           int uint32_t;
Ntypedef unsigned       __INT64 uint64_t;
Xtypedef unsigned       __int64 uint64_t;
N
N    /* 7.18.1.2 */
N
N    /* smallest type of at least n bits */
N    /* minimum-width signed integer types */
Ntypedef   signed          char int_least8_t;
Ntypedef   signed short     int int_least16_t;
Ntypedef   signed           int int_least32_t;
Ntypedef   signed       __INT64 int_least64_t;
Xtypedef   signed       __int64 int_least64_t;
N
N    /* minimum-width unsigned integer types */
Ntypedef unsigned          char uint_least8_t;
Ntypedef unsigned short     int uint_least16_t;
Ntypedef unsigned           int uint_least32_t;
Ntypedef unsigned       __INT64 uint_least64_t;
Xtypedef unsigned       __int64 uint_least64_t;
N
N    /* 7.18.1.3 */
N
N    /* fastest minimum-width signed integer types */
Ntypedef   signed           int int_fast8_t;
Ntypedef   signed           int int_fast16_t;
Ntypedef   signed           int int_fast32_t;
Ntypedef   signed       __INT64 int_fast64_t;
Xtypedef   signed       __int64 int_fast64_t;
N
N    /* fastest minimum-width unsigned integer types */
Ntypedef unsigned           int uint_fast8_t;
Ntypedef unsigned           int uint_fast16_t;
Ntypedef unsigned           int uint_fast32_t;
Ntypedef unsigned       __INT64 uint_fast64_t;
Xtypedef unsigned       __int64 uint_fast64_t;
N
N    /* 7.18.1.4 integer types capable of holding object pointers */
N#if __sizeof_ptr == 8
X#if 4 == 8
Stypedef   signed       __INT64 intptr_t;
Stypedef unsigned       __INT64 uintptr_t;
N#else
Ntypedef   signed           int intptr_t;
Ntypedef unsigned           int uintptr_t;
N#endif
N
N    /* 7.18.1.5 greatest-width integer types */
Ntypedef   signed     __LONGLONG intmax_t;
Xtypedef   signed     long long intmax_t;
Ntypedef unsigned     __LONGLONG uintmax_t;
Xtypedef unsigned     long long uintmax_t;
N
N
N#if !defined(__cplusplus) || defined(__STDC_LIMIT_MACROS)
X#if !0L || 0L
N
N    /* 7.18.2.1 */
N
N    /* minimum values of exact-width signed integer types */
N#define INT8_MIN                   -128
N#define INT16_MIN                -32768
N#define INT32_MIN          (~0x7fffffff)   /* -2147483648 is unsigned */
N#define INT64_MIN  __INT64_C(~0x7fffffffffffffff) /* -9223372036854775808 is unsigned */
N
N    /* maximum values of exact-width signed integer types */
N#define INT8_MAX                    127
N#define INT16_MAX                 32767
N#define INT32_MAX            2147483647
N#define INT64_MAX  __INT64_C(9223372036854775807)
N
N    /* maximum values of exact-width unsigned integer types */
N#define UINT8_MAX                   255
N#define UINT16_MAX                65535
N#define UINT32_MAX           4294967295u
N#define UINT64_MAX __UINT64_C(18446744073709551615)
N
N    /* 7.18.2.2 */
N
N    /* minimum values of minimum-width signed integer types */
N#define INT_LEAST8_MIN                   -128
N#define INT_LEAST16_MIN                -32768
N#define INT_LEAST32_MIN          (~0x7fffffff)
N#define INT_LEAST64_MIN  __INT64_C(~0x7fffffffffffffff)
N
N    /* maximum values of minimum-width signed integer types */
N#define INT_LEAST8_MAX                    127
N#define INT_LEAST16_MAX                 32767
N#define INT_LEAST32_MAX            2147483647
N#define INT_LEAST64_MAX  __INT64_C(9223372036854775807)
N
N    /* maximum values of minimum-width unsigned integer types */
N#define UINT_LEAST8_MAX                   255
N#define UINT_LEAST16_MAX                65535
N#define UINT_LEAST32_MAX           4294967295u
N#define UINT_LEAST64_MAX __UINT64_C(18446744073709551615)
N
N    /* 7.18.2.3 */
N
N    /* minimum values of fastest minimum-width signed integer types */
N#define INT_FAST8_MIN           (~0x7fffffff)
N#define INT_FAST16_MIN          (~0x7fffffff)
N#define INT_FAST32_MIN          (~0x7fffffff)
N#define INT_FAST64_MIN  __INT64_C(~0x7fffffffffffffff)
N
N    /* maximum values of fastest minimum-width signed integer types */
N#define INT_FAST8_MAX             2147483647
N#define INT_FAST16_MAX            2147483647
N#define INT_FAST32_MAX            2147483647
N#define INT_FAST64_MAX  __INT64_C(9223372036854775807)
N
N    /* maximum values of fastest minimum-width unsigned integer types */
N#define UINT_FAST8_MAX            4294967295u
N#define UINT_FAST16_MAX           4294967295u
N#define UINT_FAST32_MAX           4294967295u
N#define UINT_FAST64_MAX __UINT64_C(18446744073709551615)
N
N    /* 7.18.2.4 */
N
N    /* minimum value of pointer-holding signed integer type */
N#if __sizeof_ptr == 8
X#if 4 == 8
S#define INTPTR_MIN INT64_MIN
N#else
N#define INTPTR_MIN INT32_MIN
N#endif
N
N    /* maximum value of pointer-holding signed integer type */
N#if __sizeof_ptr == 8
X#if 4 == 8
S#define INTPTR_MAX INT64_MAX
N#else
N#define INTPTR_MAX INT32_MAX
N#endif
N
N    /* maximum value of pointer-holding unsigned integer type */
N#if __sizeof_ptr == 8
X#if 4 == 8
S#define UINTPTR_MAX UINT64_MAX
N#else
N#define UINTPTR_MAX UINT32_MAX
N#endif
N
N    /* 7.18.2.5 */
N
N    /* minimum value of greatest-width signed integer type */
N#define INTMAX_MIN  __ESCAPE__(~0x7fffffffffffffffll)
N
N    /* maximum value of greatest-width signed integer type */
N#define INTMAX_MAX  __ESCAPE__(9223372036854775807ll)
N
N    /* maximum value of greatest-width unsigned integer type */
N#define UINTMAX_MAX __ESCAPE__(18446744073709551615ull)
N
N    /* 7.18.3 */
N
N    /* limits of ptrdiff_t */
N#if __sizeof_ptr == 8
X#if 4 == 8
S#define PTRDIFF_MIN INT64_MIN
S#define PTRDIFF_MAX INT64_MAX
N#else
N#define PTRDIFF_MIN INT32_MIN
N#define PTRDIFF_MAX INT32_MAX
N#endif
N
N    /* limits of sig_atomic_t */
N#define SIG_ATOMIC_MIN (~0x7fffffff)
N#define SIG_ATOMIC_MAX   2147483647
N
N    /* limit of size_t */
N#if __sizeof_ptr == 8
X#if 4 == 8
S#define SIZE_MAX UINT64_MAX
N#else
N#define SIZE_MAX UINT32_MAX
N#endif
N
N    /* limits of wchar_t */
N    /* NB we have to undef and redef because they're defined in both
N     * stdint.h and wchar.h */
N#undef WCHAR_MIN
N#undef WCHAR_MAX
N
N#if defined(__WCHAR32) || (defined(__ARM_SIZEOF_WCHAR_T) && __ARM_SIZEOF_WCHAR_T == 4)
X#if 0L || (0L && __ARM_SIZEOF_WCHAR_T == 4)
S  #define WCHAR_MIN   0
S  #define WCHAR_MAX   0xffffffffU
N#else
N  #define WCHAR_MIN   0
N  #define WCHAR_MAX   65535
N#endif
N
N    /* limits of wint_t */
N#define WINT_MIN (~0x7fffffff)
N#define WINT_MAX 2147483647
N
N#endif /* __STDC_LIMIT_MACROS */
N
N#if !defined(__cplusplus) || defined(__STDC_CONSTANT_MACROS)
X#if !0L || 0L
N
N    /* 7.18.4.1 macros for minimum-width integer constants */
N#define INT8_C(x)   (x)
N#define INT16_C(x)  (x)
N#define INT32_C(x)  (x)
N#define INT64_C(x)  __INT64_C(x)
N
N#define UINT8_C(x)  (x ## u)
N#define UINT16_C(x) (x ## u)
N#define UINT32_C(x) (x ## u)
N#define UINT64_C(x) __UINT64_C(x)
N
N    /* 7.18.4.2 macros for greatest-width integer constants */
N#define INTMAX_C(x)  __ESCAPE__(x ## ll)
N#define UINTMAX_C(x) __ESCAPE__(x ## ull)
N
N#endif /* __STDC_CONSTANT_MACROS */
N
N    #ifdef __cplusplus
S         }  /* extern "C" */
S      }  /* namespace std */
N    #endif /* __cplusplus */
N  #endif /* __STDINT_DECLS */
N
N  #ifdef __cplusplus
S    #ifndef __STDINT_NO_EXPORTS
S      using ::std::int8_t;
S      using ::std::int16_t;
S      using ::std::int32_t;
S      using ::std::int64_t;
S      using ::std::uint8_t;
S      using ::std::uint16_t;
S      using ::std::uint32_t;
S      using ::std::uint64_t;
S      using ::std::int_least8_t;
S      using ::std::int_least16_t;
S      using ::std::int_least32_t;
S      using ::std::int_least64_t;
S      using ::std::uint_least8_t;
S      using ::std::uint_least16_t;
S      using ::std::uint_least32_t;
S      using ::std::uint_least64_t;
S      using ::std::int_fast8_t;
S      using ::std::int_fast16_t;
S      using ::std::int_fast32_t;
S      using ::std::int_fast64_t;
S      using ::std::uint_fast8_t;
S      using ::std::uint_fast16_t;
S      using ::std::uint_fast32_t;
S      using ::std::uint_fast64_t;
S      using ::std::intptr_t;
S      using ::std::uintptr_t;
S      using ::std::intmax_t;
S      using ::std::uintmax_t;
S    #endif
N  #endif /* __cplusplus */
N
N#undef __INT64
N#undef __LONGLONG
N
N#endif /* __stdint_h */
N
N/* end of stdint.h */
L 91 "..\..\Libraries\CMSIS\core_cm3.h" 2
N
N#if defined (__ICCARM__)
X#if 0L
S  #include <intrinsics.h>                     /* IAR Intrinsics   */
N#endif
N
N
N#ifndef __NVIC_PRIO_BITS
S  #define __NVIC_PRIO_BITS    4               /*!< standard definition for NVIC Priority Bits */
N#endif
N
N
N
N
N/**
N * IO definitions
N *
N * define access restrictions to peripheral registers
N */
N
N#ifdef __cplusplus
S  #define     __I     volatile                /*!< defines 'read only' permissions      */
N#else
N  #define     __I     volatile const          /*!< defines 'read only' permissions      */
N#endif
N#define     __O     volatile                  /*!< defines 'write only' permissions     */
N#define     __IO    volatile                  /*!< defines 'read / write' permissions   */
N
N
N
N/*******************************************************************************
N *                 Register Abstraction
N ******************************************************************************/
N/** @addtogroup CMSIS_CM3_core_register CMSIS CM3 Core Register
N @{
N*/
N
N
N/** @addtogroup CMSIS_CM3_NVIC CMSIS CM3 NVIC
N  memory mapped structure for Nested Vectored Interrupt Controller (NVIC)
N  @{
N */
Ntypedef struct
N{
N  __IO uint32_t ISER[8];                      /*!< Offset: 0x000  Interrupt Set Enable Register           */
X  volatile uint32_t ISER[8];                       
N       uint32_t RESERVED0[24];                                   
N  __IO uint32_t ICER[8];                      /*!< Offset: 0x080  Interrupt Clear Enable Register         */
X  volatile uint32_t ICER[8];                       
N       uint32_t RSERVED1[24];                                    
N  __IO uint32_t ISPR[8];                      /*!< Offset: 0x100  Interrupt Set Pending Register          */
X  volatile uint32_t ISPR[8];                       
N       uint32_t RESERVED2[24];                                   
N  __IO uint32_t ICPR[8];                      /*!< Offset: 0x180  Interrupt Clear Pending Register        */
X  volatile uint32_t ICPR[8];                       
N       uint32_t RESERVED3[24];                                   
N  __IO uint32_t IABR[8];                      /*!< Offset: 0x200  Interrupt Active bit Register           */
X  volatile uint32_t IABR[8];                       
N       uint32_t RESERVED4[56];                                   
N  __IO uint8_t  IP[240];                      /*!< Offset: 0x300  Interrupt Priority Register (8Bit wide) */
X  volatile uint8_t  IP[240];                       
N       uint32_t RESERVED5[644];                                  
N  __O  uint32_t STIR;                         /*!< Offset: 0xE00  Software Trigger Interrupt Register     */
X  volatile  uint32_t STIR;                          
N}  NVIC_Type;                                               
N/*@}*/ /* end of group CMSIS_CM3_NVIC */
N
N
N/** @addtogroup CMSIS_CM3_SCB CMSIS CM3 SCB
N  memory mapped structure for System Control Block (SCB)
N  @{
N */
Ntypedef struct
N{
N  __I  uint32_t CPUID;                        /*!< Offset: 0x00  CPU ID Base Register                                  */
X  volatile const  uint32_t CPUID;                         
N  __IO uint32_t ICSR;                         /*!< Offset: 0x04  Interrupt Control State Register                      */
X  volatile uint32_t ICSR;                          
N  __IO uint32_t VTOR;                         /*!< Offset: 0x08  Vector Table Offset Register                          */
X  volatile uint32_t VTOR;                          
N  __IO uint32_t AIRCR;                        /*!< Offset: 0x0C  Application Interrupt / Reset Control Register        */
X  volatile uint32_t AIRCR;                         
N  __IO uint32_t SCR;                          /*!< Offset: 0x10  System Control Register                               */
X  volatile uint32_t SCR;                           
N  __IO uint32_t CCR;                          /*!< Offset: 0x14  Configuration Control Register                        */
X  volatile uint32_t CCR;                           
N  __IO uint8_t  SHP[12];                      /*!< Offset: 0x18  System Handlers Priority Registers (4-7, 8-11, 12-15) */
X  volatile uint8_t  SHP[12];                       
N  __IO uint32_t SHCSR;                        /*!< Offset: 0x24  System Handler Control and State Register             */
X  volatile uint32_t SHCSR;                         
N  __IO uint32_t CFSR;                         /*!< Offset: 0x28  Configurable Fault Status Register                    */
X  volatile uint32_t CFSR;                          
N  __IO uint32_t HFSR;                         /*!< Offset: 0x2C  Hard Fault Status Register                            */
X  volatile uint32_t HFSR;                          
N  __IO uint32_t DFSR;                         /*!< Offset: 0x30  Debug Fault Status Register                           */
X  volatile uint32_t DFSR;                          
N  __IO uint32_t MMFAR;                        /*!< Offset: 0x34  Mem Manage Address Register                           */
X  volatile uint32_t MMFAR;                         
N  __IO uint32_t BFAR;                         /*!< Offset: 0x38  Bus Fault Address Register                            */
X  volatile uint32_t BFAR;                          
N  __IO uint32_t AFSR;                         /*!< Offset: 0x3C  Auxiliary Fault Status Register                       */
X  volatile uint32_t AFSR;                          
N  __I  uint32_t PFR[2];                       /*!< Offset: 0x40  Processor Feature Register                            */
X  volatile const  uint32_t PFR[2];                        
N  __I  uint32_t DFR;                          /*!< Offset: 0x48  Debug Feature Register                                */
X  volatile const  uint32_t DFR;                           
N  __I  uint32_t ADR;                          /*!< Offset: 0x4C  Auxiliary Feature Register                            */
X  volatile const  uint32_t ADR;                           
N  __I  uint32_t MMFR[4];                      /*!< Offset: 0x50  Memory Model Feature Register                         */
X  volatile const  uint32_t MMFR[4];                       
N  __I  uint32_t ISAR[5];                      /*!< Offset: 0x60  ISA Feature Register                                  */
X  volatile const  uint32_t ISAR[5];                       
N} SCB_Type;                                                
N
N/* SCB CPUID Register Definitions */
N#define SCB_CPUID_IMPLEMENTER_Pos          24                                             /*!< SCB CPUID: IMPLEMENTER Position */
N#define SCB_CPUID_IMPLEMENTER_Msk          (0xFFul << SCB_CPUID_IMPLEMENTER_Pos)          /*!< SCB CPUID: IMPLEMENTER Mask */
N
N#define SCB_CPUID_VARIANT_Pos              20                                             /*!< SCB CPUID: VARIANT Position */
N#define SCB_CPUID_VARIANT_Msk              (0xFul << SCB_CPUID_VARIANT_Pos)               /*!< SCB CPUID: VARIANT Mask */
N
N#define SCB_CPUID_PARTNO_Pos                4                                             /*!< SCB CPUID: PARTNO Position */
N#define SCB_CPUID_PARTNO_Msk               (0xFFFul << SCB_CPUID_PARTNO_Pos)              /*!< SCB CPUID: PARTNO Mask */
N
N#define SCB_CPUID_REVISION_Pos              0                                             /*!< SCB CPUID: REVISION Position */
N#define SCB_CPUID_REVISION_Msk             (0xFul << SCB_CPUID_REVISION_Pos)              /*!< SCB CPUID: REVISION Mask */
N
N/* SCB Interrupt Control State Register Definitions */
N#define SCB_ICSR_NMIPENDSET_Pos            31                                             /*!< SCB ICSR: NMIPENDSET Position */
N#define SCB_ICSR_NMIPENDSET_Msk            (1ul << SCB_ICSR_NMIPENDSET_Pos)               /*!< SCB ICSR: NMIPENDSET Mask */
N
N#define SCB_ICSR_PENDSVSET_Pos             28                                             /*!< SCB ICSR: PENDSVSET Position */
N#define SCB_ICSR_PENDSVSET_Msk             (1ul << SCB_ICSR_PENDSVSET_Pos)                /*!< SCB ICSR: PENDSVSET Mask */
N
N#define SCB_ICSR_PENDSVCLR_Pos             27                                             /*!< SCB ICSR: PENDSVCLR Position */
N#define SCB_ICSR_PENDSVCLR_Msk             (1ul << SCB_ICSR_PENDSVCLR_Pos)                /*!< SCB ICSR: PENDSVCLR Mask */
N
N#define SCB_ICSR_PENDSTSET_Pos             26                                             /*!< SCB ICSR: PENDSTSET Position */
N#define SCB_ICSR_PENDSTSET_Msk             (1ul << SCB_ICSR_PENDSTSET_Pos)                /*!< SCB ICSR: PENDSTSET Mask */
N
N#define SCB_ICSR_PENDSTCLR_Pos             25                                             /*!< SCB ICSR: PENDSTCLR Position */
N#define SCB_ICSR_PENDSTCLR_Msk             (1ul << SCB_ICSR_PENDSTCLR_Pos)                /*!< SCB ICSR: PENDSTCLR Mask */
N
N#define SCB_ICSR_ISRPREEMPT_Pos            23                                             /*!< SCB ICSR: ISRPREEMPT Position */
N#define SCB_ICSR_ISRPREEMPT_Msk            (1ul << SCB_ICSR_ISRPREEMPT_Pos)               /*!< SCB ICSR: ISRPREEMPT Mask */
N
N#define SCB_ICSR_ISRPENDING_Pos            22                                             /*!< SCB ICSR: ISRPENDING Position */
N#define SCB_ICSR_ISRPENDING_Msk            (1ul << SCB_ICSR_ISRPENDING_Pos)               /*!< SCB ICSR: ISRPENDING Mask */
N
N#define SCB_ICSR_VECTPENDING_Pos           12                                             /*!< SCB ICSR: VECTPENDING Position */
N#define SCB_ICSR_VECTPENDING_Msk           (0x1FFul << SCB_ICSR_VECTPENDING_Pos)          /*!< SCB ICSR: VECTPENDING Mask */
N
N#define SCB_ICSR_RETTOBASE_Pos             11                                             /*!< SCB ICSR: RETTOBASE Position */
N#define SCB_ICSR_RETTOBASE_Msk             (1ul << SCB_ICSR_RETTOBASE_Pos)                /*!< SCB ICSR: RETTOBASE Mask */
N
N#define SCB_ICSR_VECTACTIVE_Pos             0                                             /*!< SCB ICSR: VECTACTIVE Position */
N#define SCB_ICSR_VECTACTIVE_Msk            (0x1FFul << SCB_ICSR_VECTACTIVE_Pos)           /*!< SCB ICSR: VECTACTIVE Mask */
N
N/* SCB Interrupt Control State Register Definitions */
N#define SCB_VTOR_TBLBASE_Pos               29                                             /*!< SCB VTOR: TBLBASE Position */
N#define SCB_VTOR_TBLBASE_Msk               (0x1FFul << SCB_VTOR_TBLBASE_Pos)              /*!< SCB VTOR: TBLBASE Mask */
N
N#define SCB_VTOR_TBLOFF_Pos                 7                                             /*!< SCB VTOR: TBLOFF Position */
N#define SCB_VTOR_TBLOFF_Msk                (0x3FFFFFul << SCB_VTOR_TBLOFF_Pos)            /*!< SCB VTOR: TBLOFF Mask */
N
N/* SCB Application Interrupt and Reset Control Register Definitions */
N#define SCB_AIRCR_VECTKEY_Pos              16                                             /*!< SCB AIRCR: VECTKEY Position */
N#define SCB_AIRCR_VECTKEY_Msk              (0xFFFFul << SCB_AIRCR_VECTKEY_Pos)            /*!< SCB AIRCR: VECTKEY Mask */
N
N#define SCB_AIRCR_VECTKEYSTAT_Pos          16                                             /*!< SCB AIRCR: VECTKEYSTAT Position */
N#define SCB_AIRCR_VECTKEYSTAT_Msk          (0xFFFFul << SCB_AIRCR_VECTKEYSTAT_Pos)        /*!< SCB AIRCR: VECTKEYSTAT Mask */
N
N#define SCB_AIRCR_ENDIANESS_Pos            15                                             /*!< SCB AIRCR: ENDIANESS Position */
N#define SCB_AIRCR_ENDIANESS_Msk            (1ul << SCB_AIRCR_ENDIANESS_Pos)               /*!< SCB AIRCR: ENDIANESS Mask */
N
N#define SCB_AIRCR_PRIGROUP_Pos              8                                             /*!< SCB AIRCR: PRIGROUP Position */
N#define SCB_AIRCR_PRIGROUP_Msk             (7ul << SCB_AIRCR_PRIGROUP_Pos)                /*!< SCB AIRCR: PRIGROUP Mask */
N
N#define SCB_AIRCR_SYSRESETREQ_Pos           2                                             /*!< SCB AIRCR: SYSRESETREQ Position */
N#define SCB_AIRCR_SYSRESETREQ_Msk          (1ul << SCB_AIRCR_SYSRESETREQ_Pos)             /*!< SCB AIRCR: SYSRESETREQ Mask */
N
N#define SCB_AIRCR_VECTCLRACTIVE_Pos         1                                             /*!< SCB AIRCR: VECTCLRACTIVE Position */
N#define SCB_AIRCR_VECTCLRACTIVE_Msk        (1ul << SCB_AIRCR_VECTCLRACTIVE_Pos)           /*!< SCB AIRCR: VECTCLRACTIVE Mask */
N
N#define SCB_AIRCR_VECTRESET_Pos             0                                             /*!< SCB AIRCR: VECTRESET Position */
N#define SCB_AIRCR_VECTRESET_Msk            (1ul << SCB_AIRCR_VECTRESET_Pos)               /*!< SCB AIRCR: VECTRESET Mask */
N
N/* SCB System Control Register Definitions */
N#define SCB_SCR_SEVONPEND_Pos               4                                             /*!< SCB SCR: SEVONPEND Position */
N#define SCB_SCR_SEVONPEND_Msk              (1ul << SCB_SCR_SEVONPEND_Pos)                 /*!< SCB SCR: SEVONPEND Mask */
N
N#define SCB_SCR_SLEEPDEEP_Pos               2                                             /*!< SCB SCR: SLEEPDEEP Position */
N#define SCB_SCR_SLEEPDEEP_Msk              (1ul << SCB_SCR_SLEEPDEEP_Pos)                 /*!< SCB SCR: SLEEPDEEP Mask */
N
N#define SCB_SCR_SLEEPONEXIT_Pos             1                                             /*!< SCB SCR: SLEEPONEXIT Position */
N#define SCB_SCR_SLEEPONEXIT_Msk            (1ul << SCB_SCR_SLEEPONEXIT_Pos)               /*!< SCB SCR: SLEEPONEXIT Mask */
N
N/* SCB Configuration Control Register Definitions */
N#define SCB_CCR_STKALIGN_Pos                9                                             /*!< SCB CCR: STKALIGN Position */
N#define SCB_CCR_STKALIGN_Msk               (1ul << SCB_CCR_STKALIGN_Pos)                  /*!< SCB CCR: STKALIGN Mask */
N
N#define SCB_CCR_BFHFNMIGN_Pos               8                                             /*!< SCB CCR: BFHFNMIGN Position */
N#define SCB_CCR_BFHFNMIGN_Msk              (1ul << SCB_CCR_BFHFNMIGN_Pos)                 /*!< SCB CCR: BFHFNMIGN Mask */
N
N#define SCB_CCR_DIV_0_TRP_Pos               4                                             /*!< SCB CCR: DIV_0_TRP Position */
N#define SCB_CCR_DIV_0_TRP_Msk              (1ul << SCB_CCR_DIV_0_TRP_Pos)                 /*!< SCB CCR: DIV_0_TRP Mask */
N
N#define SCB_CCR_UNALIGN_TRP_Pos             3                                             /*!< SCB CCR: UNALIGN_TRP Position */
N#define SCB_CCR_UNALIGN_TRP_Msk            (1ul << SCB_CCR_UNALIGN_TRP_Pos)               /*!< SCB CCR: UNALIGN_TRP Mask */
N
N#define SCB_CCR_USERSETMPEND_Pos            1                                             /*!< SCB CCR: USERSETMPEND Position */
N#define SCB_CCR_USERSETMPEND_Msk           (1ul << SCB_CCR_USERSETMPEND_Pos)              /*!< SCB CCR: USERSETMPEND Mask */
N
N#define SCB_CCR_NONBASETHRDENA_Pos          0                                             /*!< SCB CCR: NONBASETHRDENA Position */
N#define SCB_CCR_NONBASETHRDENA_Msk         (1ul << SCB_CCR_NONBASETHRDENA_Pos)            /*!< SCB CCR: NONBASETHRDENA Mask */
N
N/* SCB System Handler Control and State Register Definitions */
N#define SCB_SHCSR_USGFAULTENA_Pos          18                                             /*!< SCB SHCSR: USGFAULTENA Position */
N#define SCB_SHCSR_USGFAULTENA_Msk          (1ul << SCB_SHCSR_USGFAULTENA_Pos)             /*!< SCB SHCSR: USGFAULTENA Mask */
N
N#define SCB_SHCSR_BUSFAULTENA_Pos          17                                             /*!< SCB SHCSR: BUSFAULTENA Position */
N#define SCB_SHCSR_BUSFAULTENA_Msk          (1ul << SCB_SHCSR_BUSFAULTENA_Pos)             /*!< SCB SHCSR: BUSFAULTENA Mask */
N
N#define SCB_SHCSR_MEMFAULTENA_Pos          16                                             /*!< SCB SHCSR: MEMFAULTENA Position */
N#define SCB_SHCSR_MEMFAULTENA_Msk          (1ul << SCB_SHCSR_MEMFAULTENA_Pos)             /*!< SCB SHCSR: MEMFAULTENA Mask */
N
N#define SCB_SHCSR_SVCALLPENDED_Pos         15                                             /*!< SCB SHCSR: SVCALLPENDED Position */
N#define SCB_SHCSR_SVCALLPENDED_Msk         (1ul << SCB_SHCSR_SVCALLPENDED_Pos)            /*!< SCB SHCSR: SVCALLPENDED Mask */
N
N#define SCB_SHCSR_BUSFAULTPENDED_Pos       14                                             /*!< SCB SHCSR: BUSFAULTPENDED Position */
N#define SCB_SHCSR_BUSFAULTPENDED_Msk       (1ul << SCB_SHCSR_BUSFAULTPENDED_Pos)          /*!< SCB SHCSR: BUSFAULTPENDED Mask */
N
N#define SCB_SHCSR_MEMFAULTPENDED_Pos       13                                             /*!< SCB SHCSR: MEMFAULTPENDED Position */
N#define SCB_SHCSR_MEMFAULTPENDED_Msk       (1ul << SCB_SHCSR_MEMFAULTPENDED_Pos)          /*!< SCB SHCSR: MEMFAULTPENDED Mask */
N
N#define SCB_SHCSR_USGFAULTPENDED_Pos       12                                             /*!< SCB SHCSR: USGFAULTPENDED Position */
N#define SCB_SHCSR_USGFAULTPENDED_Msk       (1ul << SCB_SHCSR_USGFAULTPENDED_Pos)          /*!< SCB SHCSR: USGFAULTPENDED Mask */
N
N#define SCB_SHCSR_SYSTICKACT_Pos           11                                             /*!< SCB SHCSR: SYSTICKACT Position */
N#define SCB_SHCSR_SYSTICKACT_Msk           (1ul << SCB_SHCSR_SYSTICKACT_Pos)              /*!< SCB SHCSR: SYSTICKACT Mask */
N
N#define SCB_SHCSR_PENDSVACT_Pos            10                                             /*!< SCB SHCSR: PENDSVACT Position */
N#define SCB_SHCSR_PENDSVACT_Msk            (1ul << SCB_SHCSR_PENDSVACT_Pos)               /*!< SCB SHCSR: PENDSVACT Mask */
N
N#define SCB_SHCSR_MONITORACT_Pos            8                                             /*!< SCB SHCSR: MONITORACT Position */
N#define SCB_SHCSR_MONITORACT_Msk           (1ul << SCB_SHCSR_MONITORACT_Pos)              /*!< SCB SHCSR: MONITORACT Mask */
N
N#define SCB_SHCSR_SVCALLACT_Pos             7                                             /*!< SCB SHCSR: SVCALLACT Position */
N#define SCB_SHCSR_SVCALLACT_Msk            (1ul << SCB_SHCSR_SVCALLACT_Pos)               /*!< SCB SHCSR: SVCALLACT Mask */
N                                     
N#define SCB_SHCSR_USGFAULTACT_Pos           3                                             /*!< SCB SHCSR: USGFAULTACT Position */
N#define SCB_SHCSR_USGFAULTACT_Msk          (1ul << SCB_SHCSR_USGFAULTACT_Pos)             /*!< SCB SHCSR: USGFAULTACT Mask */
N
N#define SCB_SHCSR_BUSFAULTACT_Pos           1                                             /*!< SCB SHCSR: BUSFAULTACT Position */
N#define SCB_SHCSR_BUSFAULTACT_Msk          (1ul << SCB_SHCSR_BUSFAULTACT_Pos)             /*!< SCB SHCSR: BUSFAULTACT Mask */
N
N#define SCB_SHCSR_MEMFAULTACT_Pos           0                                             /*!< SCB SHCSR: MEMFAULTACT Position */
N#define SCB_SHCSR_MEMFAULTACT_Msk          (1ul << SCB_SHCSR_MEMFAULTACT_Pos)             /*!< SCB SHCSR: MEMFAULTACT Mask */
N
N/* SCB Configurable Fault Status Registers Definitions */
N#define SCB_CFSR_USGFAULTSR_Pos            16                                             /*!< SCB CFSR: Usage Fault Status Register Position */
N#define SCB_CFSR_USGFAULTSR_Msk            (0xFFFFul << SCB_CFSR_USGFAULTSR_Pos)          /*!< SCB CFSR: Usage Fault Status Register Mask */
N
N#define SCB_CFSR_BUSFAULTSR_Pos             8                                             /*!< SCB CFSR: Bus Fault Status Register Position */
N#define SCB_CFSR_BUSFAULTSR_Msk            (0xFFul << SCB_CFSR_BUSFAULTSR_Pos)            /*!< SCB CFSR: Bus Fault Status Register Mask */
N
N#define SCB_CFSR_MEMFAULTSR_Pos             0                                             /*!< SCB CFSR: Memory Manage Fault Status Register Position */
N#define SCB_CFSR_MEMFAULTSR_Msk            (0xFFul << SCB_CFSR_MEMFAULTSR_Pos)            /*!< SCB CFSR: Memory Manage Fault Status Register Mask */
N
N/* SCB Hard Fault Status Registers Definitions */
N#define SCB_HFSR_DEBUGEVT_Pos              31                                             /*!< SCB HFSR: DEBUGEVT Position */
N#define SCB_HFSR_DEBUGEVT_Msk              (1ul << SCB_HFSR_DEBUGEVT_Pos)                 /*!< SCB HFSR: DEBUGEVT Mask */
N
N#define SCB_HFSR_FORCED_Pos                30                                             /*!< SCB HFSR: FORCED Position */
N#define SCB_HFSR_FORCED_Msk                (1ul << SCB_HFSR_FORCED_Pos)                   /*!< SCB HFSR: FORCED Mask */
N
N#define SCB_HFSR_VECTTBL_Pos                1                                             /*!< SCB HFSR: VECTTBL Position */
N#define SCB_HFSR_VECTTBL_Msk               (1ul << SCB_HFSR_VECTTBL_Pos)                  /*!< SCB HFSR: VECTTBL Mask */
N
N/* SCB Debug Fault Status Register Definitions */
N#define SCB_DFSR_EXTERNAL_Pos               4                                             /*!< SCB DFSR: EXTERNAL Position */
N#define SCB_DFSR_EXTERNAL_Msk              (1ul << SCB_DFSR_EXTERNAL_Pos)                 /*!< SCB DFSR: EXTERNAL Mask */
N
N#define SCB_DFSR_VCATCH_Pos                 3                                             /*!< SCB DFSR: VCATCH Position */
N#define SCB_DFSR_VCATCH_Msk                (1ul << SCB_DFSR_VCATCH_Pos)                   /*!< SCB DFSR: VCATCH Mask */
N
N#define SCB_DFSR_DWTTRAP_Pos                2                                             /*!< SCB DFSR: DWTTRAP Position */
N#define SCB_DFSR_DWTTRAP_Msk               (1ul << SCB_DFSR_DWTTRAP_Pos)                  /*!< SCB DFSR: DWTTRAP Mask */
N
N#define SCB_DFSR_BKPT_Pos                   1                                             /*!< SCB DFSR: BKPT Position */
N#define SCB_DFSR_BKPT_Msk                  (1ul << SCB_DFSR_BKPT_Pos)                     /*!< SCB DFSR: BKPT Mask */
N
N#define SCB_DFSR_HALTED_Pos                 0                                             /*!< SCB DFSR: HALTED Position */
N#define SCB_DFSR_HALTED_Msk                (1ul << SCB_DFSR_HALTED_Pos)                   /*!< SCB DFSR: HALTED Mask */
N/*@}*/ /* end of group CMSIS_CM3_SCB */
N
N
N/** @addtogroup CMSIS_CM3_SysTick CMSIS CM3 SysTick
N  memory mapped structure for SysTick
N  @{
N */
Ntypedef struct
N{
N  __IO uint32_t CTRL;                         /*!< Offset: 0x00  SysTick Control and Status Register */
X  volatile uint32_t CTRL;                          
N  __IO uint32_t LOAD;                         /*!< Offset: 0x04  SysTick Reload Value Register       */
X  volatile uint32_t LOAD;                          
N  __IO uint32_t VAL;                          /*!< Offset: 0x08  SysTick Current Value Register      */
X  volatile uint32_t VAL;                           
N  __I  uint32_t CALIB;                        /*!< Offset: 0x0C  SysTick Calibration Register        */
X  volatile const  uint32_t CALIB;                         
N} SysTick_Type;
N
N/* SysTick Control / Status Register Definitions */
N#define SysTick_CTRL_COUNTFLAG_Pos         16                                             /*!< SysTick CTRL: COUNTFLAG Position */
N#define SysTick_CTRL_COUNTFLAG_Msk         (1ul << SysTick_CTRL_COUNTFLAG_Pos)            /*!< SysTick CTRL: COUNTFLAG Mask */
N
N#define SysTick_CTRL_CLKSOURCE_Pos          2                                             /*!< SysTick CTRL: CLKSOURCE Position */
N#define SysTick_CTRL_CLKSOURCE_Msk         (1ul << SysTick_CTRL_CLKSOURCE_Pos)            /*!< SysTick CTRL: CLKSOURCE Mask */
N
N#define SysTick_CTRL_TICKINT_Pos            1                                             /*!< SysTick CTRL: TICKINT Position */
N#define SysTick_CTRL_TICKINT_Msk           (1ul << SysTick_CTRL_TICKINT_Pos)              /*!< SysTick CTRL: TICKINT Mask */
N
N#define SysTick_CTRL_ENABLE_Pos             0                                             /*!< SysTick CTRL: ENABLE Position */
N#define SysTick_CTRL_ENABLE_Msk            (1ul << SysTick_CTRL_ENABLE_Pos)               /*!< SysTick CTRL: ENABLE Mask */
N
N/* SysTick Reload Register Definitions */
N#define SysTick_LOAD_RELOAD_Pos             0                                             /*!< SysTick LOAD: RELOAD Position */
N#define SysTick_LOAD_RELOAD_Msk            (0xFFFFFFul << SysTick_LOAD_RELOAD_Pos)        /*!< SysTick LOAD: RELOAD Mask */
N
N/* SysTick Current Register Definitions */
N#define SysTick_VAL_CURRENT_Pos             0                                             /*!< SysTick VAL: CURRENT Position */
N#define SysTick_VAL_CURRENT_Msk            (0xFFFFFFul << SysTick_VAL_CURRENT_Pos)        /*!< SysTick VAL: CURRENT Mask */
N
N/* SysTick Calibration Register Definitions */
N#define SysTick_CALIB_NOREF_Pos            31                                             /*!< SysTick CALIB: NOREF Position */
N#define SysTick_CALIB_NOREF_Msk            (1ul << SysTick_CALIB_NOREF_Pos)               /*!< SysTick CALIB: NOREF Mask */
N
N#define SysTick_CALIB_SKEW_Pos             30                                             /*!< SysTick CALIB: SKEW Position */
N#define SysTick_CALIB_SKEW_Msk             (1ul << SysTick_CALIB_SKEW_Pos)                /*!< SysTick CALIB: SKEW Mask */
N
N#define SysTick_CALIB_TENMS_Pos             0                                             /*!< SysTick CALIB: TENMS Position */
N#define SysTick_CALIB_TENMS_Msk            (0xFFFFFFul << SysTick_VAL_CURRENT_Pos)        /*!< SysTick CALIB: TENMS Mask */
N/*@}*/ /* end of group CMSIS_CM3_SysTick */
N
N
N/** @addtogroup CMSIS_CM3_ITM CMSIS CM3 ITM
N  memory mapped structure for Instrumentation Trace Macrocell (ITM)
N  @{
N */
Ntypedef struct
N{
N  __O  union  
X  volatile  union  
N  {
N    __O  uint8_t    u8;                       /*!< Offset:       ITM Stimulus Port 8-bit                   */
X    volatile  uint8_t    u8;                        
N    __O  uint16_t   u16;                      /*!< Offset:       ITM Stimulus Port 16-bit                  */
X    volatile  uint16_t   u16;                       
N    __O  uint32_t   u32;                      /*!< Offset:       ITM Stimulus Port 32-bit                  */
X    volatile  uint32_t   u32;                       
N  }  PORT [32];                               /*!< Offset: 0x00  ITM Stimulus Port Registers               */
N       uint32_t RESERVED0[864];                                 
N  __IO uint32_t TER;                          /*!< Offset:       ITM Trace Enable Register                 */
X  volatile uint32_t TER;                           
N       uint32_t RESERVED1[15];                                  
N  __IO uint32_t TPR;                          /*!< Offset:       ITM Trace Privilege Register              */
X  volatile uint32_t TPR;                           
N       uint32_t RESERVED2[15];                                  
N  __IO uint32_t TCR;                          /*!< Offset:       ITM Trace Control Register                */
X  volatile uint32_t TCR;                           
N       uint32_t RESERVED3[29];                                  
N  __IO uint32_t IWR;                          /*!< Offset:       ITM Integration Write Register            */
X  volatile uint32_t IWR;                           
N  __IO uint32_t IRR;                          /*!< Offset:       ITM Integration Read Register             */
X  volatile uint32_t IRR;                           
N  __IO uint32_t IMCR;                         /*!< Offset:       ITM Integration Mode Control Register     */
X  volatile uint32_t IMCR;                          
N       uint32_t RESERVED4[43];                                  
N  __IO uint32_t LAR;                          /*!< Offset:       ITM Lock Access Register                  */
X  volatile uint32_t LAR;                           
N  __IO uint32_t LSR;                          /*!< Offset:       ITM Lock Status Register                  */
X  volatile uint32_t LSR;                           
N       uint32_t RESERVED5[6];                                   
N  __I  uint32_t PID4;                         /*!< Offset:       ITM Peripheral Identification Register #4 */
X  volatile const  uint32_t PID4;                          
N  __I  uint32_t PID5;                         /*!< Offset:       ITM Peripheral Identification Register #5 */
X  volatile const  uint32_t PID5;                          
N  __I  uint32_t PID6;                         /*!< Offset:       ITM Peripheral Identification Register #6 */
X  volatile const  uint32_t PID6;                          
N  __I  uint32_t PID7;                         /*!< Offset:       ITM Peripheral Identification Register #7 */
X  volatile const  uint32_t PID7;                          
N  __I  uint32_t PID0;                         /*!< Offset:       ITM Peripheral Identification Register #0 */
X  volatile const  uint32_t PID0;                          
N  __I  uint32_t PID1;                         /*!< Offset:       ITM Peripheral Identification Register #1 */
X  volatile const  uint32_t PID1;                          
N  __I  uint32_t PID2;                         /*!< Offset:       ITM Peripheral Identification Register #2 */
X  volatile const  uint32_t PID2;                          
N  __I  uint32_t PID3;                         /*!< Offset:       ITM Peripheral Identification Register #3 */
X  volatile const  uint32_t PID3;                          
N  __I  uint32_t CID0;                         /*!< Offset:       ITM Component  Identification Register #0 */
X  volatile const  uint32_t CID0;                          
N  __I  uint32_t CID1;                         /*!< Offset:       ITM Component  Identification Register #1 */
X  volatile const  uint32_t CID1;                          
N  __I  uint32_t CID2;                         /*!< Offset:       ITM Component  Identification Register #2 */
X  volatile const  uint32_t CID2;                          
N  __I  uint32_t CID3;                         /*!< Offset:       ITM Component  Identification Register #3 */
X  volatile const  uint32_t CID3;                          
N} ITM_Type;                                                
N
N/* ITM Trace Privilege Register Definitions */
N#define ITM_TPR_PRIVMASK_Pos                0                                             /*!< ITM TPR: PRIVMASK Position */
N#define ITM_TPR_PRIVMASK_Msk               (0xFul << ITM_TPR_PRIVMASK_Pos)                /*!< ITM TPR: PRIVMASK Mask */
N
N/* ITM Trace Control Register Definitions */
N#define ITM_TCR_BUSY_Pos                   23                                             /*!< ITM TCR: BUSY Position */
N#define ITM_TCR_BUSY_Msk                   (1ul << ITM_TCR_BUSY_Pos)                      /*!< ITM TCR: BUSY Mask */
N
N#define ITM_TCR_ATBID_Pos                  16                                             /*!< ITM TCR: ATBID Position */
N#define ITM_TCR_ATBID_Msk                  (0x7Ful << ITM_TCR_ATBID_Pos)                  /*!< ITM TCR: ATBID Mask */
N
N#define ITM_TCR_TSPrescale_Pos              8                                             /*!< ITM TCR: TSPrescale Position */
N#define ITM_TCR_TSPrescale_Msk             (3ul << ITM_TCR_TSPrescale_Pos)                /*!< ITM TCR: TSPrescale Mask */
N
N#define ITM_TCR_SWOENA_Pos                  4                                             /*!< ITM TCR: SWOENA Position */
N#define ITM_TCR_SWOENA_Msk                 (1ul << ITM_TCR_SWOENA_Pos)                    /*!< ITM TCR: SWOENA Mask */
N
N#define ITM_TCR_DWTENA_Pos                  3                                             /*!< ITM TCR: DWTENA Position */
N#define ITM_TCR_DWTENA_Msk                 (1ul << ITM_TCR_DWTENA_Pos)                    /*!< ITM TCR: DWTENA Mask */
N
N#define ITM_TCR_SYNCENA_Pos                 2                                             /*!< ITM TCR: SYNCENA Position */
N#define ITM_TCR_SYNCENA_Msk                (1ul << ITM_TCR_SYNCENA_Pos)                   /*!< ITM TCR: SYNCENA Mask */
N
N#define ITM_TCR_TSENA_Pos                   1                                             /*!< ITM TCR: TSENA Position */
N#define ITM_TCR_TSENA_Msk                  (1ul << ITM_TCR_TSENA_Pos)                     /*!< ITM TCR: TSENA Mask */
N
N#define ITM_TCR_ITMENA_Pos                  0                                             /*!< ITM TCR: ITM Enable bit Position */
N#define ITM_TCR_ITMENA_Msk                 (1ul << ITM_TCR_ITMENA_Pos)                    /*!< ITM TCR: ITM Enable bit Mask */
N
N/* ITM Integration Write Register Definitions */
N#define ITM_IWR_ATVALIDM_Pos                0                                             /*!< ITM IWR: ATVALIDM Position */
N#define ITM_IWR_ATVALIDM_Msk               (1ul << ITM_IWR_ATVALIDM_Pos)                  /*!< ITM IWR: ATVALIDM Mask */
N
N/* ITM Integration Read Register Definitions */
N#define ITM_IRR_ATREADYM_Pos                0                                             /*!< ITM IRR: ATREADYM Position */
N#define ITM_IRR_ATREADYM_Msk               (1ul << ITM_IRR_ATREADYM_Pos)                  /*!< ITM IRR: ATREADYM Mask */
N
N/* ITM Integration Mode Control Register Definitions */
N#define ITM_IMCR_INTEGRATION_Pos            0                                             /*!< ITM IMCR: INTEGRATION Position */
N#define ITM_IMCR_INTEGRATION_Msk           (1ul << ITM_IMCR_INTEGRATION_Pos)              /*!< ITM IMCR: INTEGRATION Mask */
N
N/* ITM Lock Status Register Definitions */
N#define ITM_LSR_ByteAcc_Pos                 2                                             /*!< ITM LSR: ByteAcc Position */
N#define ITM_LSR_ByteAcc_Msk                (1ul << ITM_LSR_ByteAcc_Pos)                   /*!< ITM LSR: ByteAcc Mask */
N
N#define ITM_LSR_Access_Pos                  1                                             /*!< ITM LSR: Access Position */
N#define ITM_LSR_Access_Msk                 (1ul << ITM_LSR_Access_Pos)                    /*!< ITM LSR: Access Mask */
N
N#define ITM_LSR_Present_Pos                 0                                             /*!< ITM LSR: Present Position */
N#define ITM_LSR_Present_Msk                (1ul << ITM_LSR_Present_Pos)                   /*!< ITM LSR: Present Mask */
N/*@}*/ /* end of group CMSIS_CM3_ITM */
N
N
N/** @addtogroup CMSIS_CM3_InterruptType CMSIS CM3 Interrupt Type
N  memory mapped structure for Interrupt Type
N  @{
N */
Ntypedef struct
N{
N       uint32_t RESERVED0;
N  __I  uint32_t ICTR;                         /*!< Offset: 0x04  Interrupt Control Type Register */
X  volatile const  uint32_t ICTR;                          
N#if ((defined __CM3_REV) && (__CM3_REV >= 0x200))
X#if ((0L) && (__CM3_REV >= 0x200))
S  __IO uint32_t ACTLR;                        /*!< Offset: 0x08  Auxiliary Control Register      */
N#else
N       uint32_t RESERVED1;
N#endif
N} InterruptType_Type;
N
N/* Interrupt Controller Type Register Definitions */
N#define InterruptType_ICTR_INTLINESNUM_Pos  0                                             /*!< InterruptType ICTR: INTLINESNUM Position */
N#define InterruptType_ICTR_INTLINESNUM_Msk (0x1Ful << InterruptType_ICTR_INTLINESNUM_Pos) /*!< InterruptType ICTR: INTLINESNUM Mask */
N
N/* Auxiliary Control Register Definitions */
N#define InterruptType_ACTLR_DISFOLD_Pos     2                                             /*!< InterruptType ACTLR: DISFOLD Position */
N#define InterruptType_ACTLR_DISFOLD_Msk    (1ul << InterruptType_ACTLR_DISFOLD_Pos)       /*!< InterruptType ACTLR: DISFOLD Mask */
N
N#define InterruptType_ACTLR_DISDEFWBUF_Pos  1                                             /*!< InterruptType ACTLR: DISDEFWBUF Position */
N#define InterruptType_ACTLR_DISDEFWBUF_Msk (1ul << InterruptType_ACTLR_DISDEFWBUF_Pos)    /*!< InterruptType ACTLR: DISDEFWBUF Mask */
N
N#define InterruptType_ACTLR_DISMCYCINT_Pos  0                                             /*!< InterruptType ACTLR: DISMCYCINT Position */
N#define InterruptType_ACTLR_DISMCYCINT_Msk (1ul << InterruptType_ACTLR_DISMCYCINT_Pos)    /*!< InterruptType ACTLR: DISMCYCINT Mask */
N/*@}*/ /* end of group CMSIS_CM3_InterruptType */
N
N
N#if defined (__MPU_PRESENT) && (__MPU_PRESENT == 1)
X#if 1L && (0 == 1)
S/** @addtogroup CMSIS_CM3_MPU CMSIS CM3 MPU
S  memory mapped structure for Memory Protection Unit (MPU)
S  @{
S */
Stypedef struct
S{
S  __I  uint32_t TYPE;                         /*!< Offset: 0x00  MPU Type Register                              */
S  __IO uint32_t CTRL;                         /*!< Offset: 0x04  MPU Control Register                           */
S  __IO uint32_t RNR;                          /*!< Offset: 0x08  MPU Region RNRber Register                     */
S  __IO uint32_t RBAR;                         /*!< Offset: 0x0C  MPU Region Base Address Register               */
S  __IO uint32_t RASR;                         /*!< Offset: 0x10  MPU Region Attribute and Size Register         */
S  __IO uint32_t RBAR_A1;                      /*!< Offset: 0x14  MPU Alias 1 Region Base Address Register       */
S  __IO uint32_t RASR_A1;                      /*!< Offset: 0x18  MPU Alias 1 Region Attribute and Size Register */
S  __IO uint32_t RBAR_A2;                      /*!< Offset: 0x1C  MPU Alias 2 Region Base Address Register       */
S  __IO uint32_t RASR_A2;                      /*!< Offset: 0x20  MPU Alias 2 Region Attribute and Size Register */
S  __IO uint32_t RBAR_A3;                      /*!< Offset: 0x24  MPU Alias 3 Region Base Address Register       */
S  __IO uint32_t RASR_A3;                      /*!< Offset: 0x28  MPU Alias 3 Region Attribute and Size Register */
S} MPU_Type;                                                
S
S/* MPU Type Register */
S#define MPU_TYPE_IREGION_Pos               16                                             /*!< MPU TYPE: IREGION Position */
S#define MPU_TYPE_IREGION_Msk               (0xFFul << MPU_TYPE_IREGION_Pos)               /*!< MPU TYPE: IREGION Mask */
S
S#define MPU_TYPE_DREGION_Pos                8                                             /*!< MPU TYPE: DREGION Position */
S#define MPU_TYPE_DREGION_Msk               (0xFFul << MPU_TYPE_DREGION_Pos)               /*!< MPU TYPE: DREGION Mask */
S
S#define MPU_TYPE_SEPARATE_Pos               0                                             /*!< MPU TYPE: SEPARATE Position */
S#define MPU_TYPE_SEPARATE_Msk              (1ul << MPU_TYPE_SEPARATE_Pos)                 /*!< MPU TYPE: SEPARATE Mask */
S
S/* MPU Control Register */
S#define MPU_CTRL_PRIVDEFENA_Pos             2                                             /*!< MPU CTRL: PRIVDEFENA Position */
S#define MPU_CTRL_PRIVDEFENA_Msk            (1ul << MPU_CTRL_PRIVDEFENA_Pos)               /*!< MPU CTRL: PRIVDEFENA Mask */
S
S#define MPU_CTRL_HFNMIENA_Pos               1                                             /*!< MPU CTRL: HFNMIENA Position */
S#define MPU_CTRL_HFNMIENA_Msk              (1ul << MPU_CTRL_HFNMIENA_Pos)                 /*!< MPU CTRL: HFNMIENA Mask */
S
S#define MPU_CTRL_ENABLE_Pos                 0                                             /*!< MPU CTRL: ENABLE Position */
S#define MPU_CTRL_ENABLE_Msk                (1ul << MPU_CTRL_ENABLE_Pos)                   /*!< MPU CTRL: ENABLE Mask */
S
S/* MPU Region Number Register */
S#define MPU_RNR_REGION_Pos                  0                                             /*!< MPU RNR: REGION Position */
S#define MPU_RNR_REGION_Msk                 (0xFFul << MPU_RNR_REGION_Pos)                 /*!< MPU RNR: REGION Mask */
S
S/* MPU Region Base Address Register */
S#define MPU_RBAR_ADDR_Pos                   5                                             /*!< MPU RBAR: ADDR Position */
S#define MPU_RBAR_ADDR_Msk                  (0x7FFFFFFul << MPU_RBAR_ADDR_Pos)             /*!< MPU RBAR: ADDR Mask */
S
S#define MPU_RBAR_VALID_Pos                  4                                             /*!< MPU RBAR: VALID Position */
S#define MPU_RBAR_VALID_Msk                 (1ul << MPU_RBAR_VALID_Pos)                    /*!< MPU RBAR: VALID Mask */
S
S#define MPU_RBAR_REGION_Pos                 0                                             /*!< MPU RBAR: REGION Position */
S#define MPU_RBAR_REGION_Msk                (0xFul << MPU_RBAR_REGION_Pos)                 /*!< MPU RBAR: REGION Mask */
S
S/* MPU Region Attribute and Size Register */
S#define MPU_RASR_XN_Pos                    28                                             /*!< MPU RASR: XN Position */
S#define MPU_RASR_XN_Msk                    (1ul << MPU_RASR_XN_Pos)                       /*!< MPU RASR: XN Mask */
S
S#define MPU_RASR_AP_Pos                    24                                             /*!< MPU RASR: AP Position */
S#define MPU_RASR_AP_Msk                    (7ul << MPU_RASR_AP_Pos)                       /*!< MPU RASR: AP Mask */
S
S#define MPU_RASR_TEX_Pos                   19                                             /*!< MPU RASR: TEX Position */
S#define MPU_RASR_TEX_Msk                   (7ul << MPU_RASR_TEX_Pos)                      /*!< MPU RASR: TEX Mask */
S
S#define MPU_RASR_S_Pos                     18                                             /*!< MPU RASR: Shareable bit Position */
S#define MPU_RASR_S_Msk                     (1ul << MPU_RASR_S_Pos)                        /*!< MPU RASR: Shareable bit Mask */
S
S#define MPU_RASR_C_Pos                     17                                             /*!< MPU RASR: Cacheable bit Position */
S#define MPU_RASR_C_Msk                     (1ul << MPU_RASR_C_Pos)                        /*!< MPU RASR: Cacheable bit Mask */
S
S#define MPU_RASR_B_Pos                     16                                             /*!< MPU RASR: Bufferable bit Position */
S#define MPU_RASR_B_Msk                     (1ul << MPU_RASR_B_Pos)                        /*!< MPU RASR: Bufferable bit Mask */
S
S#define MPU_RASR_SRD_Pos                    8                                             /*!< MPU RASR: Sub-Region Disable Position */
S#define MPU_RASR_SRD_Msk                   (0xFFul << MPU_RASR_SRD_Pos)                   /*!< MPU RASR: Sub-Region Disable Mask */
S
S#define MPU_RASR_SIZE_Pos                   1                                             /*!< MPU RASR: Region Size Field Position */
S#define MPU_RASR_SIZE_Msk                  (0x1Ful << MPU_RASR_SIZE_Pos)                  /*!< MPU RASR: Region Size Field Mask */
S
S#define MPU_RASR_ENA_Pos                     0                                            /*!< MPU RASR: Region enable bit Position */
S#define MPU_RASR_ENA_Msk                    (0x1Ful << MPU_RASR_ENA_Pos)                  /*!< MPU RASR: Region enable bit Disable Mask */
S
S/*@}*/ /* end of group CMSIS_CM3_MPU */
N#endif
N
N
N/** @addtogroup CMSIS_CM3_CoreDebug CMSIS CM3 Core Debug
N  memory mapped structure for Core Debug Register
N  @{
N */
Ntypedef struct
N{
N  __IO uint32_t DHCSR;                        /*!< Offset: 0x00  Debug Halting Control and Status Register    */
X  volatile uint32_t DHCSR;                         
N  __O  uint32_t DCRSR;                        /*!< Offset: 0x04  Debug Core Register Selector Register        */
X  volatile  uint32_t DCRSR;                         
N  __IO uint32_t DCRDR;                        /*!< Offset: 0x08  Debug Core Register Data Register            */
X  volatile uint32_t DCRDR;                         
N  __IO uint32_t DEMCR;                        /*!< Offset: 0x0C  Debug Exception and Monitor Control Register */
X  volatile uint32_t DEMCR;                         
N} CoreDebug_Type;
N
N/* Debug Halting Control and Status Register */
N#define CoreDebug_DHCSR_DBGKEY_Pos         16                                             /*!< CoreDebug DHCSR: DBGKEY Position */
N#define CoreDebug_DHCSR_DBGKEY_Msk         (0xFFFFul << CoreDebug_DHCSR_DBGKEY_Pos)       /*!< CoreDebug DHCSR: DBGKEY Mask */
N
N#define CoreDebug_DHCSR_S_RESET_ST_Pos     25                                             /*!< CoreDebug DHCSR: S_RESET_ST Position */
N#define CoreDebug_DHCSR_S_RESET_ST_Msk     (1ul << CoreDebug_DHCSR_S_RESET_ST_Pos)        /*!< CoreDebug DHCSR: S_RESET_ST Mask */
N
N#define CoreDebug_DHCSR_S_RETIRE_ST_Pos    24                                             /*!< CoreDebug DHCSR: S_RETIRE_ST Position */
N#define CoreDebug_DHCSR_S_RETIRE_ST_Msk    (1ul << CoreDebug_DHCSR_S_RETIRE_ST_Pos)       /*!< CoreDebug DHCSR: S_RETIRE_ST Mask */
N
N#define CoreDebug_DHCSR_S_LOCKUP_Pos       19                                             /*!< CoreDebug DHCSR: S_LOCKUP Position */
N#define CoreDebug_DHCSR_S_LOCKUP_Msk       (1ul << CoreDebug_DHCSR_S_LOCKUP_Pos)          /*!< CoreDebug DHCSR: S_LOCKUP Mask */
N
N#define CoreDebug_DHCSR_S_SLEEP_Pos        18                                             /*!< CoreDebug DHCSR: S_SLEEP Position */
N#define CoreDebug_DHCSR_S_SLEEP_Msk        (1ul << CoreDebug_DHCSR_S_SLEEP_Pos)           /*!< CoreDebug DHCSR: S_SLEEP Mask */
N
N#define CoreDebug_DHCSR_S_HALT_Pos         17                                             /*!< CoreDebug DHCSR: S_HALT Position */
N#define CoreDebug_DHCSR_S_HALT_Msk         (1ul << CoreDebug_DHCSR_S_HALT_Pos)            /*!< CoreDebug DHCSR: S_HALT Mask */
N
N#define CoreDebug_DHCSR_S_REGRDY_Pos       16                                             /*!< CoreDebug DHCSR: S_REGRDY Position */
N#define CoreDebug_DHCSR_S_REGRDY_Msk       (1ul << CoreDebug_DHCSR_S_REGRDY_Pos)          /*!< CoreDebug DHCSR: S_REGRDY Mask */
N
N#define CoreDebug_DHCSR_C_SNAPSTALL_Pos     5                                             /*!< CoreDebug DHCSR: C_SNAPSTALL Position */
N#define CoreDebug_DHCSR_C_SNAPSTALL_Msk    (1ul << CoreDebug_DHCSR_C_SNAPSTALL_Pos)       /*!< CoreDebug DHCSR: C_SNAPSTALL Mask */
N
N#define CoreDebug_DHCSR_C_MASKINTS_Pos      3                                             /*!< CoreDebug DHCSR: C_MASKINTS Position */
N#define CoreDebug_DHCSR_C_MASKINTS_Msk     (1ul << CoreDebug_DHCSR_C_MASKINTS_Pos)        /*!< CoreDebug DHCSR: C_MASKINTS Mask */
N
N#define CoreDebug_DHCSR_C_STEP_Pos          2                                             /*!< CoreDebug DHCSR: C_STEP Position */
N#define CoreDebug_DHCSR_C_STEP_Msk         (1ul << CoreDebug_DHCSR_C_STEP_Pos)            /*!< CoreDebug DHCSR: C_STEP Mask */
N
N#define CoreDebug_DHCSR_C_HALT_Pos          1                                             /*!< CoreDebug DHCSR: C_HALT Position */
N#define CoreDebug_DHCSR_C_HALT_Msk         (1ul << CoreDebug_DHCSR_C_HALT_Pos)            /*!< CoreDebug DHCSR: C_HALT Mask */
N
N#define CoreDebug_DHCSR_C_DEBUGEN_Pos       0                                             /*!< CoreDebug DHCSR: C_DEBUGEN Position */
N#define CoreDebug_DHCSR_C_DEBUGEN_Msk      (1ul << CoreDebug_DHCSR_C_DEBUGEN_Pos)         /*!< CoreDebug DHCSR: C_DEBUGEN Mask */
N
N/* Debug Core Register Selector Register */
N#define CoreDebug_DCRSR_REGWnR_Pos         16                                             /*!< CoreDebug DCRSR: REGWnR Position */
N#define CoreDebug_DCRSR_REGWnR_Msk         (1ul << CoreDebug_DCRSR_REGWnR_Pos)            /*!< CoreDebug DCRSR: REGWnR Mask */
N
N#define CoreDebug_DCRSR_REGSEL_Pos          0                                             /*!< CoreDebug DCRSR: REGSEL Position */
N#define CoreDebug_DCRSR_REGSEL_Msk         (0x1Ful << CoreDebug_DCRSR_REGSEL_Pos)         /*!< CoreDebug DCRSR: REGSEL Mask */
N
N/* Debug Exception and Monitor Control Register */
N#define CoreDebug_DEMCR_TRCENA_Pos         24                                             /*!< CoreDebug DEMCR: TRCENA Position */
N#define CoreDebug_DEMCR_TRCENA_Msk         (1ul << CoreDebug_DEMCR_TRCENA_Pos)            /*!< CoreDebug DEMCR: TRCENA Mask */
N
N#define CoreDebug_DEMCR_MON_REQ_Pos        19                                             /*!< CoreDebug DEMCR: MON_REQ Position */
N#define CoreDebug_DEMCR_MON_REQ_Msk        (1ul << CoreDebug_DEMCR_MON_REQ_Pos)           /*!< CoreDebug DEMCR: MON_REQ Mask */
N
N#define CoreDebug_DEMCR_MON_STEP_Pos       18                                             /*!< CoreDebug DEMCR: MON_STEP Position */
N#define CoreDebug_DEMCR_MON_STEP_Msk       (1ul << CoreDebug_DEMCR_MON_STEP_Pos)          /*!< CoreDebug DEMCR: MON_STEP Mask */
N
N#define CoreDebug_DEMCR_MON_PEND_Pos       17                                             /*!< CoreDebug DEMCR: MON_PEND Position */
N#define CoreDebug_DEMCR_MON_PEND_Msk       (1ul << CoreDebug_DEMCR_MON_PEND_Pos)          /*!< CoreDebug DEMCR: MON_PEND Mask */
N
N#define CoreDebug_DEMCR_MON_EN_Pos         16                                             /*!< CoreDebug DEMCR: MON_EN Position */
N#define CoreDebug_DEMCR_MON_EN_Msk         (1ul << CoreDebug_DEMCR_MON_EN_Pos)            /*!< CoreDebug DEMCR: MON_EN Mask */
N
N#define CoreDebug_DEMCR_VC_HARDERR_Pos     10                                             /*!< CoreDebug DEMCR: VC_HARDERR Position */
N#define CoreDebug_DEMCR_VC_HARDERR_Msk     (1ul << CoreDebug_DEMCR_VC_HARDERR_Pos)        /*!< CoreDebug DEMCR: VC_HARDERR Mask */
N
N#define CoreDebug_DEMCR_VC_INTERR_Pos       9                                             /*!< CoreDebug DEMCR: VC_INTERR Position */
N#define CoreDebug_DEMCR_VC_INTERR_Msk      (1ul << CoreDebug_DEMCR_VC_INTERR_Pos)         /*!< CoreDebug DEMCR: VC_INTERR Mask */
N
N#define CoreDebug_DEMCR_VC_BUSERR_Pos       8                                             /*!< CoreDebug DEMCR: VC_BUSERR Position */
N#define CoreDebug_DEMCR_VC_BUSERR_Msk      (1ul << CoreDebug_DEMCR_VC_BUSERR_Pos)         /*!< CoreDebug DEMCR: VC_BUSERR Mask */
N
N#define CoreDebug_DEMCR_VC_STATERR_Pos      7                                             /*!< CoreDebug DEMCR: VC_STATERR Position */
N#define CoreDebug_DEMCR_VC_STATERR_Msk     (1ul << CoreDebug_DEMCR_VC_STATERR_Pos)        /*!< CoreDebug DEMCR: VC_STATERR Mask */
N
N#define CoreDebug_DEMCR_VC_CHKERR_Pos       6                                             /*!< CoreDebug DEMCR: VC_CHKERR Position */
N#define CoreDebug_DEMCR_VC_CHKERR_Msk      (1ul << CoreDebug_DEMCR_VC_CHKERR_Pos)         /*!< CoreDebug DEMCR: VC_CHKERR Mask */
N
N#define CoreDebug_DEMCR_VC_NOCPERR_Pos      5                                             /*!< CoreDebug DEMCR: VC_NOCPERR Position */
N#define CoreDebug_DEMCR_VC_NOCPERR_Msk     (1ul << CoreDebug_DEMCR_VC_NOCPERR_Pos)        /*!< CoreDebug DEMCR: VC_NOCPERR Mask */
N
N#define CoreDebug_DEMCR_VC_MMERR_Pos        4                                             /*!< CoreDebug DEMCR: VC_MMERR Position */
N#define CoreDebug_DEMCR_VC_MMERR_Msk       (1ul << CoreDebug_DEMCR_VC_MMERR_Pos)          /*!< CoreDebug DEMCR: VC_MMERR Mask */
N
N#define CoreDebug_DEMCR_VC_CORERESET_Pos    0                                             /*!< CoreDebug DEMCR: VC_CORERESET Position */
N#define CoreDebug_DEMCR_VC_CORERESET_Msk   (1ul << CoreDebug_DEMCR_VC_CORERESET_Pos)      /*!< CoreDebug DEMCR: VC_CORERESET Mask */
N/*@}*/ /* end of group CMSIS_CM3_CoreDebug */
N
N
N/* Memory mapping of Cortex-M3 Hardware */
N#define SCS_BASE            (0xE000E000)                              /*!< System Control Space Base Address */
N#define ITM_BASE            (0xE0000000)                              /*!< ITM Base Address                  */
N#define CoreDebug_BASE      (0xE000EDF0)                              /*!< Core Debug Base Address           */
N#define SysTick_BASE        (SCS_BASE +  0x0010)                      /*!< SysTick Base Address              */
N#define NVIC_BASE           (SCS_BASE +  0x0100)                      /*!< NVIC Base Address                 */
N#define SCB_BASE            (SCS_BASE +  0x0D00)                      /*!< System Control Block Base Address */
N
N#define InterruptType       ((InterruptType_Type *) SCS_BASE)         /*!< Interrupt Type Register           */
N#define SCB                 ((SCB_Type *)           SCB_BASE)         /*!< SCB configuration struct          */
N#define SysTick             ((SysTick_Type *)       SysTick_BASE)     /*!< SysTick configuration struct      */
N#define NVIC                ((NVIC_Type *)          NVIC_BASE)        /*!< NVIC configuration struct         */
N#define ITM                 ((ITM_Type *)           ITM_BASE)         /*!< ITM configuration struct          */
N#define CoreDebug           ((CoreDebug_Type *)     CoreDebug_BASE)   /*!< Core Debug configuration struct   */
N
N#if defined (__MPU_PRESENT) && (__MPU_PRESENT == 1)
X#if 1L && (0 == 1)
S  #define MPU_BASE          (SCS_BASE +  0x0D90)                      /*!< Memory Protection Unit            */
S  #define MPU               ((MPU_Type*)            MPU_BASE)         /*!< Memory Protection Unit            */
N#endif
N
N/*@}*/ /* end of group CMSIS_CM3_core_register */
N
N
N/*******************************************************************************
N *                Hardware Abstraction Layer
N ******************************************************************************/
N
N#if defined ( __CC_ARM   )
X#if 1L
N  #define __ASM            __asm                                      /*!< asm keyword for ARM Compiler          */
N  #define __INLINE         __inline                                   /*!< inline keyword for ARM Compiler       */
N
N#elif defined ( __ICCARM__ )
S  #define __ASM           __asm                                       /*!< asm keyword for IAR Compiler          */
S  #define __INLINE        inline                                      /*!< inline keyword for IAR Compiler. Only avaiable in High optimization mode! */
S
S#elif defined   (  __GNUC__  )
S  #define __ASM            __asm                                      /*!< asm keyword for GNU Compiler          */
S  #define __INLINE         inline                                     /*!< inline keyword for GNU Compiler       */
S
S#elif defined   (  __TASKING__  )
S  #define __ASM            __asm                                      /*!< asm keyword for TASKING Compiler      */
S  #define __INLINE         inline                                     /*!< inline keyword for TASKING Compiler   */
S
N#endif
N
N
N/* ###################  Compiler specific Intrinsics  ########################### */
N
N#if defined ( __CC_ARM   ) /*------------------RealView Compiler -----------------*/
X#if 1L  
N/* ARM armcc specific functions */
N
N#define __enable_fault_irq                __enable_fiq
N#define __disable_fault_irq               __disable_fiq
N
N#define __NOP                             __nop
N#define __WFI                             __wfi
N#define __WFE                             __wfe
N#define __SEV                             __sev
N#define __ISB()                           __isb(0)
N#define __DSB()                           __dsb(0)
N#define __DMB()                           __dmb(0)
N#define __REV                             __rev
N#define __RBIT                            __rbit
N#define __LDREXB(ptr)                     ((unsigned char ) __ldrex(ptr))
N#define __LDREXH(ptr)                     ((unsigned short) __ldrex(ptr))
N#define __LDREXW(ptr)                     ((unsigned int  ) __ldrex(ptr))
N#define __STREXB(value, ptr)              __strex(value, ptr)
N#define __STREXH(value, ptr)              __strex(value, ptr)
N#define __STREXW(value, ptr)              __strex(value, ptr)
N
N
N/* intrinsic unsigned long long __ldrexd(volatile void *ptr) */
N/* intrinsic int __strexd(unsigned long long val, volatile void *ptr) */
N/* intrinsic void __enable_irq();     */
N/* intrinsic void __disable_irq();    */
N
N
N/**
N * @brief  Return the Process Stack Pointer
N *
N * @return ProcessStackPointer
N *
N * Return the actual process stack pointer
N */
Nextern uint32_t __get_PSP(void);
N
N/**
N * @brief  Set the Process Stack Pointer
N *
N * @param  topOfProcStack  Process Stack Pointer
N *
N * Assign the value ProcessStackPointer to the MSP 
N * (process stack pointer) Cortex processor register
N */
Nextern void __set_PSP(uint32_t topOfProcStack);
N
N/**
N * @brief  Return the Main Stack Pointer
N *
N * @return Main Stack Pointer
N *
N * Return the current value of the MSP (main stack pointer)
N * Cortex processor register
N */
Nextern uint32_t __get_MSP(void);
N
N/**
N * @brief  Set the Main Stack Pointer
N *
N * @param  topOfMainStack  Main Stack Pointer
N *
N * Assign the value mainStackPointer to the MSP 
N * (main stack pointer) Cortex processor register
N */
Nextern void __set_MSP(uint32_t topOfMainStack);
N
N/**
N * @brief  Reverse byte order in unsigned short value
N *
N * @param   value  value to reverse
N * @return         reversed value
N *
N * Reverse byte order in unsigned short value
N */
Nextern uint32_t __REV16(uint16_t value);
N
N/**
N * @brief  Reverse byte order in signed short value with sign extension to integer
N *
N * @param   value  value to reverse
N * @return         reversed value
N *
N * Reverse byte order in signed short value with sign extension to integer
N */
Nextern int32_t __REVSH(int16_t value);
N
N
N#if (__ARMCC_VERSION < 400000)
X#if (5060750 < 400000)
S
S/**
S * @brief  Remove the exclusive lock created by ldrex
S *
S * Removes the exclusive lock which is created by ldrex.
S */
Sextern void __CLREX(void);
S
S/**
S * @brief  Return the Base Priority value
S *
S * @return BasePriority
S *
S * Return the content of the base priority register
S */
Sextern uint32_t __get_BASEPRI(void);
S
S/**
S * @brief  Set the Base Priority value
S *
S * @param  basePri  BasePriority
S *
S * Set the base priority register
S */
Sextern void __set_BASEPRI(uint32_t basePri);
S
S/**
S * @brief  Return the Priority Mask value
S *
S * @return PriMask
S *
S * Return state of the priority mask bit from the priority mask register
S */
Sextern uint32_t __get_PRIMASK(void);
S
S/**
S * @brief  Set the Priority Mask value
S *
S * @param   priMask  PriMask
S *
S * Set the priority mask bit in the priority mask register
S */
Sextern void __set_PRIMASK(uint32_t priMask);
S
S/**
S * @brief  Return the Fault Mask value
S *
S * @return FaultMask
S *
S * Return the content of the fault mask register
S */
Sextern uint32_t __get_FAULTMASK(void);
S
S/**
S * @brief  Set the Fault Mask value
S *
S * @param  faultMask faultMask value
S *
S * Set the fault mask register
S */
Sextern void __set_FAULTMASK(uint32_t faultMask);
S
S/**
S * @brief  Return the Control Register value
S * 
S * @return Control value
S *
S * Return the content of the control register
S */
Sextern uint32_t __get_CONTROL(void);
S
S/**
S * @brief  Set the Control Register value
S *
S * @param  control  Control value
S *
S * Set the control register
S */
Sextern void __set_CONTROL(uint32_t control);
S
N#else  /* (__ARMCC_VERSION >= 400000)  */
N
N/**
N * @brief  Remove the exclusive lock created by ldrex
N *
N * Removes the exclusive lock which is created by ldrex.
N */
N#define __CLREX                           __clrex
N
N/**
N * @brief  Return the Base Priority value
N *
N * @return BasePriority
N *
N * Return the content of the base priority register
N */
Nstatic __INLINE uint32_t  __get_BASEPRI(void)
Xstatic __inline uint32_t  __get_BASEPRI(void)
N{
N  register uint32_t __regBasePri         __ASM("basepri");
X  register uint32_t __regBasePri         __asm("basepri");
N  return(__regBasePri);
N}
N
N/**
N * @brief  Set the Base Priority value
N *
N * @param  basePri  BasePriority
N *
N * Set the base priority register
N */
Nstatic __INLINE void __set_BASEPRI(uint32_t basePri)
Xstatic __inline void __set_BASEPRI(uint32_t basePri)
N{
N  register uint32_t __regBasePri         __ASM("basepri");
X  register uint32_t __regBasePri         __asm("basepri");
N  __regBasePri = (basePri & 0xff);
N}
N
N/**
N * @brief  Return the Priority Mask value
N *
N * @return PriMask
N *
N * Return state of the priority mask bit from the priority mask register
N */
Nstatic __INLINE uint32_t __get_PRIMASK(void)
Xstatic __inline uint32_t __get_PRIMASK(void)
N{
N  register uint32_t __regPriMask         __ASM("primask");
X  register uint32_t __regPriMask         __asm("primask");
N  return(__regPriMask);
N}
N
N/**
N * @brief  Set the Priority Mask value
N *
N * @param  priMask  PriMask
N *
N * Set the priority mask bit in the priority mask register
N */
Nstatic __INLINE void __set_PRIMASK(uint32_t priMask)
Xstatic __inline void __set_PRIMASK(uint32_t priMask)
N{
N  register uint32_t __regPriMask         __ASM("primask");
X  register uint32_t __regPriMask         __asm("primask");
N  __regPriMask = (priMask);
N}
N
N/**
N * @brief  Return the Fault Mask value
N *
N * @return FaultMask
N *
N * Return the content of the fault mask register
N */
Nstatic __INLINE uint32_t __get_FAULTMASK(void)
Xstatic __inline uint32_t __get_FAULTMASK(void)
N{
N  register uint32_t __regFaultMask       __ASM("faultmask");
X  register uint32_t __regFaultMask       __asm("faultmask");
N  return(__regFaultMask);
N}
N
N/**
N * @brief  Set the Fault Mask value
N *
N * @param  faultMask  faultMask value
N *
N * Set the fault mask register
N */
Nstatic __INLINE void __set_FAULTMASK(uint32_t faultMask)
Xstatic __inline void __set_FAULTMASK(uint32_t faultMask)
N{
N  register uint32_t __regFaultMask       __ASM("faultmask");
X  register uint32_t __regFaultMask       __asm("faultmask");
N  __regFaultMask = (faultMask & 1);
N}
N
N/**
N * @brief  Return the Control Register value
N * 
N * @return Control value
N *
N * Return the content of the control register
N */
Nstatic __INLINE uint32_t __get_CONTROL(void)
Xstatic __inline uint32_t __get_CONTROL(void)
N{
N  register uint32_t __regControl         __ASM("control");
X  register uint32_t __regControl         __asm("control");
N  return(__regControl);
N}
N
N/**
N * @brief  Set the Control Register value
N *
N * @param  control  Control value
N *
N * Set the control register
N */
Nstatic __INLINE void __set_CONTROL(uint32_t control)
Xstatic __inline void __set_CONTROL(uint32_t control)
N{
N  register uint32_t __regControl         __ASM("control");
X  register uint32_t __regControl         __asm("control");
N  __regControl = control;
N}
N
N#endif /* __ARMCC_VERSION  */ 
N
N
N
N#elif (defined (__ICCARM__)) /*------------------ ICC Compiler -------------------*/
S/* IAR iccarm specific functions */
S
S#define __enable_irq                              __enable_interrupt        /*!< global Interrupt enable */
S#define __disable_irq                             __disable_interrupt       /*!< global Interrupt disable */
S
Sstatic __INLINE void __enable_fault_irq()         { __ASM ("cpsie f"); }
Sstatic __INLINE void __disable_fault_irq()        { __ASM ("cpsid f"); }
S
S#define __NOP                                     __no_operation            /*!< no operation intrinsic in IAR Compiler */ 
Sstatic __INLINE  void __WFI()                     { __ASM ("wfi"); }
Sstatic __INLINE  void __WFE()                     { __ASM ("wfe"); }
Sstatic __INLINE  void __SEV()                     { __ASM ("sev"); }
Sstatic __INLINE  void __CLREX()                   { __ASM ("clrex"); }
S
S/* intrinsic void __ISB(void)                                     */
S/* intrinsic void __DSB(void)                                     */
S/* intrinsic void __DMB(void)                                     */
S/* intrinsic void __set_PRIMASK();                                */
S/* intrinsic void __get_PRIMASK();                                */
S/* intrinsic void __set_FAULTMASK();                              */
S/* intrinsic void __get_FAULTMASK();                              */
S/* intrinsic uint32_t __REV(uint32_t value);                      */
S/* intrinsic uint32_t __REVSH(uint32_t value);                    */
S/* intrinsic unsigned long __STREX(unsigned long, unsigned long); */
S/* intrinsic unsigned long __LDREX(unsigned long *);              */
S
S
S/**
S * @brief  Return the Process Stack Pointer
S *
S * @return ProcessStackPointer
S *
S * Return the actual process stack pointer
S */
Sextern uint32_t __get_PSP(void);
S
S/**
S * @brief  Set the Process Stack Pointer
S *
S * @param  topOfProcStack  Process Stack Pointer
S *
S * Assign the value ProcessStackPointer to the MSP 
S * (process stack pointer) Cortex processor register
S */
Sextern void __set_PSP(uint32_t topOfProcStack);
S
S/**
S * @brief  Return the Main Stack Pointer
S *
S * @return Main Stack Pointer
S *
S * Return the current value of the MSP (main stack pointer)
S * Cortex processor register
S */
Sextern uint32_t __get_MSP(void);
S
S/**
S * @brief  Set the Main Stack Pointer
S *
S * @param  topOfMainStack  Main Stack Pointer
S *
S * Assign the value mainStackPointer to the MSP 
S * (main stack pointer) Cortex processor register
S */
Sextern void __set_MSP(uint32_t topOfMainStack);
S
S/**
S * @brief  Reverse byte order in unsigned short value
S *
S * @param  value  value to reverse
S * @return        reversed value
S *
S * Reverse byte order in unsigned short value
S */
Sextern uint32_t __REV16(uint16_t value);
S
S/**
S * @brief  Reverse bit order of value
S *
S * @param  value  value to reverse
S * @return        reversed value
S *
S * Reverse bit order of value
S */
Sextern uint32_t __RBIT(uint32_t value);
S
S/**
S * @brief  LDR Exclusive (8 bit)
S *
S * @param  *addr  address pointer
S * @return        value of (*address)
S *
S * Exclusive LDR command for 8 bit values)
S */
Sextern uint8_t __LDREXB(uint8_t *addr);
S
S/**
S * @brief  LDR Exclusive (16 bit)
S *
S * @param  *addr  address pointer
S * @return        value of (*address)
S *
S * Exclusive LDR command for 16 bit values
S */
Sextern uint16_t __LDREXH(uint16_t *addr);
S
S/**
S * @brief  LDR Exclusive (32 bit)
S *
S * @param  *addr  address pointer
S * @return        value of (*address)
S *
S * Exclusive LDR command for 32 bit values
S */
Sextern uint32_t __LDREXW(uint32_t *addr);
S
S/**
S * @brief  STR Exclusive (8 bit)
S *
S * @param  value  value to store
S * @param  *addr  address pointer
S * @return        successful / failed
S *
S * Exclusive STR command for 8 bit values
S */
Sextern uint32_t __STREXB(uint8_t value, uint8_t *addr);
S
S/**
S * @brief  STR Exclusive (16 bit)
S *
S * @param  value  value to store
S * @param  *addr  address pointer
S * @return        successful / failed
S *
S * Exclusive STR command for 16 bit values
S */
Sextern uint32_t __STREXH(uint16_t value, uint16_t *addr);
S
S/**
S * @brief  STR Exclusive (32 bit)
S *
S * @param  value  value to store
S * @param  *addr  address pointer
S * @return        successful / failed
S *
S * Exclusive STR command for 32 bit values
S */
Sextern uint32_t __STREXW(uint32_t value, uint32_t *addr);
S
S
S
S#elif (defined (__GNUC__)) /*------------------ GNU Compiler ---------------------*/
S/* GNU gcc specific functions */
S
Sstatic __INLINE void __enable_irq()               { __ASM volatile ("cpsie i"); }
Sstatic __INLINE void __disable_irq()              { __ASM volatile ("cpsid i"); }
S
Sstatic __INLINE void __enable_fault_irq()         { __ASM volatile ("cpsie f"); }
Sstatic __INLINE void __disable_fault_irq()        { __ASM volatile ("cpsid f"); }
S
Sstatic __INLINE void __NOP()                      { __ASM volatile ("nop"); }
Sstatic __INLINE void __WFI()                      { __ASM volatile ("wfi"); }
Sstatic __INLINE void __WFE()                      { __ASM volatile ("wfe"); }
Sstatic __INLINE void __SEV()                      { __ASM volatile ("sev"); }
Sstatic __INLINE void __ISB()                      { __ASM volatile ("isb"); }
Sstatic __INLINE void __DSB()                      { __ASM volatile ("dsb"); }
Sstatic __INLINE void __DMB()                      { __ASM volatile ("dmb"); }
Sstatic __INLINE void __CLREX()                    { __ASM volatile ("clrex"); }
S
S
S/**
S * @brief  Return the Process Stack Pointer
S *
S * @return ProcessStackPointer
S *
S * Return the actual process stack pointer
S */
Sextern uint32_t __get_PSP(void);
S
S/**
S * @brief  Set the Process Stack Pointer
S *
S * @param  topOfProcStack  Process Stack Pointer
S *
S * Assign the value ProcessStackPointer to the MSP 
S * (process stack pointer) Cortex processor register
S */
Sextern void __set_PSP(uint32_t topOfProcStack);
S
S/**
S * @brief  Return the Main Stack Pointer
S *
S * @return Main Stack Pointer
S *
S * Return the current value of the MSP (main stack pointer)
S * Cortex processor register
S */
Sextern uint32_t __get_MSP(void);
S
S/**
S * @brief  Set the Main Stack Pointer
S *
S * @param  topOfMainStack  Main Stack Pointer
S *
S * Assign the value mainStackPointer to the MSP 
S * (main stack pointer) Cortex processor register
S */
Sextern void __set_MSP(uint32_t topOfMainStack);
S
S/**
S * @brief  Return the Base Priority value
S *
S * @return BasePriority
S *
S * Return the content of the base priority register
S */
Sextern uint32_t __get_BASEPRI(void);
S
S/**
S * @brief  Set the Base Priority value
S *
S * @param  basePri  BasePriority
S *
S * Set the base priority register
S */
Sextern void __set_BASEPRI(uint32_t basePri);
S
S/**
S * @brief  Return the Priority Mask value
S *
S * @return PriMask
S *
S * Return state of the priority mask bit from the priority mask register
S */
Sextern uint32_t  __get_PRIMASK(void);
S
S/**
S * @brief  Set the Priority Mask value
S *
S * @param  priMask  PriMask
S *
S * Set the priority mask bit in the priority mask register
S */
Sextern void __set_PRIMASK(uint32_t priMask);
S
S/**
S * @brief  Return the Fault Mask value
S *
S * @return FaultMask
S *
S * Return the content of the fault mask register
S */
Sextern uint32_t __get_FAULTMASK(void);
S
S/**
S * @brief  Set the Fault Mask value
S *
S * @param  faultMask  faultMask value
S *
S * Set the fault mask register
S */
Sextern void __set_FAULTMASK(uint32_t faultMask);
S
S/**
S * @brief  Return the Control Register value
S* 
S*  @return Control value
S *
S * Return the content of the control register
S */
Sextern uint32_t __get_CONTROL(void);
S
S/**
S * @brief  Set the Control Register value
S *
S * @param  control  Control value
S *
S * Set the control register
S */
Sextern void __set_CONTROL(uint32_t control);
S
S/**
S * @brief  Reverse byte order in integer value
S *
S * @param  value  value to reverse
S * @return        reversed value
S *
S * Reverse byte order in integer value
S */
Sextern uint32_t __REV(uint32_t value);
S
S/**
S * @brief  Reverse byte order in unsigned short value
S *
S * @param  value  value to reverse
S * @return        reversed value
S *
S * Reverse byte order in unsigned short value
S */
Sextern uint32_t __REV16(uint16_t value);
S
S/**
S * @brief  Reverse byte order in signed short value with sign extension to integer
S *
S * @param  value  value to reverse
S * @return        reversed value
S *
S * Reverse byte order in signed short value with sign extension to integer
S */
Sextern int32_t __REVSH(int16_t value);
S
S/**
S * @brief  Reverse bit order of value
S *
S * @param  value  value to reverse
S * @return        reversed value
S *
S * Reverse bit order of value
S */
Sextern uint32_t __RBIT(uint32_t value);
S
S/**
S * @brief  LDR Exclusive (8 bit)
S *
S * @param  *addr  address pointer
S * @return        value of (*address)
S *
S * Exclusive LDR command for 8 bit value
S */
Sextern uint8_t __LDREXB(uint8_t *addr);
S
S/**
S * @brief  LDR Exclusive (16 bit)
S *
S * @param  *addr  address pointer
S * @return        value of (*address)
S *
S * Exclusive LDR command for 16 bit values
S */
Sextern uint16_t __LDREXH(uint16_t *addr);
S
S/**
S * @brief  LDR Exclusive (32 bit)
S *
S * @param  *addr  address pointer
S * @return        value of (*address)
S *
S * Exclusive LDR command for 32 bit values
S */
Sextern uint32_t __LDREXW(uint32_t *addr);
S
S/**
S * @brief  STR Exclusive (8 bit)
S *
S * @param  value  value to store
S * @param  *addr  address pointer
S * @return        successful / failed
S *
S * Exclusive STR command for 8 bit values
S */
Sextern uint32_t __STREXB(uint8_t value, uint8_t *addr);
S
S/**
S * @brief  STR Exclusive (16 bit)
S *
S * @param  value  value to store
S * @param  *addr  address pointer
S * @return        successful / failed
S *
S * Exclusive STR command for 16 bit values
S */
Sextern uint32_t __STREXH(uint16_t value, uint16_t *addr);
S
S/**
S * @brief  STR Exclusive (32 bit)
S *
S * @param  value  value to store
S * @param  *addr  address pointer
S * @return        successful / failed
S *
S * Exclusive STR command for 32 bit values
S */
Sextern uint32_t __STREXW(uint32_t value, uint32_t *addr);
S
S
S#elif (defined (__TASKING__)) /*------------------ TASKING Compiler ---------------------*/
S/* TASKING carm specific functions */
S
S/*
S * The CMSIS functions have been implemented as intrinsics in the compiler.
S * Please use "carm -?i" to get an up to date list of all instrinsics,
S * Including the CMSIS ones.
S */
S
N#endif
N
N
N/** @addtogroup CMSIS_CM3_Core_FunctionInterface CMSIS CM3 Core Function Interface
N  Core  Function Interface containing:
N  - Core NVIC Functions
N  - Core SysTick Functions
N  - Core Reset Functions
N*/
N/*@{*/
N
N/* ##########################   NVIC functions  #################################### */
N
N/**
N * @brief  Set the Priority Grouping in NVIC Interrupt Controller
N *
N * @param  PriorityGroup is priority grouping field
N *
N * Set the priority grouping field using the required unlock sequence.
N * The parameter priority_grouping is assigned to the field 
N * SCB->AIRCR [10:8] PRIGROUP field. Only values from 0..7 are used.
N * In case of a conflict between priority grouping and available
N * priority bits (__NVIC_PRIO_BITS) the smallest possible priority group is set.
N */
Nstatic __INLINE void NVIC_SetPriorityGrouping(uint32_t PriorityGroup)
Xstatic __inline void NVIC_SetPriorityGrouping(uint32_t PriorityGroup)
N{
N  uint32_t reg_value;
N  uint32_t PriorityGroupTmp = (PriorityGroup & 0x07);                         /* only values 0..7 are used          */
N  
N  reg_value  =  SCB->AIRCR;                                                   /* read old register configuration    */
X  reg_value  =  ((SCB_Type *) ((0xE000E000) + 0x0D00))->AIRCR;                                                    
N  reg_value &= ~(SCB_AIRCR_VECTKEY_Msk | SCB_AIRCR_PRIGROUP_Msk);             /* clear bits to change               */
X  reg_value &= ~((0xFFFFul << 16) | (7ul << 8));              
N  reg_value  =  (reg_value                       |
N                (0x5FA << SCB_AIRCR_VECTKEY_Pos) | 
X                (0x5FA << 16) | 
N                (PriorityGroupTmp << 8));                                     /* Insert write key and priorty group */
N  SCB->AIRCR =  reg_value;
X  ((SCB_Type *) ((0xE000E000) + 0x0D00))->AIRCR =  reg_value;
N}
N
N/**
N * @brief  Get the Priority Grouping from NVIC Interrupt Controller
N *
N * @return priority grouping field 
N *
N * Get the priority grouping from NVIC Interrupt Controller.
N * priority grouping is SCB->AIRCR [10:8] PRIGROUP field.
N */
Nstatic __INLINE uint32_t NVIC_GetPriorityGrouping(void)
Xstatic __inline uint32_t NVIC_GetPriorityGrouping(void)
N{
N  return ((SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) >> SCB_AIRCR_PRIGROUP_Pos);   /* read priority grouping field */
X  return ((((SCB_Type *) ((0xE000E000) + 0x0D00))->AIRCR & (7ul << 8)) >> 8);    
N}
N
N/**
N * @brief  Enable Interrupt in NVIC Interrupt Controller
N *
N * @param  IRQn   The positive number of the external interrupt to enable
N *
N * Enable a device specific interupt in the NVIC interrupt controller.
N * The interrupt number cannot be a negative value.
N */
Nstatic __INLINE void NVIC_EnableIRQ(IRQn_Type IRQn)
Xstatic __inline void NVIC_EnableIRQ(IRQn_Type IRQn)
N{
N  NVIC->ISER[((uint32_t)(IRQn) >> 5)] = (1 << ((uint32_t)(IRQn) & 0x1F)); /* enable interrupt */
X  ((NVIC_Type *) ((0xE000E000) + 0x0100))->ISER[((uint32_t)(IRQn) >> 5)] = (1 << ((uint32_t)(IRQn) & 0x1F));  
N}
N
N/**
N * @brief  Disable the interrupt line for external interrupt specified
N * 
N * @param  IRQn   The positive number of the external interrupt to disable
N * 
N * Disable a device specific interupt in the NVIC interrupt controller.
N * The interrupt number cannot be a negative value.
N */
Nstatic __INLINE void NVIC_DisableIRQ(IRQn_Type IRQn)
Xstatic __inline void NVIC_DisableIRQ(IRQn_Type IRQn)
N{
N  NVIC->ICER[((uint32_t)(IRQn) >> 5)] = (1 << ((uint32_t)(IRQn) & 0x1F)); /* disable interrupt */
X  ((NVIC_Type *) ((0xE000E000) + 0x0100))->ICER[((uint32_t)(IRQn) >> 5)] = (1 << ((uint32_t)(IRQn) & 0x1F));  
N}
N
N/**
N * @brief  Read the interrupt pending bit for a device specific interrupt source
N * 
N * @param  IRQn    The number of the device specifc interrupt
N * @return         1 = interrupt pending, 0 = interrupt not pending
N *
N * Read the pending register in NVIC and return 1 if its status is pending, 
N * otherwise it returns 0
N */
Nstatic __INLINE uint32_t NVIC_GetPendingIRQ(IRQn_Type IRQn)
Xstatic __inline uint32_t NVIC_GetPendingIRQ(IRQn_Type IRQn)
N{
N  return((uint32_t) ((NVIC->ISPR[(uint32_t)(IRQn) >> 5] & (1 << ((uint32_t)(IRQn) & 0x1F)))?1:0)); /* Return 1 if pending else 0 */
X  return((uint32_t) ((((NVIC_Type *) ((0xE000E000) + 0x0100))->ISPR[(uint32_t)(IRQn) >> 5] & (1 << ((uint32_t)(IRQn) & 0x1F)))?1:0));  
N}
N
N/**
N * @brief  Set the pending bit for an external interrupt
N * 
N * @param  IRQn    The number of the interrupt for set pending
N *
N * Set the pending bit for the specified interrupt.
N * The interrupt number cannot be a negative value.
N */
Nstatic __INLINE void NVIC_SetPendingIRQ(IRQn_Type IRQn)
Xstatic __inline void NVIC_SetPendingIRQ(IRQn_Type IRQn)
N{
N  NVIC->ISPR[((uint32_t)(IRQn) >> 5)] = (1 << ((uint32_t)(IRQn) & 0x1F)); /* set interrupt pending */
X  ((NVIC_Type *) ((0xE000E000) + 0x0100))->ISPR[((uint32_t)(IRQn) >> 5)] = (1 << ((uint32_t)(IRQn) & 0x1F));  
N}
N
N/**
N * @brief  Clear the pending bit for an external interrupt
N *
N * @param  IRQn    The number of the interrupt for clear pending
N *
N * Clear the pending bit for the specified interrupt. 
N * The interrupt number cannot be a negative value.
N */
Nstatic __INLINE void NVIC_ClearPendingIRQ(IRQn_Type IRQn)
Xstatic __inline void NVIC_ClearPendingIRQ(IRQn_Type IRQn)
N{
N  NVIC->ICPR[((uint32_t)(IRQn) >> 5)] = (1 << ((uint32_t)(IRQn) & 0x1F)); /* Clear pending interrupt */
X  ((NVIC_Type *) ((0xE000E000) + 0x0100))->ICPR[((uint32_t)(IRQn) >> 5)] = (1 << ((uint32_t)(IRQn) & 0x1F));  
N}
N
N/**
N * @brief  Read the active bit for an external interrupt
N *
N * @param  IRQn    The number of the interrupt for read active bit
N * @return         1 = interrupt active, 0 = interrupt not active
N *
N * Read the active register in NVIC and returns 1 if its status is active, 
N * otherwise it returns 0.
N */
Nstatic __INLINE uint32_t NVIC_GetActive(IRQn_Type IRQn)
Xstatic __inline uint32_t NVIC_GetActive(IRQn_Type IRQn)
N{
N  return((uint32_t)((NVIC->IABR[(uint32_t)(IRQn) >> 5] & (1 << ((uint32_t)(IRQn) & 0x1F)))?1:0)); /* Return 1 if active else 0 */
X  return((uint32_t)((((NVIC_Type *) ((0xE000E000) + 0x0100))->IABR[(uint32_t)(IRQn) >> 5] & (1 << ((uint32_t)(IRQn) & 0x1F)))?1:0));  
N}
N
N/**
N * @brief  Set the priority for an interrupt
N *
N * @param  IRQn      The number of the interrupt for set priority
N * @param  priority  The priority to set
N *
N * Set the priority for the specified interrupt. The interrupt 
N * number can be positive to specify an external (device specific) 
N * interrupt, or negative to specify an internal (core) interrupt.
N *
N * Note: The priority cannot be set for every core interrupt.
N */
Nstatic __INLINE void NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
Xstatic __inline void NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
N{
N  if(IRQn < 0) {
N    SCB->SHP[((uint32_t)(IRQn) & 0xF)-4] = ((priority << (8 - __NVIC_PRIO_BITS)) & 0xff); } /* set Priority for Cortex-M3 System Interrupts */
X    ((SCB_Type *) ((0xE000E000) + 0x0D00))->SHP[((uint32_t)(IRQn) & 0xF)-4] = ((priority << (8 - 4)) & 0xff); }  
N  else {
N    NVIC->IP[(uint32_t)(IRQn)] = ((priority << (8 - __NVIC_PRIO_BITS)) & 0xff);    }        /* set Priority for device specific Interrupts  */
X    ((NVIC_Type *) ((0xE000E000) + 0x0100))->IP[(uint32_t)(IRQn)] = ((priority << (8 - 4)) & 0xff);    }         
N}
N
N/**
N * @brief  Read the priority for an interrupt
N *
N * @param  IRQn      The number of the interrupt for get priority
N * @return           The priority for the interrupt
N *
N * Read the priority for the specified interrupt. The interrupt 
N * number can be positive to specify an external (device specific) 
N * interrupt, or negative to specify an internal (core) interrupt.
N *
N * The returned priority value is automatically aligned to the implemented
N * priority bits of the microcontroller.
N *
N * Note: The priority cannot be set for every core interrupt.
N */
Nstatic __INLINE uint32_t NVIC_GetPriority(IRQn_Type IRQn)
Xstatic __inline uint32_t NVIC_GetPriority(IRQn_Type IRQn)
N{
N
N  if(IRQn < 0) {
N    return((uint32_t)(SCB->SHP[((uint32_t)(IRQn) & 0xF)-4] >> (8 - __NVIC_PRIO_BITS)));  } /* get priority for Cortex-M3 system interrupts */
X    return((uint32_t)(((SCB_Type *) ((0xE000E000) + 0x0D00))->SHP[((uint32_t)(IRQn) & 0xF)-4] >> (8 - 4)));  }  
N  else {
N    return((uint32_t)(NVIC->IP[(uint32_t)(IRQn)]           >> (8 - __NVIC_PRIO_BITS)));  } /* get priority for device specific interrupts  */
X    return((uint32_t)(((NVIC_Type *) ((0xE000E000) + 0x0100))->IP[(uint32_t)(IRQn)]           >> (8 - 4)));  }  
N}
N
N
N/**
N * @brief  Encode the priority for an interrupt
N *
N * @param  PriorityGroup    The used priority group
N * @param  PreemptPriority  The preemptive priority value (starting from 0)
N * @param  SubPriority      The sub priority value (starting from 0)
N * @return                  The encoded priority for the interrupt
N *
N * Encode the priority for an interrupt with the given priority group,
N * preemptive priority value and sub priority value.
N * In case of a conflict between priority grouping and available
N * priority bits (__NVIC_PRIO_BITS) the samllest possible priority group is set.
N *
N * The returned priority value can be used for NVIC_SetPriority(...) function
N */
Nstatic __INLINE uint32_t NVIC_EncodePriority (uint32_t PriorityGroup, uint32_t PreemptPriority, uint32_t SubPriority)
Xstatic __inline uint32_t NVIC_EncodePriority (uint32_t PriorityGroup, uint32_t PreemptPriority, uint32_t SubPriority)
N{
N  uint32_t PriorityGroupTmp = (PriorityGroup & 0x07);          /* only values 0..7 are used          */
N  uint32_t PreemptPriorityBits;
N  uint32_t SubPriorityBits;
N
N  PreemptPriorityBits = ((7 - PriorityGroupTmp) > __NVIC_PRIO_BITS) ? __NVIC_PRIO_BITS : 7 - PriorityGroupTmp;
X  PreemptPriorityBits = ((7 - PriorityGroupTmp) > 4) ? 4 : 7 - PriorityGroupTmp;
N  SubPriorityBits     = ((PriorityGroupTmp + __NVIC_PRIO_BITS) < 7) ? 0 : PriorityGroupTmp - 7 + __NVIC_PRIO_BITS;
X  SubPriorityBits     = ((PriorityGroupTmp + 4) < 7) ? 0 : PriorityGroupTmp - 7 + 4;
N 
N  return (
N           ((PreemptPriority & ((1 << (PreemptPriorityBits)) - 1)) << SubPriorityBits) |
N           ((SubPriority     & ((1 << (SubPriorityBits    )) - 1)))
N         );
N}
N
N
N/**
N * @brief  Decode the priority of an interrupt
N *
N * @param  Priority           The priority for the interrupt
N * @param  PriorityGroup      The used priority group
N * @param  pPreemptPriority   The preemptive priority value (starting from 0)
N * @param  pSubPriority       The sub priority value (starting from 0)
N *
N * Decode an interrupt priority value with the given priority group to 
N * preemptive priority value and sub priority value.
N * In case of a conflict between priority grouping and available
N * priority bits (__NVIC_PRIO_BITS) the samllest possible priority group is set.
N *
N * The priority value can be retrieved with NVIC_GetPriority(...) function
N */
Nstatic __INLINE void NVIC_DecodePriority (uint32_t Priority, uint32_t PriorityGroup, uint32_t* pPreemptPriority, uint32_t* pSubPriority)
Xstatic __inline void NVIC_DecodePriority (uint32_t Priority, uint32_t PriorityGroup, uint32_t* pPreemptPriority, uint32_t* pSubPriority)
N{
N  uint32_t PriorityGroupTmp = (PriorityGroup & 0x07);          /* only values 0..7 are used          */
N  uint32_t PreemptPriorityBits;
N  uint32_t SubPriorityBits;
N
N  PreemptPriorityBits = ((7 - PriorityGroupTmp) > __NVIC_PRIO_BITS) ? __NVIC_PRIO_BITS : 7 - PriorityGroupTmp;
X  PreemptPriorityBits = ((7 - PriorityGroupTmp) > 4) ? 4 : 7 - PriorityGroupTmp;
N  SubPriorityBits     = ((PriorityGroupTmp + __NVIC_PRIO_BITS) < 7) ? 0 : PriorityGroupTmp - 7 + __NVIC_PRIO_BITS;
X  SubPriorityBits     = ((PriorityGroupTmp + 4) < 7) ? 0 : PriorityGroupTmp - 7 + 4;
N  
N  *pPreemptPriority = (Priority >> SubPriorityBits) & ((1 << (PreemptPriorityBits)) - 1);
N  *pSubPriority     = (Priority                   ) & ((1 << (SubPriorityBits    )) - 1);
N}
N
N
N
N/* ##################################    SysTick function  ############################################ */
N
N#if (!defined (__Vendor_SysTickConfig)) || (__Vendor_SysTickConfig == 0)
X#if (!1L) || (0 == 0)
N
N/**
N * @brief  Initialize and start the SysTick counter and its interrupt.
N *
N * @param   ticks   number of ticks between two interrupts
N * @return  1 = failed, 0 = successful
N *
N * Initialise the system tick timer and its interrupt and start the
N * system tick timer / counter in free running mode to generate 
N * periodical interrupts.
N */
Nstatic __INLINE uint32_t SysTick_Config(uint32_t ticks)
Xstatic __inline uint32_t SysTick_Config(uint32_t ticks)
N{ 
N  if (ticks > SysTick_LOAD_RELOAD_Msk)  return (1);            /* Reload value impossible */
X  if (ticks > (0xFFFFFFul << 0))  return (1);             
N                                                               
N  SysTick->LOAD  = (ticks & SysTick_LOAD_RELOAD_Msk) - 1;      /* set reload register */
X  ((SysTick_Type *) ((0xE000E000) + 0x0010))->LOAD  = (ticks & (0xFFFFFFul << 0)) - 1;       
N  NVIC_SetPriority (SysTick_IRQn, (1<<__NVIC_PRIO_BITS) - 1);  /* set Priority for Cortex-M0 System Interrupts */
X  NVIC_SetPriority (SysTick_IRQn, (1<<4) - 1);   
N  SysTick->VAL   = 0;                                          /* Load the SysTick Counter Value */
X  ((SysTick_Type *) ((0xE000E000) + 0x0010))->VAL   = 0;                                           
N  SysTick->CTRL  = SysTick_CTRL_CLKSOURCE_Msk | 
X  ((SysTick_Type *) ((0xE000E000) + 0x0010))->CTRL  = (1ul << 2) | 
N                   SysTick_CTRL_TICKINT_Msk   | 
X                   (1ul << 1)   | 
N                   SysTick_CTRL_ENABLE_Msk;                    /* Enable SysTick IRQ and SysTick Timer */
X                   (1ul << 0);                     
N  return (0);                                                  /* Function successful */
N}
N
N#endif
N
N
N
N
N/* ##################################    Reset function  ############################################ */
N
N/**
N * @brief  Initiate a system reset request.
N *
N * Initiate a system reset request to reset the MCU
N */
Nstatic __INLINE void NVIC_SystemReset(void)
Xstatic __inline void NVIC_SystemReset(void)
N{
N  SCB->AIRCR  = ((0x5FA << SCB_AIRCR_VECTKEY_Pos)      | 
X  ((SCB_Type *) ((0xE000E000) + 0x0D00))->AIRCR  = ((0x5FA << 16)      | 
N                 (SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) | 
X                 (((SCB_Type *) ((0xE000E000) + 0x0D00))->AIRCR & (7ul << 8)) | 
N                 SCB_AIRCR_SYSRESETREQ_Msk);                   /* Keep priority group unchanged */
X                 (1ul << 2));                    
N  __DSB();                                                     /* Ensure completion of memory access */              
X  __dsb(0);                                                                    
N  while(1);                                                    /* wait until reset */
N}
N
N/*@}*/ /* end of group CMSIS_CM3_Core_FunctionInterface */
N
N
N
N/* ##################################### Debug In/Output function ########################################### */
N
N/** @addtogroup CMSIS_CM3_CoreDebugInterface CMSIS CM3 Core Debug Interface
N  Core Debug Interface containing:
N  - Core Debug Receive / Transmit Functions
N  - Core Debug Defines
N  - Core Debug Variables
N*/
N/*@{*/
N
Nextern volatile int ITM_RxBuffer;                    /*!< variable to receive characters                             */
N#define             ITM_RXBUFFER_EMPTY    0x5AA55AA5 /*!< value identifying ITM_RxBuffer is ready for next character */
N
N
N/**
N * @brief  Outputs a character via the ITM channel 0
N *
N * @param  ch   character to output
N * @return      character to output
N *
N * The function outputs a character via the ITM channel 0. 
N * The function returns when no debugger is connected that has booked the output.  
N * It is blocking when a debugger is connected, but the previous character send is not transmitted. 
N */
Nstatic __INLINE uint32_t ITM_SendChar (uint32_t ch)
Xstatic __inline uint32_t ITM_SendChar (uint32_t ch)
N{
N  if ((CoreDebug->DEMCR & CoreDebug_DEMCR_TRCENA_Msk)  &&      /* Trace enabled */
X  if ((((CoreDebug_Type *) (0xE000EDF0))->DEMCR & (1ul << 24))  &&       
N      (ITM->TCR & ITM_TCR_ITMENA_Msk)                  &&      /* ITM enabled */
X      (((ITM_Type *) (0xE0000000))->TCR & (1ul << 0))                  &&       
N      (ITM->TER & (1ul << 0)        )                    )     /* ITM Port #0 enabled */
X      (((ITM_Type *) (0xE0000000))->TER & (1ul << 0)        )                    )      
N  {
N    while (ITM->PORT[0].u32 == 0);
X    while (((ITM_Type *) (0xE0000000))->PORT[0].u32 == 0);
N    ITM->PORT[0].u8 = (uint8_t) ch;
X    ((ITM_Type *) (0xE0000000))->PORT[0].u8 = (uint8_t) ch;
N  }  
N  return (ch);
N}
N
N
N/**
N * @brief  Inputs a character via variable ITM_RxBuffer
N *
N * @return      received character, -1 = no character received
N *
N * The function inputs a character via variable ITM_RxBuffer. 
N * The function returns when no debugger is connected that has booked the output.  
N * It is blocking when a debugger is connected, but the previous character send is not transmitted. 
N */
Nstatic __INLINE int ITM_ReceiveChar (void) {
Xstatic __inline int ITM_ReceiveChar (void) {
N  int ch = -1;                               /* no character available */
N
N  if (ITM_RxBuffer != ITM_RXBUFFER_EMPTY) {
X  if (ITM_RxBuffer != 0x5AA55AA5) {
N    ch = ITM_RxBuffer;
N    ITM_RxBuffer = ITM_RXBUFFER_EMPTY;       /* ready for next character */
X    ITM_RxBuffer = 0x5AA55AA5;        
N  }
N  
N  return (ch); 
N}
N
N
N/**
N * @brief  Check if a character via variable ITM_RxBuffer is available
N *
N * @return      1 = character available, 0 = no character available
N *
N * The function checks  variable ITM_RxBuffer whether a character is available or not. 
N * The function returns '1' if a character is available and '0' if no character is available. 
N */
Nstatic __INLINE int ITM_CheckChar (void) {
Xstatic __inline int ITM_CheckChar (void) {
N
N  if (ITM_RxBuffer == ITM_RXBUFFER_EMPTY) {
X  if (ITM_RxBuffer == 0x5AA55AA5) {
N    return (0);                                 /* no character available */
N  } else {
N    return (1);                                 /*    character available */
N  }
N}
N
N/*@}*/ /* end of group CMSIS_CM3_core_DebugInterface */
N
N
N#ifdef __cplusplus
S}
N#endif
N
N/*@}*/ /* end of group CMSIS_CM3_core_definitions */
N
N#endif /* __CM3_CORE_H__ */
N
N/*lint -restore */
L 479 "..\..\Libraries\CMSIS\stm32f10x.h" 2
N#include "system_stm32f10x.h"
L 1 "..\..\Libraries\CMSIS\system_stm32f10x.h" 1
N/**
N  ******************************************************************************
N  * @file    system_stm32f10x.h
N  * @author  MCD Application Team
N  * @version V3.5.0
N  * @date    11-March-2011
N  * @brief   CMSIS Cortex-M3 Device Peripheral Access Layer System Header File.
N  ******************************************************************************
N  * @attention
N  *
N  * THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
N  * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE
N  * TIME. AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY
N  * DIRECT, INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING
N  * FROM THE CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE
N  * CODING INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
N  *
N  * <h2><center>&copy; COPYRIGHT 2011 STMicroelectronics</center></h2>
N  ******************************************************************************
N  */
N
N/** @addtogroup CMSIS
N  * @{
N  */
N
N/** @addtogroup stm32f10x_system
N  * @{
N  */  
N  
N/**
N  * @brief Define to prevent recursive inclusion
N  */
N#ifndef __SYSTEM_STM32F10X_H
N#define __SYSTEM_STM32F10X_H
N
N#ifdef __cplusplus
S extern "C" {
N#endif 
N
N/** @addtogroup STM32F10x_System_Includes
N  * @{
N  */
N
N/**
N  * @}
N  */
N
N
N/** @addtogroup STM32F10x_System_Exported_types
N  * @{
N  */
N
Nextern uint32_t SystemCoreClock;          /*!< System Clock Frequency (Core Clock) */
N
N/**
N  * @}
N  */
N
N/** @addtogroup STM32F10x_System_Exported_Constants
N  * @{
N  */
N
N/**
N  * @}
N  */
N
N/** @addtogroup STM32F10x_System_Exported_Macros
N  * @{
N  */
N
N/**
N  * @}
N  */
N
N/** @addtogroup STM32F10x_System_Exported_Functions
N  * @{
N  */
N  
Nextern void SystemInit(void);
Nextern void SystemCoreClockUpdate(void);
N/**
N  * @}
N  */
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif /*__SYSTEM_STM32F10X_H */
N
N/**
N  * @}
N  */
N  
N/**
N  * @}
N  */  
N/******************* (C) COPYRIGHT 2011 STMicroelectronics *****END OF FILE****/
L 480 "..\..\Libraries\CMSIS\stm32f10x.h" 2
N#include <stdint.h>
N
N/** @addtogroup Exported_types
N  * @{
N  */  
N
N/*!< STM32F10x Standard Peripheral Library old types (maintained for legacy purpose) */
Ntypedef int32_t  s32;
Ntypedef int16_t s16;
Ntypedef int8_t  s8;
N
Ntypedef const int32_t sc32;  /*!< Read Only */
Ntypedef const int16_t sc16;  /*!< Read Only */
Ntypedef const int8_t sc8;   /*!< Read Only */
N
Ntypedef __IO int32_t  vs32;
Xtypedef volatile int32_t  vs32;
Ntypedef __IO int16_t  vs16;
Xtypedef volatile int16_t  vs16;
Ntypedef __IO int8_t   vs8;
Xtypedef volatile int8_t   vs8;
N
Ntypedef __I int32_t vsc32;  /*!< Read Only */
Xtypedef volatile const int32_t vsc32;   
Ntypedef __I int16_t vsc16;  /*!< Read Only */
Xtypedef volatile const int16_t vsc16;   
Ntypedef __I int8_t vsc8;   /*!< Read Only */
Xtypedef volatile const int8_t vsc8;    
N
Ntypedef uint32_t  u32;
Ntypedef uint16_t u16;
Ntypedef uint8_t  u8;
N
Ntypedef const uint32_t uc32;  /*!< Read Only */
Ntypedef const uint16_t uc16;  /*!< Read Only */
Ntypedef const uint8_t uc8;   /*!< Read Only */
N
Ntypedef __IO uint32_t  vu32;
Xtypedef volatile uint32_t  vu32;
Ntypedef __IO uint16_t vu16;
Xtypedef volatile uint16_t vu16;
Ntypedef __IO uint8_t  vu8;
Xtypedef volatile uint8_t  vu8;
N
Ntypedef __I uint32_t vuc32;  /*!< Read Only */
Xtypedef volatile const uint32_t vuc32;   
Ntypedef __I uint16_t vuc16;  /*!< Read Only */
Xtypedef volatile const uint16_t vuc16;   
Ntypedef __I uint8_t vuc8;   /*!< Read Only */
Xtypedef volatile const uint8_t vuc8;    
N
Ntypedef enum {RESET = 0, SET = !RESET} FlagStatus, ITStatus;
N
Ntypedef enum {DISABLE = 0, ENABLE = !DISABLE} FunctionalState;
N#define IS_FUNCTIONAL_STATE(STATE) (((STATE) == DISABLE) || ((STATE) == ENABLE))
N
Ntypedef enum {ERROR = 0, SUCCESS = !ERROR} ErrorStatus;
N
N/*!< STM32F10x Standard Peripheral Library old definitions (maintained for legacy purpose) */
N#define HSEStartUp_TimeOut   HSE_STARTUP_TIMEOUT
N#define HSE_Value            HSE_VALUE
N#define HSI_Value            HSI_VALUE
N/**
N  * @}
N  */
N
N/** @addtogroup Peripheral_registers_structures
N  * @{
N  */   
N
N/** 
N  * @brief Analog to Digital Converter  
N  */
N
Ntypedef struct
N{
N  __IO uint32_t SR;
X  volatile uint32_t SR;
N  __IO uint32_t CR1;
X  volatile uint32_t CR1;
N  __IO uint32_t CR2;
X  volatile uint32_t CR2;
N  __IO uint32_t SMPR1;
X  volatile uint32_t SMPR1;
N  __IO uint32_t SMPR2;
X  volatile uint32_t SMPR2;
N  __IO uint32_t JOFR1;
X  volatile uint32_t JOFR1;
N  __IO uint32_t JOFR2;
X  volatile uint32_t JOFR2;
N  __IO uint32_t JOFR3;
X  volatile uint32_t JOFR3;
N  __IO uint32_t JOFR4;
X  volatile uint32_t JOFR4;
N  __IO uint32_t HTR;
X  volatile uint32_t HTR;
N  __IO uint32_t LTR;
X  volatile uint32_t LTR;
N  __IO uint32_t SQR1;
X  volatile uint32_t SQR1;
N  __IO uint32_t SQR2;
X  volatile uint32_t SQR2;
N  __IO uint32_t SQR3;
X  volatile uint32_t SQR3;
N  __IO uint32_t JSQR;
X  volatile uint32_t JSQR;
N  __IO uint32_t JDR1;
X  volatile uint32_t JDR1;
N  __IO uint32_t JDR2;
X  volatile uint32_t JDR2;
N  __IO uint32_t JDR3;
X  volatile uint32_t JDR3;
N  __IO uint32_t JDR4;
X  volatile uint32_t JDR4;
N  __IO uint32_t DR;
X  volatile uint32_t DR;
N} ADC_TypeDef;
N
N/** 
N  * @brief Backup Registers  
N  */
N
Ntypedef struct
N{
N  uint32_t  RESERVED0;
N  __IO uint16_t DR1;
X  volatile uint16_t DR1;
N  uint16_t  RESERVED1;
N  __IO uint16_t DR2;
X  volatile uint16_t DR2;
N  uint16_t  RESERVED2;
N  __IO uint16_t DR3;
X  volatile uint16_t DR3;
N  uint16_t  RESERVED3;
N  __IO uint16_t DR4;
X  volatile uint16_t DR4;
N  uint16_t  RESERVED4;
N  __IO uint16_t DR5;
X  volatile uint16_t DR5;
N  uint16_t  RESERVED5;
N  __IO uint16_t DR6;
X  volatile uint16_t DR6;
N  uint16_t  RESERVED6;
N  __IO uint16_t DR7;
X  volatile uint16_t DR7;
N  uint16_t  RESERVED7;
N  __IO uint16_t DR8;
X  volatile uint16_t DR8;
N  uint16_t  RESERVED8;
N  __IO uint16_t DR9;
X  volatile uint16_t DR9;
N  uint16_t  RESERVED9;
N  __IO uint16_t DR10;
X  volatile uint16_t DR10;
N  uint16_t  RESERVED10; 
N  __IO uint16_t RTCCR;
X  volatile uint16_t RTCCR;
N  uint16_t  RESERVED11;
N  __IO uint16_t CR;
X  volatile uint16_t CR;
N  uint16_t  RESERVED12;
N  __IO uint16_t CSR;
X  volatile uint16_t CSR;
N  uint16_t  RESERVED13[5];
N  __IO uint16_t DR11;
X  volatile uint16_t DR11;
N  uint16_t  RESERVED14;
N  __IO uint16_t DR12;
X  volatile uint16_t DR12;
N  uint16_t  RESERVED15;
N  __IO uint16_t DR13;
X  volatile uint16_t DR13;
N  uint16_t  RESERVED16;
N  __IO uint16_t DR14;
X  volatile uint16_t DR14;
N  uint16_t  RESERVED17;
N  __IO uint16_t DR15;
X  volatile uint16_t DR15;
N  uint16_t  RESERVED18;
N  __IO uint16_t DR16;
X  volatile uint16_t DR16;
N  uint16_t  RESERVED19;
N  __IO uint16_t DR17;
X  volatile uint16_t DR17;
N  uint16_t  RESERVED20;
N  __IO uint16_t DR18;
X  volatile uint16_t DR18;
N  uint16_t  RESERVED21;
N  __IO uint16_t DR19;
X  volatile uint16_t DR19;
N  uint16_t  RESERVED22;
N  __IO uint16_t DR20;
X  volatile uint16_t DR20;
N  uint16_t  RESERVED23;
N  __IO uint16_t DR21;
X  volatile uint16_t DR21;
N  uint16_t  RESERVED24;
N  __IO uint16_t DR22;
X  volatile uint16_t DR22;
N  uint16_t  RESERVED25;
N  __IO uint16_t DR23;
X  volatile uint16_t DR23;
N  uint16_t  RESERVED26;
N  __IO uint16_t DR24;
X  volatile uint16_t DR24;
N  uint16_t  RESERVED27;
N  __IO uint16_t DR25;
X  volatile uint16_t DR25;
N  uint16_t  RESERVED28;
N  __IO uint16_t DR26;
X  volatile uint16_t DR26;
N  uint16_t  RESERVED29;
N  __IO uint16_t DR27;
X  volatile uint16_t DR27;
N  uint16_t  RESERVED30;
N  __IO uint16_t DR28;
X  volatile uint16_t DR28;
N  uint16_t  RESERVED31;
N  __IO uint16_t DR29;
X  volatile uint16_t DR29;
N  uint16_t  RESERVED32;
N  __IO uint16_t DR30;
X  volatile uint16_t DR30;
N  uint16_t  RESERVED33; 
N  __IO uint16_t DR31;
X  volatile uint16_t DR31;
N  uint16_t  RESERVED34;
N  __IO uint16_t DR32;
X  volatile uint16_t DR32;
N  uint16_t  RESERVED35;
N  __IO uint16_t DR33;
X  volatile uint16_t DR33;
N  uint16_t  RESERVED36;
N  __IO uint16_t DR34;
X  volatile uint16_t DR34;
N  uint16_t  RESERVED37;
N  __IO uint16_t DR35;
X  volatile uint16_t DR35;
N  uint16_t  RESERVED38;
N  __IO uint16_t DR36;
X  volatile uint16_t DR36;
N  uint16_t  RESERVED39;
N  __IO uint16_t DR37;
X  volatile uint16_t DR37;
N  uint16_t  RESERVED40;
N  __IO uint16_t DR38;
X  volatile uint16_t DR38;
N  uint16_t  RESERVED41;
N  __IO uint16_t DR39;
X  volatile uint16_t DR39;
N  uint16_t  RESERVED42;
N  __IO uint16_t DR40;
X  volatile uint16_t DR40;
N  uint16_t  RESERVED43;
N  __IO uint16_t DR41;
X  volatile uint16_t DR41;
N  uint16_t  RESERVED44;
N  __IO uint16_t DR42;
X  volatile uint16_t DR42;
N  uint16_t  RESERVED45;    
N} BKP_TypeDef;
N  
N/** 
N  * @brief Controller Area Network TxMailBox 
N  */
N
Ntypedef struct
N{
N  __IO uint32_t TIR;
X  volatile uint32_t TIR;
N  __IO uint32_t TDTR;
X  volatile uint32_t TDTR;
N  __IO uint32_t TDLR;
X  volatile uint32_t TDLR;
N  __IO uint32_t TDHR;
X  volatile uint32_t TDHR;
N} CAN_TxMailBox_TypeDef;
N
N/** 
N  * @brief Controller Area Network FIFOMailBox 
N  */
N  
Ntypedef struct
N{
N  __IO uint32_t RIR;
X  volatile uint32_t RIR;
N  __IO uint32_t RDTR;
X  volatile uint32_t RDTR;
N  __IO uint32_t RDLR;
X  volatile uint32_t RDLR;
N  __IO uint32_t RDHR;
X  volatile uint32_t RDHR;
N} CAN_FIFOMailBox_TypeDef;
N
N/** 
N  * @brief Controller Area Network FilterRegister 
N  */
N  
Ntypedef struct
N{
N  __IO uint32_t FR1;
X  volatile uint32_t FR1;
N  __IO uint32_t FR2;
X  volatile uint32_t FR2;
N} CAN_FilterRegister_TypeDef;
N
N/** 
N  * @brief Controller Area Network 
N  */
N  
Ntypedef struct
N{
N  __IO uint32_t MCR;
X  volatile uint32_t MCR;
N  __IO uint32_t MSR;
X  volatile uint32_t MSR;
N  __IO uint32_t TSR;
X  volatile uint32_t TSR;
N  __IO uint32_t RF0R;
X  volatile uint32_t RF0R;
N  __IO uint32_t RF1R;
X  volatile uint32_t RF1R;
N  __IO uint32_t IER;
X  volatile uint32_t IER;
N  __IO uint32_t ESR;
X  volatile uint32_t ESR;
N  __IO uint32_t BTR;
X  volatile uint32_t BTR;
N  uint32_t  RESERVED0[88];
N  CAN_TxMailBox_TypeDef sTxMailBox[3];
N  CAN_FIFOMailBox_TypeDef sFIFOMailBox[2];
N  uint32_t  RESERVED1[12];
N  __IO uint32_t FMR;
X  volatile uint32_t FMR;
N  __IO uint32_t FM1R;
X  volatile uint32_t FM1R;
N  uint32_t  RESERVED2;
N  __IO uint32_t FS1R;
X  volatile uint32_t FS1R;
N  uint32_t  RESERVED3;
N  __IO uint32_t FFA1R;
X  volatile uint32_t FFA1R;
N  uint32_t  RESERVED4;
N  __IO uint32_t FA1R;
X  volatile uint32_t FA1R;
N  uint32_t  RESERVED5[8];
N#ifndef STM32F10X_CL
N  CAN_FilterRegister_TypeDef sFilterRegister[14];
N#else
S  CAN_FilterRegister_TypeDef sFilterRegister[28];
N#endif /* STM32F10X_CL */  
N} CAN_TypeDef;
N
N/** 
N  * @brief Consumer Electronics Control (CEC)
N  */
Ntypedef struct
N{
N  __IO uint32_t CFGR;
X  volatile uint32_t CFGR;
N  __IO uint32_t OAR;
X  volatile uint32_t OAR;
N  __IO uint32_t PRES;
X  volatile uint32_t PRES;
N  __IO uint32_t ESR;
X  volatile uint32_t ESR;
N  __IO uint32_t CSR;
X  volatile uint32_t CSR;
N  __IO uint32_t TXD;
X  volatile uint32_t TXD;
N  __IO uint32_t RXD;  
X  volatile uint32_t RXD;  
N} CEC_TypeDef;
N
N/** 
N  * @brief CRC calculation unit 
N  */
N
Ntypedef struct
N{
N  __IO uint32_t DR;
X  volatile uint32_t DR;
N  __IO uint8_t  IDR;
X  volatile uint8_t  IDR;
N  uint8_t   RESERVED0;
N  uint16_t  RESERVED1;
N  __IO uint32_t CR;
X  volatile uint32_t CR;
N} CRC_TypeDef;
N
N/** 
N  * @brief Digital to Analog Converter
N  */
N
Ntypedef struct
N{
N  __IO uint32_t CR;
X  volatile uint32_t CR;
N  __IO uint32_t SWTRIGR;
X  volatile uint32_t SWTRIGR;
N  __IO uint32_t DHR12R1;
X  volatile uint32_t DHR12R1;
N  __IO uint32_t DHR12L1;
X  volatile uint32_t DHR12L1;
N  __IO uint32_t DHR8R1;
X  volatile uint32_t DHR8R1;
N  __IO uint32_t DHR12R2;
X  volatile uint32_t DHR12R2;
N  __IO uint32_t DHR12L2;
X  volatile uint32_t DHR12L2;
N  __IO uint32_t DHR8R2;
X  volatile uint32_t DHR8R2;
N  __IO uint32_t DHR12RD;
X  volatile uint32_t DHR12RD;
N  __IO uint32_t DHR12LD;
X  volatile uint32_t DHR12LD;
N  __IO uint32_t DHR8RD;
X  volatile uint32_t DHR8RD;
N  __IO uint32_t DOR1;
X  volatile uint32_t DOR1;
N  __IO uint32_t DOR2;
X  volatile uint32_t DOR2;
N#if defined (STM32F10X_LD_VL) || defined (STM32F10X_MD_VL) || defined (STM32F10X_HD_VL)
X#if 0L || 0L || 0L
S  __IO uint32_t SR;
N#endif
N} DAC_TypeDef;
N
N/** 
N  * @brief Debug MCU
N  */
N
Ntypedef struct
N{
N  __IO uint32_t IDCODE;
X  volatile uint32_t IDCODE;
N  __IO uint32_t CR;	
X  volatile uint32_t CR;	
N}DBGMCU_TypeDef;
N
N/** 
N  * @brief DMA Controller
N  */
N
Ntypedef struct
N{
N  __IO uint32_t CCR;
X  volatile uint32_t CCR;
N  __IO uint32_t CNDTR;
X  volatile uint32_t CNDTR;
N  __IO uint32_t CPAR;
X  volatile uint32_t CPAR;
N  __IO uint32_t CMAR;
X  volatile uint32_t CMAR;
N} DMA_Channel_TypeDef;
N
Ntypedef struct
N{
N  __IO uint32_t ISR;
X  volatile uint32_t ISR;
N  __IO uint32_t IFCR;
X  volatile uint32_t IFCR;
N} DMA_TypeDef;
N
N/** 
N  * @brief Ethernet MAC
N  */
N
Ntypedef struct
N{
N  __IO uint32_t MACCR;
X  volatile uint32_t MACCR;
N  __IO uint32_t MACFFR;
X  volatile uint32_t MACFFR;
N  __IO uint32_t MACHTHR;
X  volatile uint32_t MACHTHR;
N  __IO uint32_t MACHTLR;
X  volatile uint32_t MACHTLR;
N  __IO uint32_t MACMIIAR;
X  volatile uint32_t MACMIIAR;
N  __IO uint32_t MACMIIDR;
X  volatile uint32_t MACMIIDR;
N  __IO uint32_t MACFCR;
X  volatile uint32_t MACFCR;
N  __IO uint32_t MACVLANTR;             /*    8 */
X  volatile uint32_t MACVLANTR;              
N       uint32_t RESERVED0[2];
N  __IO uint32_t MACRWUFFR;             /*   11 */
X  volatile uint32_t MACRWUFFR;              
N  __IO uint32_t MACPMTCSR;
X  volatile uint32_t MACPMTCSR;
N       uint32_t RESERVED1[2];
N  __IO uint32_t MACSR;                 /*   15 */
X  volatile uint32_t MACSR;                  
N  __IO uint32_t MACIMR;
X  volatile uint32_t MACIMR;
N  __IO uint32_t MACA0HR;
X  volatile uint32_t MACA0HR;
N  __IO uint32_t MACA0LR;
X  volatile uint32_t MACA0LR;
N  __IO uint32_t MACA1HR;
X  volatile uint32_t MACA1HR;
N  __IO uint32_t MACA1LR;
X  volatile uint32_t MACA1LR;
N  __IO uint32_t MACA2HR;
X  volatile uint32_t MACA2HR;
N  __IO uint32_t MACA2LR;
X  volatile uint32_t MACA2LR;
N  __IO uint32_t MACA3HR;
X  volatile uint32_t MACA3HR;
N  __IO uint32_t MACA3LR;               /*   24 */
X  volatile uint32_t MACA3LR;                
N       uint32_t RESERVED2[40];
N  __IO uint32_t MMCCR;                 /*   65 */
X  volatile uint32_t MMCCR;                  
N  __IO uint32_t MMCRIR;
X  volatile uint32_t MMCRIR;
N  __IO uint32_t MMCTIR;
X  volatile uint32_t MMCTIR;
N  __IO uint32_t MMCRIMR;
X  volatile uint32_t MMCRIMR;
N  __IO uint32_t MMCTIMR;               /*   69 */
X  volatile uint32_t MMCTIMR;                
N       uint32_t RESERVED3[14];
N  __IO uint32_t MMCTGFSCCR;            /*   84 */
X  volatile uint32_t MMCTGFSCCR;             
N  __IO uint32_t MMCTGFMSCCR;
X  volatile uint32_t MMCTGFMSCCR;
N       uint32_t RESERVED4[5];
N  __IO uint32_t MMCTGFCR;
X  volatile uint32_t MMCTGFCR;
N       uint32_t RESERVED5[10];
N  __IO uint32_t MMCRFCECR;
X  volatile uint32_t MMCRFCECR;
N  __IO uint32_t MMCRFAECR;
X  volatile uint32_t MMCRFAECR;
N       uint32_t RESERVED6[10];
N  __IO uint32_t MMCRGUFCR;
X  volatile uint32_t MMCRGUFCR;
N       uint32_t RESERVED7[334];
N  __IO uint32_t PTPTSCR;
X  volatile uint32_t PTPTSCR;
N  __IO uint32_t PTPSSIR;
X  volatile uint32_t PTPSSIR;
N  __IO uint32_t PTPTSHR;
X  volatile uint32_t PTPTSHR;
N  __IO uint32_t PTPTSLR;
X  volatile uint32_t PTPTSLR;
N  __IO uint32_t PTPTSHUR;
X  volatile uint32_t PTPTSHUR;
N  __IO uint32_t PTPTSLUR;
X  volatile uint32_t PTPTSLUR;
N  __IO uint32_t PTPTSAR;
X  volatile uint32_t PTPTSAR;
N  __IO uint32_t PTPTTHR;
X  volatile uint32_t PTPTTHR;
N  __IO uint32_t PTPTTLR;
X  volatile uint32_t PTPTTLR;
N       uint32_t RESERVED8[567];
N  __IO uint32_t DMABMR;
X  volatile uint32_t DMABMR;
N  __IO uint32_t DMATPDR;
X  volatile uint32_t DMATPDR;
N  __IO uint32_t DMARPDR;
X  volatile uint32_t DMARPDR;
N  __IO uint32_t DMARDLAR;
X  volatile uint32_t DMARDLAR;
N  __IO uint32_t DMATDLAR;
X  volatile uint32_t DMATDLAR;
N  __IO uint32_t DMASR;
X  volatile uint32_t DMASR;
N  __IO uint32_t DMAOMR;
X  volatile uint32_t DMAOMR;
N  __IO uint32_t DMAIER;
X  volatile uint32_t DMAIER;
N  __IO uint32_t DMAMFBOCR;
X  volatile uint32_t DMAMFBOCR;
N       uint32_t RESERVED9[9];
N  __IO uint32_t DMACHTDR;
X  volatile uint32_t DMACHTDR;
N  __IO uint32_t DMACHRDR;
X  volatile uint32_t DMACHRDR;
N  __IO uint32_t DMACHTBAR;
X  volatile uint32_t DMACHTBAR;
N  __IO uint32_t DMACHRBAR;
X  volatile uint32_t DMACHRBAR;
N} ETH_TypeDef;
N
N/** 
N  * @brief External Interrupt/Event Controller
N  */
N
Ntypedef struct
N{
N  __IO uint32_t IMR;
X  volatile uint32_t IMR;
N  __IO uint32_t EMR;
X  volatile uint32_t EMR;
N  __IO uint32_t RTSR;
X  volatile uint32_t RTSR;
N  __IO uint32_t FTSR;
X  volatile uint32_t FTSR;
N  __IO uint32_t SWIER;
X  volatile uint32_t SWIER;
N  __IO uint32_t PR;
X  volatile uint32_t PR;
N} EXTI_TypeDef;
N
N/** 
N  * @brief FLASH Registers
N  */
N
Ntypedef struct
N{
N  __IO uint32_t ACR;
X  volatile uint32_t ACR;
N  __IO uint32_t KEYR;
X  volatile uint32_t KEYR;
N  __IO uint32_t OPTKEYR;
X  volatile uint32_t OPTKEYR;
N  __IO uint32_t SR;
X  volatile uint32_t SR;
N  __IO uint32_t CR;
X  volatile uint32_t CR;
N  __IO uint32_t AR;
X  volatile uint32_t AR;
N  __IO uint32_t RESERVED;
X  volatile uint32_t RESERVED;
N  __IO uint32_t OBR;
X  volatile uint32_t OBR;
N  __IO uint32_t WRPR;
X  volatile uint32_t WRPR;
N#ifdef STM32F10X_XL
S  uint32_t RESERVED1[8]; 
S  __IO uint32_t KEYR2;
S  uint32_t RESERVED2;   
S  __IO uint32_t SR2;
S  __IO uint32_t CR2;
S  __IO uint32_t AR2; 
N#endif /* STM32F10X_XL */  
N} FLASH_TypeDef;
N
N/** 
N  * @brief Option Bytes Registers
N  */
N  
Ntypedef struct
N{
N  __IO uint16_t RDP;
X  volatile uint16_t RDP;
N  __IO uint16_t USER;
X  volatile uint16_t USER;
N  __IO uint16_t Data0;
X  volatile uint16_t Data0;
N  __IO uint16_t Data1;
X  volatile uint16_t Data1;
N  __IO uint16_t WRP0;
X  volatile uint16_t WRP0;
N  __IO uint16_t WRP1;
X  volatile uint16_t WRP1;
N  __IO uint16_t WRP2;
X  volatile uint16_t WRP2;
N  __IO uint16_t WRP3;
X  volatile uint16_t WRP3;
N} OB_TypeDef;
N
N/** 
N  * @brief Flexible Static Memory Controller
N  */
N
Ntypedef struct
N{
N  __IO uint32_t BTCR[8];   
X  volatile uint32_t BTCR[8];   
N} FSMC_Bank1_TypeDef; 
N
N/** 
N  * @brief Flexible Static Memory Controller Bank1E
N  */
N  
Ntypedef struct
N{
N  __IO uint32_t BWTR[7];
X  volatile uint32_t BWTR[7];
N} FSMC_Bank1E_TypeDef;
N
N/** 
N  * @brief Flexible Static Memory Controller Bank2
N  */
N  
Ntypedef struct
N{
N  __IO uint32_t PCR2;
X  volatile uint32_t PCR2;
N  __IO uint32_t SR2;
X  volatile uint32_t SR2;
N  __IO uint32_t PMEM2;
X  volatile uint32_t PMEM2;
N  __IO uint32_t PATT2;
X  volatile uint32_t PATT2;
N  uint32_t  RESERVED0;   
N  __IO uint32_t ECCR2; 
X  volatile uint32_t ECCR2; 
N} FSMC_Bank2_TypeDef;  
N
N/** 
N  * @brief Flexible Static Memory Controller Bank3
N  */
N  
Ntypedef struct
N{
N  __IO uint32_t PCR3;
X  volatile uint32_t PCR3;
N  __IO uint32_t SR3;
X  volatile uint32_t SR3;
N  __IO uint32_t PMEM3;
X  volatile uint32_t PMEM3;
N  __IO uint32_t PATT3;
X  volatile uint32_t PATT3;
N  uint32_t  RESERVED0;   
N  __IO uint32_t ECCR3; 
X  volatile uint32_t ECCR3; 
N} FSMC_Bank3_TypeDef; 
N
N/** 
N  * @brief Flexible Static Memory Controller Bank4
N  */
N  
Ntypedef struct
N{
N  __IO uint32_t PCR4;
X  volatile uint32_t PCR4;
N  __IO uint32_t SR4;
X  volatile uint32_t SR4;
N  __IO uint32_t PMEM4;
X  volatile uint32_t PMEM4;
N  __IO uint32_t PATT4;
X  volatile uint32_t PATT4;
N  __IO uint32_t PIO4; 
X  volatile uint32_t PIO4; 
N} FSMC_Bank4_TypeDef; 
N
N/** 
N  * @brief General Purpose I/O
N  */
N
Ntypedef struct
N{
N  __IO uint32_t CRL;
X  volatile uint32_t CRL;
N  __IO uint32_t CRH;
X  volatile uint32_t CRH;
N  __IO uint32_t IDR;
X  volatile uint32_t IDR;
N  __IO uint32_t ODR;
X  volatile uint32_t ODR;
N  __IO uint32_t BSRR;
X  volatile uint32_t BSRR;
N  __IO uint32_t BRR;
X  volatile uint32_t BRR;
N  __IO uint32_t LCKR;
X  volatile uint32_t LCKR;
N} GPIO_TypeDef;
N
N/** 
N  * @brief Alternate Function I/O
N  */
N
Ntypedef struct
N{
N  __IO uint32_t EVCR;
X  volatile uint32_t EVCR;
N  __IO uint32_t MAPR;
X  volatile uint32_t MAPR;
N  __IO uint32_t EXTICR[4];
X  volatile uint32_t EXTICR[4];
N  uint32_t RESERVED0;
N  __IO uint32_t MAPR2;  
X  volatile uint32_t MAPR2;  
N} AFIO_TypeDef;
N/** 
N  * @brief Inter Integrated Circuit Interface
N  */
N
Ntypedef struct
N{
N  __IO uint16_t CR1;
X  volatile uint16_t CR1;
N  uint16_t  RESERVED0;
N  __IO uint16_t CR2;
X  volatile uint16_t CR2;
N  uint16_t  RESERVED1;
N  __IO uint16_t OAR1;
X  volatile uint16_t OAR1;
N  uint16_t  RESERVED2;
N  __IO uint16_t OAR2;
X  volatile uint16_t OAR2;
N  uint16_t  RESERVED3;
N  __IO uint16_t DR;
X  volatile uint16_t DR;
N  uint16_t  RESERVED4;
N  __IO uint16_t SR1;
X  volatile uint16_t SR1;
N  uint16_t  RESERVED5;
N  __IO uint16_t SR2;
X  volatile uint16_t SR2;
N  uint16_t  RESERVED6;
N  __IO uint16_t CCR;
X  volatile uint16_t CCR;
N  uint16_t  RESERVED7;
N  __IO uint16_t TRISE;
X  volatile uint16_t TRISE;
N  uint16_t  RESERVED8;
N} I2C_TypeDef;
N
N/** 
N  * @brief Independent WATCHDOG
N  */
N
Ntypedef struct
N{
N  __IO uint32_t KR;
X  volatile uint32_t KR;
N  __IO uint32_t PR;
X  volatile uint32_t PR;
N  __IO uint32_t RLR;
X  volatile uint32_t RLR;
N  __IO uint32_t SR;
X  volatile uint32_t SR;
N} IWDG_TypeDef;
N
N/** 
N  * @brief Power Control
N  */
N
Ntypedef struct
N{
N  __IO uint32_t CR;
X  volatile uint32_t CR;
N  __IO uint32_t CSR;
X  volatile uint32_t CSR;
N} PWR_TypeDef;
N
N/** 
N  * @brief Reset and Clock Control
N  */
N
Ntypedef struct
N{
N  __IO uint32_t CR;
X  volatile uint32_t CR;
N  __IO uint32_t CFGR;
X  volatile uint32_t CFGR;
N  __IO uint32_t CIR;
X  volatile uint32_t CIR;
N  __IO uint32_t APB2RSTR;
X  volatile uint32_t APB2RSTR;
N  __IO uint32_t APB1RSTR;
X  volatile uint32_t APB1RSTR;
N  __IO uint32_t AHBENR;
X  volatile uint32_t AHBENR;
N  __IO uint32_t APB2ENR;
X  volatile uint32_t APB2ENR;
N  __IO uint32_t APB1ENR;
X  volatile uint32_t APB1ENR;
N  __IO uint32_t BDCR;
X  volatile uint32_t BDCR;
N  __IO uint32_t CSR;
X  volatile uint32_t CSR;
N
N#ifdef STM32F10X_CL  
S  __IO uint32_t AHBRSTR;
S  __IO uint32_t CFGR2;
N#endif /* STM32F10X_CL */ 
N
N#if defined (STM32F10X_LD_VL) || defined (STM32F10X_MD_VL) || defined (STM32F10X_HD_VL)   
X#if 0L || 0L || 0L   
S  uint32_t RESERVED0;
S  __IO uint32_t CFGR2;
N#endif /* STM32F10X_LD_VL || STM32F10X_MD_VL || STM32F10X_HD_VL */ 
N} RCC_TypeDef;
N
N/** 
N  * @brief Real-Time Clock
N  */
N
Ntypedef struct
N{
N  __IO uint16_t CRH;
X  volatile uint16_t CRH;
N  uint16_t  RESERVED0;
N  __IO uint16_t CRL;
X  volatile uint16_t CRL;
N  uint16_t  RESERVED1;
N  __IO uint16_t PRLH;
X  volatile uint16_t PRLH;
N  uint16_t  RESERVED2;
N  __IO uint16_t PRLL;
X  volatile uint16_t PRLL;
N  uint16_t  RESERVED3;
N  __IO uint16_t DIVH;
X  volatile uint16_t DIVH;
N  uint16_t  RESERVED4;
N  __IO uint16_t DIVL;
X  volatile uint16_t DIVL;
N  uint16_t  RESERVED5;
N  __IO uint16_t CNTH;
X  volatile uint16_t CNTH;
N  uint16_t  RESERVED6;
N  __IO uint16_t CNTL;
X  volatile uint16_t CNTL;
N  uint16_t  RESERVED7;
N  __IO uint16_t ALRH;
X  volatile uint16_t ALRH;
N  uint16_t  RESERVED8;
N  __IO uint16_t ALRL;
X  volatile uint16_t ALRL;
N  uint16_t  RESERVED9;
N} RTC_TypeDef;
N
N/** 
N  * @brief SD host Interface
N  */
N
Ntypedef struct
N{
N  __IO uint32_t POWER;
X  volatile uint32_t POWER;
N  __IO uint32_t CLKCR;
X  volatile uint32_t CLKCR;
N  __IO uint32_t ARG;
X  volatile uint32_t ARG;
N  __IO uint32_t CMD;
X  volatile uint32_t CMD;
N  __I uint32_t RESPCMD;
X  volatile const uint32_t RESPCMD;
N  __I uint32_t RESP1;
X  volatile const uint32_t RESP1;
N  __I uint32_t RESP2;
X  volatile const uint32_t RESP2;
N  __I uint32_t RESP3;
X  volatile const uint32_t RESP3;
N  __I uint32_t RESP4;
X  volatile const uint32_t RESP4;
N  __IO uint32_t DTIMER;
X  volatile uint32_t DTIMER;
N  __IO uint32_t DLEN;
X  volatile uint32_t DLEN;
N  __IO uint32_t DCTRL;
X  volatile uint32_t DCTRL;
N  __I uint32_t DCOUNT;
X  volatile const uint32_t DCOUNT;
N  __I uint32_t STA;
X  volatile const uint32_t STA;
N  __IO uint32_t ICR;
X  volatile uint32_t ICR;
N  __IO uint32_t MASK;
X  volatile uint32_t MASK;
N  uint32_t  RESERVED0[2];
N  __I uint32_t FIFOCNT;
X  volatile const uint32_t FIFOCNT;
N  uint32_t  RESERVED1[13];
N  __IO uint32_t FIFO;
X  volatile uint32_t FIFO;
N} SDIO_TypeDef;
N
N/** 
N  * @brief Serial Peripheral Interface
N  */
N
Ntypedef struct
N{
N  __IO uint16_t CR1;
X  volatile uint16_t CR1;
N  uint16_t  RESERVED0;
N  __IO uint16_t CR2;
X  volatile uint16_t CR2;
N  uint16_t  RESERVED1;
N  __IO uint16_t SR;
X  volatile uint16_t SR;
N  uint16_t  RESERVED2;
N  __IO uint16_t DR;
X  volatile uint16_t DR;
N  uint16_t  RESERVED3;
N  __IO uint16_t CRCPR;
X  volatile uint16_t CRCPR;
N  uint16_t  RESERVED4;
N  __IO uint16_t RXCRCR;
X  volatile uint16_t RXCRCR;
N  uint16_t  RESERVED5;
N  __IO uint16_t TXCRCR;
X  volatile uint16_t TXCRCR;
N  uint16_t  RESERVED6;
N  __IO uint16_t I2SCFGR;
X  volatile uint16_t I2SCFGR;
N  uint16_t  RESERVED7;
N  __IO uint16_t I2SPR;
X  volatile uint16_t I2SPR;
N  uint16_t  RESERVED8;  
N} SPI_TypeDef;
N
N/** 
N  * @brief TIM
N  */
N
Ntypedef struct
N{
N  __IO uint16_t CR1;
X  volatile uint16_t CR1;
N  uint16_t  RESERVED0;
N  __IO uint16_t CR2;
X  volatile uint16_t CR2;
N  uint16_t  RESERVED1;
N  __IO uint16_t SMCR;
X  volatile uint16_t SMCR;
N  uint16_t  RESERVED2;
N  __IO uint16_t DIER;
X  volatile uint16_t DIER;
N  uint16_t  RESERVED3;
N  __IO uint16_t SR;
X  volatile uint16_t SR;
N  uint16_t  RESERVED4;
N  __IO uint16_t EGR;
X  volatile uint16_t EGR;
N  uint16_t  RESERVED5;
N  __IO uint16_t CCMR1;
X  volatile uint16_t CCMR1;
N  uint16_t  RESERVED6;
N  __IO uint16_t CCMR2;
X  volatile uint16_t CCMR2;
N  uint16_t  RESERVED7;
N  __IO uint16_t CCER;
X  volatile uint16_t CCER;
N  uint16_t  RESERVED8;
N  __IO uint16_t CNT;
X  volatile uint16_t CNT;
N  uint16_t  RESERVED9;
N  __IO uint16_t PSC;
X  volatile uint16_t PSC;
N  uint16_t  RESERVED10;
N  __IO uint16_t ARR;
X  volatile uint16_t ARR;
N  uint16_t  RESERVED11;
N  __IO uint16_t RCR;
X  volatile uint16_t RCR;
N  uint16_t  RESERVED12;
N  __IO uint16_t CCR1;
X  volatile uint16_t CCR1;
N  uint16_t  RESERVED13;
N  __IO uint16_t CCR2;
X  volatile uint16_t CCR2;
N  uint16_t  RESERVED14;
N  __IO uint16_t CCR3;
X  volatile uint16_t CCR3;
N  uint16_t  RESERVED15;
N  __IO uint16_t CCR4;
X  volatile uint16_t CCR4;
N  uint16_t  RESERVED16;
N  __IO uint16_t BDTR;
X  volatile uint16_t BDTR;
N  uint16_t  RESERVED17;
N  __IO uint16_t DCR;
X  volatile uint16_t DCR;
N  uint16_t  RESERVED18;
N  __IO uint16_t DMAR;
X  volatile uint16_t DMAR;
N  uint16_t  RESERVED19;
N} TIM_TypeDef;
N
N/** 
N  * @brief Universal Synchronous Asynchronous Receiver Transmitter
N  */
N 
Ntypedef struct
N{
N  __IO uint16_t SR;
X  volatile uint16_t SR;
N  uint16_t  RESERVED0;
N  __IO uint16_t DR;
X  volatile uint16_t DR;
N  uint16_t  RESERVED1;
N  __IO uint16_t BRR;
X  volatile uint16_t BRR;
N  uint16_t  RESERVED2;
N  __IO uint16_t CR1;
X  volatile uint16_t CR1;
N  uint16_t  RESERVED3;
N  __IO uint16_t CR2;
X  volatile uint16_t CR2;
N  uint16_t  RESERVED4;
N  __IO uint16_t CR3;
X  volatile uint16_t CR3;
N  uint16_t  RESERVED5;
N  __IO uint16_t GTPR;
X  volatile uint16_t GTPR;
N  uint16_t  RESERVED6;
N} USART_TypeDef;
N
N/** 
N  * @brief Window WATCHDOG
N  */
N
Ntypedef struct
N{
N  __IO uint32_t CR;
X  volatile uint32_t CR;
N  __IO uint32_t CFR;
X  volatile uint32_t CFR;
N  __IO uint32_t SR;
X  volatile uint32_t SR;
N} WWDG_TypeDef;
N
N/**
N  * @}
N  */
N  
N/** @addtogroup Peripheral_memory_map
N  * @{
N  */
N
N
N#define FLASH_BASE            ((uint32_t)0x08000000) /*!< FLASH base address in the alias region */
N#define SRAM_BASE             ((uint32_t)0x20000000) /*!< SRAM base address in the alias region */
N#define PERIPH_BASE           ((uint32_t)0x40000000) /*!< Peripheral base address in the alias region */
N
N#define SRAM_BB_BASE          ((uint32_t)0x22000000) /*!< SRAM base address in the bit-band region */
N#define PERIPH_BB_BASE        ((uint32_t)0x42000000) /*!< Peripheral base address in the bit-band region */
N
N#define FSMC_R_BASE           ((uint32_t)0xA0000000) /*!< FSMC registers base address */
N
N/*!< Peripheral memory map */
N#define APB1PERIPH_BASE       PERIPH_BASE
N#define APB2PERIPH_BASE       (PERIPH_BASE + 0x10000)
N#define AHBPERIPH_BASE        (PERIPH_BASE + 0x20000)
N
N#define TIM2_BASE             (APB1PERIPH_BASE + 0x0000)
N#define TIM3_BASE             (APB1PERIPH_BASE + 0x0400)
N#define TIM4_BASE             (APB1PERIPH_BASE + 0x0800)
N#define TIM5_BASE             (APB1PERIPH_BASE + 0x0C00)
N#define TIM6_BASE             (APB1PERIPH_BASE + 0x1000)
N#define TIM7_BASE             (APB1PERIPH_BASE + 0x1400)
N#define TIM12_BASE            (APB1PERIPH_BASE + 0x1800)
N#define TIM13_BASE            (APB1PERIPH_BASE + 0x1C00)
N#define TIM14_BASE            (APB1PERIPH_BASE + 0x2000)
N#define RTC_BASE              (APB1PERIPH_BASE + 0x2800)
N#define WWDG_BASE             (APB1PERIPH_BASE + 0x2C00)
N#define IWDG_BASE             (APB1PERIPH_BASE + 0x3000)
N#define SPI2_BASE             (APB1PERIPH_BASE + 0x3800)
N#define SPI3_BASE             (APB1PERIPH_BASE + 0x3C00)
N#define USART2_BASE           (APB1PERIPH_BASE + 0x4400)
N#define USART3_BASE           (APB1PERIPH_BASE + 0x4800)
N#define UART4_BASE            (APB1PERIPH_BASE + 0x4C00)
N#define UART5_BASE            (APB1PERIPH_BASE + 0x5000)
N#define I2C1_BASE             (APB1PERIPH_BASE + 0x5400)
N#define I2C2_BASE             (APB1PERIPH_BASE + 0x5800)
N#define CAN1_BASE             (APB1PERIPH_BASE + 0x6400)
N#define CAN2_BASE             (APB1PERIPH_BASE + 0x6800)
N#define BKP_BASE              (APB1PERIPH_BASE + 0x6C00)
N#define PWR_BASE              (APB1PERIPH_BASE + 0x7000)
N#define DAC_BASE              (APB1PERIPH_BASE + 0x7400)
N#define CEC_BASE              (APB1PERIPH_BASE + 0x7800)
N
N#define AFIO_BASE             (APB2PERIPH_BASE + 0x0000)
N#define EXTI_BASE             (APB2PERIPH_BASE + 0x0400)
N#define GPIOA_BASE            (APB2PERIPH_BASE + 0x0800)
N#define GPIOB_BASE            (APB2PERIPH_BASE + 0x0C00)
N#define GPIOC_BASE            (APB2PERIPH_BASE + 0x1000)
N#define GPIOD_BASE            (APB2PERIPH_BASE + 0x1400)
N#define GPIOE_BASE            (APB2PERIPH_BASE + 0x1800)
N#define GPIOF_BASE            (APB2PERIPH_BASE + 0x1C00)
N#define GPIOG_BASE            (APB2PERIPH_BASE + 0x2000)
N#define ADC1_BASE             (APB2PERIPH_BASE + 0x2400)
N#define ADC2_BASE             (APB2PERIPH_BASE + 0x2800)
N#define TIM1_BASE             (APB2PERIPH_BASE + 0x2C00)
N#define SPI1_BASE             (APB2PERIPH_BASE + 0x3000)
N#define TIM8_BASE             (APB2PERIPH_BASE + 0x3400)
N#define USART1_BASE           (APB2PERIPH_BASE + 0x3800)
N#define ADC3_BASE             (APB2PERIPH_BASE + 0x3C00)
N#define TIM15_BASE            (APB2PERIPH_BASE + 0x4000)
N#define TIM16_BASE            (APB2PERIPH_BASE + 0x4400)
N#define TIM17_BASE            (APB2PERIPH_BASE + 0x4800)
N#define TIM9_BASE             (APB2PERIPH_BASE + 0x4C00)
N#define TIM10_BASE            (APB2PERIPH_BASE + 0x5000)
N#define TIM11_BASE            (APB2PERIPH_BASE + 0x5400)
N
N#define SDIO_BASE             (PERIPH_BASE + 0x18000)
N
N#define DMA1_BASE             (AHBPERIPH_BASE + 0x0000)
N#define DMA1_Channel1_BASE    (AHBPERIPH_BASE + 0x0008)
N#define DMA1_Channel2_BASE    (AHBPERIPH_BASE + 0x001C)
N#define DMA1_Channel3_BASE    (AHBPERIPH_BASE + 0x0030)
N#define DMA1_Channel4_BASE    (AHBPERIPH_BASE + 0x0044)
N#define DMA1_Channel5_BASE    (AHBPERIPH_BASE + 0x0058)
N#define DMA1_Channel6_BASE    (AHBPERIPH_BASE + 0x006C)
N#define DMA1_Channel7_BASE    (AHBPERIPH_BASE + 0x0080)
N#define DMA2_BASE             (AHBPERIPH_BASE + 0x0400)
N#define DMA2_Channel1_BASE    (AHBPERIPH_BASE + 0x0408)
N#define DMA2_Channel2_BASE    (AHBPERIPH_BASE + 0x041C)
N#define DMA2_Channel3_BASE    (AHBPERIPH_BASE + 0x0430)
N#define DMA2_Channel4_BASE    (AHBPERIPH_BASE + 0x0444)
N#define DMA2_Channel5_BASE    (AHBPERIPH_BASE + 0x0458)
N#define RCC_BASE              (AHBPERIPH_BASE + 0x1000)
N#define CRC_BASE              (AHBPERIPH_BASE + 0x3000)
N
N#define FLASH_R_BASE          (AHBPERIPH_BASE + 0x2000) /*!< Flash registers base address */
N#define OB_BASE               ((uint32_t)0x1FFFF800)    /*!< Flash Option Bytes base address */
N
N#define ETH_BASE              (AHBPERIPH_BASE + 0x8000)
N#define ETH_MAC_BASE          (ETH_BASE)
N#define ETH_MMC_BASE          (ETH_BASE + 0x0100)
N#define ETH_PTP_BASE          (ETH_BASE + 0x0700)
N#define ETH_DMA_BASE          (ETH_BASE + 0x1000)
N
N#define FSMC_Bank1_R_BASE     (FSMC_R_BASE + 0x0000) /*!< FSMC Bank1 registers base address */
N#define FSMC_Bank1E_R_BASE    (FSMC_R_BASE + 0x0104) /*!< FSMC Bank1E registers base address */
N#define FSMC_Bank2_R_BASE     (FSMC_R_BASE + 0x0060) /*!< FSMC Bank2 registers base address */
N#define FSMC_Bank3_R_BASE     (FSMC_R_BASE + 0x0080) /*!< FSMC Bank3 registers base address */
N#define FSMC_Bank4_R_BASE     (FSMC_R_BASE + 0x00A0) /*!< FSMC Bank4 registers base address */
N
N#define DBGMCU_BASE          ((uint32_t)0xE0042000) /*!< Debug MCU registers base address */
N
N/**
N  * @}
N  */
N  
N/** @addtogroup Peripheral_declaration
N  * @{
N  */  
N
N#define TIM2                ((TIM_TypeDef *) TIM2_BASE)
N#define TIM3                ((TIM_TypeDef *) TIM3_BASE)
N#define TIM4                ((TIM_TypeDef *) TIM4_BASE)
N#define TIM5                ((TIM_TypeDef *) TIM5_BASE)
N#define TIM6                ((TIM_TypeDef *) TIM6_BASE)
N#define TIM7                ((TIM_TypeDef *) TIM7_BASE)
N#define TIM12               ((TIM_TypeDef *) TIM12_BASE)
N#define TIM13               ((TIM_TypeDef *) TIM13_BASE)
N#define TIM14               ((TIM_TypeDef *) TIM14_BASE)
N#define RTC                 ((RTC_TypeDef *) RTC_BASE)
N#define WWDG                ((WWDG_TypeDef *) WWDG_BASE)
N#define IWDG                ((IWDG_TypeDef *) IWDG_BASE)
N#define SPI2                ((SPI_TypeDef *) SPI2_BASE)
N#define SPI3                ((SPI_TypeDef *) SPI3_BASE)
N#define USART2              ((USART_TypeDef *) USART2_BASE)
N#define USART3              ((USART_TypeDef *) USART3_BASE)
N#define UART4               ((USART_TypeDef *) UART4_BASE)
N#define UART5               ((USART_TypeDef *) UART5_BASE)
N#define I2C1                ((I2C_TypeDef *) I2C1_BASE)
N#define I2C2                ((I2C_TypeDef *) I2C2_BASE)
N#define CAN1                ((CAN_TypeDef *) CAN1_BASE)
N#define CAN2                ((CAN_TypeDef *) CAN2_BASE)
N#define BKP                 ((BKP_TypeDef *) BKP_BASE)
N#define PWR                 ((PWR_TypeDef *) PWR_BASE)
N#define DAC                 ((DAC_TypeDef *) DAC_BASE)
N#define CEC                 ((CEC_TypeDef *) CEC_BASE)
N#define AFIO                ((AFIO_TypeDef *) AFIO_BASE)
N#define EXTI                ((EXTI_TypeDef *) EXTI_BASE)
N#define GPIOA               ((GPIO_TypeDef *) GPIOA_BASE)
N#define GPIOB               ((GPIO_TypeDef *) GPIOB_BASE)
N#define GPIOC               ((GPIO_TypeDef *) GPIOC_BASE)
N#define GPIOD               ((GPIO_TypeDef *) GPIOD_BASE)
N#define GPIOE               ((GPIO_TypeDef *) GPIOE_BASE)
N#define GPIOF               ((GPIO_TypeDef *) GPIOF_BASE)
N#define GPIOG               ((GPIO_TypeDef *) GPIOG_BASE)
N#define ADC1                ((ADC_TypeDef *) ADC1_BASE)
N#define ADC2                ((ADC_TypeDef *) ADC2_BASE)
N#define TIM1                ((TIM_TypeDef *) TIM1_BASE)
N#define SPI1                ((SPI_TypeDef *) SPI1_BASE)
N#define TIM8                ((TIM_TypeDef *) TIM8_BASE)
N#define USART1              ((USART_TypeDef *) USART1_BASE)
N#define ADC3                ((ADC_TypeDef *) ADC3_BASE)
N#define TIM15               ((TIM_TypeDef *) TIM15_BASE)
N#define TIM16               ((TIM_TypeDef *) TIM16_BASE)
N#define TIM17               ((TIM_TypeDef *) TIM17_BASE)
N#define TIM9                ((TIM_TypeDef *) TIM9_BASE)
N#define TIM10               ((TIM_TypeDef *) TIM10_BASE)
N#define TIM11               ((TIM_TypeDef *) TIM11_BASE)
N#define SDIO                ((SDIO_TypeDef *) SDIO_BASE)
N#define DMA1                ((DMA_TypeDef *) DMA1_BASE)
N#define DMA2                ((DMA_TypeDef *) DMA2_BASE)
N#define DMA1_Channel1       ((DMA_Channel_TypeDef *) DMA1_Channel1_BASE)
N#define DMA1_Channel2       ((DMA_Channel_TypeDef *) DMA1_Channel2_BASE)
N#define DMA1_Channel3       ((DMA_Channel_TypeDef *) DMA1_Channel3_BASE)
N#define DMA1_Channel4       ((DMA_Channel_TypeDef *) DMA1_Channel4_BASE)
N#define DMA1_Channel5       ((DMA_Channel_TypeDef *) DMA1_Channel5_BASE)
N#define DMA1_Channel6       ((DMA_Channel_TypeDef *) DMA1_Channel6_BASE)
N#define DMA1_Channel7       ((DMA_Channel_TypeDef *) DMA1_Channel7_BASE)
N#define DMA2_Channel1       ((DMA_Channel_TypeDef *) DMA2_Channel1_BASE)
N#define DMA2_Channel2       ((DMA_Channel_TypeDef *) DMA2_Channel2_BASE)
N#define DMA2_Channel3       ((DMA_Channel_TypeDef *) DMA2_Channel3_BASE)
N#define DMA2_Channel4       ((DMA_Channel_TypeDef *) DMA2_Channel4_BASE)
N#define DMA2_Channel5       ((DMA_Channel_TypeDef *) DMA2_Channel5_BASE)
N#define RCC                 ((RCC_TypeDef *) RCC_BASE)
N#define CRC                 ((CRC_TypeDef *) CRC_BASE)
N#define FLASH               ((FLASH_TypeDef *) FLASH_R_BASE)
N#define OB                  ((OB_TypeDef *) OB_BASE) 
N#define ETH                 ((ETH_TypeDef *) ETH_BASE)
N#define FSMC_Bank1          ((FSMC_Bank1_TypeDef *) FSMC_Bank1_R_BASE)
N#define FSMC_Bank1E         ((FSMC_Bank1E_TypeDef *) FSMC_Bank1E_R_BASE)
N#define FSMC_Bank2          ((FSMC_Bank2_TypeDef *) FSMC_Bank2_R_BASE)
N#define FSMC_Bank3          ((FSMC_Bank3_TypeDef *) FSMC_Bank3_R_BASE)
N#define FSMC_Bank4          ((FSMC_Bank4_TypeDef *) FSMC_Bank4_R_BASE)
N#define DBGMCU              ((DBGMCU_TypeDef *) DBGMCU_BASE)
N
N/**
N  * @}
N  */
N
N/** @addtogroup Exported_constants
N  * @{
N  */
N  
N  /** @addtogroup Peripheral_Registers_Bits_Definition
N  * @{
N  */
N    
N/******************************************************************************/
N/*                         Peripheral Registers_Bits_Definition               */
N/******************************************************************************/
N
N/******************************************************************************/
N/*                                                                            */
N/*                          CRC calculation unit                              */
N/*                                                                            */
N/******************************************************************************/
N
N/*******************  Bit definition for CRC_DR register  *********************/
N#define  CRC_DR_DR                           ((uint32_t)0xFFFFFFFF) /*!< Data register bits */
N
N
N/*******************  Bit definition for CRC_IDR register  ********************/
N#define  CRC_IDR_IDR                         ((uint8_t)0xFF)        /*!< General-purpose 8-bit data register bits */
N
N
N/********************  Bit definition for CRC_CR register  ********************/
N#define  CRC_CR_RESET                        ((uint8_t)0x01)        /*!< RESET bit */
N
N/******************************************************************************/
N/*                                                                            */
N/*                             Power Control                                  */
N/*                                                                            */
N/******************************************************************************/
N
N/********************  Bit definition for PWR_CR register  ********************/
N#define  PWR_CR_LPDS                         ((uint16_t)0x0001)     /*!< Low-Power Deepsleep */
N#define  PWR_CR_PDDS                         ((uint16_t)0x0002)     /*!< Power Down Deepsleep */
N#define  PWR_CR_CWUF                         ((uint16_t)0x0004)     /*!< Clear Wakeup Flag */
N#define  PWR_CR_CSBF                         ((uint16_t)0x0008)     /*!< Clear Standby Flag */
N#define  PWR_CR_PVDE                         ((uint16_t)0x0010)     /*!< Power Voltage Detector Enable */
N
N#define  PWR_CR_PLS                          ((uint16_t)0x00E0)     /*!< PLS[2:0] bits (PVD Level Selection) */
N#define  PWR_CR_PLS_0                        ((uint16_t)0x0020)     /*!< Bit 0 */
N#define  PWR_CR_PLS_1                        ((uint16_t)0x0040)     /*!< Bit 1 */
N#define  PWR_CR_PLS_2                        ((uint16_t)0x0080)     /*!< Bit 2 */
N
N/*!< PVD level configuration */
N#define  PWR_CR_PLS_2V2                      ((uint16_t)0x0000)     /*!< PVD level 2.2V */
N#define  PWR_CR_PLS_2V3                      ((uint16_t)0x0020)     /*!< PVD level 2.3V */
N#define  PWR_CR_PLS_2V4                      ((uint16_t)0x0040)     /*!< PVD level 2.4V */
N#define  PWR_CR_PLS_2V5                      ((uint16_t)0x0060)     /*!< PVD level 2.5V */
N#define  PWR_CR_PLS_2V6                      ((uint16_t)0x0080)     /*!< PVD level 2.6V */
N#define  PWR_CR_PLS_2V7                      ((uint16_t)0x00A0)     /*!< PVD level 2.7V */
N#define  PWR_CR_PLS_2V8                      ((uint16_t)0x00C0)     /*!< PVD level 2.8V */
N#define  PWR_CR_PLS_2V9                      ((uint16_t)0x00E0)     /*!< PVD level 2.9V */
N
N#define  PWR_CR_DBP                          ((uint16_t)0x0100)     /*!< Disable Backup Domain write protection */
N
N
N/*******************  Bit definition for PWR_CSR register  ********************/
N#define  PWR_CSR_WUF                         ((uint16_t)0x0001)     /*!< Wakeup Flag */
N#define  PWR_CSR_SBF                         ((uint16_t)0x0002)     /*!< Standby Flag */
N#define  PWR_CSR_PVDO                        ((uint16_t)0x0004)     /*!< PVD Output */
N#define  PWR_CSR_EWUP                        ((uint16_t)0x0100)     /*!< Enable WKUP pin */
N
N/******************************************************************************/
N/*                                                                            */
N/*                            Backup registers                                */
N/*                                                                            */
N/******************************************************************************/
N
N/*******************  Bit definition for BKP_DR1 register  ********************/
N#define  BKP_DR1_D                           ((uint16_t)0xFFFF)     /*!< Backup data */
N
N/*******************  Bit definition for BKP_DR2 register  ********************/
N#define  BKP_DR2_D                           ((uint16_t)0xFFFF)     /*!< Backup data */
N
N/*******************  Bit definition for BKP_DR3 register  ********************/
N#define  BKP_DR3_D                           ((uint16_t)0xFFFF)     /*!< Backup data */
N
N/*******************  Bit definition for BKP_DR4 register  ********************/
N#define  BKP_DR4_D                           ((uint16_t)0xFFFF)     /*!< Backup data */
N
N/*******************  Bit definition for BKP_DR5 register  ********************/
N#define  BKP_DR5_D                           ((uint16_t)0xFFFF)     /*!< Backup data */
N
N/*******************  Bit definition for BKP_DR6 register  ********************/
N#define  BKP_DR6_D                           ((uint16_t)0xFFFF)     /*!< Backup data */
N
N/*******************  Bit definition for BKP_DR7 register  ********************/
N#define  BKP_DR7_D                           ((uint16_t)0xFFFF)     /*!< Backup data */
N
N/*******************  Bit definition for BKP_DR8 register  ********************/
N#define  BKP_DR8_D                           ((uint16_t)0xFFFF)     /*!< Backup data */
N
N/*******************  Bit definition for BKP_DR9 register  ********************/
N#define  BKP_DR9_D                           ((uint16_t)0xFFFF)     /*!< Backup data */
N
N/*******************  Bit definition for BKP_DR10 register  *******************/
N#define  BKP_DR10_D                          ((uint16_t)0xFFFF)     /*!< Backup data */
N
N/*******************  Bit definition for BKP_DR11 register  *******************/
N#define  BKP_DR11_D                          ((uint16_t)0xFFFF)     /*!< Backup data */
N
N/*******************  Bit definition for BKP_DR12 register  *******************/
N#define  BKP_DR12_D                          ((uint16_t)0xFFFF)     /*!< Backup data */
N
N/*******************  Bit definition for BKP_DR13 register  *******************/
N#define  BKP_DR13_D                          ((uint16_t)0xFFFF)     /*!< Backup data */
N
N/*******************  Bit definition for BKP_DR14 register  *******************/
N#define  BKP_DR14_D                          ((uint16_t)0xFFFF)     /*!< Backup data */
N
N/*******************  Bit definition for BKP_DR15 register  *******************/
N#define  BKP_DR15_D                          ((uint16_t)0xFFFF)     /*!< Backup data */
N
N/*******************  Bit definition for BKP_DR16 register  *******************/
N#define  BKP_DR16_D                          ((uint16_t)0xFFFF)     /*!< Backup data */
N
N/*******************  Bit definition for BKP_DR17 register  *******************/
N#define  BKP_DR17_D                          ((uint16_t)0xFFFF)     /*!< Backup data */
N
N/******************  Bit definition for BKP_DR18 register  ********************/
N#define  BKP_DR18_D                          ((uint16_t)0xFFFF)     /*!< Backup data */
N
N/*******************  Bit definition for BKP_DR19 register  *******************/
N#define  BKP_DR19_D                          ((uint16_t)0xFFFF)     /*!< Backup data */
N
N/*******************  Bit definition for BKP_DR20 register  *******************/
N#define  BKP_DR20_D                          ((uint16_t)0xFFFF)     /*!< Backup data */
N
N/*******************  Bit definition for BKP_DR21 register  *******************/
N#define  BKP_DR21_D                          ((uint16_t)0xFFFF)     /*!< Backup data */
N
N/*******************  Bit definition for BKP_DR22 register  *******************/
N#define  BKP_DR22_D                          ((uint16_t)0xFFFF)     /*!< Backup data */
N
N/*******************  Bit definition for BKP_DR23 register  *******************/
N#define  BKP_DR23_D                          ((uint16_t)0xFFFF)     /*!< Backup data */
N
N/*******************  Bit definition for BKP_DR24 register  *******************/
N#define  BKP_DR24_D                          ((uint16_t)0xFFFF)     /*!< Backup data */
N
N/*******************  Bit definition for BKP_DR25 register  *******************/
N#define  BKP_DR25_D                          ((uint16_t)0xFFFF)     /*!< Backup data */
N
N/*******************  Bit definition for BKP_DR26 register  *******************/
N#define  BKP_DR26_D                          ((uint16_t)0xFFFF)     /*!< Backup data */
N
N/*******************  Bit definition for BKP_DR27 register  *******************/
N#define  BKP_DR27_D                          ((uint16_t)0xFFFF)     /*!< Backup data */
N
N/*******************  Bit definition for BKP_DR28 register  *******************/
N#define  BKP_DR28_D                          ((uint16_t)0xFFFF)     /*!< Backup data */
N
N/*******************  Bit definition for BKP_DR29 register  *******************/
N#define  BKP_DR29_D                          ((uint16_t)0xFFFF)     /*!< Backup data */
N
N/*******************  Bit definition for BKP_DR30 register  *******************/
N#define  BKP_DR30_D                          ((uint16_t)0xFFFF)     /*!< Backup data */
N
N/*******************  Bit definition for BKP_DR31 register  *******************/
N#define  BKP_DR31_D                          ((uint16_t)0xFFFF)     /*!< Backup data */
N
N/*******************  Bit definition for BKP_DR32 register  *******************/
N#define  BKP_DR32_D                          ((uint16_t)0xFFFF)     /*!< Backup data */
N
N/*******************  Bit definition for BKP_DR33 register  *******************/
N#define  BKP_DR33_D                          ((uint16_t)0xFFFF)     /*!< Backup data */
N
N/*******************  Bit definition for BKP_DR34 register  *******************/
N#define  BKP_DR34_D                          ((uint16_t)0xFFFF)     /*!< Backup data */
N
N/*******************  Bit definition for BKP_DR35 register  *******************/
N#define  BKP_DR35_D                          ((uint16_t)0xFFFF)     /*!< Backup data */
N
N/*******************  Bit definition for BKP_DR36 register  *******************/
N#define  BKP_DR36_D                          ((uint16_t)0xFFFF)     /*!< Backup data */
N
N/*******************  Bit definition for BKP_DR37 register  *******************/
N#define  BKP_DR37_D                          ((uint16_t)0xFFFF)     /*!< Backup data */
N
N/*******************  Bit definition for BKP_DR38 register  *******************/
N#define  BKP_DR38_D                          ((uint16_t)0xFFFF)     /*!< Backup data */
N
N/*******************  Bit definition for BKP_DR39 register  *******************/
N#define  BKP_DR39_D                          ((uint16_t)0xFFFF)     /*!< Backup data */
N
N/*******************  Bit definition for BKP_DR40 register  *******************/
N#define  BKP_DR40_D                          ((uint16_t)0xFFFF)     /*!< Backup data */
N
N/*******************  Bit definition for BKP_DR41 register  *******************/
N#define  BKP_DR41_D                          ((uint16_t)0xFFFF)     /*!< Backup data */
N
N/*******************  Bit definition for BKP_DR42 register  *******************/
N#define  BKP_DR42_D                          ((uint16_t)0xFFFF)     /*!< Backup data */
N
N/******************  Bit definition for BKP_RTCCR register  *******************/
N#define  BKP_RTCCR_CAL                       ((uint16_t)0x007F)     /*!< Calibration value */
N#define  BKP_RTCCR_CCO                       ((uint16_t)0x0080)     /*!< Calibration Clock Output */
N#define  BKP_RTCCR_ASOE                      ((uint16_t)0x0100)     /*!< Alarm or Second Output Enable */
N#define  BKP_RTCCR_ASOS                      ((uint16_t)0x0200)     /*!< Alarm or Second Output Selection */
N
N/********************  Bit definition for BKP_CR register  ********************/
N#define  BKP_CR_TPE                          ((uint8_t)0x01)        /*!< TAMPER pin enable */
N#define  BKP_CR_TPAL                         ((uint8_t)0x02)        /*!< TAMPER pin active level */
N
N/*******************  Bit definition for BKP_CSR register  ********************/
N#define  BKP_CSR_CTE                         ((uint16_t)0x0001)     /*!< Clear Tamper event */
N#define  BKP_CSR_CTI                         ((uint16_t)0x0002)     /*!< Clear Tamper Interrupt */
N#define  BKP_CSR_TPIE                        ((uint16_t)0x0004)     /*!< TAMPER Pin interrupt enable */
N#define  BKP_CSR_TEF                         ((uint16_t)0x0100)     /*!< Tamper Event Flag */
N#define  BKP_CSR_TIF                         ((uint16_t)0x0200)     /*!< Tamper Interrupt Flag */
N
N/******************************************************************************/
N/*                                                                            */
N/*                         Reset and Clock Control                            */
N/*                                                                            */
N/******************************************************************************/
N
N/********************  Bit definition for RCC_CR register  ********************/
N#define  RCC_CR_HSION                        ((uint32_t)0x00000001)        /*!< Internal High Speed clock enable */
N#define  RCC_CR_HSIRDY                       ((uint32_t)0x00000002)        /*!< Internal High Speed clock ready flag */
N#define  RCC_CR_HSITRIM                      ((uint32_t)0x000000F8)        /*!< Internal High Speed clock trimming */
N#define  RCC_CR_HSICAL                       ((uint32_t)0x0000FF00)        /*!< Internal High Speed clock Calibration */
N#define  RCC_CR_HSEON                        ((uint32_t)0x00010000)        /*!< External High Speed clock enable */
N#define  RCC_CR_HSERDY                       ((uint32_t)0x00020000)        /*!< External High Speed clock ready flag */
N#define  RCC_CR_HSEBYP                       ((uint32_t)0x00040000)        /*!< External High Speed clock Bypass */
N#define  RCC_CR_CSSON                        ((uint32_t)0x00080000)        /*!< Clock Security System enable */
N#define  RCC_CR_PLLON                        ((uint32_t)0x01000000)        /*!< PLL enable */
N#define  RCC_CR_PLLRDY                       ((uint32_t)0x02000000)        /*!< PLL clock ready flag */
N
N#ifdef STM32F10X_CL
S #define  RCC_CR_PLL2ON                       ((uint32_t)0x04000000)        /*!< PLL2 enable */
S #define  RCC_CR_PLL2RDY                      ((uint32_t)0x08000000)        /*!< PLL2 clock ready flag */
S #define  RCC_CR_PLL3ON                       ((uint32_t)0x10000000)        /*!< PLL3 enable */
S #define  RCC_CR_PLL3RDY                      ((uint32_t)0x20000000)        /*!< PLL3 clock ready flag */
N#endif /* STM32F10X_CL */
N
N/*******************  Bit definition for RCC_CFGR register  *******************/
N/*!< SW configuration */
N#define  RCC_CFGR_SW                         ((uint32_t)0x00000003)        /*!< SW[1:0] bits (System clock Switch) */
N#define  RCC_CFGR_SW_0                       ((uint32_t)0x00000001)        /*!< Bit 0 */
N#define  RCC_CFGR_SW_1                       ((uint32_t)0x00000002)        /*!< Bit 1 */
N
N#define  RCC_CFGR_SW_HSI                     ((uint32_t)0x00000000)        /*!< HSI selected as system clock */
N#define  RCC_CFGR_SW_HSE                     ((uint32_t)0x00000001)        /*!< HSE selected as system clock */
N#define  RCC_CFGR_SW_PLL                     ((uint32_t)0x00000002)        /*!< PLL selected as system clock */
N
N/*!< SWS configuration */
N#define  RCC_CFGR_SWS                        ((uint32_t)0x0000000C)        /*!< SWS[1:0] bits (System Clock Switch Status) */
N#define  RCC_CFGR_SWS_0                      ((uint32_t)0x00000004)        /*!< Bit 0 */
N#define  RCC_CFGR_SWS_1                      ((uint32_t)0x00000008)        /*!< Bit 1 */
N
N#define  RCC_CFGR_SWS_HSI                    ((uint32_t)0x00000000)        /*!< HSI oscillator used as system clock */
N#define  RCC_CFGR_SWS_HSE                    ((uint32_t)0x00000004)        /*!< HSE oscillator used as system clock */
N#define  RCC_CFGR_SWS_PLL                    ((uint32_t)0x00000008)        /*!< PLL used as system clock */
N
N/*!< HPRE configuration */
N#define  RCC_CFGR_HPRE                       ((uint32_t)0x000000F0)        /*!< HPRE[3:0] bits (AHB prescaler) */
N#define  RCC_CFGR_HPRE_0                     ((uint32_t)0x00000010)        /*!< Bit 0 */
N#define  RCC_CFGR_HPRE_1                     ((uint32_t)0x00000020)        /*!< Bit 1 */
N#define  RCC_CFGR_HPRE_2                     ((uint32_t)0x00000040)        /*!< Bit 2 */
N#define  RCC_CFGR_HPRE_3                     ((uint32_t)0x00000080)        /*!< Bit 3 */
N
N#define  RCC_CFGR_HPRE_DIV1                  ((uint32_t)0x00000000)        /*!< SYSCLK not divided */
N#define  RCC_CFGR_HPRE_DIV2                  ((uint32_t)0x00000080)        /*!< SYSCLK divided by 2 */
N#define  RCC_CFGR_HPRE_DIV4                  ((uint32_t)0x00000090)        /*!< SYSCLK divided by 4 */
N#define  RCC_CFGR_HPRE_DIV8                  ((uint32_t)0x000000A0)        /*!< SYSCLK divided by 8 */
N#define  RCC_CFGR_HPRE_DIV16                 ((uint32_t)0x000000B0)        /*!< SYSCLK divided by 16 */
N#define  RCC_CFGR_HPRE_DIV64                 ((uint32_t)0x000000C0)        /*!< SYSCLK divided by 64 */
N#define  RCC_CFGR_HPRE_DIV128                ((uint32_t)0x000000D0)        /*!< SYSCLK divided by 128 */
N#define  RCC_CFGR_HPRE_DIV256                ((uint32_t)0x000000E0)        /*!< SYSCLK divided by 256 */
N#define  RCC_CFGR_HPRE_DIV512                ((uint32_t)0x000000F0)        /*!< SYSCLK divided by 512 */
N
N/*!< PPRE1 configuration */
N#define  RCC_CFGR_PPRE1                      ((uint32_t)0x00000700)        /*!< PRE1[2:0] bits (APB1 prescaler) */
N#define  RCC_CFGR_PPRE1_0                    ((uint32_t)0x00000100)        /*!< Bit 0 */
N#define  RCC_CFGR_PPRE1_1                    ((uint32_t)0x00000200)        /*!< Bit 1 */
N#define  RCC_CFGR_PPRE1_2                    ((uint32_t)0x00000400)        /*!< Bit 2 */
N
N#define  RCC_CFGR_PPRE1_DIV1                 ((uint32_t)0x00000000)        /*!< HCLK not divided */
N#define  RCC_CFGR_PPRE1_DIV2                 ((uint32_t)0x00000400)        /*!< HCLK divided by 2 */
N#define  RCC_CFGR_PPRE1_DIV4                 ((uint32_t)0x00000500)        /*!< HCLK divided by 4 */
N#define  RCC_CFGR_PPRE1_DIV8                 ((uint32_t)0x00000600)        /*!< HCLK divided by 8 */
N#define  RCC_CFGR_PPRE1_DIV16                ((uint32_t)0x00000700)        /*!< HCLK divided by 16 */
N
N/*!< PPRE2 configuration */
N#define  RCC_CFGR_PPRE2                      ((uint32_t)0x00003800)        /*!< PRE2[2:0] bits (APB2 prescaler) */
N#define  RCC_CFGR_PPRE2_0                    ((uint32_t)0x00000800)        /*!< Bit 0 */
N#define  RCC_CFGR_PPRE2_1                    ((uint32_t)0x00001000)        /*!< Bit 1 */
N#define  RCC_CFGR_PPRE2_2                    ((uint32_t)0x00002000)        /*!< Bit 2 */
N
N#define  RCC_CFGR_PPRE2_DIV1                 ((uint32_t)0x00000000)        /*!< HCLK not divided */
N#define  RCC_CFGR_PPRE2_DIV2                 ((uint32_t)0x00002000)        /*!< HCLK divided by 2 */
N#define  RCC_CFGR_PPRE2_DIV4                 ((uint32_t)0x00002800)        /*!< HCLK divided by 4 */
N#define  RCC_CFGR_PPRE2_DIV8                 ((uint32_t)0x00003000)        /*!< HCLK divided by 8 */
N#define  RCC_CFGR_PPRE2_DIV16                ((uint32_t)0x00003800)        /*!< HCLK divided by 16 */
N
N/*!< ADCPPRE configuration */
N#define  RCC_CFGR_ADCPRE                     ((uint32_t)0x0000C000)        /*!< ADCPRE[1:0] bits (ADC prescaler) */
N#define  RCC_CFGR_ADCPRE_0                   ((uint32_t)0x00004000)        /*!< Bit 0 */
N#define  RCC_CFGR_ADCPRE_1                   ((uint32_t)0x00008000)        /*!< Bit 1 */
N
N#define  RCC_CFGR_ADCPRE_DIV2                ((uint32_t)0x00000000)        /*!< PCLK2 divided by 2 */
N#define  RCC_CFGR_ADCPRE_DIV4                ((uint32_t)0x00004000)        /*!< PCLK2 divided by 4 */
N#define  RCC_CFGR_ADCPRE_DIV6                ((uint32_t)0x00008000)        /*!< PCLK2 divided by 6 */
N#define  RCC_CFGR_ADCPRE_DIV8                ((uint32_t)0x0000C000)        /*!< PCLK2 divided by 8 */
N
N#define  RCC_CFGR_PLLSRC                     ((uint32_t)0x00010000)        /*!< PLL entry clock source */
N
N#define  RCC_CFGR_PLLXTPRE                   ((uint32_t)0x00020000)        /*!< HSE divider for PLL entry */
N
N/*!< PLLMUL configuration */
N#define  RCC_CFGR_PLLMULL                    ((uint32_t)0x003C0000)        /*!< PLLMUL[3:0] bits (PLL multiplication factor) */
N#define  RCC_CFGR_PLLMULL_0                  ((uint32_t)0x00040000)        /*!< Bit 0 */
N#define  RCC_CFGR_PLLMULL_1                  ((uint32_t)0x00080000)        /*!< Bit 1 */
N#define  RCC_CFGR_PLLMULL_2                  ((uint32_t)0x00100000)        /*!< Bit 2 */
N#define  RCC_CFGR_PLLMULL_3                  ((uint32_t)0x00200000)        /*!< Bit 3 */
N
N#ifdef STM32F10X_CL
S #define  RCC_CFGR_PLLSRC_HSI_Div2           ((uint32_t)0x00000000)        /*!< HSI clock divided by 2 selected as PLL entry clock source */
S #define  RCC_CFGR_PLLSRC_PREDIV1            ((uint32_t)0x00010000)        /*!< PREDIV1 clock selected as PLL entry clock source */
S
S #define  RCC_CFGR_PLLXTPRE_PREDIV1          ((uint32_t)0x00000000)        /*!< PREDIV1 clock not divided for PLL entry */
S #define  RCC_CFGR_PLLXTPRE_PREDIV1_Div2     ((uint32_t)0x00020000)        /*!< PREDIV1 clock divided by 2 for PLL entry */
S
S #define  RCC_CFGR_PLLMULL4                  ((uint32_t)0x00080000)        /*!< PLL input clock * 4 */
S #define  RCC_CFGR_PLLMULL5                  ((uint32_t)0x000C0000)        /*!< PLL input clock * 5 */
S #define  RCC_CFGR_PLLMULL6                  ((uint32_t)0x00100000)        /*!< PLL input clock * 6 */
S #define  RCC_CFGR_PLLMULL7                  ((uint32_t)0x00140000)        /*!< PLL input clock * 7 */
S #define  RCC_CFGR_PLLMULL8                  ((uint32_t)0x00180000)        /*!< PLL input clock * 8 */
S #define  RCC_CFGR_PLLMULL9                  ((uint32_t)0x001C0000)        /*!< PLL input clock * 9 */
S #define  RCC_CFGR_PLLMULL6_5                ((uint32_t)0x00340000)        /*!< PLL input clock * 6.5 */
S 
S #define  RCC_CFGR_OTGFSPRE                  ((uint32_t)0x00400000)        /*!< USB OTG FS prescaler */
S 
S/*!< MCO configuration */
S #define  RCC_CFGR_MCO                       ((uint32_t)0x0F000000)        /*!< MCO[3:0] bits (Microcontroller Clock Output) */
S #define  RCC_CFGR_MCO_0                     ((uint32_t)0x01000000)        /*!< Bit 0 */
S #define  RCC_CFGR_MCO_1                     ((uint32_t)0x02000000)        /*!< Bit 1 */
S #define  RCC_CFGR_MCO_2                     ((uint32_t)0x04000000)        /*!< Bit 2 */
S #define  RCC_CFGR_MCO_3                     ((uint32_t)0x08000000)        /*!< Bit 3 */
S
S #define  RCC_CFGR_MCO_NOCLOCK               ((uint32_t)0x00000000)        /*!< No clock */
S #define  RCC_CFGR_MCO_SYSCLK                ((uint32_t)0x04000000)        /*!< System clock selected as MCO source */
S #define  RCC_CFGR_MCO_HSI                   ((uint32_t)0x05000000)        /*!< HSI clock selected as MCO source */
S #define  RCC_CFGR_MCO_HSE                   ((uint32_t)0x06000000)        /*!< HSE clock selected as MCO source */
S #define  RCC_CFGR_MCO_PLLCLK_Div2           ((uint32_t)0x07000000)        /*!< PLL clock divided by 2 selected as MCO source */
S #define  RCC_CFGR_MCO_PLL2CLK               ((uint32_t)0x08000000)        /*!< PLL2 clock selected as MCO source*/
S #define  RCC_CFGR_MCO_PLL3CLK_Div2          ((uint32_t)0x09000000)        /*!< PLL3 clock divided by 2 selected as MCO source*/
S #define  RCC_CFGR_MCO_Ext_HSE               ((uint32_t)0x0A000000)        /*!< XT1 external 3-25 MHz oscillator clock selected as MCO source */
S #define  RCC_CFGR_MCO_PLL3CLK               ((uint32_t)0x0B000000)        /*!< PLL3 clock selected as MCO source */
S#elif defined (STM32F10X_LD_VL) || defined (STM32F10X_MD_VL) || defined (STM32F10X_HD_VL)
X#elif 0L || 0L || 0L
S #define  RCC_CFGR_PLLSRC_HSI_Div2           ((uint32_t)0x00000000)        /*!< HSI clock divided by 2 selected as PLL entry clock source */
S #define  RCC_CFGR_PLLSRC_PREDIV1            ((uint32_t)0x00010000)        /*!< PREDIV1 clock selected as PLL entry clock source */
S
S #define  RCC_CFGR_PLLXTPRE_PREDIV1          ((uint32_t)0x00000000)        /*!< PREDIV1 clock not divided for PLL entry */
S #define  RCC_CFGR_PLLXTPRE_PREDIV1_Div2     ((uint32_t)0x00020000)        /*!< PREDIV1 clock divided by 2 for PLL entry */
S
S #define  RCC_CFGR_PLLMULL2                  ((uint32_t)0x00000000)        /*!< PLL input clock*2 */
S #define  RCC_CFGR_PLLMULL3                  ((uint32_t)0x00040000)        /*!< PLL input clock*3 */
S #define  RCC_CFGR_PLLMULL4                  ((uint32_t)0x00080000)        /*!< PLL input clock*4 */
S #define  RCC_CFGR_PLLMULL5                  ((uint32_t)0x000C0000)        /*!< PLL input clock*5 */
S #define  RCC_CFGR_PLLMULL6                  ((uint32_t)0x00100000)        /*!< PLL input clock*6 */
S #define  RCC_CFGR_PLLMULL7                  ((uint32_t)0x00140000)        /*!< PLL input clock*7 */
S #define  RCC_CFGR_PLLMULL8                  ((uint32_t)0x00180000)        /*!< PLL input clock*8 */
S #define  RCC_CFGR_PLLMULL9                  ((uint32_t)0x001C0000)        /*!< PLL input clock*9 */
S #define  RCC_CFGR_PLLMULL10                 ((uint32_t)0x00200000)        /*!< PLL input clock10 */
S #define  RCC_CFGR_PLLMULL11                 ((uint32_t)0x00240000)        /*!< PLL input clock*11 */
S #define  RCC_CFGR_PLLMULL12                 ((uint32_t)0x00280000)        /*!< PLL input clock*12 */
S #define  RCC_CFGR_PLLMULL13                 ((uint32_t)0x002C0000)        /*!< PLL input clock*13 */
S #define  RCC_CFGR_PLLMULL14                 ((uint32_t)0x00300000)        /*!< PLL input clock*14 */
S #define  RCC_CFGR_PLLMULL15                 ((uint32_t)0x00340000)        /*!< PLL input clock*15 */
S #define  RCC_CFGR_PLLMULL16                 ((uint32_t)0x00380000)        /*!< PLL input clock*16 */
S
S/*!< MCO configuration */
S #define  RCC_CFGR_MCO                       ((uint32_t)0x07000000)        /*!< MCO[2:0] bits (Microcontroller Clock Output) */
S #define  RCC_CFGR_MCO_0                     ((uint32_t)0x01000000)        /*!< Bit 0 */
S #define  RCC_CFGR_MCO_1                     ((uint32_t)0x02000000)        /*!< Bit 1 */
S #define  RCC_CFGR_MCO_2                     ((uint32_t)0x04000000)        /*!< Bit 2 */
S
S #define  RCC_CFGR_MCO_NOCLOCK               ((uint32_t)0x00000000)        /*!< No clock */
S #define  RCC_CFGR_MCO_SYSCLK                ((uint32_t)0x04000000)        /*!< System clock selected as MCO source */
S #define  RCC_CFGR_MCO_HSI                   ((uint32_t)0x05000000)        /*!< HSI clock selected as MCO source */
S #define  RCC_CFGR_MCO_HSE                   ((uint32_t)0x06000000)        /*!< HSE clock selected as MCO source  */
S #define  RCC_CFGR_MCO_PLL                   ((uint32_t)0x07000000)        /*!< PLL clock divided by 2 selected as MCO source */
N#else
N #define  RCC_CFGR_PLLSRC_HSI_Div2           ((uint32_t)0x00000000)        /*!< HSI clock divided by 2 selected as PLL entry clock source */
N #define  RCC_CFGR_PLLSRC_HSE                ((uint32_t)0x00010000)        /*!< HSE clock selected as PLL entry clock source */
N
N #define  RCC_CFGR_PLLXTPRE_HSE              ((uint32_t)0x00000000)        /*!< HSE clock not divided for PLL entry */
N #define  RCC_CFGR_PLLXTPRE_HSE_Div2         ((uint32_t)0x00020000)        /*!< HSE clock divided by 2 for PLL entry */
N
N #define  RCC_CFGR_PLLMULL2                  ((uint32_t)0x00000000)        /*!< PLL input clock*2 */
N #define  RCC_CFGR_PLLMULL3                  ((uint32_t)0x00040000)        /*!< PLL input clock*3 */
N #define  RCC_CFGR_PLLMULL4                  ((uint32_t)0x00080000)        /*!< PLL input clock*4 */
N #define  RCC_CFGR_PLLMULL5                  ((uint32_t)0x000C0000)        /*!< PLL input clock*5 */
N #define  RCC_CFGR_PLLMULL6                  ((uint32_t)0x00100000)        /*!< PLL input clock*6 */
N #define  RCC_CFGR_PLLMULL7                  ((uint32_t)0x00140000)        /*!< PLL input clock*7 */
N #define  RCC_CFGR_PLLMULL8                  ((uint32_t)0x00180000)        /*!< PLL input clock*8 */
N #define  RCC_CFGR_PLLMULL9                  ((uint32_t)0x001C0000)        /*!< PLL input clock*9 */
N #define  RCC_CFGR_PLLMULL10                 ((uint32_t)0x00200000)        /*!< PLL input clock10 */
N #define  RCC_CFGR_PLLMULL11                 ((uint32_t)0x00240000)        /*!< PLL input clock*11 */
N #define  RCC_CFGR_PLLMULL12                 ((uint32_t)0x00280000)        /*!< PLL input clock*12 */
N #define  RCC_CFGR_PLLMULL13                 ((uint32_t)0x002C0000)        /*!< PLL input clock*13 */
N #define  RCC_CFGR_PLLMULL14                 ((uint32_t)0x00300000)        /*!< PLL input clock*14 */
N #define  RCC_CFGR_PLLMULL15                 ((uint32_t)0x00340000)        /*!< PLL input clock*15 */
N #define  RCC_CFGR_PLLMULL16                 ((uint32_t)0x00380000)        /*!< PLL input clock*16 */
N #define  RCC_CFGR_USBPRE                    ((uint32_t)0x00400000)        /*!< USB Device prescaler */
N
N/*!< MCO configuration */
N #define  RCC_CFGR_MCO                       ((uint32_t)0x07000000)        /*!< MCO[2:0] bits (Microcontroller Clock Output) */
N #define  RCC_CFGR_MCO_0                     ((uint32_t)0x01000000)        /*!< Bit 0 */
N #define  RCC_CFGR_MCO_1                     ((uint32_t)0x02000000)        /*!< Bit 1 */
N #define  RCC_CFGR_MCO_2                     ((uint32_t)0x04000000)        /*!< Bit 2 */
N
N #define  RCC_CFGR_MCO_NOCLOCK               ((uint32_t)0x00000000)        /*!< No clock */
N #define  RCC_CFGR_MCO_SYSCLK                ((uint32_t)0x04000000)        /*!< System clock selected as MCO source */
N #define  RCC_CFGR_MCO_HSI                   ((uint32_t)0x05000000)        /*!< HSI clock selected as MCO source */
N #define  RCC_CFGR_MCO_HSE                   ((uint32_t)0x06000000)        /*!< HSE clock selected as MCO source  */
N #define  RCC_CFGR_MCO_PLL                   ((uint32_t)0x07000000)        /*!< PLL clock divided by 2 selected as MCO source */
N#endif /* STM32F10X_CL */
N
N/*!<******************  Bit definition for RCC_CIR register  ********************/
N#define  RCC_CIR_LSIRDYF                     ((uint32_t)0x00000001)        /*!< LSI Ready Interrupt flag */
N#define  RCC_CIR_LSERDYF                     ((uint32_t)0x00000002)        /*!< LSE Ready Interrupt flag */
N#define  RCC_CIR_HSIRDYF                     ((uint32_t)0x00000004)        /*!< HSI Ready Interrupt flag */
N#define  RCC_CIR_HSERDYF                     ((uint32_t)0x00000008)        /*!< HSE Ready Interrupt flag */
N#define  RCC_CIR_PLLRDYF                     ((uint32_t)0x00000010)        /*!< PLL Ready Interrupt flag */
N#define  RCC_CIR_CSSF                        ((uint32_t)0x00000080)        /*!< Clock Security System Interrupt flag */
N#define  RCC_CIR_LSIRDYIE                    ((uint32_t)0x00000100)        /*!< LSI Ready Interrupt Enable */
N#define  RCC_CIR_LSERDYIE                    ((uint32_t)0x00000200)        /*!< LSE Ready Interrupt Enable */
N#define  RCC_CIR_HSIRDYIE                    ((uint32_t)0x00000400)        /*!< HSI Ready Interrupt Enable */
N#define  RCC_CIR_HSERDYIE                    ((uint32_t)0x00000800)        /*!< HSE Ready Interrupt Enable */
N#define  RCC_CIR_PLLRDYIE                    ((uint32_t)0x00001000)        /*!< PLL Ready Interrupt Enable */
N#define  RCC_CIR_LSIRDYC                     ((uint32_t)0x00010000)        /*!< LSI Ready Interrupt Clear */
N#define  RCC_CIR_LSERDYC                     ((uint32_t)0x00020000)        /*!< LSE Ready Interrupt Clear */
N#define  RCC_CIR_HSIRDYC                     ((uint32_t)0x00040000)        /*!< HSI Ready Interrupt Clear */
N#define  RCC_CIR_HSERDYC                     ((uint32_t)0x00080000)        /*!< HSE Ready Interrupt Clear */
N#define  RCC_CIR_PLLRDYC                     ((uint32_t)0x00100000)        /*!< PLL Ready Interrupt Clear */
N#define  RCC_CIR_CSSC                        ((uint32_t)0x00800000)        /*!< Clock Security System Interrupt Clear */
N
N#ifdef STM32F10X_CL
S #define  RCC_CIR_PLL2RDYF                    ((uint32_t)0x00000020)        /*!< PLL2 Ready Interrupt flag */
S #define  RCC_CIR_PLL3RDYF                    ((uint32_t)0x00000040)        /*!< PLL3 Ready Interrupt flag */
S #define  RCC_CIR_PLL2RDYIE                   ((uint32_t)0x00002000)        /*!< PLL2 Ready Interrupt Enable */
S #define  RCC_CIR_PLL3RDYIE                   ((uint32_t)0x00004000)        /*!< PLL3 Ready Interrupt Enable */
S #define  RCC_CIR_PLL2RDYC                    ((uint32_t)0x00200000)        /*!< PLL2 Ready Interrupt Clear */
S #define  RCC_CIR_PLL3RDYC                    ((uint32_t)0x00400000)        /*!< PLL3 Ready Interrupt Clear */
N#endif /* STM32F10X_CL */
N
N/*****************  Bit definition for RCC_APB2RSTR register  *****************/
N#define  RCC_APB2RSTR_AFIORST                ((uint32_t)0x00000001)        /*!< Alternate Function I/O reset */
N#define  RCC_APB2RSTR_IOPARST                ((uint32_t)0x00000004)        /*!< I/O port A reset */
N#define  RCC_APB2RSTR_IOPBRST                ((uint32_t)0x00000008)        /*!< I/O port B reset */
N#define  RCC_APB2RSTR_IOPCRST                ((uint32_t)0x00000010)        /*!< I/O port C reset */
N#define  RCC_APB2RSTR_IOPDRST                ((uint32_t)0x00000020)        /*!< I/O port D reset */
N#define  RCC_APB2RSTR_ADC1RST                ((uint32_t)0x00000200)        /*!< ADC 1 interface reset */
N
N#if !defined (STM32F10X_LD_VL) && !defined (STM32F10X_MD_VL) && !defined (STM32F10X_HD_VL)
X#if !0L && !0L && !0L
N#define  RCC_APB2RSTR_ADC2RST                ((uint32_t)0x00000400)        /*!< ADC 2 interface reset */
N#endif
N
N#define  RCC_APB2RSTR_TIM1RST                ((uint32_t)0x00000800)        /*!< TIM1 Timer reset */
N#define  RCC_APB2RSTR_SPI1RST                ((uint32_t)0x00001000)        /*!< SPI 1 reset */
N#define  RCC_APB2RSTR_USART1RST              ((uint32_t)0x00004000)        /*!< USART1 reset */
N
N#if defined (STM32F10X_LD_VL) || defined (STM32F10X_MD_VL) || defined (STM32F10X_HD_VL)
X#if 0L || 0L || 0L
S#define  RCC_APB2RSTR_TIM15RST               ((uint32_t)0x00010000)        /*!< TIM15 Timer reset */
S#define  RCC_APB2RSTR_TIM16RST               ((uint32_t)0x00020000)        /*!< TIM16 Timer reset */
S#define  RCC_APB2RSTR_TIM17RST               ((uint32_t)0x00040000)        /*!< TIM17 Timer reset */
N#endif
N
N#if !defined (STM32F10X_LD) && !defined (STM32F10X_LD_VL)
X#if !0L && !0L
N #define  RCC_APB2RSTR_IOPERST               ((uint32_t)0x00000040)        /*!< I/O port E reset */
N#endif /* STM32F10X_LD && STM32F10X_LD_VL */
N
N#if defined (STM32F10X_HD) || defined (STM32F10X_XL)
X#if 1L || 0L
N #define  RCC_APB2RSTR_IOPFRST               ((uint32_t)0x00000080)        /*!< I/O port F reset */
N #define  RCC_APB2RSTR_IOPGRST               ((uint32_t)0x00000100)        /*!< I/O port G reset */
N #define  RCC_APB2RSTR_TIM8RST               ((uint32_t)0x00002000)        /*!< TIM8 Timer reset */
N #define  RCC_APB2RSTR_ADC3RST               ((uint32_t)0x00008000)        /*!< ADC3 interface reset */
N#endif
N
N#if defined (STM32F10X_HD_VL)
X#if 0L
S #define  RCC_APB2RSTR_IOPFRST               ((uint32_t)0x00000080)        /*!< I/O port F reset */
S #define  RCC_APB2RSTR_IOPGRST               ((uint32_t)0x00000100)        /*!< I/O port G reset */
N#endif
N
N#ifdef STM32F10X_XL
S #define  RCC_APB2RSTR_TIM9RST               ((uint32_t)0x00080000)         /*!< TIM9 Timer reset */
S #define  RCC_APB2RSTR_TIM10RST              ((uint32_t)0x00100000)         /*!< TIM10 Timer reset */
S #define  RCC_APB2RSTR_TIM11RST              ((uint32_t)0x00200000)         /*!< TIM11 Timer reset */
N#endif /* STM32F10X_XL */
N
N/*****************  Bit definition for RCC_APB1RSTR register  *****************/
N#define  RCC_APB1RSTR_TIM2RST                ((uint32_t)0x00000001)        /*!< Timer 2 reset */
N#define  RCC_APB1RSTR_TIM3RST                ((uint32_t)0x00000002)        /*!< Timer 3 reset */
N#define  RCC_APB1RSTR_WWDGRST                ((uint32_t)0x00000800)        /*!< Window Watchdog reset */
N#define  RCC_APB1RSTR_USART2RST              ((uint32_t)0x00020000)        /*!< USART 2 reset */
N#define  RCC_APB1RSTR_I2C1RST                ((uint32_t)0x00200000)        /*!< I2C 1 reset */
N
N#if !defined (STM32F10X_LD_VL) && !defined (STM32F10X_MD_VL) && !defined (STM32F10X_HD_VL)
X#if !0L && !0L && !0L
N#define  RCC_APB1RSTR_CAN1RST                ((uint32_t)0x02000000)        /*!< CAN1 reset */
N#endif
N
N#define  RCC_APB1RSTR_BKPRST                 ((uint32_t)0x08000000)        /*!< Backup interface reset */
N#define  RCC_APB1RSTR_PWRRST                 ((uint32_t)0x10000000)        /*!< Power interface reset */
N
N#if !defined (STM32F10X_LD) && !defined (STM32F10X_LD_VL)
X#if !0L && !0L
N #define  RCC_APB1RSTR_TIM4RST               ((uint32_t)0x00000004)        /*!< Timer 4 reset */
N #define  RCC_APB1RSTR_SPI2RST               ((uint32_t)0x00004000)        /*!< SPI 2 reset */
N #define  RCC_APB1RSTR_USART3RST             ((uint32_t)0x00040000)        /*!< USART 3 reset */
N #define  RCC_APB1RSTR_I2C2RST               ((uint32_t)0x00400000)        /*!< I2C 2 reset */
N#endif /* STM32F10X_LD && STM32F10X_LD_VL */
N
N#if defined (STM32F10X_HD) || defined (STM32F10X_MD) || defined (STM32F10X_LD) || defined  (STM32F10X_XL)
X#if 1L || 0L || 0L || 0L
N #define  RCC_APB1RSTR_USBRST                ((uint32_t)0x00800000)        /*!< USB Device reset */
N#endif
N
N#if defined (STM32F10X_HD) || defined  (STM32F10X_CL) || defined  (STM32F10X_XL)
X#if 1L || 0L || 0L
N #define  RCC_APB1RSTR_TIM5RST                ((uint32_t)0x00000008)        /*!< Timer 5 reset */
N #define  RCC_APB1RSTR_TIM6RST                ((uint32_t)0x00000010)        /*!< Timer 6 reset */
N #define  RCC_APB1RSTR_TIM7RST                ((uint32_t)0x00000020)        /*!< Timer 7 reset */
N #define  RCC_APB1RSTR_SPI3RST                ((uint32_t)0x00008000)        /*!< SPI 3 reset */
N #define  RCC_APB1RSTR_UART4RST               ((uint32_t)0x00080000)        /*!< UART 4 reset */
N #define  RCC_APB1RSTR_UART5RST               ((uint32_t)0x00100000)        /*!< UART 5 reset */
N #define  RCC_APB1RSTR_DACRST                 ((uint32_t)0x20000000)        /*!< DAC interface reset */
N#endif
N
N#if defined (STM32F10X_LD_VL) || defined  (STM32F10X_MD_VL) || defined  (STM32F10X_HD_VL)
X#if 0L || 0L || 0L
S #define  RCC_APB1RSTR_TIM6RST                ((uint32_t)0x00000010)        /*!< Timer 6 reset */
S #define  RCC_APB1RSTR_TIM7RST                ((uint32_t)0x00000020)        /*!< Timer 7 reset */
S #define  RCC_APB1RSTR_DACRST                 ((uint32_t)0x20000000)        /*!< DAC interface reset */
S #define  RCC_APB1RSTR_CECRST                 ((uint32_t)0x40000000)        /*!< CEC interface reset */ 
N#endif
N
N#if defined  (STM32F10X_HD_VL)
X#if 0L
S #define  RCC_APB1RSTR_TIM5RST                ((uint32_t)0x00000008)        /*!< Timer 5 reset */
S #define  RCC_APB1RSTR_TIM12RST               ((uint32_t)0x00000040)        /*!< TIM12 Timer reset */
S #define  RCC_APB1RSTR_TIM13RST               ((uint32_t)0x00000080)        /*!< TIM13 Timer reset */
S #define  RCC_APB1RSTR_TIM14RST               ((uint32_t)0x00000100)        /*!< TIM14 Timer reset */
S #define  RCC_APB1RSTR_SPI3RST                ((uint32_t)0x00008000)        /*!< SPI 3 reset */ 
S #define  RCC_APB1RSTR_UART4RST               ((uint32_t)0x00080000)        /*!< UART 4 reset */
S #define  RCC_APB1RSTR_UART5RST               ((uint32_t)0x00100000)        /*!< UART 5 reset */ 
N#endif
N
N#ifdef STM32F10X_CL
S #define  RCC_APB1RSTR_CAN2RST                ((uint32_t)0x04000000)        /*!< CAN2 reset */
N#endif /* STM32F10X_CL */
N
N#ifdef STM32F10X_XL
S #define  RCC_APB1RSTR_TIM12RST               ((uint32_t)0x00000040)         /*!< TIM12 Timer reset */
S #define  RCC_APB1RSTR_TIM13RST               ((uint32_t)0x00000080)         /*!< TIM13 Timer reset */
S #define  RCC_APB1RSTR_TIM14RST               ((uint32_t)0x00000100)         /*!< TIM14 Timer reset */
N#endif /* STM32F10X_XL */
N
N/******************  Bit definition for RCC_AHBENR register  ******************/
N#define  RCC_AHBENR_DMA1EN                   ((uint16_t)0x0001)            /*!< DMA1 clock enable */
N#define  RCC_AHBENR_SRAMEN                   ((uint16_t)0x0004)            /*!< SRAM interface clock enable */
N#define  RCC_AHBENR_FLITFEN                  ((uint16_t)0x0010)            /*!< FLITF clock enable */
N#define  RCC_AHBENR_CRCEN                    ((uint16_t)0x0040)            /*!< CRC clock enable */
N
N#if defined (STM32F10X_HD) || defined  (STM32F10X_CL) || defined  (STM32F10X_HD_VL)
X#if 1L || 0L || 0L
N #define  RCC_AHBENR_DMA2EN                  ((uint16_t)0x0002)            /*!< DMA2 clock enable */
N#endif
N
N#if defined (STM32F10X_HD) || defined (STM32F10X_XL)
X#if 1L || 0L
N #define  RCC_AHBENR_FSMCEN                  ((uint16_t)0x0100)            /*!< FSMC clock enable */
N #define  RCC_AHBENR_SDIOEN                  ((uint16_t)0x0400)            /*!< SDIO clock enable */
N#endif
N
N#if defined (STM32F10X_HD_VL)
X#if 0L
S #define  RCC_AHBENR_FSMCEN                  ((uint16_t)0x0100)            /*!< FSMC clock enable */
N#endif
N
N#ifdef STM32F10X_CL
S #define  RCC_AHBENR_OTGFSEN                 ((uint32_t)0x00001000)         /*!< USB OTG FS clock enable */
S #define  RCC_AHBENR_ETHMACEN                ((uint32_t)0x00004000)         /*!< ETHERNET MAC clock enable */
S #define  RCC_AHBENR_ETHMACTXEN              ((uint32_t)0x00008000)         /*!< ETHERNET MAC Tx clock enable */
S #define  RCC_AHBENR_ETHMACRXEN              ((uint32_t)0x00010000)         /*!< ETHERNET MAC Rx clock enable */
N#endif /* STM32F10X_CL */
N
N/******************  Bit definition for RCC_APB2ENR register  *****************/
N#define  RCC_APB2ENR_AFIOEN                  ((uint32_t)0x00000001)         /*!< Alternate Function I/O clock enable */
N#define  RCC_APB2ENR_IOPAEN                  ((uint32_t)0x00000004)         /*!< I/O port A clock enable */
N#define  RCC_APB2ENR_IOPBEN                  ((uint32_t)0x00000008)         /*!< I/O port B clock enable */
N#define  RCC_APB2ENR_IOPCEN                  ((uint32_t)0x00000010)         /*!< I/O port C clock enable */
N#define  RCC_APB2ENR_IOPDEN                  ((uint32_t)0x00000020)         /*!< I/O port D clock enable */
N#define  RCC_APB2ENR_ADC1EN                  ((uint32_t)0x00000200)         /*!< ADC 1 interface clock enable */
N
N#if !defined (STM32F10X_LD_VL) && !defined (STM32F10X_MD_VL) && !defined (STM32F10X_HD_VL)
X#if !0L && !0L && !0L
N#define  RCC_APB2ENR_ADC2EN                  ((uint32_t)0x00000400)         /*!< ADC 2 interface clock enable */
N#endif
N
N#define  RCC_APB2ENR_TIM1EN                  ((uint32_t)0x00000800)         /*!< TIM1 Timer clock enable */
N#define  RCC_APB2ENR_SPI1EN                  ((uint32_t)0x00001000)         /*!< SPI 1 clock enable */
N#define  RCC_APB2ENR_USART1EN                ((uint32_t)0x00004000)         /*!< USART1 clock enable */
N
N#if defined (STM32F10X_LD_VL) || defined (STM32F10X_MD_VL) || defined (STM32F10X_HD_VL)
X#if 0L || 0L || 0L
S#define  RCC_APB2ENR_TIM15EN                 ((uint32_t)0x00010000)         /*!< TIM15 Timer clock enable */
S#define  RCC_APB2ENR_TIM16EN                 ((uint32_t)0x00020000)         /*!< TIM16 Timer clock enable */
S#define  RCC_APB2ENR_TIM17EN                 ((uint32_t)0x00040000)         /*!< TIM17 Timer clock enable */
N#endif
N
N#if !defined (STM32F10X_LD) && !defined (STM32F10X_LD_VL)
X#if !0L && !0L
N #define  RCC_APB2ENR_IOPEEN                 ((uint32_t)0x00000040)         /*!< I/O port E clock enable */
N#endif /* STM32F10X_LD && STM32F10X_LD_VL */
N
N#if defined (STM32F10X_HD) || defined (STM32F10X_XL)
X#if 1L || 0L
N #define  RCC_APB2ENR_IOPFEN                 ((uint32_t)0x00000080)         /*!< I/O port F clock enable */
N #define  RCC_APB2ENR_IOPGEN                 ((uint32_t)0x00000100)         /*!< I/O port G clock enable */
N #define  RCC_APB2ENR_TIM8EN                 ((uint32_t)0x00002000)         /*!< TIM8 Timer clock enable */
N #define  RCC_APB2ENR_ADC3EN                 ((uint32_t)0x00008000)         /*!< DMA1 clock enable */
N#endif
N
N#if defined (STM32F10X_HD_VL)
X#if 0L
S #define  RCC_APB2ENR_IOPFEN                 ((uint32_t)0x00000080)         /*!< I/O port F clock enable */
S #define  RCC_APB2ENR_IOPGEN                 ((uint32_t)0x00000100)         /*!< I/O port G clock enable */
N#endif
N
N#ifdef STM32F10X_XL
S #define  RCC_APB2ENR_TIM9EN                 ((uint32_t)0x00080000)         /*!< TIM9 Timer clock enable  */
S #define  RCC_APB2ENR_TIM10EN                ((uint32_t)0x00100000)         /*!< TIM10 Timer clock enable  */
S #define  RCC_APB2ENR_TIM11EN                ((uint32_t)0x00200000)         /*!< TIM11 Timer clock enable */
N#endif
N
N/*****************  Bit definition for RCC_APB1ENR register  ******************/
N#define  RCC_APB1ENR_TIM2EN                  ((uint32_t)0x00000001)        /*!< Timer 2 clock enabled*/
N#define  RCC_APB1ENR_TIM3EN                  ((uint32_t)0x00000002)        /*!< Timer 3 clock enable */
N#define  RCC_APB1ENR_WWDGEN                  ((uint32_t)0x00000800)        /*!< Window Watchdog clock enable */
N#define  RCC_APB1ENR_USART2EN                ((uint32_t)0x00020000)        /*!< USART 2 clock enable */
N#define  RCC_APB1ENR_I2C1EN                  ((uint32_t)0x00200000)        /*!< I2C 1 clock enable */
N
N#if !defined (STM32F10X_LD_VL) && !defined (STM32F10X_MD_VL) && !defined (STM32F10X_HD_VL)
X#if !0L && !0L && !0L
N#define  RCC_APB1ENR_CAN1EN                  ((uint32_t)0x02000000)        /*!< CAN1 clock enable */
N#endif
N
N#define  RCC_APB1ENR_BKPEN                   ((uint32_t)0x08000000)        /*!< Backup interface clock enable */
N#define  RCC_APB1ENR_PWREN                   ((uint32_t)0x10000000)        /*!< Power interface clock enable */
N
N#if !defined (STM32F10X_LD) && !defined (STM32F10X_LD_VL)
X#if !0L && !0L
N #define  RCC_APB1ENR_TIM4EN                 ((uint32_t)0x00000004)        /*!< Timer 4 clock enable */
N #define  RCC_APB1ENR_SPI2EN                 ((uint32_t)0x00004000)        /*!< SPI 2 clock enable */
N #define  RCC_APB1ENR_USART3EN               ((uint32_t)0x00040000)        /*!< USART 3 clock enable */
N #define  RCC_APB1ENR_I2C2EN                 ((uint32_t)0x00400000)        /*!< I2C 2 clock enable */
N#endif /* STM32F10X_LD && STM32F10X_LD_VL */
N
N#if defined (STM32F10X_HD) || defined (STM32F10X_MD) || defined  (STM32F10X_LD)
X#if 1L || 0L || 0L
N #define  RCC_APB1ENR_USBEN                  ((uint32_t)0x00800000)        /*!< USB Device clock enable */
N#endif
N
N#if defined (STM32F10X_HD) || defined  (STM32F10X_CL)
X#if 1L || 0L
N #define  RCC_APB1ENR_TIM5EN                 ((uint32_t)0x00000008)        /*!< Timer 5 clock enable */
N #define  RCC_APB1ENR_TIM6EN                 ((uint32_t)0x00000010)        /*!< Timer 6 clock enable */
N #define  RCC_APB1ENR_TIM7EN                 ((uint32_t)0x00000020)        /*!< Timer 7 clock enable */
N #define  RCC_APB1ENR_SPI3EN                 ((uint32_t)0x00008000)        /*!< SPI 3 clock enable */
N #define  RCC_APB1ENR_UART4EN                ((uint32_t)0x00080000)        /*!< UART 4 clock enable */
N #define  RCC_APB1ENR_UART5EN                ((uint32_t)0x00100000)        /*!< UART 5 clock enable */
N #define  RCC_APB1ENR_DACEN                  ((uint32_t)0x20000000)        /*!< DAC interface clock enable */
N#endif
N
N#if defined (STM32F10X_LD_VL) || defined  (STM32F10X_MD_VL) || defined  (STM32F10X_HD_VL)
X#if 0L || 0L || 0L
S #define  RCC_APB1ENR_TIM6EN                 ((uint32_t)0x00000010)        /*!< Timer 6 clock enable */
S #define  RCC_APB1ENR_TIM7EN                 ((uint32_t)0x00000020)        /*!< Timer 7 clock enable */
S #define  RCC_APB1ENR_DACEN                  ((uint32_t)0x20000000)        /*!< DAC interface clock enable */
S #define  RCC_APB1ENR_CECEN                  ((uint32_t)0x40000000)        /*!< CEC interface clock enable */ 
N#endif
N
N#ifdef STM32F10X_HD_VL
S #define  RCC_APB1ENR_TIM5EN                 ((uint32_t)0x00000008)        /*!< Timer 5 clock enable */
S #define  RCC_APB1ENR_TIM12EN                ((uint32_t)0x00000040)         /*!< TIM12 Timer clock enable  */
S #define  RCC_APB1ENR_TIM13EN                ((uint32_t)0x00000080)         /*!< TIM13 Timer clock enable  */
S #define  RCC_APB1ENR_TIM14EN                ((uint32_t)0x00000100)         /*!< TIM14 Timer clock enable */
S #define  RCC_APB1ENR_SPI3EN                 ((uint32_t)0x00008000)        /*!< SPI 3 clock enable */
S #define  RCC_APB1ENR_UART4EN                ((uint32_t)0x00080000)        /*!< UART 4 clock enable */
S #define  RCC_APB1ENR_UART5EN                ((uint32_t)0x00100000)        /*!< UART 5 clock enable */ 
N#endif /* STM32F10X_HD_VL */
N
N#ifdef STM32F10X_CL
S #define  RCC_APB1ENR_CAN2EN                  ((uint32_t)0x04000000)        /*!< CAN2 clock enable */
N#endif /* STM32F10X_CL */
N
N#ifdef STM32F10X_XL
S #define  RCC_APB1ENR_TIM12EN                ((uint32_t)0x00000040)         /*!< TIM12 Timer clock enable  */
S #define  RCC_APB1ENR_TIM13EN                ((uint32_t)0x00000080)         /*!< TIM13 Timer clock enable  */
S #define  RCC_APB1ENR_TIM14EN                ((uint32_t)0x00000100)         /*!< TIM14 Timer clock enable */
N#endif /* STM32F10X_XL */
N
N/*******************  Bit definition for RCC_BDCR register  *******************/
N#define  RCC_BDCR_LSEON                      ((uint32_t)0x00000001)        /*!< External Low Speed oscillator enable */
N#define  RCC_BDCR_LSERDY                     ((uint32_t)0x00000002)        /*!< External Low Speed oscillator Ready */
N#define  RCC_BDCR_LSEBYP                     ((uint32_t)0x00000004)        /*!< External Low Speed oscillator Bypass */
N
N#define  RCC_BDCR_RTCSEL                     ((uint32_t)0x00000300)        /*!< RTCSEL[1:0] bits (RTC clock source selection) */
N#define  RCC_BDCR_RTCSEL_0                   ((uint32_t)0x00000100)        /*!< Bit 0 */
N#define  RCC_BDCR_RTCSEL_1                   ((uint32_t)0x00000200)        /*!< Bit 1 */
N
N/*!< RTC congiguration */
N#define  RCC_BDCR_RTCSEL_NOCLOCK             ((uint32_t)0x00000000)        /*!< No clock */
N#define  RCC_BDCR_RTCSEL_LSE                 ((uint32_t)0x00000100)        /*!< LSE oscillator clock used as RTC clock */
N#define  RCC_BDCR_RTCSEL_LSI                 ((uint32_t)0x00000200)        /*!< LSI oscillator clock used as RTC clock */
N#define  RCC_BDCR_RTCSEL_HSE                 ((uint32_t)0x00000300)        /*!< HSE oscillator clock divided by 128 used as RTC clock */
N
N#define  RCC_BDCR_RTCEN                      ((uint32_t)0x00008000)        /*!< RTC clock enable */
N#define  RCC_BDCR_BDRST                      ((uint32_t)0x00010000)        /*!< Backup domain software reset  */
N
N/*******************  Bit definition for RCC_CSR register  ********************/  
N#define  RCC_CSR_LSION                       ((uint32_t)0x00000001)        /*!< Internal Low Speed oscillator enable */
N#define  RCC_CSR_LSIRDY                      ((uint32_t)0x00000002)        /*!< Internal Low Speed oscillator Ready */
N#define  RCC_CSR_RMVF                        ((uint32_t)0x01000000)        /*!< Remove reset flag */
N#define  RCC_CSR_PINRSTF                     ((uint32_t)0x04000000)        /*!< PIN reset flag */
N#define  RCC_CSR_PORRSTF                     ((uint32_t)0x08000000)        /*!< POR/PDR reset flag */
N#define  RCC_CSR_SFTRSTF                     ((uint32_t)0x10000000)        /*!< Software Reset flag */
N#define  RCC_CSR_IWDGRSTF                    ((uint32_t)0x20000000)        /*!< Independent Watchdog reset flag */
N#define  RCC_CSR_WWDGRSTF                    ((uint32_t)0x40000000)        /*!< Window watchdog reset flag */
N#define  RCC_CSR_LPWRRSTF                    ((uint32_t)0x80000000)        /*!< Low-Power reset flag */
N
N#ifdef STM32F10X_CL
S/*******************  Bit definition for RCC_AHBRSTR register  ****************/
S #define  RCC_AHBRSTR_OTGFSRST               ((uint32_t)0x00001000)         /*!< USB OTG FS reset */
S #define  RCC_AHBRSTR_ETHMACRST              ((uint32_t)0x00004000)         /*!< ETHERNET MAC reset */
S
S/*******************  Bit definition for RCC_CFGR2 register  ******************/
S/*!< PREDIV1 configuration */
S #define  RCC_CFGR2_PREDIV1                  ((uint32_t)0x0000000F)        /*!< PREDIV1[3:0] bits */
S #define  RCC_CFGR2_PREDIV1_0                ((uint32_t)0x00000001)        /*!< Bit 0 */
S #define  RCC_CFGR2_PREDIV1_1                ((uint32_t)0x00000002)        /*!< Bit 1 */
S #define  RCC_CFGR2_PREDIV1_2                ((uint32_t)0x00000004)        /*!< Bit 2 */
S #define  RCC_CFGR2_PREDIV1_3                ((uint32_t)0x00000008)        /*!< Bit 3 */
S
S #define  RCC_CFGR2_PREDIV1_DIV1             ((uint32_t)0x00000000)        /*!< PREDIV1 input clock not divided */
S #define  RCC_CFGR2_PREDIV1_DIV2             ((uint32_t)0x00000001)        /*!< PREDIV1 input clock divided by 2 */
S #define  RCC_CFGR2_PREDIV1_DIV3             ((uint32_t)0x00000002)        /*!< PREDIV1 input clock divided by 3 */
S #define  RCC_CFGR2_PREDIV1_DIV4             ((uint32_t)0x00000003)        /*!< PREDIV1 input clock divided by 4 */
S #define  RCC_CFGR2_PREDIV1_DIV5             ((uint32_t)0x00000004)        /*!< PREDIV1 input clock divided by 5 */
S #define  RCC_CFGR2_PREDIV1_DIV6             ((uint32_t)0x00000005)        /*!< PREDIV1 input clock divided by 6 */
S #define  RCC_CFGR2_PREDIV1_DIV7             ((uint32_t)0x00000006)        /*!< PREDIV1 input clock divided by 7 */
S #define  RCC_CFGR2_PREDIV1_DIV8             ((uint32_t)0x00000007)        /*!< PREDIV1 input clock divided by 8 */
S #define  RCC_CFGR2_PREDIV1_DIV9             ((uint32_t)0x00000008)        /*!< PREDIV1 input clock divided by 9 */
S #define  RCC_CFGR2_PREDIV1_DIV10            ((uint32_t)0x00000009)        /*!< PREDIV1 input clock divided by 10 */
S #define  RCC_CFGR2_PREDIV1_DIV11            ((uint32_t)0x0000000A)        /*!< PREDIV1 input clock divided by 11 */
S #define  RCC_CFGR2_PREDIV1_DIV12            ((uint32_t)0x0000000B)        /*!< PREDIV1 input clock divided by 12 */
S #define  RCC_CFGR2_PREDIV1_DIV13            ((uint32_t)0x0000000C)        /*!< PREDIV1 input clock divided by 13 */
S #define  RCC_CFGR2_PREDIV1_DIV14            ((uint32_t)0x0000000D)        /*!< PREDIV1 input clock divided by 14 */
S #define  RCC_CFGR2_PREDIV1_DIV15            ((uint32_t)0x0000000E)        /*!< PREDIV1 input clock divided by 15 */
S #define  RCC_CFGR2_PREDIV1_DIV16            ((uint32_t)0x0000000F)        /*!< PREDIV1 input clock divided by 16 */
S
S/*!< PREDIV2 configuration */
S #define  RCC_CFGR2_PREDIV2                  ((uint32_t)0x000000F0)        /*!< PREDIV2[3:0] bits */
S #define  RCC_CFGR2_PREDIV2_0                ((uint32_t)0x00000010)        /*!< Bit 0 */
S #define  RCC_CFGR2_PREDIV2_1                ((uint32_t)0x00000020)        /*!< Bit 1 */
S #define  RCC_CFGR2_PREDIV2_2                ((uint32_t)0x00000040)        /*!< Bit 2 */
S #define  RCC_CFGR2_PREDIV2_3                ((uint32_t)0x00000080)        /*!< Bit 3 */
S
S #define  RCC_CFGR2_PREDIV2_DIV1             ((uint32_t)0x00000000)        /*!< PREDIV2 input clock not divided */
S #define  RCC_CFGR2_PREDIV2_DIV2             ((uint32_t)0x00000010)        /*!< PREDIV2 input clock divided by 2 */
S #define  RCC_CFGR2_PREDIV2_DIV3             ((uint32_t)0x00000020)        /*!< PREDIV2 input clock divided by 3 */
S #define  RCC_CFGR2_PREDIV2_DIV4             ((uint32_t)0x00000030)        /*!< PREDIV2 input clock divided by 4 */
S #define  RCC_CFGR2_PREDIV2_DIV5             ((uint32_t)0x00000040)        /*!< PREDIV2 input clock divided by 5 */
S #define  RCC_CFGR2_PREDIV2_DIV6             ((uint32_t)0x00000050)        /*!< PREDIV2 input clock divided by 6 */
S #define  RCC_CFGR2_PREDIV2_DIV7             ((uint32_t)0x00000060)        /*!< PREDIV2 input clock divided by 7 */
S #define  RCC_CFGR2_PREDIV2_DIV8             ((uint32_t)0x00000070)        /*!< PREDIV2 input clock divided by 8 */
S #define  RCC_CFGR2_PREDIV2_DIV9             ((uint32_t)0x00000080)        /*!< PREDIV2 input clock divided by 9 */
S #define  RCC_CFGR2_PREDIV2_DIV10            ((uint32_t)0x00000090)        /*!< PREDIV2 input clock divided by 10 */
S #define  RCC_CFGR2_PREDIV2_DIV11            ((uint32_t)0x000000A0)        /*!< PREDIV2 input clock divided by 11 */
S #define  RCC_CFGR2_PREDIV2_DIV12            ((uint32_t)0x000000B0)        /*!< PREDIV2 input clock divided by 12 */
S #define  RCC_CFGR2_PREDIV2_DIV13            ((uint32_t)0x000000C0)        /*!< PREDIV2 input clock divided by 13 */
S #define  RCC_CFGR2_PREDIV2_DIV14            ((uint32_t)0x000000D0)        /*!< PREDIV2 input clock divided by 14 */
S #define  RCC_CFGR2_PREDIV2_DIV15            ((uint32_t)0x000000E0)        /*!< PREDIV2 input clock divided by 15 */
S #define  RCC_CFGR2_PREDIV2_DIV16            ((uint32_t)0x000000F0)        /*!< PREDIV2 input clock divided by 16 */
S
S/*!< PLL2MUL configuration */
S #define  RCC_CFGR2_PLL2MUL                  ((uint32_t)0x00000F00)        /*!< PLL2MUL[3:0] bits */
S #define  RCC_CFGR2_PLL2MUL_0                ((uint32_t)0x00000100)        /*!< Bit 0 */
S #define  RCC_CFGR2_PLL2MUL_1                ((uint32_t)0x00000200)        /*!< Bit 1 */
S #define  RCC_CFGR2_PLL2MUL_2                ((uint32_t)0x00000400)        /*!< Bit 2 */
S #define  RCC_CFGR2_PLL2MUL_3                ((uint32_t)0x00000800)        /*!< Bit 3 */
S
S #define  RCC_CFGR2_PLL2MUL8                 ((uint32_t)0x00000600)        /*!< PLL2 input clock * 8 */
S #define  RCC_CFGR2_PLL2MUL9                 ((uint32_t)0x00000700)        /*!< PLL2 input clock * 9 */
S #define  RCC_CFGR2_PLL2MUL10                ((uint32_t)0x00000800)        /*!< PLL2 input clock * 10 */
S #define  RCC_CFGR2_PLL2MUL11                ((uint32_t)0x00000900)        /*!< PLL2 input clock * 11 */
S #define  RCC_CFGR2_PLL2MUL12                ((uint32_t)0x00000A00)        /*!< PLL2 input clock * 12 */
S #define  RCC_CFGR2_PLL2MUL13                ((uint32_t)0x00000B00)        /*!< PLL2 input clock * 13 */
S #define  RCC_CFGR2_PLL2MUL14                ((uint32_t)0x00000C00)        /*!< PLL2 input clock * 14 */
S #define  RCC_CFGR2_PLL2MUL16                ((uint32_t)0x00000E00)        /*!< PLL2 input clock * 16 */
S #define  RCC_CFGR2_PLL2MUL20                ((uint32_t)0x00000F00)        /*!< PLL2 input clock * 20 */
S
S/*!< PLL3MUL configuration */
S #define  RCC_CFGR2_PLL3MUL                  ((uint32_t)0x0000F000)        /*!< PLL3MUL[3:0] bits */
S #define  RCC_CFGR2_PLL3MUL_0                ((uint32_t)0x00001000)        /*!< Bit 0 */
S #define  RCC_CFGR2_PLL3MUL_1                ((uint32_t)0x00002000)        /*!< Bit 1 */
S #define  RCC_CFGR2_PLL3MUL_2                ((uint32_t)0x00004000)        /*!< Bit 2 */
S #define  RCC_CFGR2_PLL3MUL_3                ((uint32_t)0x00008000)        /*!< Bit 3 */
S
S #define  RCC_CFGR2_PLL3MUL8                 ((uint32_t)0x00006000)        /*!< PLL3 input clock * 8 */
S #define  RCC_CFGR2_PLL3MUL9                 ((uint32_t)0x00007000)        /*!< PLL3 input clock * 9 */
S #define  RCC_CFGR2_PLL3MUL10                ((uint32_t)0x00008000)        /*!< PLL3 input clock * 10 */
S #define  RCC_CFGR2_PLL3MUL11                ((uint32_t)0x00009000)        /*!< PLL3 input clock * 11 */
S #define  RCC_CFGR2_PLL3MUL12                ((uint32_t)0x0000A000)        /*!< PLL3 input clock * 12 */
S #define  RCC_CFGR2_PLL3MUL13                ((uint32_t)0x0000B000)        /*!< PLL3 input clock * 13 */
S #define  RCC_CFGR2_PLL3MUL14                ((uint32_t)0x0000C000)        /*!< PLL3 input clock * 14 */
S #define  RCC_CFGR2_PLL3MUL16                ((uint32_t)0x0000E000)        /*!< PLL3 input clock * 16 */
S #define  RCC_CFGR2_PLL3MUL20                ((uint32_t)0x0000F000)        /*!< PLL3 input clock * 20 */
S
S #define  RCC_CFGR2_PREDIV1SRC               ((uint32_t)0x00010000)        /*!< PREDIV1 entry clock source */
S #define  RCC_CFGR2_PREDIV1SRC_PLL2          ((uint32_t)0x00010000)        /*!< PLL2 selected as PREDIV1 entry clock source */
S #define  RCC_CFGR2_PREDIV1SRC_HSE           ((uint32_t)0x00000000)        /*!< HSE selected as PREDIV1 entry clock source */
S #define  RCC_CFGR2_I2S2SRC                  ((uint32_t)0x00020000)        /*!< I2S2 entry clock source */
S #define  RCC_CFGR2_I2S3SRC                  ((uint32_t)0x00040000)        /*!< I2S3 clock source */
N#endif /* STM32F10X_CL */
N
N#if defined (STM32F10X_LD_VL) || defined (STM32F10X_MD_VL) || defined (STM32F10X_HD_VL)
X#if 0L || 0L || 0L
S/*******************  Bit definition for RCC_CFGR2 register  ******************/
S/*!< PREDIV1 configuration */
S #define  RCC_CFGR2_PREDIV1                  ((uint32_t)0x0000000F)        /*!< PREDIV1[3:0] bits */
S #define  RCC_CFGR2_PREDIV1_0                ((uint32_t)0x00000001)        /*!< Bit 0 */
S #define  RCC_CFGR2_PREDIV1_1                ((uint32_t)0x00000002)        /*!< Bit 1 */
S #define  RCC_CFGR2_PREDIV1_2                ((uint32_t)0x00000004)        /*!< Bit 2 */
S #define  RCC_CFGR2_PREDIV1_3                ((uint32_t)0x00000008)        /*!< Bit 3 */
S
S #define  RCC_CFGR2_PREDIV1_DIV1             ((uint32_t)0x00000000)        /*!< PREDIV1 input clock not divided */
S #define  RCC_CFGR2_PREDIV1_DIV2             ((uint32_t)0x00000001)        /*!< PREDIV1 input clock divided by 2 */
S #define  RCC_CFGR2_PREDIV1_DIV3             ((uint32_t)0x00000002)        /*!< PREDIV1 input clock divided by 3 */
S #define  RCC_CFGR2_PREDIV1_DIV4             ((uint32_t)0x00000003)        /*!< PREDIV1 input clock divided by 4 */
S #define  RCC_CFGR2_PREDIV1_DIV5             ((uint32_t)0x00000004)        /*!< PREDIV1 input clock divided by 5 */
S #define  RCC_CFGR2_PREDIV1_DIV6             ((uint32_t)0x00000005)        /*!< PREDIV1 input clock divided by 6 */
S #define  RCC_CFGR2_PREDIV1_DIV7             ((uint32_t)0x00000006)        /*!< PREDIV1 input clock divided by 7 */
S #define  RCC_CFGR2_PREDIV1_DIV8             ((uint32_t)0x00000007)        /*!< PREDIV1 input clock divided by 8 */
S #define  RCC_CFGR2_PREDIV1_DIV9             ((uint32_t)0x00000008)        /*!< PREDIV1 input clock divided by 9 */
S #define  RCC_CFGR2_PREDIV1_DIV10            ((uint32_t)0x00000009)        /*!< PREDIV1 input clock divided by 10 */
S #define  RCC_CFGR2_PREDIV1_DIV11            ((uint32_t)0x0000000A)        /*!< PREDIV1 input clock divided by 11 */
S #define  RCC_CFGR2_PREDIV1_DIV12            ((uint32_t)0x0000000B)        /*!< PREDIV1 input clock divided by 12 */
S #define  RCC_CFGR2_PREDIV1_DIV13            ((uint32_t)0x0000000C)        /*!< PREDIV1 input clock divided by 13 */
S #define  RCC_CFGR2_PREDIV1_DIV14            ((uint32_t)0x0000000D)        /*!< PREDIV1 input clock divided by 14 */
S #define  RCC_CFGR2_PREDIV1_DIV15            ((uint32_t)0x0000000E)        /*!< PREDIV1 input clock divided by 15 */
S #define  RCC_CFGR2_PREDIV1_DIV16            ((uint32_t)0x0000000F)        /*!< PREDIV1 input clock divided by 16 */
N#endif
N 
N/******************************************************************************/
N/*                                                                            */
N/*                General Purpose and Alternate Function I/O                  */
N/*                                                                            */
N/******************************************************************************/
N
N/*******************  Bit definition for GPIO_CRL register  *******************/
N#define  GPIO_CRL_MODE                       ((uint32_t)0x33333333)        /*!< Port x mode bits */
N
N#define  GPIO_CRL_MODE0                      ((uint32_t)0x00000003)        /*!< MODE0[1:0] bits (Port x mode bits, pin 0) */
N#define  GPIO_CRL_MODE0_0                    ((uint32_t)0x00000001)        /*!< Bit 0 */
N#define  GPIO_CRL_MODE0_1                    ((uint32_t)0x00000002)        /*!< Bit 1 */
N
N#define  GPIO_CRL_MODE1                      ((uint32_t)0x00000030)        /*!< MODE1[1:0] bits (Port x mode bits, pin 1) */
N#define  GPIO_CRL_MODE1_0                    ((uint32_t)0x00000010)        /*!< Bit 0 */
N#define  GPIO_CRL_MODE1_1                    ((uint32_t)0x00000020)        /*!< Bit 1 */
N
N#define  GPIO_CRL_MODE2                      ((uint32_t)0x00000300)        /*!< MODE2[1:0] bits (Port x mode bits, pin 2) */
N#define  GPIO_CRL_MODE2_0                    ((uint32_t)0x00000100)        /*!< Bit 0 */
N#define  GPIO_CRL_MODE2_1                    ((uint32_t)0x00000200)        /*!< Bit 1 */
N
N#define  GPIO_CRL_MODE3                      ((uint32_t)0x00003000)        /*!< MODE3[1:0] bits (Port x mode bits, pin 3) */
N#define  GPIO_CRL_MODE3_0                    ((uint32_t)0x00001000)        /*!< Bit 0 */
N#define  GPIO_CRL_MODE3_1                    ((uint32_t)0x00002000)        /*!< Bit 1 */
N
N#define  GPIO_CRL_MODE4                      ((uint32_t)0x00030000)        /*!< MODE4[1:0] bits (Port x mode bits, pin 4) */
N#define  GPIO_CRL_MODE4_0                    ((uint32_t)0x00010000)        /*!< Bit 0 */
N#define  GPIO_CRL_MODE4_1                    ((uint32_t)0x00020000)        /*!< Bit 1 */
N
N#define  GPIO_CRL_MODE5                      ((uint32_t)0x00300000)        /*!< MODE5[1:0] bits (Port x mode bits, pin 5) */
N#define  GPIO_CRL_MODE5_0                    ((uint32_t)0x00100000)        /*!< Bit 0 */
N#define  GPIO_CRL_MODE5_1                    ((uint32_t)0x00200000)        /*!< Bit 1 */
N
N#define  GPIO_CRL_MODE6                      ((uint32_t)0x03000000)        /*!< MODE6[1:0] bits (Port x mode bits, pin 6) */
N#define  GPIO_CRL_MODE6_0                    ((uint32_t)0x01000000)        /*!< Bit 0 */
N#define  GPIO_CRL_MODE6_1                    ((uint32_t)0x02000000)        /*!< Bit 1 */
N
N#define  GPIO_CRL_MODE7                      ((uint32_t)0x30000000)        /*!< MODE7[1:0] bits (Port x mode bits, pin 7) */
N#define  GPIO_CRL_MODE7_0                    ((uint32_t)0x10000000)        /*!< Bit 0 */
N#define  GPIO_CRL_MODE7_1                    ((uint32_t)0x20000000)        /*!< Bit 1 */
N
N#define  GPIO_CRL_CNF                        ((uint32_t)0xCCCCCCCC)        /*!< Port x configuration bits */
N
N#define  GPIO_CRL_CNF0                       ((uint32_t)0x0000000C)        /*!< CNF0[1:0] bits (Port x configuration bits, pin 0) */
N#define  GPIO_CRL_CNF0_0                     ((uint32_t)0x00000004)        /*!< Bit 0 */
N#define  GPIO_CRL_CNF0_1                     ((uint32_t)0x00000008)        /*!< Bit 1 */
N
N#define  GPIO_CRL_CNF1                       ((uint32_t)0x000000C0)        /*!< CNF1[1:0] bits (Port x configuration bits, pin 1) */
N#define  GPIO_CRL_CNF1_0                     ((uint32_t)0x00000040)        /*!< Bit 0 */
N#define  GPIO_CRL_CNF1_1                     ((uint32_t)0x00000080)        /*!< Bit 1 */
N
N#define  GPIO_CRL_CNF2                       ((uint32_t)0x00000C00)        /*!< CNF2[1:0] bits (Port x configuration bits, pin 2) */
N#define  GPIO_CRL_CNF2_0                     ((uint32_t)0x00000400)        /*!< Bit 0 */
N#define  GPIO_CRL_CNF2_1                     ((uint32_t)0x00000800)        /*!< Bit 1 */
N
N#define  GPIO_CRL_CNF3                       ((uint32_t)0x0000C000)        /*!< CNF3[1:0] bits (Port x configuration bits, pin 3) */
N#define  GPIO_CRL_CNF3_0                     ((uint32_t)0x00004000)        /*!< Bit 0 */
N#define  GPIO_CRL_CNF3_1                     ((uint32_t)0x00008000)        /*!< Bit 1 */
N
N#define  GPIO_CRL_CNF4                       ((uint32_t)0x000C0000)        /*!< CNF4[1:0] bits (Port x configuration bits, pin 4) */
N#define  GPIO_CRL_CNF4_0                     ((uint32_t)0x00040000)        /*!< Bit 0 */
N#define  GPIO_CRL_CNF4_1                     ((uint32_t)0x00080000)        /*!< Bit 1 */
N
N#define  GPIO_CRL_CNF5                       ((uint32_t)0x00C00000)        /*!< CNF5[1:0] bits (Port x configuration bits, pin 5) */
N#define  GPIO_CRL_CNF5_0                     ((uint32_t)0x00400000)        /*!< Bit 0 */
N#define  GPIO_CRL_CNF5_1                     ((uint32_t)0x00800000)        /*!< Bit 1 */
N
N#define  GPIO_CRL_CNF6                       ((uint32_t)0x0C000000)        /*!< CNF6[1:0] bits (Port x configuration bits, pin 6) */
N#define  GPIO_CRL_CNF6_0                     ((uint32_t)0x04000000)        /*!< Bit 0 */
N#define  GPIO_CRL_CNF6_1                     ((uint32_t)0x08000000)        /*!< Bit 1 */
N
N#define  GPIO_CRL_CNF7                       ((uint32_t)0xC0000000)        /*!< CNF7[1:0] bits (Port x configuration bits, pin 7) */
N#define  GPIO_CRL_CNF7_0                     ((uint32_t)0x40000000)        /*!< Bit 0 */
N#define  GPIO_CRL_CNF7_1                     ((uint32_t)0x80000000)        /*!< Bit 1 */
N
N/*******************  Bit definition for GPIO_CRH register  *******************/
N#define  GPIO_CRH_MODE                       ((uint32_t)0x33333333)        /*!< Port x mode bits */
N
N#define  GPIO_CRH_MODE8                      ((uint32_t)0x00000003)        /*!< MODE8[1:0] bits (Port x mode bits, pin 8) */
N#define  GPIO_CRH_MODE8_0                    ((uint32_t)0x00000001)        /*!< Bit 0 */
N#define  GPIO_CRH_MODE8_1                    ((uint32_t)0x00000002)        /*!< Bit 1 */
N
N#define  GPIO_CRH_MODE9                      ((uint32_t)0x00000030)        /*!< MODE9[1:0] bits (Port x mode bits, pin 9) */
N#define  GPIO_CRH_MODE9_0                    ((uint32_t)0x00000010)        /*!< Bit 0 */
N#define  GPIO_CRH_MODE9_1                    ((uint32_t)0x00000020)        /*!< Bit 1 */
N
N#define  GPIO_CRH_MODE10                     ((uint32_t)0x00000300)        /*!< MODE10[1:0] bits (Port x mode bits, pin 10) */
N#define  GPIO_CRH_MODE10_0                   ((uint32_t)0x00000100)        /*!< Bit 0 */
N#define  GPIO_CRH_MODE10_1                   ((uint32_t)0x00000200)        /*!< Bit 1 */
N
N#define  GPIO_CRH_MODE11                     ((uint32_t)0x00003000)        /*!< MODE11[1:0] bits (Port x mode bits, pin 11) */
N#define  GPIO_CRH_MODE11_0                   ((uint32_t)0x00001000)        /*!< Bit 0 */
N#define  GPIO_CRH_MODE11_1                   ((uint32_t)0x00002000)        /*!< Bit 1 */
N
N#define  GPIO_CRH_MODE12                     ((uint32_t)0x00030000)        /*!< MODE12[1:0] bits (Port x mode bits, pin 12) */
N#define  GPIO_CRH_MODE12_0                   ((uint32_t)0x00010000)        /*!< Bit 0 */
N#define  GPIO_CRH_MODE12_1                   ((uint32_t)0x00020000)        /*!< Bit 1 */
N
N#define  GPIO_CRH_MODE13                     ((uint32_t)0x00300000)        /*!< MODE13[1:0] bits (Port x mode bits, pin 13) */
N#define  GPIO_CRH_MODE13_0                   ((uint32_t)0x00100000)        /*!< Bit 0 */
N#define  GPIO_CRH_MODE13_1                   ((uint32_t)0x00200000)        /*!< Bit 1 */
N
N#define  GPIO_CRH_MODE14                     ((uint32_t)0x03000000)        /*!< MODE14[1:0] bits (Port x mode bits, pin 14) */
N#define  GPIO_CRH_MODE14_0                   ((uint32_t)0x01000000)        /*!< Bit 0 */
N#define  GPIO_CRH_MODE14_1                   ((uint32_t)0x02000000)        /*!< Bit 1 */
N
N#define  GPIO_CRH_MODE15                     ((uint32_t)0x30000000)        /*!< MODE15[1:0] bits (Port x mode bits, pin 15) */
N#define  GPIO_CRH_MODE15_0                   ((uint32_t)0x10000000)        /*!< Bit 0 */
N#define  GPIO_CRH_MODE15_1                   ((uint32_t)0x20000000)        /*!< Bit 1 */
N
N#define  GPIO_CRH_CNF                        ((uint32_t)0xCCCCCCCC)        /*!< Port x configuration bits */
N
N#define  GPIO_CRH_CNF8                       ((uint32_t)0x0000000C)        /*!< CNF8[1:0] bits (Port x configuration bits, pin 8) */
N#define  GPIO_CRH_CNF8_0                     ((uint32_t)0x00000004)        /*!< Bit 0 */
N#define  GPIO_CRH_CNF8_1                     ((uint32_t)0x00000008)        /*!< Bit 1 */
N
N#define  GPIO_CRH_CNF9                       ((uint32_t)0x000000C0)        /*!< CNF9[1:0] bits (Port x configuration bits, pin 9) */
N#define  GPIO_CRH_CNF9_0                     ((uint32_t)0x00000040)        /*!< Bit 0 */
N#define  GPIO_CRH_CNF9_1                     ((uint32_t)0x00000080)        /*!< Bit 1 */
N
N#define  GPIO_CRH_CNF10                      ((uint32_t)0x00000C00)        /*!< CNF10[1:0] bits (Port x configuration bits, pin 10) */
N#define  GPIO_CRH_CNF10_0                    ((uint32_t)0x00000400)        /*!< Bit 0 */
N#define  GPIO_CRH_CNF10_1                    ((uint32_t)0x00000800)        /*!< Bit 1 */
N
N#define  GPIO_CRH_CNF11                      ((uint32_t)0x0000C000)        /*!< CNF11[1:0] bits (Port x configuration bits, pin 11) */
N#define  GPIO_CRH_CNF11_0                    ((uint32_t)0x00004000)        /*!< Bit 0 */
N#define  GPIO_CRH_CNF11_1                    ((uint32_t)0x00008000)        /*!< Bit 1 */
N
N#define  GPIO_CRH_CNF12                      ((uint32_t)0x000C0000)        /*!< CNF12[1:0] bits (Port x configuration bits, pin 12) */
N#define  GPIO_CRH_CNF12_0                    ((uint32_t)0x00040000)        /*!< Bit 0 */
N#define  GPIO_CRH_CNF12_1                    ((uint32_t)0x00080000)        /*!< Bit 1 */
N
N#define  GPIO_CRH_CNF13                      ((uint32_t)0x00C00000)        /*!< CNF13[1:0] bits (Port x configuration bits, pin 13) */
N#define  GPIO_CRH_CNF13_0                    ((uint32_t)0x00400000)        /*!< Bit 0 */
N#define  GPIO_CRH_CNF13_1                    ((uint32_t)0x00800000)        /*!< Bit 1 */
N
N#define  GPIO_CRH_CNF14                      ((uint32_t)0x0C000000)        /*!< CNF14[1:0] bits (Port x configuration bits, pin 14) */
N#define  GPIO_CRH_CNF14_0                    ((uint32_t)0x04000000)        /*!< Bit 0 */
N#define  GPIO_CRH_CNF14_1                    ((uint32_t)0x08000000)        /*!< Bit 1 */
N
N#define  GPIO_CRH_CNF15                      ((uint32_t)0xC0000000)        /*!< CNF15[1:0] bits (Port x configuration bits, pin 15) */
N#define  GPIO_CRH_CNF15_0                    ((uint32_t)0x40000000)        /*!< Bit 0 */
N#define  GPIO_CRH_CNF15_1                    ((uint32_t)0x80000000)        /*!< Bit 1 */
N
N/*!<******************  Bit definition for GPIO_IDR register  *******************/
N#define GPIO_IDR_IDR0                        ((uint16_t)0x0001)            /*!< Port input data, bit 0 */
N#define GPIO_IDR_IDR1                        ((uint16_t)0x0002)            /*!< Port input data, bit 1 */
N#define GPIO_IDR_IDR2                        ((uint16_t)0x0004)            /*!< Port input data, bit 2 */
N#define GPIO_IDR_IDR3                        ((uint16_t)0x0008)            /*!< Port input data, bit 3 */
N#define GPIO_IDR_IDR4                        ((uint16_t)0x0010)            /*!< Port input data, bit 4 */
N#define GPIO_IDR_IDR5                        ((uint16_t)0x0020)            /*!< Port input data, bit 5 */
N#define GPIO_IDR_IDR6                        ((uint16_t)0x0040)            /*!< Port input data, bit 6 */
N#define GPIO_IDR_IDR7                        ((uint16_t)0x0080)            /*!< Port input data, bit 7 */
N#define GPIO_IDR_IDR8                        ((uint16_t)0x0100)            /*!< Port input data, bit 8 */
N#define GPIO_IDR_IDR9                        ((uint16_t)0x0200)            /*!< Port input data, bit 9 */
N#define GPIO_IDR_IDR10                       ((uint16_t)0x0400)            /*!< Port input data, bit 10 */
N#define GPIO_IDR_IDR11                       ((uint16_t)0x0800)            /*!< Port input data, bit 11 */
N#define GPIO_IDR_IDR12                       ((uint16_t)0x1000)            /*!< Port input data, bit 12 */
N#define GPIO_IDR_IDR13                       ((uint16_t)0x2000)            /*!< Port input data, bit 13 */
N#define GPIO_IDR_IDR14                       ((uint16_t)0x4000)            /*!< Port input data, bit 14 */
N#define GPIO_IDR_IDR15                       ((uint16_t)0x8000)            /*!< Port input data, bit 15 */
N
N/*******************  Bit definition for GPIO_ODR register  *******************/
N#define GPIO_ODR_ODR0                        ((uint16_t)0x0001)            /*!< Port output data, bit 0 */
N#define GPIO_ODR_ODR1                        ((uint16_t)0x0002)            /*!< Port output data, bit 1 */
N#define GPIO_ODR_ODR2                        ((uint16_t)0x0004)            /*!< Port output data, bit 2 */
N#define GPIO_ODR_ODR3                        ((uint16_t)0x0008)            /*!< Port output data, bit 3 */
N#define GPIO_ODR_ODR4                        ((uint16_t)0x0010)            /*!< Port output data, bit 4 */
N#define GPIO_ODR_ODR5                        ((uint16_t)0x0020)            /*!< Port output data, bit 5 */
N#define GPIO_ODR_ODR6                        ((uint16_t)0x0040)            /*!< Port output data, bit 6 */
N#define GPIO_ODR_ODR7                        ((uint16_t)0x0080)            /*!< Port output data, bit 7 */
N#define GPIO_ODR_ODR8                        ((uint16_t)0x0100)            /*!< Port output data, bit 8 */
N#define GPIO_ODR_ODR9                        ((uint16_t)0x0200)            /*!< Port output data, bit 9 */
N#define GPIO_ODR_ODR10                       ((uint16_t)0x0400)            /*!< Port output data, bit 10 */
N#define GPIO_ODR_ODR11                       ((uint16_t)0x0800)            /*!< Port output data, bit 11 */
N#define GPIO_ODR_ODR12                       ((uint16_t)0x1000)            /*!< Port output data, bit 12 */
N#define GPIO_ODR_ODR13                       ((uint16_t)0x2000)            /*!< Port output data, bit 13 */
N#define GPIO_ODR_ODR14                       ((uint16_t)0x4000)            /*!< Port output data, bit 14 */
N#define GPIO_ODR_ODR15                       ((uint16_t)0x8000)            /*!< Port output data, bit 15 */
N
N/******************  Bit definition for GPIO_BSRR register  *******************/
N#define GPIO_BSRR_BS0                        ((uint32_t)0x00000001)        /*!< Port x Set bit 0 */
N#define GPIO_BSRR_BS1                        ((uint32_t)0x00000002)        /*!< Port x Set bit 1 */
N#define GPIO_BSRR_BS2                        ((uint32_t)0x00000004)        /*!< Port x Set bit 2 */
N#define GPIO_BSRR_BS3                        ((uint32_t)0x00000008)        /*!< Port x Set bit 3 */
N#define GPIO_BSRR_BS4                        ((uint32_t)0x00000010)        /*!< Port x Set bit 4 */
N#define GPIO_BSRR_BS5                        ((uint32_t)0x00000020)        /*!< Port x Set bit 5 */
N#define GPIO_BSRR_BS6                        ((uint32_t)0x00000040)        /*!< Port x Set bit 6 */
N#define GPIO_BSRR_BS7                        ((uint32_t)0x00000080)        /*!< Port x Set bit 7 */
N#define GPIO_BSRR_BS8                        ((uint32_t)0x00000100)        /*!< Port x Set bit 8 */
N#define GPIO_BSRR_BS9                        ((uint32_t)0x00000200)        /*!< Port x Set bit 9 */
N#define GPIO_BSRR_BS10                       ((uint32_t)0x00000400)        /*!< Port x Set bit 10 */
N#define GPIO_BSRR_BS11                       ((uint32_t)0x00000800)        /*!< Port x Set bit 11 */
N#define GPIO_BSRR_BS12                       ((uint32_t)0x00001000)        /*!< Port x Set bit 12 */
N#define GPIO_BSRR_BS13                       ((uint32_t)0x00002000)        /*!< Port x Set bit 13 */
N#define GPIO_BSRR_BS14                       ((uint32_t)0x00004000)        /*!< Port x Set bit 14 */
N#define GPIO_BSRR_BS15                       ((uint32_t)0x00008000)        /*!< Port x Set bit 15 */
N
N#define GPIO_BSRR_BR0                        ((uint32_t)0x00010000)        /*!< Port x Reset bit 0 */
N#define GPIO_BSRR_BR1                        ((uint32_t)0x00020000)        /*!< Port x Reset bit 1 */
N#define GPIO_BSRR_BR2                        ((uint32_t)0x00040000)        /*!< Port x Reset bit 2 */
N#define GPIO_BSRR_BR3                        ((uint32_t)0x00080000)        /*!< Port x Reset bit 3 */
N#define GPIO_BSRR_BR4                        ((uint32_t)0x00100000)        /*!< Port x Reset bit 4 */
N#define GPIO_BSRR_BR5                        ((uint32_t)0x00200000)        /*!< Port x Reset bit 5 */
N#define GPIO_BSRR_BR6                        ((uint32_t)0x00400000)        /*!< Port x Reset bit 6 */
N#define GPIO_BSRR_BR7                        ((uint32_t)0x00800000)        /*!< Port x Reset bit 7 */
N#define GPIO_BSRR_BR8                        ((uint32_t)0x01000000)        /*!< Port x Reset bit 8 */
N#define GPIO_BSRR_BR9                        ((uint32_t)0x02000000)        /*!< Port x Reset bit 9 */
N#define GPIO_BSRR_BR10                       ((uint32_t)0x04000000)        /*!< Port x Reset bit 10 */
N#define GPIO_BSRR_BR11                       ((uint32_t)0x08000000)        /*!< Port x Reset bit 11 */
N#define GPIO_BSRR_BR12                       ((uint32_t)0x10000000)        /*!< Port x Reset bit 12 */
N#define GPIO_BSRR_BR13                       ((uint32_t)0x20000000)        /*!< Port x Reset bit 13 */
N#define GPIO_BSRR_BR14                       ((uint32_t)0x40000000)        /*!< Port x Reset bit 14 */
N#define GPIO_BSRR_BR15                       ((uint32_t)0x80000000)        /*!< Port x Reset bit 15 */
N
N/*******************  Bit definition for GPIO_BRR register  *******************/
N#define GPIO_BRR_BR0                         ((uint16_t)0x0001)            /*!< Port x Reset bit 0 */
N#define GPIO_BRR_BR1                         ((uint16_t)0x0002)            /*!< Port x Reset bit 1 */
N#define GPIO_BRR_BR2                         ((uint16_t)0x0004)            /*!< Port x Reset bit 2 */
N#define GPIO_BRR_BR3                         ((uint16_t)0x0008)            /*!< Port x Reset bit 3 */
N#define GPIO_BRR_BR4                         ((uint16_t)0x0010)            /*!< Port x Reset bit 4 */
N#define GPIO_BRR_BR5                         ((uint16_t)0x0020)            /*!< Port x Reset bit 5 */
N#define GPIO_BRR_BR6                         ((uint16_t)0x0040)            /*!< Port x Reset bit 6 */
N#define GPIO_BRR_BR7                         ((uint16_t)0x0080)            /*!< Port x Reset bit 7 */
N#define GPIO_BRR_BR8                         ((uint16_t)0x0100)            /*!< Port x Reset bit 8 */
N#define GPIO_BRR_BR9                         ((uint16_t)0x0200)            /*!< Port x Reset bit 9 */
N#define GPIO_BRR_BR10                        ((uint16_t)0x0400)            /*!< Port x Reset bit 10 */
N#define GPIO_BRR_BR11                        ((uint16_t)0x0800)            /*!< Port x Reset bit 11 */
N#define GPIO_BRR_BR12                        ((uint16_t)0x1000)            /*!< Port x Reset bit 12 */
N#define GPIO_BRR_BR13                        ((uint16_t)0x2000)            /*!< Port x Reset bit 13 */
N#define GPIO_BRR_BR14                        ((uint16_t)0x4000)            /*!< Port x Reset bit 14 */
N#define GPIO_BRR_BR15                        ((uint16_t)0x8000)            /*!< Port x Reset bit 15 */
N
N/******************  Bit definition for GPIO_LCKR register  *******************/
N#define GPIO_LCKR_LCK0                       ((uint32_t)0x00000001)        /*!< Port x Lock bit 0 */
N#define GPIO_LCKR_LCK1                       ((uint32_t)0x00000002)        /*!< Port x Lock bit 1 */
N#define GPIO_LCKR_LCK2                       ((uint32_t)0x00000004)        /*!< Port x Lock bit 2 */
N#define GPIO_LCKR_LCK3                       ((uint32_t)0x00000008)        /*!< Port x Lock bit 3 */
N#define GPIO_LCKR_LCK4                       ((uint32_t)0x00000010)        /*!< Port x Lock bit 4 */
N#define GPIO_LCKR_LCK5                       ((uint32_t)0x00000020)        /*!< Port x Lock bit 5 */
N#define GPIO_LCKR_LCK6                       ((uint32_t)0x00000040)        /*!< Port x Lock bit 6 */
N#define GPIO_LCKR_LCK7                       ((uint32_t)0x00000080)        /*!< Port x Lock bit 7 */
N#define GPIO_LCKR_LCK8                       ((uint32_t)0x00000100)        /*!< Port x Lock bit 8 */
N#define GPIO_LCKR_LCK9                       ((uint32_t)0x00000200)        /*!< Port x Lock bit 9 */
N#define GPIO_LCKR_LCK10                      ((uint32_t)0x00000400)        /*!< Port x Lock bit 10 */
N#define GPIO_LCKR_LCK11                      ((uint32_t)0x00000800)        /*!< Port x Lock bit 11 */
N#define GPIO_LCKR_LCK12                      ((uint32_t)0x00001000)        /*!< Port x Lock bit 12 */
N#define GPIO_LCKR_LCK13                      ((uint32_t)0x00002000)        /*!< Port x Lock bit 13 */
N#define GPIO_LCKR_LCK14                      ((uint32_t)0x00004000)        /*!< Port x Lock bit 14 */
N#define GPIO_LCKR_LCK15                      ((uint32_t)0x00008000)        /*!< Port x Lock bit 15 */
N#define GPIO_LCKR_LCKK                       ((uint32_t)0x00010000)        /*!< Lock key */
N
N/*----------------------------------------------------------------------------*/
N
N/******************  Bit definition for AFIO_EVCR register  *******************/
N#define AFIO_EVCR_PIN                        ((uint8_t)0x0F)               /*!< PIN[3:0] bits (Pin selection) */
N#define AFIO_EVCR_PIN_0                      ((uint8_t)0x01)               /*!< Bit 0 */
N#define AFIO_EVCR_PIN_1                      ((uint8_t)0x02)               /*!< Bit 1 */
N#define AFIO_EVCR_PIN_2                      ((uint8_t)0x04)               /*!< Bit 2 */
N#define AFIO_EVCR_PIN_3                      ((uint8_t)0x08)               /*!< Bit 3 */
N
N/*!< PIN configuration */
N#define AFIO_EVCR_PIN_PX0                    ((uint8_t)0x00)               /*!< Pin 0 selected */
N#define AFIO_EVCR_PIN_PX1                    ((uint8_t)0x01)               /*!< Pin 1 selected */
N#define AFIO_EVCR_PIN_PX2                    ((uint8_t)0x02)               /*!< Pin 2 selected */
N#define AFIO_EVCR_PIN_PX3                    ((uint8_t)0x03)               /*!< Pin 3 selected */
N#define AFIO_EVCR_PIN_PX4                    ((uint8_t)0x04)               /*!< Pin 4 selected */
N#define AFIO_EVCR_PIN_PX5                    ((uint8_t)0x05)               /*!< Pin 5 selected */
N#define AFIO_EVCR_PIN_PX6                    ((uint8_t)0x06)               /*!< Pin 6 selected */
N#define AFIO_EVCR_PIN_PX7                    ((uint8_t)0x07)               /*!< Pin 7 selected */
N#define AFIO_EVCR_PIN_PX8                    ((uint8_t)0x08)               /*!< Pin 8 selected */
N#define AFIO_EVCR_PIN_PX9                    ((uint8_t)0x09)               /*!< Pin 9 selected */
N#define AFIO_EVCR_PIN_PX10                   ((uint8_t)0x0A)               /*!< Pin 10 selected */
N#define AFIO_EVCR_PIN_PX11                   ((uint8_t)0x0B)               /*!< Pin 11 selected */
N#define AFIO_EVCR_PIN_PX12                   ((uint8_t)0x0C)               /*!< Pin 12 selected */
N#define AFIO_EVCR_PIN_PX13                   ((uint8_t)0x0D)               /*!< Pin 13 selected */
N#define AFIO_EVCR_PIN_PX14                   ((uint8_t)0x0E)               /*!< Pin 14 selected */
N#define AFIO_EVCR_PIN_PX15                   ((uint8_t)0x0F)               /*!< Pin 15 selected */
N
N#define AFIO_EVCR_PORT                       ((uint8_t)0x70)               /*!< PORT[2:0] bits (Port selection) */
N#define AFIO_EVCR_PORT_0                     ((uint8_t)0x10)               /*!< Bit 0 */
N#define AFIO_EVCR_PORT_1                     ((uint8_t)0x20)               /*!< Bit 1 */
N#define AFIO_EVCR_PORT_2                     ((uint8_t)0x40)               /*!< Bit 2 */
N
N/*!< PORT configuration */
N#define AFIO_EVCR_PORT_PA                    ((uint8_t)0x00)               /*!< Port A selected */
N#define AFIO_EVCR_PORT_PB                    ((uint8_t)0x10)               /*!< Port B selected */
N#define AFIO_EVCR_PORT_PC                    ((uint8_t)0x20)               /*!< Port C selected */
N#define AFIO_EVCR_PORT_PD                    ((uint8_t)0x30)               /*!< Port D selected */
N#define AFIO_EVCR_PORT_PE                    ((uint8_t)0x40)               /*!< Port E selected */
N
N#define AFIO_EVCR_EVOE                       ((uint8_t)0x80)               /*!< Event Output Enable */
N
N/******************  Bit definition for AFIO_MAPR register  *******************/
N#define AFIO_MAPR_SPI1_REMAP                 ((uint32_t)0x00000001)        /*!< SPI1 remapping */
N#define AFIO_MAPR_I2C1_REMAP                 ((uint32_t)0x00000002)        /*!< I2C1 remapping */
N#define AFIO_MAPR_USART1_REMAP               ((uint32_t)0x00000004)        /*!< USART1 remapping */
N#define AFIO_MAPR_USART2_REMAP               ((uint32_t)0x00000008)        /*!< USART2 remapping */
N
N#define AFIO_MAPR_USART3_REMAP               ((uint32_t)0x00000030)        /*!< USART3_REMAP[1:0] bits (USART3 remapping) */
N#define AFIO_MAPR_USART3_REMAP_0             ((uint32_t)0x00000010)        /*!< Bit 0 */
N#define AFIO_MAPR_USART3_REMAP_1             ((uint32_t)0x00000020)        /*!< Bit 1 */
N
N/* USART3_REMAP configuration */
N#define AFIO_MAPR_USART3_REMAP_NOREMAP       ((uint32_t)0x00000000)        /*!< No remap (TX/PB10, RX/PB11, CK/PB12, CTS/PB13, RTS/PB14) */
N#define AFIO_MAPR_USART3_REMAP_PARTIALREMAP  ((uint32_t)0x00000010)        /*!< Partial remap (TX/PC10, RX/PC11, CK/PC12, CTS/PB13, RTS/PB14) */
N#define AFIO_MAPR_USART3_REMAP_FULLREMAP     ((uint32_t)0x00000030)        /*!< Full remap (TX/PD8, RX/PD9, CK/PD10, CTS/PD11, RTS/PD12) */
N
N#define AFIO_MAPR_TIM1_REMAP                 ((uint32_t)0x000000C0)        /*!< TIM1_REMAP[1:0] bits (TIM1 remapping) */
N#define AFIO_MAPR_TIM1_REMAP_0               ((uint32_t)0x00000040)        /*!< Bit 0 */
N#define AFIO_MAPR_TIM1_REMAP_1               ((uint32_t)0x00000080)        /*!< Bit 1 */
N
N/*!< TIM1_REMAP configuration */
N#define AFIO_MAPR_TIM1_REMAP_NOREMAP         ((uint32_t)0x00000000)        /*!< No remap (ETR/PA12, CH1/PA8, CH2/PA9, CH3/PA10, CH4/PA11, BKIN/PB12, CH1N/PB13, CH2N/PB14, CH3N/PB15) */
N#define AFIO_MAPR_TIM1_REMAP_PARTIALREMAP    ((uint32_t)0x00000040)        /*!< Partial remap (ETR/PA12, CH1/PA8, CH2/PA9, CH3/PA10, CH4/PA11, BKIN/PA6, CH1N/PA7, CH2N/PB0, CH3N/PB1) */
N#define AFIO_MAPR_TIM1_REMAP_FULLREMAP       ((uint32_t)0x000000C0)        /*!< Full remap (ETR/PE7, CH1/PE9, CH2/PE11, CH3/PE13, CH4/PE14, BKIN/PE15, CH1N/PE8, CH2N/PE10, CH3N/PE12) */
N
N#define AFIO_MAPR_TIM2_REMAP                 ((uint32_t)0x00000300)        /*!< TIM2_REMAP[1:0] bits (TIM2 remapping) */
N#define AFIO_MAPR_TIM2_REMAP_0               ((uint32_t)0x00000100)        /*!< Bit 0 */
N#define AFIO_MAPR_TIM2_REMAP_1               ((uint32_t)0x00000200)        /*!< Bit 1 */
N
N/*!< TIM2_REMAP configuration */
N#define AFIO_MAPR_TIM2_REMAP_NOREMAP         ((uint32_t)0x00000000)        /*!< No remap (CH1/ETR/PA0, CH2/PA1, CH3/PA2, CH4/PA3) */
N#define AFIO_MAPR_TIM2_REMAP_PARTIALREMAP1   ((uint32_t)0x00000100)        /*!< Partial remap (CH1/ETR/PA15, CH2/PB3, CH3/PA2, CH4/PA3) */
N#define AFIO_MAPR_TIM2_REMAP_PARTIALREMAP2   ((uint32_t)0x00000200)        /*!< Partial remap (CH1/ETR/PA0, CH2/PA1, CH3/PB10, CH4/PB11) */
N#define AFIO_MAPR_TIM2_REMAP_FULLREMAP       ((uint32_t)0x00000300)        /*!< Full remap (CH1/ETR/PA15, CH2/PB3, CH3/PB10, CH4/PB11) */
N
N#define AFIO_MAPR_TIM3_REMAP                 ((uint32_t)0x00000C00)        /*!< TIM3_REMAP[1:0] bits (TIM3 remapping) */
N#define AFIO_MAPR_TIM3_REMAP_0               ((uint32_t)0x00000400)        /*!< Bit 0 */
N#define AFIO_MAPR_TIM3_REMAP_1               ((uint32_t)0x00000800)        /*!< Bit 1 */
N
N/*!< TIM3_REMAP configuration */
N#define AFIO_MAPR_TIM3_REMAP_NOREMAP         ((uint32_t)0x00000000)        /*!< No remap (CH1/PA6, CH2/PA7, CH3/PB0, CH4/PB1) */
N#define AFIO_MAPR_TIM3_REMAP_PARTIALREMAP    ((uint32_t)0x00000800)        /*!< Partial remap (CH1/PB4, CH2/PB5, CH3/PB0, CH4/PB1) */
N#define AFIO_MAPR_TIM3_REMAP_FULLREMAP       ((uint32_t)0x00000C00)        /*!< Full remap (CH1/PC6, CH2/PC7, CH3/PC8, CH4/PC9) */
N
N#define AFIO_MAPR_TIM4_REMAP                 ((uint32_t)0x00001000)        /*!< TIM4_REMAP bit (TIM4 remapping) */
N
N#define AFIO_MAPR_CAN_REMAP                  ((uint32_t)0x00006000)        /*!< CAN_REMAP[1:0] bits (CAN Alternate function remapping) */
N#define AFIO_MAPR_CAN_REMAP_0                ((uint32_t)0x00002000)        /*!< Bit 0 */
N#define AFIO_MAPR_CAN_REMAP_1                ((uint32_t)0x00004000)        /*!< Bit 1 */
N
N/*!< CAN_REMAP configuration */
N#define AFIO_MAPR_CAN_REMAP_REMAP1           ((uint32_t)0x00000000)        /*!< CANRX mapped to PA11, CANTX mapped to PA12 */
N#define AFIO_MAPR_CAN_REMAP_REMAP2           ((uint32_t)0x00004000)        /*!< CANRX mapped to PB8, CANTX mapped to PB9 */
N#define AFIO_MAPR_CAN_REMAP_REMAP3           ((uint32_t)0x00006000)        /*!< CANRX mapped to PD0, CANTX mapped to PD1 */
N
N#define AFIO_MAPR_PD01_REMAP                 ((uint32_t)0x00008000)        /*!< Port D0/Port D1 mapping on OSC_IN/OSC_OUT */
N#define AFIO_MAPR_TIM5CH4_IREMAP             ((uint32_t)0x00010000)        /*!< TIM5 Channel4 Internal Remap */
N#define AFIO_MAPR_ADC1_ETRGINJ_REMAP         ((uint32_t)0x00020000)        /*!< ADC 1 External Trigger Injected Conversion remapping */
N#define AFIO_MAPR_ADC1_ETRGREG_REMAP         ((uint32_t)0x00040000)        /*!< ADC 1 External Trigger Regular Conversion remapping */
N#define AFIO_MAPR_ADC2_ETRGINJ_REMAP         ((uint32_t)0x00080000)        /*!< ADC 2 External Trigger Injected Conversion remapping */
N#define AFIO_MAPR_ADC2_ETRGREG_REMAP         ((uint32_t)0x00100000)        /*!< ADC 2 External Trigger Regular Conversion remapping */
N
N/*!< SWJ_CFG configuration */
N#define AFIO_MAPR_SWJ_CFG                    ((uint32_t)0x07000000)        /*!< SWJ_CFG[2:0] bits (Serial Wire JTAG configuration) */
N#define AFIO_MAPR_SWJ_CFG_0                  ((uint32_t)0x01000000)        /*!< Bit 0 */
N#define AFIO_MAPR_SWJ_CFG_1                  ((uint32_t)0x02000000)        /*!< Bit 1 */
N#define AFIO_MAPR_SWJ_CFG_2                  ((uint32_t)0x04000000)        /*!< Bit 2 */
N
N#define AFIO_MAPR_SWJ_CFG_RESET              ((uint32_t)0x00000000)        /*!< Full SWJ (JTAG-DP + SW-DP) : Reset State */
N#define AFIO_MAPR_SWJ_CFG_NOJNTRST           ((uint32_t)0x01000000)        /*!< Full SWJ (JTAG-DP + SW-DP) but without JNTRST */
N#define AFIO_MAPR_SWJ_CFG_JTAGDISABLE        ((uint32_t)0x02000000)        /*!< JTAG-DP Disabled and SW-DP Enabled */
N#define AFIO_MAPR_SWJ_CFG_DISABLE            ((uint32_t)0x04000000)        /*!< JTAG-DP Disabled and SW-DP Disabled */
N
N#ifdef STM32F10X_CL
S/*!< ETH_REMAP configuration */
S #define AFIO_MAPR_ETH_REMAP                  ((uint32_t)0x00200000)        /*!< SPI3_REMAP bit (Ethernet MAC I/O remapping) */
S
S/*!< CAN2_REMAP configuration */
S #define AFIO_MAPR_CAN2_REMAP                 ((uint32_t)0x00400000)        /*!< CAN2_REMAP bit (CAN2 I/O remapping) */
S
S/*!< MII_RMII_SEL configuration */
S #define AFIO_MAPR_MII_RMII_SEL               ((uint32_t)0x00800000)        /*!< MII_RMII_SEL bit (Ethernet MII or RMII selection) */
S
S/*!< SPI3_REMAP configuration */
S #define AFIO_MAPR_SPI3_REMAP                 ((uint32_t)0x10000000)        /*!< SPI3_REMAP bit (SPI3 remapping) */
S
S/*!< TIM2ITR1_IREMAP configuration */
S #define AFIO_MAPR_TIM2ITR1_IREMAP            ((uint32_t)0x20000000)        /*!< TIM2ITR1_IREMAP bit (TIM2 internal trigger 1 remapping) */
S
S/*!< PTP_PPS_REMAP configuration */
S #define AFIO_MAPR_PTP_PPS_REMAP              ((uint32_t)0x40000000)        /*!< PTP_PPS_REMAP bit (Ethernet PTP PPS remapping) */
N#endif
N
N/*****************  Bit definition for AFIO_EXTICR1 register  *****************/
N#define AFIO_EXTICR1_EXTI0                   ((uint16_t)0x000F)            /*!< EXTI 0 configuration */
N#define AFIO_EXTICR1_EXTI1                   ((uint16_t)0x00F0)            /*!< EXTI 1 configuration */
N#define AFIO_EXTICR1_EXTI2                   ((uint16_t)0x0F00)            /*!< EXTI 2 configuration */
N#define AFIO_EXTICR1_EXTI3                   ((uint16_t)0xF000)            /*!< EXTI 3 configuration */
N
N/*!< EXTI0 configuration */
N#define AFIO_EXTICR1_EXTI0_PA                ((uint16_t)0x0000)            /*!< PA[0] pin */
N#define AFIO_EXTICR1_EXTI0_PB                ((uint16_t)0x0001)            /*!< PB[0] pin */
N#define AFIO_EXTICR1_EXTI0_PC                ((uint16_t)0x0002)            /*!< PC[0] pin */
N#define AFIO_EXTICR1_EXTI0_PD                ((uint16_t)0x0003)            /*!< PD[0] pin */
N#define AFIO_EXTICR1_EXTI0_PE                ((uint16_t)0x0004)            /*!< PE[0] pin */
N#define AFIO_EXTICR1_EXTI0_PF                ((uint16_t)0x0005)            /*!< PF[0] pin */
N#define AFIO_EXTICR1_EXTI0_PG                ((uint16_t)0x0006)            /*!< PG[0] pin */
N
N/*!< EXTI1 configuration */
N#define AFIO_EXTICR1_EXTI1_PA                ((uint16_t)0x0000)            /*!< PA[1] pin */
N#define AFIO_EXTICR1_EXTI1_PB                ((uint16_t)0x0010)            /*!< PB[1] pin */
N#define AFIO_EXTICR1_EXTI1_PC                ((uint16_t)0x0020)            /*!< PC[1] pin */
N#define AFIO_EXTICR1_EXTI1_PD                ((uint16_t)0x0030)            /*!< PD[1] pin */
N#define AFIO_EXTICR1_EXTI1_PE                ((uint16_t)0x0040)            /*!< PE[1] pin */
N#define AFIO_EXTICR1_EXTI1_PF                ((uint16_t)0x0050)            /*!< PF[1] pin */
N#define AFIO_EXTICR1_EXTI1_PG                ((uint16_t)0x0060)            /*!< PG[1] pin */
N
N/*!< EXTI2 configuration */  
N#define AFIO_EXTICR1_EXTI2_PA                ((uint16_t)0x0000)            /*!< PA[2] pin */
N#define AFIO_EXTICR1_EXTI2_PB                ((uint16_t)0x0100)            /*!< PB[2] pin */
N#define AFIO_EXTICR1_EXTI2_PC                ((uint16_t)0x0200)            /*!< PC[2] pin */
N#define AFIO_EXTICR1_EXTI2_PD                ((uint16_t)0x0300)            /*!< PD[2] pin */
N#define AFIO_EXTICR1_EXTI2_PE                ((uint16_t)0x0400)            /*!< PE[2] pin */
N#define AFIO_EXTICR1_EXTI2_PF                ((uint16_t)0x0500)            /*!< PF[2] pin */
N#define AFIO_EXTICR1_EXTI2_PG                ((uint16_t)0x0600)            /*!< PG[2] pin */
N
N/*!< EXTI3 configuration */
N#define AFIO_EXTICR1_EXTI3_PA                ((uint16_t)0x0000)            /*!< PA[3] pin */
N#define AFIO_EXTICR1_EXTI3_PB                ((uint16_t)0x1000)            /*!< PB[3] pin */
N#define AFIO_EXTICR1_EXTI3_PC                ((uint16_t)0x2000)            /*!< PC[3] pin */
N#define AFIO_EXTICR1_EXTI3_PD                ((uint16_t)0x3000)            /*!< PD[3] pin */
N#define AFIO_EXTICR1_EXTI3_PE                ((uint16_t)0x4000)            /*!< PE[3] pin */
N#define AFIO_EXTICR1_EXTI3_PF                ((uint16_t)0x5000)            /*!< PF[3] pin */
N#define AFIO_EXTICR1_EXTI3_PG                ((uint16_t)0x6000)            /*!< PG[3] pin */
N
N/*****************  Bit definition for AFIO_EXTICR2 register  *****************/
N#define AFIO_EXTICR2_EXTI4                   ((uint16_t)0x000F)            /*!< EXTI 4 configuration */
N#define AFIO_EXTICR2_EXTI5                   ((uint16_t)0x00F0)            /*!< EXTI 5 configuration */
N#define AFIO_EXTICR2_EXTI6                   ((uint16_t)0x0F00)            /*!< EXTI 6 configuration */
N#define AFIO_EXTICR2_EXTI7                   ((uint16_t)0xF000)            /*!< EXTI 7 configuration */
N
N/*!< EXTI4 configuration */
N#define AFIO_EXTICR2_EXTI4_PA                ((uint16_t)0x0000)            /*!< PA[4] pin */
N#define AFIO_EXTICR2_EXTI4_PB                ((uint16_t)0x0001)            /*!< PB[4] pin */
N#define AFIO_EXTICR2_EXTI4_PC                ((uint16_t)0x0002)            /*!< PC[4] pin */
N#define AFIO_EXTICR2_EXTI4_PD                ((uint16_t)0x0003)            /*!< PD[4] pin */
N#define AFIO_EXTICR2_EXTI4_PE                ((uint16_t)0x0004)            /*!< PE[4] pin */
N#define AFIO_EXTICR2_EXTI4_PF                ((uint16_t)0x0005)            /*!< PF[4] pin */
N#define AFIO_EXTICR2_EXTI4_PG                ((uint16_t)0x0006)            /*!< PG[4] pin */
N
N/* EXTI5 configuration */
N#define AFIO_EXTICR2_EXTI5_PA                ((uint16_t)0x0000)            /*!< PA[5] pin */
N#define AFIO_EXTICR2_EXTI5_PB                ((uint16_t)0x0010)            /*!< PB[5] pin */
N#define AFIO_EXTICR2_EXTI5_PC                ((uint16_t)0x0020)            /*!< PC[5] pin */
N#define AFIO_EXTICR2_EXTI5_PD                ((uint16_t)0x0030)            /*!< PD[5] pin */
N#define AFIO_EXTICR2_EXTI5_PE                ((uint16_t)0x0040)            /*!< PE[5] pin */
N#define AFIO_EXTICR2_EXTI5_PF                ((uint16_t)0x0050)            /*!< PF[5] pin */
N#define AFIO_EXTICR2_EXTI5_PG                ((uint16_t)0x0060)            /*!< PG[5] pin */
N
N/*!< EXTI6 configuration */  
N#define AFIO_EXTICR2_EXTI6_PA                ((uint16_t)0x0000)            /*!< PA[6] pin */
N#define AFIO_EXTICR2_EXTI6_PB                ((uint16_t)0x0100)            /*!< PB[6] pin */
N#define AFIO_EXTICR2_EXTI6_PC                ((uint16_t)0x0200)            /*!< PC[6] pin */
N#define AFIO_EXTICR2_EXTI6_PD                ((uint16_t)0x0300)            /*!< PD[6] pin */
N#define AFIO_EXTICR2_EXTI6_PE                ((uint16_t)0x0400)            /*!< PE[6] pin */
N#define AFIO_EXTICR2_EXTI6_PF                ((uint16_t)0x0500)            /*!< PF[6] pin */
N#define AFIO_EXTICR2_EXTI6_PG                ((uint16_t)0x0600)            /*!< PG[6] pin */
N
N/*!< EXTI7 configuration */
N#define AFIO_EXTICR2_EXTI7_PA                ((uint16_t)0x0000)            /*!< PA[7] pin */
N#define AFIO_EXTICR2_EXTI7_PB                ((uint16_t)0x1000)            /*!< PB[7] pin */
N#define AFIO_EXTICR2_EXTI7_PC                ((uint16_t)0x2000)            /*!< PC[7] pin */
N#define AFIO_EXTICR2_EXTI7_PD                ((uint16_t)0x3000)            /*!< PD[7] pin */
N#define AFIO_EXTICR2_EXTI7_PE                ((uint16_t)0x4000)            /*!< PE[7] pin */
N#define AFIO_EXTICR2_EXTI7_PF                ((uint16_t)0x5000)            /*!< PF[7] pin */
N#define AFIO_EXTICR2_EXTI7_PG                ((uint16_t)0x6000)            /*!< PG[7] pin */
N
N/*****************  Bit definition for AFIO_EXTICR3 register  *****************/
N#define AFIO_EXTICR3_EXTI8                   ((uint16_t)0x000F)            /*!< EXTI 8 configuration */
N#define AFIO_EXTICR3_EXTI9                   ((uint16_t)0x00F0)            /*!< EXTI 9 configuration */
N#define AFIO_EXTICR3_EXTI10                  ((uint16_t)0x0F00)            /*!< EXTI 10 configuration */
N#define AFIO_EXTICR3_EXTI11                  ((uint16_t)0xF000)            /*!< EXTI 11 configuration */
N
N/*!< EXTI8 configuration */
N#define AFIO_EXTICR3_EXTI8_PA                ((uint16_t)0x0000)            /*!< PA[8] pin */
N#define AFIO_EXTICR3_EXTI8_PB                ((uint16_t)0x0001)            /*!< PB[8] pin */
N#define AFIO_EXTICR3_EXTI8_PC                ((uint16_t)0x0002)            /*!< PC[8] pin */
N#define AFIO_EXTICR3_EXTI8_PD                ((uint16_t)0x0003)            /*!< PD[8] pin */
N#define AFIO_EXTICR3_EXTI8_PE                ((uint16_t)0x0004)            /*!< PE[8] pin */
N#define AFIO_EXTICR3_EXTI8_PF                ((uint16_t)0x0005)            /*!< PF[8] pin */
N#define AFIO_EXTICR3_EXTI8_PG                ((uint16_t)0x0006)            /*!< PG[8] pin */
N
N/*!< EXTI9 configuration */
N#define AFIO_EXTICR3_EXTI9_PA                ((uint16_t)0x0000)            /*!< PA[9] pin */
N#define AFIO_EXTICR3_EXTI9_PB                ((uint16_t)0x0010)            /*!< PB[9] pin */
N#define AFIO_EXTICR3_EXTI9_PC                ((uint16_t)0x0020)            /*!< PC[9] pin */
N#define AFIO_EXTICR3_EXTI9_PD                ((uint16_t)0x0030)            /*!< PD[9] pin */
N#define AFIO_EXTICR3_EXTI9_PE                ((uint16_t)0x0040)            /*!< PE[9] pin */
N#define AFIO_EXTICR3_EXTI9_PF                ((uint16_t)0x0050)            /*!< PF[9] pin */
N#define AFIO_EXTICR3_EXTI9_PG                ((uint16_t)0x0060)            /*!< PG[9] pin */
N
N/*!< EXTI10 configuration */  
N#define AFIO_EXTICR3_EXTI10_PA               ((uint16_t)0x0000)            /*!< PA[10] pin */
N#define AFIO_EXTICR3_EXTI10_PB               ((uint16_t)0x0100)            /*!< PB[10] pin */
N#define AFIO_EXTICR3_EXTI10_PC               ((uint16_t)0x0200)            /*!< PC[10] pin */
N#define AFIO_EXTICR3_EXTI10_PD               ((uint16_t)0x0300)            /*!< PD[10] pin */
N#define AFIO_EXTICR3_EXTI10_PE               ((uint16_t)0x0400)            /*!< PE[10] pin */
N#define AFIO_EXTICR3_EXTI10_PF               ((uint16_t)0x0500)            /*!< PF[10] pin */
N#define AFIO_EXTICR3_EXTI10_PG               ((uint16_t)0x0600)            /*!< PG[10] pin */
N
N/*!< EXTI11 configuration */
N#define AFIO_EXTICR3_EXTI11_PA               ((uint16_t)0x0000)            /*!< PA[11] pin */
N#define AFIO_EXTICR3_EXTI11_PB               ((uint16_t)0x1000)            /*!< PB[11] pin */
N#define AFIO_EXTICR3_EXTI11_PC               ((uint16_t)0x2000)            /*!< PC[11] pin */
N#define AFIO_EXTICR3_EXTI11_PD               ((uint16_t)0x3000)            /*!< PD[11] pin */
N#define AFIO_EXTICR3_EXTI11_PE               ((uint16_t)0x4000)            /*!< PE[11] pin */
N#define AFIO_EXTICR3_EXTI11_PF               ((uint16_t)0x5000)            /*!< PF[11] pin */
N#define AFIO_EXTICR3_EXTI11_PG               ((uint16_t)0x6000)            /*!< PG[11] pin */
N
N/*****************  Bit definition for AFIO_EXTICR4 register  *****************/
N#define AFIO_EXTICR4_EXTI12                  ((uint16_t)0x000F)            /*!< EXTI 12 configuration */
N#define AFIO_EXTICR4_EXTI13                  ((uint16_t)0x00F0)            /*!< EXTI 13 configuration */
N#define AFIO_EXTICR4_EXTI14                  ((uint16_t)0x0F00)            /*!< EXTI 14 configuration */
N#define AFIO_EXTICR4_EXTI15                  ((uint16_t)0xF000)            /*!< EXTI 15 configuration */
N
N/* EXTI12 configuration */
N#define AFIO_EXTICR4_EXTI12_PA               ((uint16_t)0x0000)            /*!< PA[12] pin */
N#define AFIO_EXTICR4_EXTI12_PB               ((uint16_t)0x0001)            /*!< PB[12] pin */
N#define AFIO_EXTICR4_EXTI12_PC               ((uint16_t)0x0002)            /*!< PC[12] pin */
N#define AFIO_EXTICR4_EXTI12_PD               ((uint16_t)0x0003)            /*!< PD[12] pin */
N#define AFIO_EXTICR4_EXTI12_PE               ((uint16_t)0x0004)            /*!< PE[12] pin */
N#define AFIO_EXTICR4_EXTI12_PF               ((uint16_t)0x0005)            /*!< PF[12] pin */
N#define AFIO_EXTICR4_EXTI12_PG               ((uint16_t)0x0006)            /*!< PG[12] pin */
N
N/* EXTI13 configuration */
N#define AFIO_EXTICR4_EXTI13_PA               ((uint16_t)0x0000)            /*!< PA[13] pin */
N#define AFIO_EXTICR4_EXTI13_PB               ((uint16_t)0x0010)            /*!< PB[13] pin */
N#define AFIO_EXTICR4_EXTI13_PC               ((uint16_t)0x0020)            /*!< PC[13] pin */
N#define AFIO_EXTICR4_EXTI13_PD               ((uint16_t)0x0030)            /*!< PD[13] pin */
N#define AFIO_EXTICR4_EXTI13_PE               ((uint16_t)0x0040)            /*!< PE[13] pin */
N#define AFIO_EXTICR4_EXTI13_PF               ((uint16_t)0x0050)            /*!< PF[13] pin */
N#define AFIO_EXTICR4_EXTI13_PG               ((uint16_t)0x0060)            /*!< PG[13] pin */
N
N/*!< EXTI14 configuration */  
N#define AFIO_EXTICR4_EXTI14_PA               ((uint16_t)0x0000)            /*!< PA[14] pin */
N#define AFIO_EXTICR4_EXTI14_PB               ((uint16_t)0x0100)            /*!< PB[14] pin */
N#define AFIO_EXTICR4_EXTI14_PC               ((uint16_t)0x0200)            /*!< PC[14] pin */
N#define AFIO_EXTICR4_EXTI14_PD               ((uint16_t)0x0300)            /*!< PD[14] pin */
N#define AFIO_EXTICR4_EXTI14_PE               ((uint16_t)0x0400)            /*!< PE[14] pin */
N#define AFIO_EXTICR4_EXTI14_PF               ((uint16_t)0x0500)            /*!< PF[14] pin */
N#define AFIO_EXTICR4_EXTI14_PG               ((uint16_t)0x0600)            /*!< PG[14] pin */
N
N/*!< EXTI15 configuration */
N#define AFIO_EXTICR4_EXTI15_PA               ((uint16_t)0x0000)            /*!< PA[15] pin */
N#define AFIO_EXTICR4_EXTI15_PB               ((uint16_t)0x1000)            /*!< PB[15] pin */
N#define AFIO_EXTICR4_EXTI15_PC               ((uint16_t)0x2000)            /*!< PC[15] pin */
N#define AFIO_EXTICR4_EXTI15_PD               ((uint16_t)0x3000)            /*!< PD[15] pin */
N#define AFIO_EXTICR4_EXTI15_PE               ((uint16_t)0x4000)            /*!< PE[15] pin */
N#define AFIO_EXTICR4_EXTI15_PF               ((uint16_t)0x5000)            /*!< PF[15] pin */
N#define AFIO_EXTICR4_EXTI15_PG               ((uint16_t)0x6000)            /*!< PG[15] pin */
N
N#if defined (STM32F10X_LD_VL) || defined (STM32F10X_MD_VL) || defined (STM32F10X_HD_VL)
X#if 0L || 0L || 0L
S/******************  Bit definition for AFIO_MAPR2 register  ******************/
S#define AFIO_MAPR2_TIM15_REMAP               ((uint32_t)0x00000001)        /*!< TIM15 remapping */
S#define AFIO_MAPR2_TIM16_REMAP               ((uint32_t)0x00000002)        /*!< TIM16 remapping */
S#define AFIO_MAPR2_TIM17_REMAP               ((uint32_t)0x00000004)        /*!< TIM17 remapping */
S#define AFIO_MAPR2_CEC_REMAP                 ((uint32_t)0x00000008)        /*!< CEC remapping */
S#define AFIO_MAPR2_TIM1_DMA_REMAP            ((uint32_t)0x00000010)        /*!< TIM1_DMA remapping */
N#endif
N
N#ifdef STM32F10X_HD_VL
S#define AFIO_MAPR2_TIM13_REMAP               ((uint32_t)0x00000100)        /*!< TIM13 remapping */
S#define AFIO_MAPR2_TIM14_REMAP               ((uint32_t)0x00000200)        /*!< TIM14 remapping */
S#define AFIO_MAPR2_FSMC_NADV_REMAP           ((uint32_t)0x00000400)        /*!< FSMC NADV remapping */
S#define AFIO_MAPR2_TIM67_DAC_DMA_REMAP       ((uint32_t)0x00000800)        /*!< TIM6/TIM7 and DAC DMA remapping */
S#define AFIO_MAPR2_TIM12_REMAP               ((uint32_t)0x00001000)        /*!< TIM12 remapping */
S#define AFIO_MAPR2_MISC_REMAP                ((uint32_t)0x00002000)        /*!< Miscellaneous remapping */
N#endif
N
N#ifdef STM32F10X_XL 
S/******************  Bit definition for AFIO_MAPR2 register  ******************/
S#define AFIO_MAPR2_TIM9_REMAP                ((uint32_t)0x00000020)        /*!< TIM9 remapping */
S#define AFIO_MAPR2_TIM10_REMAP               ((uint32_t)0x00000040)        /*!< TIM10 remapping */
S#define AFIO_MAPR2_TIM11_REMAP               ((uint32_t)0x00000080)        /*!< TIM11 remapping */
S#define AFIO_MAPR2_TIM13_REMAP               ((uint32_t)0x00000100)        /*!< TIM13 remapping */
S#define AFIO_MAPR2_TIM14_REMAP               ((uint32_t)0x00000200)        /*!< TIM14 remapping */
S#define AFIO_MAPR2_FSMC_NADV_REMAP           ((uint32_t)0x00000400)        /*!< FSMC NADV remapping */
N#endif
N
N/******************************************************************************/
N/*                                                                            */
N/*                               SystemTick                                   */
N/*                                                                            */
N/******************************************************************************/
N
N/*****************  Bit definition for SysTick_CTRL register  *****************/
N#define  SysTick_CTRL_ENABLE                 ((uint32_t)0x00000001)        /*!< Counter enable */
N#define  SysTick_CTRL_TICKINT                ((uint32_t)0x00000002)        /*!< Counting down to 0 pends the SysTick handler */
N#define  SysTick_CTRL_CLKSOURCE              ((uint32_t)0x00000004)        /*!< Clock source */
N#define  SysTick_CTRL_COUNTFLAG              ((uint32_t)0x00010000)        /*!< Count Flag */
N
N/*****************  Bit definition for SysTick_LOAD register  *****************/
N#define  SysTick_LOAD_RELOAD                 ((uint32_t)0x00FFFFFF)        /*!< Value to load into the SysTick Current Value Register when the counter reaches 0 */
N
N/*****************  Bit definition for SysTick_VAL register  ******************/
N#define  SysTick_VAL_CURRENT                 ((uint32_t)0x00FFFFFF)        /*!< Current value at the time the register is accessed */
N
N/*****************  Bit definition for SysTick_CALIB register  ****************/
N#define  SysTick_CALIB_TENMS                 ((uint32_t)0x00FFFFFF)        /*!< Reload value to use for 10ms timing */
N#define  SysTick_CALIB_SKEW                  ((uint32_t)0x40000000)        /*!< Calibration value is not exactly 10 ms */
N#define  SysTick_CALIB_NOREF                 ((uint32_t)0x80000000)        /*!< The reference clock is not provided */
N
N/******************************************************************************/
N/*                                                                            */
N/*                  Nested Vectored Interrupt Controller                      */
N/*                                                                            */
N/******************************************************************************/
N
N/******************  Bit definition for NVIC_ISER register  *******************/
N#define  NVIC_ISER_SETENA                    ((uint32_t)0xFFFFFFFF)        /*!< Interrupt set enable bits */
N#define  NVIC_ISER_SETENA_0                  ((uint32_t)0x00000001)        /*!< bit 0 */
N#define  NVIC_ISER_SETENA_1                  ((uint32_t)0x00000002)        /*!< bit 1 */
N#define  NVIC_ISER_SETENA_2                  ((uint32_t)0x00000004)        /*!< bit 2 */
N#define  NVIC_ISER_SETENA_3                  ((uint32_t)0x00000008)        /*!< bit 3 */
N#define  NVIC_ISER_SETENA_4                  ((uint32_t)0x00000010)        /*!< bit 4 */
N#define  NVIC_ISER_SETENA_5                  ((uint32_t)0x00000020)        /*!< bit 5 */
N#define  NVIC_ISER_SETENA_6                  ((uint32_t)0x00000040)        /*!< bit 6 */
N#define  NVIC_ISER_SETENA_7                  ((uint32_t)0x00000080)        /*!< bit 7 */
N#define  NVIC_ISER_SETENA_8                  ((uint32_t)0x00000100)        /*!< bit 8 */
N#define  NVIC_ISER_SETENA_9                  ((uint32_t)0x00000200)        /*!< bit 9 */
N#define  NVIC_ISER_SETENA_10                 ((uint32_t)0x00000400)        /*!< bit 10 */
N#define  NVIC_ISER_SETENA_11                 ((uint32_t)0x00000800)        /*!< bit 11 */
N#define  NVIC_ISER_SETENA_12                 ((uint32_t)0x00001000)        /*!< bit 12 */
N#define  NVIC_ISER_SETENA_13                 ((uint32_t)0x00002000)        /*!< bit 13 */
N#define  NVIC_ISER_SETENA_14                 ((uint32_t)0x00004000)        /*!< bit 14 */
N#define  NVIC_ISER_SETENA_15                 ((uint32_t)0x00008000)        /*!< bit 15 */
N#define  NVIC_ISER_SETENA_16                 ((uint32_t)0x00010000)        /*!< bit 16 */
N#define  NVIC_ISER_SETENA_17                 ((uint32_t)0x00020000)        /*!< bit 17 */
N#define  NVIC_ISER_SETENA_18                 ((uint32_t)0x00040000)        /*!< bit 18 */
N#define  NVIC_ISER_SETENA_19                 ((uint32_t)0x00080000)        /*!< bit 19 */
N#define  NVIC_ISER_SETENA_20                 ((uint32_t)0x00100000)        /*!< bit 20 */
N#define  NVIC_ISER_SETENA_21                 ((uint32_t)0x00200000)        /*!< bit 21 */
N#define  NVIC_ISER_SETENA_22                 ((uint32_t)0x00400000)        /*!< bit 22 */
N#define  NVIC_ISER_SETENA_23                 ((uint32_t)0x00800000)        /*!< bit 23 */
N#define  NVIC_ISER_SETENA_24                 ((uint32_t)0x01000000)        /*!< bit 24 */
N#define  NVIC_ISER_SETENA_25                 ((uint32_t)0x02000000)        /*!< bit 25 */
N#define  NVIC_ISER_SETENA_26                 ((uint32_t)0x04000000)        /*!< bit 26 */
N#define  NVIC_ISER_SETENA_27                 ((uint32_t)0x08000000)        /*!< bit 27 */
N#define  NVIC_ISER_SETENA_28                 ((uint32_t)0x10000000)        /*!< bit 28 */
N#define  NVIC_ISER_SETENA_29                 ((uint32_t)0x20000000)        /*!< bit 29 */
N#define  NVIC_ISER_SETENA_30                 ((uint32_t)0x40000000)        /*!< bit 30 */
N#define  NVIC_ISER_SETENA_31                 ((uint32_t)0x80000000)        /*!< bit 31 */
N
N/******************  Bit definition for NVIC_ICER register  *******************/
N#define  NVIC_ICER_CLRENA                   ((uint32_t)0xFFFFFFFF)        /*!< Interrupt clear-enable bits */
N#define  NVIC_ICER_CLRENA_0                  ((uint32_t)0x00000001)        /*!< bit 0 */
N#define  NVIC_ICER_CLRENA_1                  ((uint32_t)0x00000002)        /*!< bit 1 */
N#define  NVIC_ICER_CLRENA_2                  ((uint32_t)0x00000004)        /*!< bit 2 */
N#define  NVIC_ICER_CLRENA_3                  ((uint32_t)0x00000008)        /*!< bit 3 */
N#define  NVIC_ICER_CLRENA_4                  ((uint32_t)0x00000010)        /*!< bit 4 */
N#define  NVIC_ICER_CLRENA_5                  ((uint32_t)0x00000020)        /*!< bit 5 */
N#define  NVIC_ICER_CLRENA_6                  ((uint32_t)0x00000040)        /*!< bit 6 */
N#define  NVIC_ICER_CLRENA_7                  ((uint32_t)0x00000080)        /*!< bit 7 */
N#define  NVIC_ICER_CLRENA_8                  ((uint32_t)0x00000100)        /*!< bit 8 */
N#define  NVIC_ICER_CLRENA_9                  ((uint32_t)0x00000200)        /*!< bit 9 */
N#define  NVIC_ICER_CLRENA_10                 ((uint32_t)0x00000400)        /*!< bit 10 */
N#define  NVIC_ICER_CLRENA_11                 ((uint32_t)0x00000800)        /*!< bit 11 */
N#define  NVIC_ICER_CLRENA_12                 ((uint32_t)0x00001000)        /*!< bit 12 */
N#define  NVIC_ICER_CLRENA_13                 ((uint32_t)0x00002000)        /*!< bit 13 */
N#define  NVIC_ICER_CLRENA_14                 ((uint32_t)0x00004000)        /*!< bit 14 */
N#define  NVIC_ICER_CLRENA_15                 ((uint32_t)0x00008000)        /*!< bit 15 */
N#define  NVIC_ICER_CLRENA_16                 ((uint32_t)0x00010000)        /*!< bit 16 */
N#define  NVIC_ICER_CLRENA_17                 ((uint32_t)0x00020000)        /*!< bit 17 */
N#define  NVIC_ICER_CLRENA_18                 ((uint32_t)0x00040000)        /*!< bit 18 */
N#define  NVIC_ICER_CLRENA_19                 ((uint32_t)0x00080000)        /*!< bit 19 */
N#define  NVIC_ICER_CLRENA_20                 ((uint32_t)0x00100000)        /*!< bit 20 */
N#define  NVIC_ICER_CLRENA_21                 ((uint32_t)0x00200000)        /*!< bit 21 */
N#define  NVIC_ICER_CLRENA_22                 ((uint32_t)0x00400000)        /*!< bit 22 */
N#define  NVIC_ICER_CLRENA_23                 ((uint32_t)0x00800000)        /*!< bit 23 */
N#define  NVIC_ICER_CLRENA_24                 ((uint32_t)0x01000000)        /*!< bit 24 */
N#define  NVIC_ICER_CLRENA_25                 ((uint32_t)0x02000000)        /*!< bit 25 */
N#define  NVIC_ICER_CLRENA_26                 ((uint32_t)0x04000000)        /*!< bit 26 */
N#define  NVIC_ICER_CLRENA_27                 ((uint32_t)0x08000000)        /*!< bit 27 */
N#define  NVIC_ICER_CLRENA_28                 ((uint32_t)0x10000000)        /*!< bit 28 */
N#define  NVIC_ICER_CLRENA_29                 ((uint32_t)0x20000000)        /*!< bit 29 */
N#define  NVIC_ICER_CLRENA_30                 ((uint32_t)0x40000000)        /*!< bit 30 */
N#define  NVIC_ICER_CLRENA_31                 ((uint32_t)0x80000000)        /*!< bit 31 */
N
N/******************  Bit definition for NVIC_ISPR register  *******************/
N#define  NVIC_ISPR_SETPEND                   ((uint32_t)0xFFFFFFFF)        /*!< Interrupt set-pending bits */
N#define  NVIC_ISPR_SETPEND_0                 ((uint32_t)0x00000001)        /*!< bit 0 */
N#define  NVIC_ISPR_SETPEND_1                 ((uint32_t)0x00000002)        /*!< bit 1 */
N#define  NVIC_ISPR_SETPEND_2                 ((uint32_t)0x00000004)        /*!< bit 2 */
N#define  NVIC_ISPR_SETPEND_3                 ((uint32_t)0x00000008)        /*!< bit 3 */
N#define  NVIC_ISPR_SETPEND_4                 ((uint32_t)0x00000010)        /*!< bit 4 */
N#define  NVIC_ISPR_SETPEND_5                 ((uint32_t)0x00000020)        /*!< bit 5 */
N#define  NVIC_ISPR_SETPEND_6                 ((uint32_t)0x00000040)        /*!< bit 6 */
N#define  NVIC_ISPR_SETPEND_7                 ((uint32_t)0x00000080)        /*!< bit 7 */
N#define  NVIC_ISPR_SETPEND_8                 ((uint32_t)0x00000100)        /*!< bit 8 */
N#define  NVIC_ISPR_SETPEND_9                 ((uint32_t)0x00000200)        /*!< bit 9 */
N#define  NVIC_ISPR_SETPEND_10                ((uint32_t)0x00000400)        /*!< bit 10 */
N#define  NVIC_ISPR_SETPEND_11                ((uint32_t)0x00000800)        /*!< bit 11 */
N#define  NVIC_ISPR_SETPEND_12                ((uint32_t)0x00001000)        /*!< bit 12 */
N#define  NVIC_ISPR_SETPEND_13                ((uint32_t)0x00002000)        /*!< bit 13 */
N#define  NVIC_ISPR_SETPEND_14                ((uint32_t)0x00004000)        /*!< bit 14 */
N#define  NVIC_ISPR_SETPEND_15                ((uint32_t)0x00008000)        /*!< bit 15 */
N#define  NVIC_ISPR_SETPEND_16                ((uint32_t)0x00010000)        /*!< bit 16 */
N#define  NVIC_ISPR_SETPEND_17                ((uint32_t)0x00020000)        /*!< bit 17 */
N#define  NVIC_ISPR_SETPEND_18                ((uint32_t)0x00040000)        /*!< bit 18 */
N#define  NVIC_ISPR_SETPEND_19                ((uint32_t)0x00080000)        /*!< bit 19 */
N#define  NVIC_ISPR_SETPEND_20                ((uint32_t)0x00100000)        /*!< bit 20 */
N#define  NVIC_ISPR_SETPEND_21                ((uint32_t)0x00200000)        /*!< bit 21 */
N#define  NVIC_ISPR_SETPEND_22                ((uint32_t)0x00400000)        /*!< bit 22 */
N#define  NVIC_ISPR_SETPEND_23                ((uint32_t)0x00800000)        /*!< bit 23 */
N#define  NVIC_ISPR_SETPEND_24                ((uint32_t)0x01000000)        /*!< bit 24 */
N#define  NVIC_ISPR_SETPEND_25                ((uint32_t)0x02000000)        /*!< bit 25 */
N#define  NVIC_ISPR_SETPEND_26                ((uint32_t)0x04000000)        /*!< bit 26 */
N#define  NVIC_ISPR_SETPEND_27                ((uint32_t)0x08000000)        /*!< bit 27 */
N#define  NVIC_ISPR_SETPEND_28                ((uint32_t)0x10000000)        /*!< bit 28 */
N#define  NVIC_ISPR_SETPEND_29                ((uint32_t)0x20000000)        /*!< bit 29 */
N#define  NVIC_ISPR_SETPEND_30                ((uint32_t)0x40000000)        /*!< bit 30 */
N#define  NVIC_ISPR_SETPEND_31                ((uint32_t)0x80000000)        /*!< bit 31 */
N
N/******************  Bit definition for NVIC_ICPR register  *******************/
N#define  NVIC_ICPR_CLRPEND                   ((uint32_t)0xFFFFFFFF)        /*!< Interrupt clear-pending bits */
N#define  NVIC_ICPR_CLRPEND_0                 ((uint32_t)0x00000001)        /*!< bit 0 */
N#define  NVIC_ICPR_CLRPEND_1                 ((uint32_t)0x00000002)        /*!< bit 1 */
N#define  NVIC_ICPR_CLRPEND_2                 ((uint32_t)0x00000004)        /*!< bit 2 */
N#define  NVIC_ICPR_CLRPEND_3                 ((uint32_t)0x00000008)        /*!< bit 3 */
N#define  NVIC_ICPR_CLRPEND_4                 ((uint32_t)0x00000010)        /*!< bit 4 */
N#define  NVIC_ICPR_CLRPEND_5                 ((uint32_t)0x00000020)        /*!< bit 5 */
N#define  NVIC_ICPR_CLRPEND_6                 ((uint32_t)0x00000040)        /*!< bit 6 */
N#define  NVIC_ICPR_CLRPEND_7                 ((uint32_t)0x00000080)        /*!< bit 7 */
N#define  NVIC_ICPR_CLRPEND_8                 ((uint32_t)0x00000100)        /*!< bit 8 */
N#define  NVIC_ICPR_CLRPEND_9                 ((uint32_t)0x00000200)        /*!< bit 9 */
N#define  NVIC_ICPR_CLRPEND_10                ((uint32_t)0x00000400)        /*!< bit 10 */
N#define  NVIC_ICPR_CLRPEND_11                ((uint32_t)0x00000800)        /*!< bit 11 */
N#define  NVIC_ICPR_CLRPEND_12                ((uint32_t)0x00001000)        /*!< bit 12 */
N#define  NVIC_ICPR_CLRPEND_13                ((uint32_t)0x00002000)        /*!< bit 13 */
N#define  NVIC_ICPR_CLRPEND_14                ((uint32_t)0x00004000)        /*!< bit 14 */
N#define  NVIC_ICPR_CLRPEND_15                ((uint32_t)0x00008000)        /*!< bit 15 */
N#define  NVIC_ICPR_CLRPEND_16                ((uint32_t)0x00010000)        /*!< bit 16 */
N#define  NVIC_ICPR_CLRPEND_17                ((uint32_t)0x00020000)        /*!< bit 17 */
N#define  NVIC_ICPR_CLRPEND_18                ((uint32_t)0x00040000)        /*!< bit 18 */
N#define  NVIC_ICPR_CLRPEND_19                ((uint32_t)0x00080000)        /*!< bit 19 */
N#define  NVIC_ICPR_CLRPEND_20                ((uint32_t)0x00100000)        /*!< bit 20 */
N#define  NVIC_ICPR_CLRPEND_21                ((uint32_t)0x00200000)        /*!< bit 21 */
N#define  NVIC_ICPR_CLRPEND_22                ((uint32_t)0x00400000)        /*!< bit 22 */
N#define  NVIC_ICPR_CLRPEND_23                ((uint32_t)0x00800000)        /*!< bit 23 */
N#define  NVIC_ICPR_CLRPEND_24                ((uint32_t)0x01000000)        /*!< bit 24 */
N#define  NVIC_ICPR_CLRPEND_25                ((uint32_t)0x02000000)        /*!< bit 25 */
N#define  NVIC_ICPR_CLRPEND_26                ((uint32_t)0x04000000)        /*!< bit 26 */
N#define  NVIC_ICPR_CLRPEND_27                ((uint32_t)0x08000000)        /*!< bit 27 */
N#define  NVIC_ICPR_CLRPEND_28                ((uint32_t)0x10000000)        /*!< bit 28 */
N#define  NVIC_ICPR_CLRPEND_29                ((uint32_t)0x20000000)        /*!< bit 29 */
N#define  NVIC_ICPR_CLRPEND_30                ((uint32_t)0x40000000)        /*!< bit 30 */
N#define  NVIC_ICPR_CLRPEND_31                ((uint32_t)0x80000000)        /*!< bit 31 */
N
N/******************  Bit definition for NVIC_IABR register  *******************/
N#define  NVIC_IABR_ACTIVE                    ((uint32_t)0xFFFFFFFF)        /*!< Interrupt active flags */
N#define  NVIC_IABR_ACTIVE_0                  ((uint32_t)0x00000001)        /*!< bit 0 */
N#define  NVIC_IABR_ACTIVE_1                  ((uint32_t)0x00000002)        /*!< bit 1 */
N#define  NVIC_IABR_ACTIVE_2                  ((uint32_t)0x00000004)        /*!< bit 2 */
N#define  NVIC_IABR_ACTIVE_3                  ((uint32_t)0x00000008)        /*!< bit 3 */
N#define  NVIC_IABR_ACTIVE_4                  ((uint32_t)0x00000010)        /*!< bit 4 */
N#define  NVIC_IABR_ACTIVE_5                  ((uint32_t)0x00000020)        /*!< bit 5 */
N#define  NVIC_IABR_ACTIVE_6                  ((uint32_t)0x00000040)        /*!< bit 6 */
N#define  NVIC_IABR_ACTIVE_7                  ((uint32_t)0x00000080)        /*!< bit 7 */
N#define  NVIC_IABR_ACTIVE_8                  ((uint32_t)0x00000100)        /*!< bit 8 */
N#define  NVIC_IABR_ACTIVE_9                  ((uint32_t)0x00000200)        /*!< bit 9 */
N#define  NVIC_IABR_ACTIVE_10                 ((uint32_t)0x00000400)        /*!< bit 10 */
N#define  NVIC_IABR_ACTIVE_11                 ((uint32_t)0x00000800)        /*!< bit 11 */
N#define  NVIC_IABR_ACTIVE_12                 ((uint32_t)0x00001000)        /*!< bit 12 */
N#define  NVIC_IABR_ACTIVE_13                 ((uint32_t)0x00002000)        /*!< bit 13 */
N#define  NVIC_IABR_ACTIVE_14                 ((uint32_t)0x00004000)        /*!< bit 14 */
N#define  NVIC_IABR_ACTIVE_15                 ((uint32_t)0x00008000)        /*!< bit 15 */
N#define  NVIC_IABR_ACTIVE_16                 ((uint32_t)0x00010000)        /*!< bit 16 */
N#define  NVIC_IABR_ACTIVE_17                 ((uint32_t)0x00020000)        /*!< bit 17 */
N#define  NVIC_IABR_ACTIVE_18                 ((uint32_t)0x00040000)        /*!< bit 18 */
N#define  NVIC_IABR_ACTIVE_19                 ((uint32_t)0x00080000)        /*!< bit 19 */
N#define  NVIC_IABR_ACTIVE_20                 ((uint32_t)0x00100000)        /*!< bit 20 */
N#define  NVIC_IABR_ACTIVE_21                 ((uint32_t)0x00200000)        /*!< bit 21 */
N#define  NVIC_IABR_ACTIVE_22                 ((uint32_t)0x00400000)        /*!< bit 22 */
N#define  NVIC_IABR_ACTIVE_23                 ((uint32_t)0x00800000)        /*!< bit 23 */
N#define  NVIC_IABR_ACTIVE_24                 ((uint32_t)0x01000000)        /*!< bit 24 */
N#define  NVIC_IABR_ACTIVE_25                 ((uint32_t)0x02000000)        /*!< bit 25 */
N#define  NVIC_IABR_ACTIVE_26                 ((uint32_t)0x04000000)        /*!< bit 26 */
N#define  NVIC_IABR_ACTIVE_27                 ((uint32_t)0x08000000)        /*!< bit 27 */
N#define  NVIC_IABR_ACTIVE_28                 ((uint32_t)0x10000000)        /*!< bit 28 */
N#define  NVIC_IABR_ACTIVE_29                 ((uint32_t)0x20000000)        /*!< bit 29 */
N#define  NVIC_IABR_ACTIVE_30                 ((uint32_t)0x40000000)        /*!< bit 30 */
N#define  NVIC_IABR_ACTIVE_31                 ((uint32_t)0x80000000)        /*!< bit 31 */
N
N/******************  Bit definition for NVIC_PRI0 register  *******************/
N#define  NVIC_IPR0_PRI_0                     ((uint32_t)0x000000FF)        /*!< Priority of interrupt 0 */
N#define  NVIC_IPR0_PRI_1                     ((uint32_t)0x0000FF00)        /*!< Priority of interrupt 1 */
N#define  NVIC_IPR0_PRI_2                     ((uint32_t)0x00FF0000)        /*!< Priority of interrupt 2 */
N#define  NVIC_IPR0_PRI_3                     ((uint32_t)0xFF000000)        /*!< Priority of interrupt 3 */
N
N/******************  Bit definition for NVIC_PRI1 register  *******************/
N#define  NVIC_IPR1_PRI_4                     ((uint32_t)0x000000FF)        /*!< Priority of interrupt 4 */
N#define  NVIC_IPR1_PRI_5                     ((uint32_t)0x0000FF00)        /*!< Priority of interrupt 5 */
N#define  NVIC_IPR1_PRI_6                     ((uint32_t)0x00FF0000)        /*!< Priority of interrupt 6 */
N#define  NVIC_IPR1_PRI_7                     ((uint32_t)0xFF000000)        /*!< Priority of interrupt 7 */
N
N/******************  Bit definition for NVIC_PRI2 register  *******************/
N#define  NVIC_IPR2_PRI_8                     ((uint32_t)0x000000FF)        /*!< Priority of interrupt 8 */
N#define  NVIC_IPR2_PRI_9                     ((uint32_t)0x0000FF00)        /*!< Priority of interrupt 9 */
N#define  NVIC_IPR2_PRI_10                    ((uint32_t)0x00FF0000)        /*!< Priority of interrupt 10 */
N#define  NVIC_IPR2_PRI_11                    ((uint32_t)0xFF000000)        /*!< Priority of interrupt 11 */
N
N/******************  Bit definition for NVIC_PRI3 register  *******************/
N#define  NVIC_IPR3_PRI_12                    ((uint32_t)0x000000FF)        /*!< Priority of interrupt 12 */
N#define  NVIC_IPR3_PRI_13                    ((uint32_t)0x0000FF00)        /*!< Priority of interrupt 13 */
N#define  NVIC_IPR3_PRI_14                    ((uint32_t)0x00FF0000)        /*!< Priority of interrupt 14 */
N#define  NVIC_IPR3_PRI_15                    ((uint32_t)0xFF000000)        /*!< Priority of interrupt 15 */
N
N/******************  Bit definition for NVIC_PRI4 register  *******************/
N#define  NVIC_IPR4_PRI_16                    ((uint32_t)0x000000FF)        /*!< Priority of interrupt 16 */
N#define  NVIC_IPR4_PRI_17                    ((uint32_t)0x0000FF00)        /*!< Priority of interrupt 17 */
N#define  NVIC_IPR4_PRI_18                    ((uint32_t)0x00FF0000)        /*!< Priority of interrupt 18 */
N#define  NVIC_IPR4_PRI_19                    ((uint32_t)0xFF000000)        /*!< Priority of interrupt 19 */
N
N/******************  Bit definition for NVIC_PRI5 register  *******************/
N#define  NVIC_IPR5_PRI_20                    ((uint32_t)0x000000FF)        /*!< Priority of interrupt 20 */
N#define  NVIC_IPR5_PRI_21                    ((uint32_t)0x0000FF00)        /*!< Priority of interrupt 21 */
N#define  NVIC_IPR5_PRI_22                    ((uint32_t)0x00FF0000)        /*!< Priority of interrupt 22 */
N#define  NVIC_IPR5_PRI_23                    ((uint32_t)0xFF000000)        /*!< Priority of interrupt 23 */
N
N/******************  Bit definition for NVIC_PRI6 register  *******************/
N#define  NVIC_IPR6_PRI_24                    ((uint32_t)0x000000FF)        /*!< Priority of interrupt 24 */
N#define  NVIC_IPR6_PRI_25                    ((uint32_t)0x0000FF00)        /*!< Priority of interrupt 25 */
N#define  NVIC_IPR6_PRI_26                    ((uint32_t)0x00FF0000)        /*!< Priority of interrupt 26 */
N#define  NVIC_IPR6_PRI_27                    ((uint32_t)0xFF000000)        /*!< Priority of interrupt 27 */
N
N/******************  Bit definition for NVIC_PRI7 register  *******************/
N#define  NVIC_IPR7_PRI_28                    ((uint32_t)0x000000FF)        /*!< Priority of interrupt 28 */
N#define  NVIC_IPR7_PRI_29                    ((uint32_t)0x0000FF00)        /*!< Priority of interrupt 29 */
N#define  NVIC_IPR7_PRI_30                    ((uint32_t)0x00FF0000)        /*!< Priority of interrupt 30 */
N#define  NVIC_IPR7_PRI_31                    ((uint32_t)0xFF000000)        /*!< Priority of interrupt 31 */
N
N/******************  Bit definition for SCB_CPUID register  *******************/
N#define  SCB_CPUID_REVISION                  ((uint32_t)0x0000000F)        /*!< Implementation defined revision number */
N#define  SCB_CPUID_PARTNO                    ((uint32_t)0x0000FFF0)        /*!< Number of processor within family */
N#define  SCB_CPUID_Constant                  ((uint32_t)0x000F0000)        /*!< Reads as 0x0F */
N#define  SCB_CPUID_VARIANT                   ((uint32_t)0x00F00000)        /*!< Implementation defined variant number */
N#define  SCB_CPUID_IMPLEMENTER               ((uint32_t)0xFF000000)        /*!< Implementer code. ARM is 0x41 */
N
N/*******************  Bit definition for SCB_ICSR register  *******************/
N#define  SCB_ICSR_VECTACTIVE                 ((uint32_t)0x000001FF)        /*!< Active ISR number field */
N#define  SCB_ICSR_RETTOBASE                  ((uint32_t)0x00000800)        /*!< All active exceptions minus the IPSR_current_exception yields the empty set */
N#define  SCB_ICSR_VECTPENDING                ((uint32_t)0x003FF000)        /*!< Pending ISR number field */
N#define  SCB_ICSR_ISRPENDING                 ((uint32_t)0x00400000)        /*!< Interrupt pending flag */
N#define  SCB_ICSR_ISRPREEMPT                 ((uint32_t)0x00800000)        /*!< It indicates that a pending interrupt becomes active in the next running cycle */
N#define  SCB_ICSR_PENDSTCLR                  ((uint32_t)0x02000000)        /*!< Clear pending SysTick bit */
N#define  SCB_ICSR_PENDSTSET                  ((uint32_t)0x04000000)        /*!< Set pending SysTick bit */
N#define  SCB_ICSR_PENDSVCLR                  ((uint32_t)0x08000000)        /*!< Clear pending pendSV bit */
N#define  SCB_ICSR_PENDSVSET                  ((uint32_t)0x10000000)        /*!< Set pending pendSV bit */
N#define  SCB_ICSR_NMIPENDSET                 ((uint32_t)0x80000000)        /*!< Set pending NMI bit */
N
N/*******************  Bit definition for SCB_VTOR register  *******************/
N#define  SCB_VTOR_TBLOFF                     ((uint32_t)0x1FFFFF80)        /*!< Vector table base offset field */
N#define  SCB_VTOR_TBLBASE                    ((uint32_t)0x20000000)        /*!< Table base in code(0) or RAM(1) */
N
N/*!<*****************  Bit definition for SCB_AIRCR register  *******************/
N#define  SCB_AIRCR_VECTRESET                 ((uint32_t)0x00000001)        /*!< System Reset bit */
N#define  SCB_AIRCR_VECTCLRACTIVE             ((uint32_t)0x00000002)        /*!< Clear active vector bit */
N#define  SCB_AIRCR_SYSRESETREQ               ((uint32_t)0x00000004)        /*!< Requests chip control logic to generate a reset */
N
N#define  SCB_AIRCR_PRIGROUP                  ((uint32_t)0x00000700)        /*!< PRIGROUP[2:0] bits (Priority group) */
N#define  SCB_AIRCR_PRIGROUP_0                ((uint32_t)0x00000100)        /*!< Bit 0 */
N#define  SCB_AIRCR_PRIGROUP_1                ((uint32_t)0x00000200)        /*!< Bit 1 */
N#define  SCB_AIRCR_PRIGROUP_2                ((uint32_t)0x00000400)        /*!< Bit 2  */
N
N/* prority group configuration */
N#define  SCB_AIRCR_PRIGROUP0                 ((uint32_t)0x00000000)        /*!< Priority group=0 (7 bits of pre-emption priority, 1 bit of subpriority) */
N#define  SCB_AIRCR_PRIGROUP1                 ((uint32_t)0x00000100)        /*!< Priority group=1 (6 bits of pre-emption priority, 2 bits of subpriority) */
N#define  SCB_AIRCR_PRIGROUP2                 ((uint32_t)0x00000200)        /*!< Priority group=2 (5 bits of pre-emption priority, 3 bits of subpriority) */
N#define  SCB_AIRCR_PRIGROUP3                 ((uint32_t)0x00000300)        /*!< Priority group=3 (4 bits of pre-emption priority, 4 bits of subpriority) */
N#define  SCB_AIRCR_PRIGROUP4                 ((uint32_t)0x00000400)        /*!< Priority group=4 (3 bits of pre-emption priority, 5 bits of subpriority) */
N#define  SCB_AIRCR_PRIGROUP5                 ((uint32_t)0x00000500)        /*!< Priority group=5 (2 bits of pre-emption priority, 6 bits of subpriority) */
N#define  SCB_AIRCR_PRIGROUP6                 ((uint32_t)0x00000600)        /*!< Priority group=6 (1 bit of pre-emption priority, 7 bits of subpriority) */
N#define  SCB_AIRCR_PRIGROUP7                 ((uint32_t)0x00000700)        /*!< Priority group=7 (no pre-emption priority, 8 bits of subpriority) */
N
N#define  SCB_AIRCR_ENDIANESS                 ((uint32_t)0x00008000)        /*!< Data endianness bit */
N#define  SCB_AIRCR_VECTKEY                   ((uint32_t)0xFFFF0000)        /*!< Register key (VECTKEY) - Reads as 0xFA05 (VECTKEYSTAT) */
N
N/*******************  Bit definition for SCB_SCR register  ********************/
N#define  SCB_SCR_SLEEPONEXIT                 ((uint8_t)0x02)               /*!< Sleep on exit bit */
N#define  SCB_SCR_SLEEPDEEP                   ((uint8_t)0x04)               /*!< Sleep deep bit */
N#define  SCB_SCR_SEVONPEND                   ((uint8_t)0x10)               /*!< Wake up from WFE */
N
N/********************  Bit definition for SCB_CCR register  *******************/
N#define  SCB_CCR_NONBASETHRDENA              ((uint16_t)0x0001)            /*!< Thread mode can be entered from any level in Handler mode by controlled return value */
N#define  SCB_CCR_USERSETMPEND                ((uint16_t)0x0002)            /*!< Enables user code to write the Software Trigger Interrupt register to trigger (pend) a Main exception */
N#define  SCB_CCR_UNALIGN_TRP                 ((uint16_t)0x0008)            /*!< Trap for unaligned access */
N#define  SCB_CCR_DIV_0_TRP                   ((uint16_t)0x0010)            /*!< Trap on Divide by 0 */
N#define  SCB_CCR_BFHFNMIGN                   ((uint16_t)0x0100)            /*!< Handlers running at priority -1 and -2 */
N#define  SCB_CCR_STKALIGN                    ((uint16_t)0x0200)            /*!< On exception entry, the SP used prior to the exception is adjusted to be 8-byte aligned */
N
N/*******************  Bit definition for SCB_SHPR register ********************/
N#define  SCB_SHPR_PRI_N                      ((uint32_t)0x000000FF)        /*!< Priority of system handler 4,8, and 12. Mem Manage, reserved and Debug Monitor */
N#define  SCB_SHPR_PRI_N1                     ((uint32_t)0x0000FF00)        /*!< Priority of system handler 5,9, and 13. Bus Fault, reserved and reserved */
N#define  SCB_SHPR_PRI_N2                     ((uint32_t)0x00FF0000)        /*!< Priority of system handler 6,10, and 14. Usage Fault, reserved and PendSV */
N#define  SCB_SHPR_PRI_N3                     ((uint32_t)0xFF000000)        /*!< Priority of system handler 7,11, and 15. Reserved, SVCall and SysTick */
N
N/******************  Bit definition for SCB_SHCSR register  *******************/
N#define  SCB_SHCSR_MEMFAULTACT               ((uint32_t)0x00000001)        /*!< MemManage is active */
N#define  SCB_SHCSR_BUSFAULTACT               ((uint32_t)0x00000002)        /*!< BusFault is active */
N#define  SCB_SHCSR_USGFAULTACT               ((uint32_t)0x00000008)        /*!< UsageFault is active */
N#define  SCB_SHCSR_SVCALLACT                 ((uint32_t)0x00000080)        /*!< SVCall is active */
N#define  SCB_SHCSR_MONITORACT                ((uint32_t)0x00000100)        /*!< Monitor is active */
N#define  SCB_SHCSR_PENDSVACT                 ((uint32_t)0x00000400)        /*!< PendSV is active */
N#define  SCB_SHCSR_SYSTICKACT                ((uint32_t)0x00000800)        /*!< SysTick is active */
N#define  SCB_SHCSR_USGFAULTPENDED            ((uint32_t)0x00001000)        /*!< Usage Fault is pended */
N#define  SCB_SHCSR_MEMFAULTPENDED            ((uint32_t)0x00002000)        /*!< MemManage is pended */
N#define  SCB_SHCSR_BUSFAULTPENDED            ((uint32_t)0x00004000)        /*!< Bus Fault is pended */
N#define  SCB_SHCSR_SVCALLPENDED              ((uint32_t)0x00008000)        /*!< SVCall is pended */
N#define  SCB_SHCSR_MEMFAULTENA               ((uint32_t)0x00010000)        /*!< MemManage enable */
N#define  SCB_SHCSR_BUSFAULTENA               ((uint32_t)0x00020000)        /*!< Bus Fault enable */
N#define  SCB_SHCSR_USGFAULTENA               ((uint32_t)0x00040000)        /*!< UsageFault enable */
N
N/*******************  Bit definition for SCB_CFSR register  *******************/
N/*!< MFSR */
N#define  SCB_CFSR_IACCVIOL                   ((uint32_t)0x00000001)        /*!< Instruction access violation */
N#define  SCB_CFSR_DACCVIOL                   ((uint32_t)0x00000002)        /*!< Data access violation */
N#define  SCB_CFSR_MUNSTKERR                  ((uint32_t)0x00000008)        /*!< Unstacking error */
N#define  SCB_CFSR_MSTKERR                    ((uint32_t)0x00000010)        /*!< Stacking error */
N#define  SCB_CFSR_MMARVALID                  ((uint32_t)0x00000080)        /*!< Memory Manage Address Register address valid flag */
N/*!< BFSR */
N#define  SCB_CFSR_IBUSERR                    ((uint32_t)0x00000100)        /*!< Instruction bus error flag */
N#define  SCB_CFSR_PRECISERR                  ((uint32_t)0x00000200)        /*!< Precise data bus error */
N#define  SCB_CFSR_IMPRECISERR                ((uint32_t)0x00000400)        /*!< Imprecise data bus error */
N#define  SCB_CFSR_UNSTKERR                   ((uint32_t)0x00000800)        /*!< Unstacking error */
N#define  SCB_CFSR_STKERR                     ((uint32_t)0x00001000)        /*!< Stacking error */
N#define  SCB_CFSR_BFARVALID                  ((uint32_t)0x00008000)        /*!< Bus Fault Address Register address valid flag */
N/*!< UFSR */
N#define  SCB_CFSR_UNDEFINSTR                 ((uint32_t)0x00010000)        /*!< The processor attempt to execute an undefined instruction */
N#define  SCB_CFSR_INVSTATE                   ((uint32_t)0x00020000)        /*!< Invalid combination of EPSR and instruction */
N#define  SCB_CFSR_INVPC                      ((uint32_t)0x00040000)        /*!< Attempt to load EXC_RETURN into pc illegally */
N#define  SCB_CFSR_NOCP                       ((uint32_t)0x00080000)        /*!< Attempt to use a coprocessor instruction */
N#define  SCB_CFSR_UNALIGNED                  ((uint32_t)0x01000000)        /*!< Fault occurs when there is an attempt to make an unaligned memory access */
N#define  SCB_CFSR_DIVBYZERO                  ((uint32_t)0x02000000)        /*!< Fault occurs when SDIV or DIV instruction is used with a divisor of 0 */
N
N/*******************  Bit definition for SCB_HFSR register  *******************/
N#define  SCB_HFSR_VECTTBL                    ((uint32_t)0x00000002)        /*!< Fault occurs because of vector table read on exception processing */
N#define  SCB_HFSR_FORCED                     ((uint32_t)0x40000000)        /*!< Hard Fault activated when a configurable Fault was received and cannot activate */
N#define  SCB_HFSR_DEBUGEVT                   ((uint32_t)0x80000000)        /*!< Fault related to debug */
N
N/*******************  Bit definition for SCB_DFSR register  *******************/
N#define  SCB_DFSR_HALTED                     ((uint8_t)0x01)               /*!< Halt request flag */
N#define  SCB_DFSR_BKPT                       ((uint8_t)0x02)               /*!< BKPT flag */
N#define  SCB_DFSR_DWTTRAP                    ((uint8_t)0x04)               /*!< Data Watchpoint and Trace (DWT) flag */
N#define  SCB_DFSR_VCATCH                     ((uint8_t)0x08)               /*!< Vector catch flag */
N#define  SCB_DFSR_EXTERNAL                   ((uint8_t)0x10)               /*!< External debug request flag */
N
N/*******************  Bit definition for SCB_MMFAR register  ******************/
N#define  SCB_MMFAR_ADDRESS                   ((uint32_t)0xFFFFFFFF)        /*!< Mem Manage fault address field */
N
N/*******************  Bit definition for SCB_BFAR register  *******************/
N#define  SCB_BFAR_ADDRESS                    ((uint32_t)0xFFFFFFFF)        /*!< Bus fault address field */
N
N/*******************  Bit definition for SCB_afsr register  *******************/
N#define  SCB_AFSR_IMPDEF                     ((uint32_t)0xFFFFFFFF)        /*!< Implementation defined */
N
N/******************************************************************************/
N/*                                                                            */
N/*                    External Interrupt/Event Controller                     */
N/*                                                                            */
N/******************************************************************************/
N
N/*******************  Bit definition for EXTI_IMR register  *******************/
N#define  EXTI_IMR_MR0                        ((uint32_t)0x00000001)        /*!< Interrupt Mask on line 0 */
N#define  EXTI_IMR_MR1                        ((uint32_t)0x00000002)        /*!< Interrupt Mask on line 1 */
N#define  EXTI_IMR_MR2                        ((uint32_t)0x00000004)        /*!< Interrupt Mask on line 2 */
N#define  EXTI_IMR_MR3                        ((uint32_t)0x00000008)        /*!< Interrupt Mask on line 3 */
N#define  EXTI_IMR_MR4                        ((uint32_t)0x00000010)        /*!< Interrupt Mask on line 4 */
N#define  EXTI_IMR_MR5                        ((uint32_t)0x00000020)        /*!< Interrupt Mask on line 5 */
N#define  EXTI_IMR_MR6                        ((uint32_t)0x00000040)        /*!< Interrupt Mask on line 6 */
N#define  EXTI_IMR_MR7                        ((uint32_t)0x00000080)        /*!< Interrupt Mask on line 7 */
N#define  EXTI_IMR_MR8                        ((uint32_t)0x00000100)        /*!< Interrupt Mask on line 8 */
N#define  EXTI_IMR_MR9                        ((uint32_t)0x00000200)        /*!< Interrupt Mask on line 9 */
N#define  EXTI_IMR_MR10                       ((uint32_t)0x00000400)        /*!< Interrupt Mask on line 10 */
N#define  EXTI_IMR_MR11                       ((uint32_t)0x00000800)        /*!< Interrupt Mask on line 11 */
N#define  EXTI_IMR_MR12                       ((uint32_t)0x00001000)        /*!< Interrupt Mask on line 12 */
N#define  EXTI_IMR_MR13                       ((uint32_t)0x00002000)        /*!< Interrupt Mask on line 13 */
N#define  EXTI_IMR_MR14                       ((uint32_t)0x00004000)        /*!< Interrupt Mask on line 14 */
N#define  EXTI_IMR_MR15                       ((uint32_t)0x00008000)        /*!< Interrupt Mask on line 15 */
N#define  EXTI_IMR_MR16                       ((uint32_t)0x00010000)        /*!< Interrupt Mask on line 16 */
N#define  EXTI_IMR_MR17                       ((uint32_t)0x00020000)        /*!< Interrupt Mask on line 17 */
N#define  EXTI_IMR_MR18                       ((uint32_t)0x00040000)        /*!< Interrupt Mask on line 18 */
N#define  EXTI_IMR_MR19                       ((uint32_t)0x00080000)        /*!< Interrupt Mask on line 19 */
N
N/*******************  Bit definition for EXTI_EMR register  *******************/
N#define  EXTI_EMR_MR0                        ((uint32_t)0x00000001)        /*!< Event Mask on line 0 */
N#define  EXTI_EMR_MR1                        ((uint32_t)0x00000002)        /*!< Event Mask on line 1 */
N#define  EXTI_EMR_MR2                        ((uint32_t)0x00000004)        /*!< Event Mask on line 2 */
N#define  EXTI_EMR_MR3                        ((uint32_t)0x00000008)        /*!< Event Mask on line 3 */
N#define  EXTI_EMR_MR4                        ((uint32_t)0x00000010)        /*!< Event Mask on line 4 */
N#define  EXTI_EMR_MR5                        ((uint32_t)0x00000020)        /*!< Event Mask on line 5 */
N#define  EXTI_EMR_MR6                        ((uint32_t)0x00000040)        /*!< Event Mask on line 6 */
N#define  EXTI_EMR_MR7                        ((uint32_t)0x00000080)        /*!< Event Mask on line 7 */
N#define  EXTI_EMR_MR8                        ((uint32_t)0x00000100)        /*!< Event Mask on line 8 */
N#define  EXTI_EMR_MR9                        ((uint32_t)0x00000200)        /*!< Event Mask on line 9 */
N#define  EXTI_EMR_MR10                       ((uint32_t)0x00000400)        /*!< Event Mask on line 10 */
N#define  EXTI_EMR_MR11                       ((uint32_t)0x00000800)        /*!< Event Mask on line 11 */
N#define  EXTI_EMR_MR12                       ((uint32_t)0x00001000)        /*!< Event Mask on line 12 */
N#define  EXTI_EMR_MR13                       ((uint32_t)0x00002000)        /*!< Event Mask on line 13 */
N#define  EXTI_EMR_MR14                       ((uint32_t)0x00004000)        /*!< Event Mask on line 14 */
N#define  EXTI_EMR_MR15                       ((uint32_t)0x00008000)        /*!< Event Mask on line 15 */
N#define  EXTI_EMR_MR16                       ((uint32_t)0x00010000)        /*!< Event Mask on line 16 */
N#define  EXTI_EMR_MR17                       ((uint32_t)0x00020000)        /*!< Event Mask on line 17 */
N#define  EXTI_EMR_MR18                       ((uint32_t)0x00040000)        /*!< Event Mask on line 18 */
N#define  EXTI_EMR_MR19                       ((uint32_t)0x00080000)        /*!< Event Mask on line 19 */
N
N/******************  Bit definition for EXTI_RTSR register  *******************/
N#define  EXTI_RTSR_TR0                       ((uint32_t)0x00000001)        /*!< Rising trigger event configuration bit of line 0 */
N#define  EXTI_RTSR_TR1                       ((uint32_t)0x00000002)        /*!< Rising trigger event configuration bit of line 1 */
N#define  EXTI_RTSR_TR2                       ((uint32_t)0x00000004)        /*!< Rising trigger event configuration bit of line 2 */
N#define  EXTI_RTSR_TR3                       ((uint32_t)0x00000008)        /*!< Rising trigger event configuration bit of line 3 */
N#define  EXTI_RTSR_TR4                       ((uint32_t)0x00000010)        /*!< Rising trigger event configuration bit of line 4 */
N#define  EXTI_RTSR_TR5                       ((uint32_t)0x00000020)        /*!< Rising trigger event configuration bit of line 5 */
N#define  EXTI_RTSR_TR6                       ((uint32_t)0x00000040)        /*!< Rising trigger event configuration bit of line 6 */
N#define  EXTI_RTSR_TR7                       ((uint32_t)0x00000080)        /*!< Rising trigger event configuration bit of line 7 */
N#define  EXTI_RTSR_TR8                       ((uint32_t)0x00000100)        /*!< Rising trigger event configuration bit of line 8 */
N#define  EXTI_RTSR_TR9                       ((uint32_t)0x00000200)        /*!< Rising trigger event configuration bit of line 9 */
N#define  EXTI_RTSR_TR10                      ((uint32_t)0x00000400)        /*!< Rising trigger event configuration bit of line 10 */
N#define  EXTI_RTSR_TR11                      ((uint32_t)0x00000800)        /*!< Rising trigger event configuration bit of line 11 */
N#define  EXTI_RTSR_TR12                      ((uint32_t)0x00001000)        /*!< Rising trigger event configuration bit of line 12 */
N#define  EXTI_RTSR_TR13                      ((uint32_t)0x00002000)        /*!< Rising trigger event configuration bit of line 13 */
N#define  EXTI_RTSR_TR14                      ((uint32_t)0x00004000)        /*!< Rising trigger event configuration bit of line 14 */
N#define  EXTI_RTSR_TR15                      ((uint32_t)0x00008000)        /*!< Rising trigger event configuration bit of line 15 */
N#define  EXTI_RTSR_TR16                      ((uint32_t)0x00010000)        /*!< Rising trigger event configuration bit of line 16 */
N#define  EXTI_RTSR_TR17                      ((uint32_t)0x00020000)        /*!< Rising trigger event configuration bit of line 17 */
N#define  EXTI_RTSR_TR18                      ((uint32_t)0x00040000)        /*!< Rising trigger event configuration bit of line 18 */
N#define  EXTI_RTSR_TR19                      ((uint32_t)0x00080000)        /*!< Rising trigger event configuration bit of line 19 */
N
N/******************  Bit definition for EXTI_FTSR register  *******************/
N#define  EXTI_FTSR_TR0                       ((uint32_t)0x00000001)        /*!< Falling trigger event configuration bit of line 0 */
N#define  EXTI_FTSR_TR1                       ((uint32_t)0x00000002)        /*!< Falling trigger event configuration bit of line 1 */
N#define  EXTI_FTSR_TR2                       ((uint32_t)0x00000004)        /*!< Falling trigger event configuration bit of line 2 */
N#define  EXTI_FTSR_TR3                       ((uint32_t)0x00000008)        /*!< Falling trigger event configuration bit of line 3 */
N#define  EXTI_FTSR_TR4                       ((uint32_t)0x00000010)        /*!< Falling trigger event configuration bit of line 4 */
N#define  EXTI_FTSR_TR5                       ((uint32_t)0x00000020)        /*!< Falling trigger event configuration bit of line 5 */
N#define  EXTI_FTSR_TR6                       ((uint32_t)0x00000040)        /*!< Falling trigger event configuration bit of line 6 */
N#define  EXTI_FTSR_TR7                       ((uint32_t)0x00000080)        /*!< Falling trigger event configuration bit of line 7 */
N#define  EXTI_FTSR_TR8                       ((uint32_t)0x00000100)        /*!< Falling trigger event configuration bit of line 8 */
N#define  EXTI_FTSR_TR9                       ((uint32_t)0x00000200)        /*!< Falling trigger event configuration bit of line 9 */
N#define  EXTI_FTSR_TR10                      ((uint32_t)0x00000400)        /*!< Falling trigger event configuration bit of line 10 */
N#define  EXTI_FTSR_TR11                      ((uint32_t)0x00000800)        /*!< Falling trigger event configuration bit of line 11 */
N#define  EXTI_FTSR_TR12                      ((uint32_t)0x00001000)        /*!< Falling trigger event configuration bit of line 12 */
N#define  EXTI_FTSR_TR13                      ((uint32_t)0x00002000)        /*!< Falling trigger event configuration bit of line 13 */
N#define  EXTI_FTSR_TR14                      ((uint32_t)0x00004000)        /*!< Falling trigger event configuration bit of line 14 */
N#define  EXTI_FTSR_TR15                      ((uint32_t)0x00008000)        /*!< Falling trigger event configuration bit of line 15 */
N#define  EXTI_FTSR_TR16                      ((uint32_t)0x00010000)        /*!< Falling trigger event configuration bit of line 16 */
N#define  EXTI_FTSR_TR17                      ((uint32_t)0x00020000)        /*!< Falling trigger event configuration bit of line 17 */
N#define  EXTI_FTSR_TR18                      ((uint32_t)0x00040000)        /*!< Falling trigger event configuration bit of line 18 */
N#define  EXTI_FTSR_TR19                      ((uint32_t)0x00080000)        /*!< Falling trigger event configuration bit of line 19 */
N
N/******************  Bit definition for EXTI_SWIER register  ******************/
N#define  EXTI_SWIER_SWIER0                   ((uint32_t)0x00000001)        /*!< Software Interrupt on line 0 */
N#define  EXTI_SWIER_SWIER1                   ((uint32_t)0x00000002)        /*!< Software Interrupt on line 1 */
N#define  EXTI_SWIER_SWIER2                   ((uint32_t)0x00000004)        /*!< Software Interrupt on line 2 */
N#define  EXTI_SWIER_SWIER3                   ((uint32_t)0x00000008)        /*!< Software Interrupt on line 3 */
N#define  EXTI_SWIER_SWIER4                   ((uint32_t)0x00000010)        /*!< Software Interrupt on line 4 */
N#define  EXTI_SWIER_SWIER5                   ((uint32_t)0x00000020)        /*!< Software Interrupt on line 5 */
N#define  EXTI_SWIER_SWIER6                   ((uint32_t)0x00000040)        /*!< Software Interrupt on line 6 */
N#define  EXTI_SWIER_SWIER7                   ((uint32_t)0x00000080)        /*!< Software Interrupt on line 7 */
N#define  EXTI_SWIER_SWIER8                   ((uint32_t)0x00000100)        /*!< Software Interrupt on line 8 */
N#define  EXTI_SWIER_SWIER9                   ((uint32_t)0x00000200)        /*!< Software Interrupt on line 9 */
N#define  EXTI_SWIER_SWIER10                  ((uint32_t)0x00000400)        /*!< Software Interrupt on line 10 */
N#define  EXTI_SWIER_SWIER11                  ((uint32_t)0x00000800)        /*!< Software Interrupt on line 11 */
N#define  EXTI_SWIER_SWIER12                  ((uint32_t)0x00001000)        /*!< Software Interrupt on line 12 */
N#define  EXTI_SWIER_SWIER13                  ((uint32_t)0x00002000)        /*!< Software Interrupt on line 13 */
N#define  EXTI_SWIER_SWIER14                  ((uint32_t)0x00004000)        /*!< Software Interrupt on line 14 */
N#define  EXTI_SWIER_SWIER15                  ((uint32_t)0x00008000)        /*!< Software Interrupt on line 15 */
N#define  EXTI_SWIER_SWIER16                  ((uint32_t)0x00010000)        /*!< Software Interrupt on line 16 */
N#define  EXTI_SWIER_SWIER17                  ((uint32_t)0x00020000)        /*!< Software Interrupt on line 17 */
N#define  EXTI_SWIER_SWIER18                  ((uint32_t)0x00040000)        /*!< Software Interrupt on line 18 */
N#define  EXTI_SWIER_SWIER19                  ((uint32_t)0x00080000)        /*!< Software Interrupt on line 19 */
N
N/*******************  Bit definition for EXTI_PR register  ********************/
N#define  EXTI_PR_PR0                         ((uint32_t)0x00000001)        /*!< Pending bit for line 0 */
N#define  EXTI_PR_PR1                         ((uint32_t)0x00000002)        /*!< Pending bit for line 1 */
N#define  EXTI_PR_PR2                         ((uint32_t)0x00000004)        /*!< Pending bit for line 2 */
N#define  EXTI_PR_PR3                         ((uint32_t)0x00000008)        /*!< Pending bit for line 3 */
N#define  EXTI_PR_PR4                         ((uint32_t)0x00000010)        /*!< Pending bit for line 4 */
N#define  EXTI_PR_PR5                         ((uint32_t)0x00000020)        /*!< Pending bit for line 5 */
N#define  EXTI_PR_PR6                         ((uint32_t)0x00000040)        /*!< Pending bit for line 6 */
N#define  EXTI_PR_PR7                         ((uint32_t)0x00000080)        /*!< Pending bit for line 7 */
N#define  EXTI_PR_PR8                         ((uint32_t)0x00000100)        /*!< Pending bit for line 8 */
N#define  EXTI_PR_PR9                         ((uint32_t)0x00000200)        /*!< Pending bit for line 9 */
N#define  EXTI_PR_PR10                        ((uint32_t)0x00000400)        /*!< Pending bit for line 10 */
N#define  EXTI_PR_PR11                        ((uint32_t)0x00000800)        /*!< Pending bit for line 11 */
N#define  EXTI_PR_PR12                        ((uint32_t)0x00001000)        /*!< Pending bit for line 12 */
N#define  EXTI_PR_PR13                        ((uint32_t)0x00002000)        /*!< Pending bit for line 13 */
N#define  EXTI_PR_PR14                        ((uint32_t)0x00004000)        /*!< Pending bit for line 14 */
N#define  EXTI_PR_PR15                        ((uint32_t)0x00008000)        /*!< Pending bit for line 15 */
N#define  EXTI_PR_PR16                        ((uint32_t)0x00010000)        /*!< Pending bit for line 16 */
N#define  EXTI_PR_PR17                        ((uint32_t)0x00020000)        /*!< Pending bit for line 17 */
N#define  EXTI_PR_PR18                        ((uint32_t)0x00040000)        /*!< Pending bit for line 18 */
N#define  EXTI_PR_PR19                        ((uint32_t)0x00080000)        /*!< Pending bit for line 19 */
N
N/******************************************************************************/
N/*                                                                            */
N/*                             DMA Controller                                 */
N/*                                                                            */
N/******************************************************************************/
N
N/*******************  Bit definition for DMA_ISR register  ********************/
N#define  DMA_ISR_GIF1                        ((uint32_t)0x00000001)        /*!< Channel 1 Global interrupt flag */
N#define  DMA_ISR_TCIF1                       ((uint32_t)0x00000002)        /*!< Channel 1 Transfer Complete flag */
N#define  DMA_ISR_HTIF1                       ((uint32_t)0x00000004)        /*!< Channel 1 Half Transfer flag */
N#define  DMA_ISR_TEIF1                       ((uint32_t)0x00000008)        /*!< Channel 1 Transfer Error flag */
N#define  DMA_ISR_GIF2                        ((uint32_t)0x00000010)        /*!< Channel 2 Global interrupt flag */
N#define  DMA_ISR_TCIF2                       ((uint32_t)0x00000020)        /*!< Channel 2 Transfer Complete flag */
N#define  DMA_ISR_HTIF2                       ((uint32_t)0x00000040)        /*!< Channel 2 Half Transfer flag */
N#define  DMA_ISR_TEIF2                       ((uint32_t)0x00000080)        /*!< Channel 2 Transfer Error flag */
N#define  DMA_ISR_GIF3                        ((uint32_t)0x00000100)        /*!< Channel 3 Global interrupt flag */
N#define  DMA_ISR_TCIF3                       ((uint32_t)0x00000200)        /*!< Channel 3 Transfer Complete flag */
N#define  DMA_ISR_HTIF3                       ((uint32_t)0x00000400)        /*!< Channel 3 Half Transfer flag */
N#define  DMA_ISR_TEIF3                       ((uint32_t)0x00000800)        /*!< Channel 3 Transfer Error flag */
N#define  DMA_ISR_GIF4                        ((uint32_t)0x00001000)        /*!< Channel 4 Global interrupt flag */
N#define  DMA_ISR_TCIF4                       ((uint32_t)0x00002000)        /*!< Channel 4 Transfer Complete flag */
N#define  DMA_ISR_HTIF4                       ((uint32_t)0x00004000)        /*!< Channel 4 Half Transfer flag */
N#define  DMA_ISR_TEIF4                       ((uint32_t)0x00008000)        /*!< Channel 4 Transfer Error flag */
N#define  DMA_ISR_GIF5                        ((uint32_t)0x00010000)        /*!< Channel 5 Global interrupt flag */
N#define  DMA_ISR_TCIF5                       ((uint32_t)0x00020000)        /*!< Channel 5 Transfer Complete flag */
N#define  DMA_ISR_HTIF5                       ((uint32_t)0x00040000)        /*!< Channel 5 Half Transfer flag */
N#define  DMA_ISR_TEIF5                       ((uint32_t)0x00080000)        /*!< Channel 5 Transfer Error flag */
N#define  DMA_ISR_GIF6                        ((uint32_t)0x00100000)        /*!< Channel 6 Global interrupt flag */
N#define  DMA_ISR_TCIF6                       ((uint32_t)0x00200000)        /*!< Channel 6 Transfer Complete flag */
N#define  DMA_ISR_HTIF6                       ((uint32_t)0x00400000)        /*!< Channel 6 Half Transfer flag */
N#define  DMA_ISR_TEIF6                       ((uint32_t)0x00800000)        /*!< Channel 6 Transfer Error flag */
N#define  DMA_ISR_GIF7                        ((uint32_t)0x01000000)        /*!< Channel 7 Global interrupt flag */
N#define  DMA_ISR_TCIF7                       ((uint32_t)0x02000000)        /*!< Channel 7 Transfer Complete flag */
N#define  DMA_ISR_HTIF7                       ((uint32_t)0x04000000)        /*!< Channel 7 Half Transfer flag */
N#define  DMA_ISR_TEIF7                       ((uint32_t)0x08000000)        /*!< Channel 7 Transfer Error flag */
N
N/*******************  Bit definition for DMA_IFCR register  *******************/
N#define  DMA_IFCR_CGIF1                      ((uint32_t)0x00000001)        /*!< Channel 1 Global interrupt clear */
N#define  DMA_IFCR_CTCIF1                     ((uint32_t)0x00000002)        /*!< Channel 1 Transfer Complete clear */
N#define  DMA_IFCR_CHTIF1                     ((uint32_t)0x00000004)        /*!< Channel 1 Half Transfer clear */
N#define  DMA_IFCR_CTEIF1                     ((uint32_t)0x00000008)        /*!< Channel 1 Transfer Error clear */
N#define  DMA_IFCR_CGIF2                      ((uint32_t)0x00000010)        /*!< Channel 2 Global interrupt clear */
N#define  DMA_IFCR_CTCIF2                     ((uint32_t)0x00000020)        /*!< Channel 2 Transfer Complete clear */
N#define  DMA_IFCR_CHTIF2                     ((uint32_t)0x00000040)        /*!< Channel 2 Half Transfer clear */
N#define  DMA_IFCR_CTEIF2                     ((uint32_t)0x00000080)        /*!< Channel 2 Transfer Error clear */
N#define  DMA_IFCR_CGIF3                      ((uint32_t)0x00000100)        /*!< Channel 3 Global interrupt clear */
N#define  DMA_IFCR_CTCIF3                     ((uint32_t)0x00000200)        /*!< Channel 3 Transfer Complete clear */
N#define  DMA_IFCR_CHTIF3                     ((uint32_t)0x00000400)        /*!< Channel 3 Half Transfer clear */
N#define  DMA_IFCR_CTEIF3                     ((uint32_t)0x00000800)        /*!< Channel 3 Transfer Error clear */
N#define  DMA_IFCR_CGIF4                      ((uint32_t)0x00001000)        /*!< Channel 4 Global interrupt clear */
N#define  DMA_IFCR_CTCIF4                     ((uint32_t)0x00002000)        /*!< Channel 4 Transfer Complete clear */
N#define  DMA_IFCR_CHTIF4                     ((uint32_t)0x00004000)        /*!< Channel 4 Half Transfer clear */
N#define  DMA_IFCR_CTEIF4                     ((uint32_t)0x00008000)        /*!< Channel 4 Transfer Error clear */
N#define  DMA_IFCR_CGIF5                      ((uint32_t)0x00010000)        /*!< Channel 5 Global interrupt clear */
N#define  DMA_IFCR_CTCIF5                     ((uint32_t)0x00020000)        /*!< Channel 5 Transfer Complete clear */
N#define  DMA_IFCR_CHTIF5                     ((uint32_t)0x00040000)        /*!< Channel 5 Half Transfer clear */
N#define  DMA_IFCR_CTEIF5                     ((uint32_t)0x00080000)        /*!< Channel 5 Transfer Error clear */
N#define  DMA_IFCR_CGIF6                      ((uint32_t)0x00100000)        /*!< Channel 6 Global interrupt clear */
N#define  DMA_IFCR_CTCIF6                     ((uint32_t)0x00200000)        /*!< Channel 6 Transfer Complete clear */
N#define  DMA_IFCR_CHTIF6                     ((uint32_t)0x00400000)        /*!< Channel 6 Half Transfer clear */
N#define  DMA_IFCR_CTEIF6                     ((uint32_t)0x00800000)        /*!< Channel 6 Transfer Error clear */
N#define  DMA_IFCR_CGIF7                      ((uint32_t)0x01000000)        /*!< Channel 7 Global interrupt clear */
N#define  DMA_IFCR_CTCIF7                     ((uint32_t)0x02000000)        /*!< Channel 7 Transfer Complete clear */
N#define  DMA_IFCR_CHTIF7                     ((uint32_t)0x04000000)        /*!< Channel 7 Half Transfer clear */
N#define  DMA_IFCR_CTEIF7                     ((uint32_t)0x08000000)        /*!< Channel 7 Transfer Error clear */
N
N/*******************  Bit definition for DMA_CCR1 register  *******************/
N#define  DMA_CCR1_EN                         ((uint16_t)0x0001)            /*!< Channel enable*/
N#define  DMA_CCR1_TCIE                       ((uint16_t)0x0002)            /*!< Transfer complete interrupt enable */
N#define  DMA_CCR1_HTIE                       ((uint16_t)0x0004)            /*!< Half Transfer interrupt enable */
N#define  DMA_CCR1_TEIE                       ((uint16_t)0x0008)            /*!< Transfer error interrupt enable */
N#define  DMA_CCR1_DIR                        ((uint16_t)0x0010)            /*!< Data transfer direction */
N#define  DMA_CCR1_CIRC                       ((uint16_t)0x0020)            /*!< Circular mode */
N#define  DMA_CCR1_PINC                       ((uint16_t)0x0040)            /*!< Peripheral increment mode */
N#define  DMA_CCR1_MINC                       ((uint16_t)0x0080)            /*!< Memory increment mode */
N
N#define  DMA_CCR1_PSIZE                      ((uint16_t)0x0300)            /*!< PSIZE[1:0] bits (Peripheral size) */
N#define  DMA_CCR1_PSIZE_0                    ((uint16_t)0x0100)            /*!< Bit 0 */
N#define  DMA_CCR1_PSIZE_1                    ((uint16_t)0x0200)            /*!< Bit 1 */
N
N#define  DMA_CCR1_MSIZE                      ((uint16_t)0x0C00)            /*!< MSIZE[1:0] bits (Memory size) */
N#define  DMA_CCR1_MSIZE_0                    ((uint16_t)0x0400)            /*!< Bit 0 */
N#define  DMA_CCR1_MSIZE_1                    ((uint16_t)0x0800)            /*!< Bit 1 */
N
N#define  DMA_CCR1_PL                         ((uint16_t)0x3000)            /*!< PL[1:0] bits(Channel Priority level) */
N#define  DMA_CCR1_PL_0                       ((uint16_t)0x1000)            /*!< Bit 0 */
N#define  DMA_CCR1_PL_1                       ((uint16_t)0x2000)            /*!< Bit 1 */
N
N#define  DMA_CCR1_MEM2MEM                    ((uint16_t)0x4000)            /*!< Memory to memory mode */
N
N/*******************  Bit definition for DMA_CCR2 register  *******************/
N#define  DMA_CCR2_EN                         ((uint16_t)0x0001)            /*!< Channel enable */
N#define  DMA_CCR2_TCIE                       ((uint16_t)0x0002)            /*!< Transfer complete interrupt enable */
N#define  DMA_CCR2_HTIE                       ((uint16_t)0x0004)            /*!< Half Transfer interrupt enable */
N#define  DMA_CCR2_TEIE                       ((uint16_t)0x0008)            /*!< Transfer error interrupt enable */
N#define  DMA_CCR2_DIR                        ((uint16_t)0x0010)            /*!< Data transfer direction */
N#define  DMA_CCR2_CIRC                       ((uint16_t)0x0020)            /*!< Circular mode */
N#define  DMA_CCR2_PINC                       ((uint16_t)0x0040)            /*!< Peripheral increment mode */
N#define  DMA_CCR2_MINC                       ((uint16_t)0x0080)            /*!< Memory increment mode */
N
N#define  DMA_CCR2_PSIZE                      ((uint16_t)0x0300)            /*!< PSIZE[1:0] bits (Peripheral size) */
N#define  DMA_CCR2_PSIZE_0                    ((uint16_t)0x0100)            /*!< Bit 0 */
N#define  DMA_CCR2_PSIZE_1                    ((uint16_t)0x0200)            /*!< Bit 1 */
N
N#define  DMA_CCR2_MSIZE                      ((uint16_t)0x0C00)            /*!< MSIZE[1:0] bits (Memory size) */
N#define  DMA_CCR2_MSIZE_0                    ((uint16_t)0x0400)            /*!< Bit 0 */
N#define  DMA_CCR2_MSIZE_1                    ((uint16_t)0x0800)            /*!< Bit 1 */
N
N#define  DMA_CCR2_PL                         ((uint16_t)0x3000)            /*!< PL[1:0] bits (Channel Priority level) */
N#define  DMA_CCR2_PL_0                       ((uint16_t)0x1000)            /*!< Bit 0 */
N#define  DMA_CCR2_PL_1                       ((uint16_t)0x2000)            /*!< Bit 1 */
N
N#define  DMA_CCR2_MEM2MEM                    ((uint16_t)0x4000)            /*!< Memory to memory mode */
N
N/*******************  Bit definition for DMA_CCR3 register  *******************/
N#define  DMA_CCR3_EN                         ((uint16_t)0x0001)            /*!< Channel enable */
N#define  DMA_CCR3_TCIE                       ((uint16_t)0x0002)            /*!< Transfer complete interrupt enable */
N#define  DMA_CCR3_HTIE                       ((uint16_t)0x0004)            /*!< Half Transfer interrupt enable */
N#define  DMA_CCR3_TEIE                       ((uint16_t)0x0008)            /*!< Transfer error interrupt enable */
N#define  DMA_CCR3_DIR                        ((uint16_t)0x0010)            /*!< Data transfer direction */
N#define  DMA_CCR3_CIRC                       ((uint16_t)0x0020)            /*!< Circular mode */
N#define  DMA_CCR3_PINC                       ((uint16_t)0x0040)            /*!< Peripheral increment mode */
N#define  DMA_CCR3_MINC                       ((uint16_t)0x0080)            /*!< Memory increment mode */
N
N#define  DMA_CCR3_PSIZE                      ((uint16_t)0x0300)            /*!< PSIZE[1:0] bits (Peripheral size) */
N#define  DMA_CCR3_PSIZE_0                    ((uint16_t)0x0100)            /*!< Bit 0 */
N#define  DMA_CCR3_PSIZE_1                    ((uint16_t)0x0200)            /*!< Bit 1 */
N
N#define  DMA_CCR3_MSIZE                      ((uint16_t)0x0C00)            /*!< MSIZE[1:0] bits (Memory size) */
N#define  DMA_CCR3_MSIZE_0                    ((uint16_t)0x0400)            /*!< Bit 0 */
N#define  DMA_CCR3_MSIZE_1                    ((uint16_t)0x0800)            /*!< Bit 1 */
N
N#define  DMA_CCR3_PL                         ((uint16_t)0x3000)            /*!< PL[1:0] bits (Channel Priority level) */
N#define  DMA_CCR3_PL_0                       ((uint16_t)0x1000)            /*!< Bit 0 */
N#define  DMA_CCR3_PL_1                       ((uint16_t)0x2000)            /*!< Bit 1 */
N
N#define  DMA_CCR3_MEM2MEM                    ((uint16_t)0x4000)            /*!< Memory to memory mode */
N
N/*!<******************  Bit definition for DMA_CCR4 register  *******************/
N#define  DMA_CCR4_EN                         ((uint16_t)0x0001)            /*!< Channel enable */
N#define  DMA_CCR4_TCIE                       ((uint16_t)0x0002)            /*!< Transfer complete interrupt enable */
N#define  DMA_CCR4_HTIE                       ((uint16_t)0x0004)            /*!< Half Transfer interrupt enable */
N#define  DMA_CCR4_TEIE                       ((uint16_t)0x0008)            /*!< Transfer error interrupt enable */
N#define  DMA_CCR4_DIR                        ((uint16_t)0x0010)            /*!< Data transfer direction */
N#define  DMA_CCR4_CIRC                       ((uint16_t)0x0020)            /*!< Circular mode */
N#define  DMA_CCR4_PINC                       ((uint16_t)0x0040)            /*!< Peripheral increment mode */
N#define  DMA_CCR4_MINC                       ((uint16_t)0x0080)            /*!< Memory increment mode */
N
N#define  DMA_CCR4_PSIZE                      ((uint16_t)0x0300)            /*!< PSIZE[1:0] bits (Peripheral size) */
N#define  DMA_CCR4_PSIZE_0                    ((uint16_t)0x0100)            /*!< Bit 0 */
N#define  DMA_CCR4_PSIZE_1                    ((uint16_t)0x0200)            /*!< Bit 1 */
N
N#define  DMA_CCR4_MSIZE                      ((uint16_t)0x0C00)            /*!< MSIZE[1:0] bits (Memory size) */
N#define  DMA_CCR4_MSIZE_0                    ((uint16_t)0x0400)            /*!< Bit 0 */
N#define  DMA_CCR4_MSIZE_1                    ((uint16_t)0x0800)            /*!< Bit 1 */
N
N#define  DMA_CCR4_PL                         ((uint16_t)0x3000)            /*!< PL[1:0] bits (Channel Priority level) */
N#define  DMA_CCR4_PL_0                       ((uint16_t)0x1000)            /*!< Bit 0 */
N#define  DMA_CCR4_PL_1                       ((uint16_t)0x2000)            /*!< Bit 1 */
N
N#define  DMA_CCR4_MEM2MEM                    ((uint16_t)0x4000)            /*!< Memory to memory mode */
N
N/******************  Bit definition for DMA_CCR5 register  *******************/
N#define  DMA_CCR5_EN                         ((uint16_t)0x0001)            /*!< Channel enable */
N#define  DMA_CCR5_TCIE                       ((uint16_t)0x0002)            /*!< Transfer complete interrupt enable */
N#define  DMA_CCR5_HTIE                       ((uint16_t)0x0004)            /*!< Half Transfer interrupt enable */
N#define  DMA_CCR5_TEIE                       ((uint16_t)0x0008)            /*!< Transfer error interrupt enable */
N#define  DMA_CCR5_DIR                        ((uint16_t)0x0010)            /*!< Data transfer direction */
N#define  DMA_CCR5_CIRC                       ((uint16_t)0x0020)            /*!< Circular mode */
N#define  DMA_CCR5_PINC                       ((uint16_t)0x0040)            /*!< Peripheral increment mode */
N#define  DMA_CCR5_MINC                       ((uint16_t)0x0080)            /*!< Memory increment mode */
N
N#define  DMA_CCR5_PSIZE                      ((uint16_t)0x0300)            /*!< PSIZE[1:0] bits (Peripheral size) */
N#define  DMA_CCR5_PSIZE_0                    ((uint16_t)0x0100)            /*!< Bit 0 */
N#define  DMA_CCR5_PSIZE_1                    ((uint16_t)0x0200)            /*!< Bit 1 */
N
N#define  DMA_CCR5_MSIZE                      ((uint16_t)0x0C00)            /*!< MSIZE[1:0] bits (Memory size) */
N#define  DMA_CCR5_MSIZE_0                    ((uint16_t)0x0400)            /*!< Bit 0 */
N#define  DMA_CCR5_MSIZE_1                    ((uint16_t)0x0800)            /*!< Bit 1 */
N
N#define  DMA_CCR5_PL                         ((uint16_t)0x3000)            /*!< PL[1:0] bits (Channel Priority level) */
N#define  DMA_CCR5_PL_0                       ((uint16_t)0x1000)            /*!< Bit 0 */
N#define  DMA_CCR5_PL_1                       ((uint16_t)0x2000)            /*!< Bit 1 */
N
N#define  DMA_CCR5_MEM2MEM                    ((uint16_t)0x4000)            /*!< Memory to memory mode enable */
N
N/*******************  Bit definition for DMA_CCR6 register  *******************/
N#define  DMA_CCR6_EN                         ((uint16_t)0x0001)            /*!< Channel enable */
N#define  DMA_CCR6_TCIE                       ((uint16_t)0x0002)            /*!< Transfer complete interrupt enable */
N#define  DMA_CCR6_HTIE                       ((uint16_t)0x0004)            /*!< Half Transfer interrupt enable */
N#define  DMA_CCR6_TEIE                       ((uint16_t)0x0008)            /*!< Transfer error interrupt enable */
N#define  DMA_CCR6_DIR                        ((uint16_t)0x0010)            /*!< Data transfer direction */
N#define  DMA_CCR6_CIRC                       ((uint16_t)0x0020)            /*!< Circular mode */
N#define  DMA_CCR6_PINC                       ((uint16_t)0x0040)            /*!< Peripheral increment mode */
N#define  DMA_CCR6_MINC                       ((uint16_t)0x0080)            /*!< Memory increment mode */
N
N#define  DMA_CCR6_PSIZE                      ((uint16_t)0x0300)            /*!< PSIZE[1:0] bits (Peripheral size) */
N#define  DMA_CCR6_PSIZE_0                    ((uint16_t)0x0100)            /*!< Bit 0 */
N#define  DMA_CCR6_PSIZE_1                    ((uint16_t)0x0200)            /*!< Bit 1 */
N
N#define  DMA_CCR6_MSIZE                      ((uint16_t)0x0C00)            /*!< MSIZE[1:0] bits (Memory size) */
N#define  DMA_CCR6_MSIZE_0                    ((uint16_t)0x0400)            /*!< Bit 0 */
N#define  DMA_CCR6_MSIZE_1                    ((uint16_t)0x0800)            /*!< Bit 1 */
N
N#define  DMA_CCR6_PL                         ((uint16_t)0x3000)            /*!< PL[1:0] bits (Channel Priority level) */
N#define  DMA_CCR6_PL_0                       ((uint16_t)0x1000)            /*!< Bit 0 */
N#define  DMA_CCR6_PL_1                       ((uint16_t)0x2000)            /*!< Bit 1 */
N
N#define  DMA_CCR6_MEM2MEM                    ((uint16_t)0x4000)            /*!< Memory to memory mode */
N
N/*******************  Bit definition for DMA_CCR7 register  *******************/
N#define  DMA_CCR7_EN                         ((uint16_t)0x0001)            /*!< Channel enable */
N#define  DMA_CCR7_TCIE                       ((uint16_t)0x0002)            /*!< Transfer complete interrupt enable */
N#define  DMA_CCR7_HTIE                       ((uint16_t)0x0004)            /*!< Half Transfer interrupt enable */
N#define  DMA_CCR7_TEIE                       ((uint16_t)0x0008)            /*!< Transfer error interrupt enable */
N#define  DMA_CCR7_DIR                        ((uint16_t)0x0010)            /*!< Data transfer direction */
N#define  DMA_CCR7_CIRC                       ((uint16_t)0x0020)            /*!< Circular mode */
N#define  DMA_CCR7_PINC                       ((uint16_t)0x0040)            /*!< Peripheral increment mode */
N#define  DMA_CCR7_MINC                       ((uint16_t)0x0080)            /*!< Memory increment mode */
N
N#define  DMA_CCR7_PSIZE            ,         ((uint16_t)0x0300)            /*!< PSIZE[1:0] bits (Peripheral size) */
N#define  DMA_CCR7_PSIZE_0                    ((uint16_t)0x0100)            /*!< Bit 0 */
N#define  DMA_CCR7_PSIZE_1                    ((uint16_t)0x0200)            /*!< Bit 1 */
N
N#define  DMA_CCR7_MSIZE                      ((uint16_t)0x0C00)            /*!< MSIZE[1:0] bits (Memory size) */
N#define  DMA_CCR7_MSIZE_0                    ((uint16_t)0x0400)            /*!< Bit 0 */
N#define  DMA_CCR7_MSIZE_1                    ((uint16_t)0x0800)            /*!< Bit 1 */
N
N#define  DMA_CCR7_PL                         ((uint16_t)0x3000)            /*!< PL[1:0] bits (Channel Priority level) */
N#define  DMA_CCR7_PL_0                       ((uint16_t)0x1000)            /*!< Bit 0 */
N#define  DMA_CCR7_PL_1                       ((uint16_t)0x2000)            /*!< Bit 1 */
N
N#define  DMA_CCR7_MEM2MEM                    ((uint16_t)0x4000)            /*!< Memory to memory mode enable */
N
N/******************  Bit definition for DMA_CNDTR1 register  ******************/
N#define  DMA_CNDTR1_NDT                      ((uint16_t)0xFFFF)            /*!< Number of data to Transfer */
N
N/******************  Bit definition for DMA_CNDTR2 register  ******************/
N#define  DMA_CNDTR2_NDT                      ((uint16_t)0xFFFF)            /*!< Number of data to Transfer */
N
N/******************  Bit definition for DMA_CNDTR3 register  ******************/
N#define  DMA_CNDTR3_NDT                      ((uint16_t)0xFFFF)            /*!< Number of data to Transfer */
N
N/******************  Bit definition for DMA_CNDTR4 register  ******************/
N#define  DMA_CNDTR4_NDT                      ((uint16_t)0xFFFF)            /*!< Number of data to Transfer */
N
N/******************  Bit definition for DMA_CNDTR5 register  ******************/
N#define  DMA_CNDTR5_NDT                      ((uint16_t)0xFFFF)            /*!< Number of data to Transfer */
N
N/******************  Bit definition for DMA_CNDTR6 register  ******************/
N#define  DMA_CNDTR6_NDT                      ((uint16_t)0xFFFF)            /*!< Number of data to Transfer */
N
N/******************  Bit definition for DMA_CNDTR7 register  ******************/
N#define  DMA_CNDTR7_NDT                      ((uint16_t)0xFFFF)            /*!< Number of data to Transfer */
N
N/******************  Bit definition for DMA_CPAR1 register  *******************/
N#define  DMA_CPAR1_PA                        ((uint32_t)0xFFFFFFFF)        /*!< Peripheral Address */
N
N/******************  Bit definition for DMA_CPAR2 register  *******************/
N#define  DMA_CPAR2_PA                        ((uint32_t)0xFFFFFFFF)        /*!< Peripheral Address */
N
N/******************  Bit definition for DMA_CPAR3 register  *******************/
N#define  DMA_CPAR3_PA                        ((uint32_t)0xFFFFFFFF)        /*!< Peripheral Address */
N
N
N/******************  Bit definition for DMA_CPAR4 register  *******************/
N#define  DMA_CPAR4_PA                        ((uint32_t)0xFFFFFFFF)        /*!< Peripheral Address */
N
N/******************  Bit definition for DMA_CPAR5 register  *******************/
N#define  DMA_CPAR5_PA                        ((uint32_t)0xFFFFFFFF)        /*!< Peripheral Address */
N
N/******************  Bit definition for DMA_CPAR6 register  *******************/
N#define  DMA_CPAR6_PA                        ((uint32_t)0xFFFFFFFF)        /*!< Peripheral Address */
N
N
N/******************  Bit definition for DMA_CPAR7 register  *******************/
N#define  DMA_CPAR7_PA                        ((uint32_t)0xFFFFFFFF)        /*!< Peripheral Address */
N
N/******************  Bit definition for DMA_CMAR1 register  *******************/
N#define  DMA_CMAR1_MA                        ((uint32_t)0xFFFFFFFF)        /*!< Memory Address */
N
N/******************  Bit definition for DMA_CMAR2 register  *******************/
N#define  DMA_CMAR2_MA                        ((uint32_t)0xFFFFFFFF)        /*!< Memory Address */
N
N/******************  Bit definition for DMA_CMAR3 register  *******************/
N#define  DMA_CMAR3_MA                        ((uint32_t)0xFFFFFFFF)        /*!< Memory Address */
N
N
N/******************  Bit definition for DMA_CMAR4 register  *******************/
N#define  DMA_CMAR4_MA                        ((uint32_t)0xFFFFFFFF)        /*!< Memory Address */
N
N/******************  Bit definition for DMA_CMAR5 register  *******************/
N#define  DMA_CMAR5_MA                        ((uint32_t)0xFFFFFFFF)        /*!< Memory Address */
N
N/******************  Bit definition for DMA_CMAR6 register  *******************/
N#define  DMA_CMAR6_MA                        ((uint32_t)0xFFFFFFFF)        /*!< Memory Address */
N
N/******************  Bit definition for DMA_CMAR7 register  *******************/
N#define  DMA_CMAR7_MA                        ((uint32_t)0xFFFFFFFF)        /*!< Memory Address */
N
N/******************************************************************************/
N/*                                                                            */
N/*                        Analog to Digital Converter                         */
N/*                                                                            */
N/******************************************************************************/
N
N/********************  Bit definition for ADC_SR register  ********************/
N#define  ADC_SR_AWD                          ((uint8_t)0x01)               /*!< Analog watchdog flag */
N#define  ADC_SR_EOC                          ((uint8_t)0x02)               /*!< End of conversion */
N#define  ADC_SR_JEOC                         ((uint8_t)0x04)               /*!< Injected channel end of conversion */
N#define  ADC_SR_JSTRT                        ((uint8_t)0x08)               /*!< Injected channel Start flag */
N#define  ADC_SR_STRT                         ((uint8_t)0x10)               /*!< Regular channel Start flag */
N
N/*******************  Bit definition for ADC_CR1 register  ********************/
N#define  ADC_CR1_AWDCH                       ((uint32_t)0x0000001F)        /*!< AWDCH[4:0] bits (Analog watchdog channel select bits) */
N#define  ADC_CR1_AWDCH_0                     ((uint32_t)0x00000001)        /*!< Bit 0 */
N#define  ADC_CR1_AWDCH_1                     ((uint32_t)0x00000002)        /*!< Bit 1 */
N#define  ADC_CR1_AWDCH_2                     ((uint32_t)0x00000004)        /*!< Bit 2 */
N#define  ADC_CR1_AWDCH_3                     ((uint32_t)0x00000008)        /*!< Bit 3 */
N#define  ADC_CR1_AWDCH_4                     ((uint32_t)0x00000010)        /*!< Bit 4 */
N
N#define  ADC_CR1_EOCIE                       ((uint32_t)0x00000020)        /*!< Interrupt enable for EOC */
N#define  ADC_CR1_AWDIE                       ((uint32_t)0x00000040)        /*!< Analog Watchdog interrupt enable */
N#define  ADC_CR1_JEOCIE                      ((uint32_t)0x00000080)        /*!< Interrupt enable for injected channels */
N#define  ADC_CR1_SCAN                        ((uint32_t)0x00000100)        /*!< Scan mode */
N#define  ADC_CR1_AWDSGL                      ((uint32_t)0x00000200)        /*!< Enable the watchdog on a single channel in scan mode */
N#define  ADC_CR1_JAUTO                       ((uint32_t)0x00000400)        /*!< Automatic injected group conversion */
N#define  ADC_CR1_DISCEN                      ((uint32_t)0x00000800)        /*!< Discontinuous mode on regular channels */
N#define  ADC_CR1_JDISCEN                     ((uint32_t)0x00001000)        /*!< Discontinuous mode on injected channels */
N
N#define  ADC_CR1_DISCNUM                     ((uint32_t)0x0000E000)        /*!< DISCNUM[2:0] bits (Discontinuous mode channel count) */
N#define  ADC_CR1_DISCNUM_0                   ((uint32_t)0x00002000)        /*!< Bit 0 */
N#define  ADC_CR1_DISCNUM_1                   ((uint32_t)0x00004000)        /*!< Bit 1 */
N#define  ADC_CR1_DISCNUM_2                   ((uint32_t)0x00008000)        /*!< Bit 2 */
N
N#define  ADC_CR1_DUALMOD                     ((uint32_t)0x000F0000)        /*!< DUALMOD[3:0] bits (Dual mode selection) */
N#define  ADC_CR1_DUALMOD_0                   ((uint32_t)0x00010000)        /*!< Bit 0 */
N#define  ADC_CR1_DUALMOD_1                   ((uint32_t)0x00020000)        /*!< Bit 1 */
N#define  ADC_CR1_DUALMOD_2                   ((uint32_t)0x00040000)        /*!< Bit 2 */
N#define  ADC_CR1_DUALMOD_3                   ((uint32_t)0x00080000)        /*!< Bit 3 */
N
N#define  ADC_CR1_JAWDEN                      ((uint32_t)0x00400000)        /*!< Analog watchdog enable on injected channels */
N#define  ADC_CR1_AWDEN                       ((uint32_t)0x00800000)        /*!< Analog watchdog enable on regular channels */
N
N  
N/*******************  Bit definition for ADC_CR2 register  ********************/
N#define  ADC_CR2_ADON                        ((uint32_t)0x00000001)        /*!< A/D Converter ON / OFF */
N#define  ADC_CR2_CONT                        ((uint32_t)0x00000002)        /*!< Continuous Conversion */
N#define  ADC_CR2_CAL                         ((uint32_t)0x00000004)        /*!< A/D Calibration */
N#define  ADC_CR2_RSTCAL                      ((uint32_t)0x00000008)        /*!< Reset Calibration */
N#define  ADC_CR2_DMA                         ((uint32_t)0x00000100)        /*!< Direct Memory access mode */
N#define  ADC_CR2_ALIGN                       ((uint32_t)0x00000800)        /*!< Data Alignment */
N
N#define  ADC_CR2_JEXTSEL                     ((uint32_t)0x00007000)        /*!< JEXTSEL[2:0] bits (External event select for injected group) */
N#define  ADC_CR2_JEXTSEL_0                   ((uint32_t)0x00001000)        /*!< Bit 0 */
N#define  ADC_CR2_JEXTSEL_1                   ((uint32_t)0x00002000)        /*!< Bit 1 */
N#define  ADC_CR2_JEXTSEL_2                   ((uint32_t)0x00004000)        /*!< Bit 2 */
N
N#define  ADC_CR2_JEXTTRIG                    ((uint32_t)0x00008000)        /*!< External Trigger Conversion mode for injected channels */
N
N#define  ADC_CR2_EXTSEL                      ((uint32_t)0x000E0000)        /*!< EXTSEL[2:0] bits (External Event Select for regular group) */
N#define  ADC_CR2_EXTSEL_0                    ((uint32_t)0x00020000)        /*!< Bit 0 */
N#define  ADC_CR2_EXTSEL_1                    ((uint32_t)0x00040000)        /*!< Bit 1 */
N#define  ADC_CR2_EXTSEL_2                    ((uint32_t)0x00080000)        /*!< Bit 2 */
N
N#define  ADC_CR2_EXTTRIG                     ((uint32_t)0x00100000)        /*!< External Trigger Conversion mode for regular channels */
N#define  ADC_CR2_JSWSTART                    ((uint32_t)0x00200000)        /*!< Start Conversion of injected channels */
N#define  ADC_CR2_SWSTART                     ((uint32_t)0x00400000)        /*!< Start Conversion of regular channels */
N#define  ADC_CR2_TSVREFE                     ((uint32_t)0x00800000)        /*!< Temperature Sensor and VREFINT Enable */
N
N/******************  Bit definition for ADC_SMPR1 register  *******************/
N#define  ADC_SMPR1_SMP10                     ((uint32_t)0x00000007)        /*!< SMP10[2:0] bits (Channel 10 Sample time selection) */
N#define  ADC_SMPR1_SMP10_0                   ((uint32_t)0x00000001)        /*!< Bit 0 */
N#define  ADC_SMPR1_SMP10_1                   ((uint32_t)0x00000002)        /*!< Bit 1 */
N#define  ADC_SMPR1_SMP10_2                   ((uint32_t)0x00000004)        /*!< Bit 2 */
N
N#define  ADC_SMPR1_SMP11                     ((uint32_t)0x00000038)        /*!< SMP11[2:0] bits (Channel 11 Sample time selection) */
N#define  ADC_SMPR1_SMP11_0                   ((uint32_t)0x00000008)        /*!< Bit 0 */
N#define  ADC_SMPR1_SMP11_1                   ((uint32_t)0x00000010)        /*!< Bit 1 */
N#define  ADC_SMPR1_SMP11_2                   ((uint32_t)0x00000020)        /*!< Bit 2 */
N
N#define  ADC_SMPR1_SMP12                     ((uint32_t)0x000001C0)        /*!< SMP12[2:0] bits (Channel 12 Sample time selection) */
N#define  ADC_SMPR1_SMP12_0                   ((uint32_t)0x00000040)        /*!< Bit 0 */
N#define  ADC_SMPR1_SMP12_1                   ((uint32_t)0x00000080)        /*!< Bit 1 */
N#define  ADC_SMPR1_SMP12_2                   ((uint32_t)0x00000100)        /*!< Bit 2 */
N
N#define  ADC_SMPR1_SMP13                     ((uint32_t)0x00000E00)        /*!< SMP13[2:0] bits (Channel 13 Sample time selection) */
N#define  ADC_SMPR1_SMP13_0                   ((uint32_t)0x00000200)        /*!< Bit 0 */
N#define  ADC_SMPR1_SMP13_1                   ((uint32_t)0x00000400)        /*!< Bit 1 */
N#define  ADC_SMPR1_SMP13_2                   ((uint32_t)0x00000800)        /*!< Bit 2 */
N
N#define  ADC_SMPR1_SMP14                     ((uint32_t)0x00007000)        /*!< SMP14[2:0] bits (Channel 14 Sample time selection) */
N#define  ADC_SMPR1_SMP14_0                   ((uint32_t)0x00001000)        /*!< Bit 0 */
N#define  ADC_SMPR1_SMP14_1                   ((uint32_t)0x00002000)        /*!< Bit 1 */
N#define  ADC_SMPR1_SMP14_2                   ((uint32_t)0x00004000)        /*!< Bit 2 */
N
N#define  ADC_SMPR1_SMP15                     ((uint32_t)0x00038000)        /*!< SMP15[2:0] bits (Channel 15 Sample time selection) */
N#define  ADC_SMPR1_SMP15_0                   ((uint32_t)0x00008000)        /*!< Bit 0 */
N#define  ADC_SMPR1_SMP15_1                   ((uint32_t)0x00010000)        /*!< Bit 1 */
N#define  ADC_SMPR1_SMP15_2                   ((uint32_t)0x00020000)        /*!< Bit 2 */
N
N#define  ADC_SMPR1_SMP16                     ((uint32_t)0x001C0000)        /*!< SMP16[2:0] bits (Channel 16 Sample time selection) */
N#define  ADC_SMPR1_SMP16_0                   ((uint32_t)0x00040000)        /*!< Bit 0 */
N#define  ADC_SMPR1_SMP16_1                   ((uint32_t)0x00080000)        /*!< Bit 1 */
N#define  ADC_SMPR1_SMP16_2                   ((uint32_t)0x00100000)        /*!< Bit 2 */
N
N#define  ADC_SMPR1_SMP17                     ((uint32_t)0x00E00000)        /*!< SMP17[2:0] bits (Channel 17 Sample time selection) */
N#define  ADC_SMPR1_SMP17_0                   ((uint32_t)0x00200000)        /*!< Bit 0 */
N#define  ADC_SMPR1_SMP17_1                   ((uint32_t)0x00400000)        /*!< Bit 1 */
N#define  ADC_SMPR1_SMP17_2                   ((uint32_t)0x00800000)        /*!< Bit 2 */
N
N/******************  Bit definition for ADC_SMPR2 register  *******************/
N#define  ADC_SMPR2_SMP0                      ((uint32_t)0x00000007)        /*!< SMP0[2:0] bits (Channel 0 Sample time selection) */
N#define  ADC_SMPR2_SMP0_0                    ((uint32_t)0x00000001)        /*!< Bit 0 */
N#define  ADC_SMPR2_SMP0_1                    ((uint32_t)0x00000002)        /*!< Bit 1 */
N#define  ADC_SMPR2_SMP0_2                    ((uint32_t)0x00000004)        /*!< Bit 2 */
N
N#define  ADC_SMPR2_SMP1                      ((uint32_t)0x00000038)        /*!< SMP1[2:0] bits (Channel 1 Sample time selection) */
N#define  ADC_SMPR2_SMP1_0                    ((uint32_t)0x00000008)        /*!< Bit 0 */
N#define  ADC_SMPR2_SMP1_1                    ((uint32_t)0x00000010)        /*!< Bit 1 */
N#define  ADC_SMPR2_SMP1_2                    ((uint32_t)0x00000020)        /*!< Bit 2 */
N
N#define  ADC_SMPR2_SMP2                      ((uint32_t)0x000001C0)        /*!< SMP2[2:0] bits (Channel 2 Sample time selection) */
N#define  ADC_SMPR2_SMP2_0                    ((uint32_t)0x00000040)        /*!< Bit 0 */
N#define  ADC_SMPR2_SMP2_1                    ((uint32_t)0x00000080)        /*!< Bit 1 */
N#define  ADC_SMPR2_SMP2_2                    ((uint32_t)0x00000100)        /*!< Bit 2 */
N
N#define  ADC_SMPR2_SMP3                      ((uint32_t)0x00000E00)        /*!< SMP3[2:0] bits (Channel 3 Sample time selection) */
N#define  ADC_SMPR2_SMP3_0                    ((uint32_t)0x00000200)        /*!< Bit 0 */
N#define  ADC_SMPR2_SMP3_1                    ((uint32_t)0x00000400)        /*!< Bit 1 */
N#define  ADC_SMPR2_SMP3_2                    ((uint32_t)0x00000800)        /*!< Bit 2 */
N
N#define  ADC_SMPR2_SMP4                      ((uint32_t)0x00007000)        /*!< SMP4[2:0] bits (Channel 4 Sample time selection) */
N#define  ADC_SMPR2_SMP4_0                    ((uint32_t)0x00001000)        /*!< Bit 0 */
N#define  ADC_SMPR2_SMP4_1                    ((uint32_t)0x00002000)        /*!< Bit 1 */
N#define  ADC_SMPR2_SMP4_2                    ((uint32_t)0x00004000)        /*!< Bit 2 */
N
N#define  ADC_SMPR2_SMP5                      ((uint32_t)0x00038000)        /*!< SMP5[2:0] bits (Channel 5 Sample time selection) */
N#define  ADC_SMPR2_SMP5_0                    ((uint32_t)0x00008000)        /*!< Bit 0 */
N#define  ADC_SMPR2_SMP5_1                    ((uint32_t)0x00010000)        /*!< Bit 1 */
N#define  ADC_SMPR2_SMP5_2                    ((uint32_t)0x00020000)        /*!< Bit 2 */
N
N#define  ADC_SMPR2_SMP6                      ((uint32_t)0x001C0000)        /*!< SMP6[2:0] bits (Channel 6 Sample time selection) */
N#define  ADC_SMPR2_SMP6_0                    ((uint32_t)0x00040000)        /*!< Bit 0 */
N#define  ADC_SMPR2_SMP6_1                    ((uint32_t)0x00080000)        /*!< Bit 1 */
N#define  ADC_SMPR2_SMP6_2                    ((uint32_t)0x00100000)        /*!< Bit 2 */
N
N#define  ADC_SMPR2_SMP7                      ((uint32_t)0x00E00000)        /*!< SMP7[2:0] bits (Channel 7 Sample time selection) */
N#define  ADC_SMPR2_SMP7_0                    ((uint32_t)0x00200000)        /*!< Bit 0 */
N#define  ADC_SMPR2_SMP7_1                    ((uint32_t)0x00400000)        /*!< Bit 1 */
N#define  ADC_SMPR2_SMP7_2                    ((uint32_t)0x00800000)        /*!< Bit 2 */
N
N#define  ADC_SMPR2_SMP8                      ((uint32_t)0x07000000)        /*!< SMP8[2:0] bits (Channel 8 Sample time selection) */
N#define  ADC_SMPR2_SMP8_0                    ((uint32_t)0x01000000)        /*!< Bit 0 */
N#define  ADC_SMPR2_SMP8_1                    ((uint32_t)0x02000000)        /*!< Bit 1 */
N#define  ADC_SMPR2_SMP8_2                    ((uint32_t)0x04000000)        /*!< Bit 2 */
N
N#define  ADC_SMPR2_SMP9                      ((uint32_t)0x38000000)        /*!< SMP9[2:0] bits (Channel 9 Sample time selection) */
N#define  ADC_SMPR2_SMP9_0                    ((uint32_t)0x08000000)        /*!< Bit 0 */
N#define  ADC_SMPR2_SMP9_1                    ((uint32_t)0x10000000)        /*!< Bit 1 */
N#define  ADC_SMPR2_SMP9_2                    ((uint32_t)0x20000000)        /*!< Bit 2 */
N
N/******************  Bit definition for ADC_JOFR1 register  *******************/
N#define  ADC_JOFR1_JOFFSET1                  ((uint16_t)0x0FFF)            /*!< Data offset for injected channel 1 */
N
N/******************  Bit definition for ADC_JOFR2 register  *******************/
N#define  ADC_JOFR2_JOFFSET2                  ((uint16_t)0x0FFF)            /*!< Data offset for injected channel 2 */
N
N/******************  Bit definition for ADC_JOFR3 register  *******************/
N#define  ADC_JOFR3_JOFFSET3                  ((uint16_t)0x0FFF)            /*!< Data offset for injected channel 3 */
N
N/******************  Bit definition for ADC_JOFR4 register  *******************/
N#define  ADC_JOFR4_JOFFSET4                  ((uint16_t)0x0FFF)            /*!< Data offset for injected channel 4 */
N
N/*******************  Bit definition for ADC_HTR register  ********************/
N#define  ADC_HTR_HT                          ((uint16_t)0x0FFF)            /*!< Analog watchdog high threshold */
N
N/*******************  Bit definition for ADC_LTR register  ********************/
N#define  ADC_LTR_LT                          ((uint16_t)0x0FFF)            /*!< Analog watchdog low threshold */
N
N/*******************  Bit definition for ADC_SQR1 register  *******************/
N#define  ADC_SQR1_SQ13                       ((uint32_t)0x0000001F)        /*!< SQ13[4:0] bits (13th conversion in regular sequence) */
N#define  ADC_SQR1_SQ13_0                     ((uint32_t)0x00000001)        /*!< Bit 0 */
N#define  ADC_SQR1_SQ13_1                     ((uint32_t)0x00000002)        /*!< Bit 1 */
N#define  ADC_SQR1_SQ13_2                     ((uint32_t)0x00000004)        /*!< Bit 2 */
N#define  ADC_SQR1_SQ13_3                     ((uint32_t)0x00000008)        /*!< Bit 3 */
N#define  ADC_SQR1_SQ13_4                     ((uint32_t)0x00000010)        /*!< Bit 4 */
N
N#define  ADC_SQR1_SQ14                       ((uint32_t)0x000003E0)        /*!< SQ14[4:0] bits (14th conversion in regular sequence) */
N#define  ADC_SQR1_SQ14_0                     ((uint32_t)0x00000020)        /*!< Bit 0 */
N#define  ADC_SQR1_SQ14_1                     ((uint32_t)0x00000040)        /*!< Bit 1 */
N#define  ADC_SQR1_SQ14_2                     ((uint32_t)0x00000080)        /*!< Bit 2 */
N#define  ADC_SQR1_SQ14_3                     ((uint32_t)0x00000100)        /*!< Bit 3 */
N#define  ADC_SQR1_SQ14_4                     ((uint32_t)0x00000200)        /*!< Bit 4 */
N
N#define  ADC_SQR1_SQ15                       ((uint32_t)0x00007C00)        /*!< SQ15[4:0] bits (15th conversion in regular sequence) */
N#define  ADC_SQR1_SQ15_0                     ((uint32_t)0x00000400)        /*!< Bit 0 */
N#define  ADC_SQR1_SQ15_1                     ((uint32_t)0x00000800)        /*!< Bit 1 */
N#define  ADC_SQR1_SQ15_2                     ((uint32_t)0x00001000)        /*!< Bit 2 */
N#define  ADC_SQR1_SQ15_3                     ((uint32_t)0x00002000)        /*!< Bit 3 */
N#define  ADC_SQR1_SQ15_4                     ((uint32_t)0x00004000)        /*!< Bit 4 */
N
N#define  ADC_SQR1_SQ16                       ((uint32_t)0x000F8000)        /*!< SQ16[4:0] bits (16th conversion in regular sequence) */
N#define  ADC_SQR1_SQ16_0                     ((uint32_t)0x00008000)        /*!< Bit 0 */
N#define  ADC_SQR1_SQ16_1                     ((uint32_t)0x00010000)        /*!< Bit 1 */
N#define  ADC_SQR1_SQ16_2                     ((uint32_t)0x00020000)        /*!< Bit 2 */
N#define  ADC_SQR1_SQ16_3                     ((uint32_t)0x00040000)        /*!< Bit 3 */
N#define  ADC_SQR1_SQ16_4                     ((uint32_t)0x00080000)        /*!< Bit 4 */
N
N#define  ADC_SQR1_L                          ((uint32_t)0x00F00000)        /*!< L[3:0] bits (Regular channel sequence length) */
N#define  ADC_SQR1_L_0                        ((uint32_t)0x00100000)        /*!< Bit 0 */
N#define  ADC_SQR1_L_1                        ((uint32_t)0x00200000)        /*!< Bit 1 */
N#define  ADC_SQR1_L_2                        ((uint32_t)0x00400000)        /*!< Bit 2 */
N#define  ADC_SQR1_L_3                        ((uint32_t)0x00800000)        /*!< Bit 3 */
N
N/*******************  Bit definition for ADC_SQR2 register  *******************/
N#define  ADC_SQR2_SQ7                        ((uint32_t)0x0000001F)        /*!< SQ7[4:0] bits (7th conversion in regular sequence) */
N#define  ADC_SQR2_SQ7_0                      ((uint32_t)0x00000001)        /*!< Bit 0 */
N#define  ADC_SQR2_SQ7_1                      ((uint32_t)0x00000002)        /*!< Bit 1 */
N#define  ADC_SQR2_SQ7_2                      ((uint32_t)0x00000004)        /*!< Bit 2 */
N#define  ADC_SQR2_SQ7_3                      ((uint32_t)0x00000008)        /*!< Bit 3 */
N#define  ADC_SQR2_SQ7_4                      ((uint32_t)0x00000010)        /*!< Bit 4 */
N
N#define  ADC_SQR2_SQ8                        ((uint32_t)0x000003E0)        /*!< SQ8[4:0] bits (8th conversion in regular sequence) */
N#define  ADC_SQR2_SQ8_0                      ((uint32_t)0x00000020)        /*!< Bit 0 */
N#define  ADC_SQR2_SQ8_1                      ((uint32_t)0x00000040)        /*!< Bit 1 */
N#define  ADC_SQR2_SQ8_2                      ((uint32_t)0x00000080)        /*!< Bit 2 */
N#define  ADC_SQR2_SQ8_3                      ((uint32_t)0x00000100)        /*!< Bit 3 */
N#define  ADC_SQR2_SQ8_4                      ((uint32_t)0x00000200)        /*!< Bit 4 */
N
N#define  ADC_SQR2_SQ9                        ((uint32_t)0x00007C00)        /*!< SQ9[4:0] bits (9th conversion in regular sequence) */
N#define  ADC_SQR2_SQ9_0                      ((uint32_t)0x00000400)        /*!< Bit 0 */
N#define  ADC_SQR2_SQ9_1                      ((uint32_t)0x00000800)        /*!< Bit 1 */
N#define  ADC_SQR2_SQ9_2                      ((uint32_t)0x00001000)        /*!< Bit 2 */
N#define  ADC_SQR2_SQ9_3                      ((uint32_t)0x00002000)        /*!< Bit 3 */
N#define  ADC_SQR2_SQ9_4                      ((uint32_t)0x00004000)        /*!< Bit 4 */
N
N#define  ADC_SQR2_SQ10                       ((uint32_t)0x000F8000)        /*!< SQ10[4:0] bits (10th conversion in regular sequence) */
N#define  ADC_SQR2_SQ10_0                     ((uint32_t)0x00008000)        /*!< Bit 0 */
N#define  ADC_SQR2_SQ10_1                     ((uint32_t)0x00010000)        /*!< Bit 1 */
N#define  ADC_SQR2_SQ10_2                     ((uint32_t)0x00020000)        /*!< Bit 2 */
N#define  ADC_SQR2_SQ10_3                     ((uint32_t)0x00040000)        /*!< Bit 3 */
N#define  ADC_SQR2_SQ10_4                     ((uint32_t)0x00080000)        /*!< Bit 4 */
N
N#define  ADC_SQR2_SQ11                       ((uint32_t)0x01F00000)        /*!< SQ11[4:0] bits (11th conversion in regular sequence) */
N#define  ADC_SQR2_SQ11_0                     ((uint32_t)0x00100000)        /*!< Bit 0 */
N#define  ADC_SQR2_SQ11_1                     ((uint32_t)0x00200000)        /*!< Bit 1 */
N#define  ADC_SQR2_SQ11_2                     ((uint32_t)0x00400000)        /*!< Bit 2 */
N#define  ADC_SQR2_SQ11_3                     ((uint32_t)0x00800000)        /*!< Bit 3 */
N#define  ADC_SQR2_SQ11_4                     ((uint32_t)0x01000000)        /*!< Bit 4 */
N
N#define  ADC_SQR2_SQ12                       ((uint32_t)0x3E000000)        /*!< SQ12[4:0] bits (12th conversion in regular sequence) */
N#define  ADC_SQR2_SQ12_0                     ((uint32_t)0x02000000)        /*!< Bit 0 */
N#define  ADC_SQR2_SQ12_1                     ((uint32_t)0x04000000)        /*!< Bit 1 */
N#define  ADC_SQR2_SQ12_2                     ((uint32_t)0x08000000)        /*!< Bit 2 */
N#define  ADC_SQR2_SQ12_3                     ((uint32_t)0x10000000)        /*!< Bit 3 */
N#define  ADC_SQR2_SQ12_4                     ((uint32_t)0x20000000)        /*!< Bit 4 */
N
N/*******************  Bit definition for ADC_SQR3 register  *******************/
N#define  ADC_SQR3_SQ1                        ((uint32_t)0x0000001F)        /*!< SQ1[4:0] bits (1st conversion in regular sequence) */
N#define  ADC_SQR3_SQ1_0                      ((uint32_t)0x00000001)        /*!< Bit 0 */
N#define  ADC_SQR3_SQ1_1                      ((uint32_t)0x00000002)        /*!< Bit 1 */
N#define  ADC_SQR3_SQ1_2                      ((uint32_t)0x00000004)        /*!< Bit 2 */
N#define  ADC_SQR3_SQ1_3                      ((uint32_t)0x00000008)        /*!< Bit 3 */
N#define  ADC_SQR3_SQ1_4                      ((uint32_t)0x00000010)        /*!< Bit 4 */
N
N#define  ADC_SQR3_SQ2                        ((uint32_t)0x000003E0)        /*!< SQ2[4:0] bits (2nd conversion in regular sequence) */
N#define  ADC_SQR3_SQ2_0                      ((uint32_t)0x00000020)        /*!< Bit 0 */
N#define  ADC_SQR3_SQ2_1                      ((uint32_t)0x00000040)        /*!< Bit 1 */
N#define  ADC_SQR3_SQ2_2                      ((uint32_t)0x00000080)        /*!< Bit 2 */
N#define  ADC_SQR3_SQ2_3                      ((uint32_t)0x00000100)        /*!< Bit 3 */
N#define  ADC_SQR3_SQ2_4                      ((uint32_t)0x00000200)        /*!< Bit 4 */
N
N#define  ADC_SQR3_SQ3                        ((uint32_t)0x00007C00)        /*!< SQ3[4:0] bits (3rd conversion in regular sequence) */
N#define  ADC_SQR3_SQ3_0                      ((uint32_t)0x00000400)        /*!< Bit 0 */
N#define  ADC_SQR3_SQ3_1                      ((uint32_t)0x00000800)        /*!< Bit 1 */
N#define  ADC_SQR3_SQ3_2                      ((uint32_t)0x00001000)        /*!< Bit 2 */
N#define  ADC_SQR3_SQ3_3                      ((uint32_t)0x00002000)        /*!< Bit 3 */
N#define  ADC_SQR3_SQ3_4                      ((uint32_t)0x00004000)        /*!< Bit 4 */
N
N#define  ADC_SQR3_SQ4                        ((uint32_t)0x000F8000)        /*!< SQ4[4:0] bits (4th conversion in regular sequence) */
N#define  ADC_SQR3_SQ4_0                      ((uint32_t)0x00008000)        /*!< Bit 0 */
N#define  ADC_SQR3_SQ4_1                      ((uint32_t)0x00010000)        /*!< Bit 1 */
N#define  ADC_SQR3_SQ4_2                      ((uint32_t)0x00020000)        /*!< Bit 2 */
N#define  ADC_SQR3_SQ4_3                      ((uint32_t)0x00040000)        /*!< Bit 3 */
N#define  ADC_SQR3_SQ4_4                      ((uint32_t)0x00080000)        /*!< Bit 4 */
N
N#define  ADC_SQR3_SQ5                        ((uint32_t)0x01F00000)        /*!< SQ5[4:0] bits (5th conversion in regular sequence) */
N#define  ADC_SQR3_SQ5_0                      ((uint32_t)0x00100000)        /*!< Bit 0 */
N#define  ADC_SQR3_SQ5_1                      ((uint32_t)0x00200000)        /*!< Bit 1 */
N#define  ADC_SQR3_SQ5_2                      ((uint32_t)0x00400000)        /*!< Bit 2 */
N#define  ADC_SQR3_SQ5_3                      ((uint32_t)0x00800000)        /*!< Bit 3 */
N#define  ADC_SQR3_SQ5_4                      ((uint32_t)0x01000000)        /*!< Bit 4 */
N
N#define  ADC_SQR3_SQ6                        ((uint32_t)0x3E000000)        /*!< SQ6[4:0] bits (6th conversion in regular sequence) */
N#define  ADC_SQR3_SQ6_0                      ((uint32_t)0x02000000)        /*!< Bit 0 */
N#define  ADC_SQR3_SQ6_1                      ((uint32_t)0x04000000)        /*!< Bit 1 */
N#define  ADC_SQR3_SQ6_2                      ((uint32_t)0x08000000)        /*!< Bit 2 */
N#define  ADC_SQR3_SQ6_3                      ((uint32_t)0x10000000)        /*!< Bit 3 */
N#define  ADC_SQR3_SQ6_4                      ((uint32_t)0x20000000)        /*!< Bit 4 */
N
N/*******************  Bit definition for ADC_JSQR register  *******************/
N#define  ADC_JSQR_JSQ1                       ((uint32_t)0x0000001F)        /*!< JSQ1[4:0] bits (1st conversion in injected sequence) */  
N#define  ADC_JSQR_JSQ1_0                     ((uint32_t)0x00000001)        /*!< Bit 0 */
N#define  ADC_JSQR_JSQ1_1                     ((uint32_t)0x00000002)        /*!< Bit 1 */
N#define  ADC_JSQR_JSQ1_2                     ((uint32_t)0x00000004)        /*!< Bit 2 */
N#define  ADC_JSQR_JSQ1_3                     ((uint32_t)0x00000008)        /*!< Bit 3 */
N#define  ADC_JSQR_JSQ1_4                     ((uint32_t)0x00000010)        /*!< Bit 4 */
N
N#define  ADC_JSQR_JSQ2                       ((uint32_t)0x000003E0)        /*!< JSQ2[4:0] bits (2nd conversion in injected sequence) */
N#define  ADC_JSQR_JSQ2_0                     ((uint32_t)0x00000020)        /*!< Bit 0 */
N#define  ADC_JSQR_JSQ2_1                     ((uint32_t)0x00000040)        /*!< Bit 1 */
N#define  ADC_JSQR_JSQ2_2                     ((uint32_t)0x00000080)        /*!< Bit 2 */
N#define  ADC_JSQR_JSQ2_3                     ((uint32_t)0x00000100)        /*!< Bit 3 */
N#define  ADC_JSQR_JSQ2_4                     ((uint32_t)0x00000200)        /*!< Bit 4 */
N
N#define  ADC_JSQR_JSQ3                       ((uint32_t)0x00007C00)        /*!< JSQ3[4:0] bits (3rd conversion in injected sequence) */
N#define  ADC_JSQR_JSQ3_0                     ((uint32_t)0x00000400)        /*!< Bit 0 */
N#define  ADC_JSQR_JSQ3_1                     ((uint32_t)0x00000800)        /*!< Bit 1 */
N#define  ADC_JSQR_JSQ3_2                     ((uint32_t)0x00001000)        /*!< Bit 2 */
N#define  ADC_JSQR_JSQ3_3                     ((uint32_t)0x00002000)        /*!< Bit 3 */
N#define  ADC_JSQR_JSQ3_4                     ((uint32_t)0x00004000)        /*!< Bit 4 */
N
N#define  ADC_JSQR_JSQ4                       ((uint32_t)0x000F8000)        /*!< JSQ4[4:0] bits (4th conversion in injected sequence) */
N#define  ADC_JSQR_JSQ4_0                     ((uint32_t)0x00008000)        /*!< Bit 0 */
N#define  ADC_JSQR_JSQ4_1                     ((uint32_t)0x00010000)        /*!< Bit 1 */
N#define  ADC_JSQR_JSQ4_2                     ((uint32_t)0x00020000)        /*!< Bit 2 */
N#define  ADC_JSQR_JSQ4_3                     ((uint32_t)0x00040000)        /*!< Bit 3 */
N#define  ADC_JSQR_JSQ4_4                     ((uint32_t)0x00080000)        /*!< Bit 4 */
N
N#define  ADC_JSQR_JL                         ((uint32_t)0x00300000)        /*!< JL[1:0] bits (Injected Sequence length) */
N#define  ADC_JSQR_JL_0                       ((uint32_t)0x00100000)        /*!< Bit 0 */
N#define  ADC_JSQR_JL_1                       ((uint32_t)0x00200000)        /*!< Bit 1 */
N
N/*******************  Bit definition for ADC_JDR1 register  *******************/
N#define  ADC_JDR1_JDATA                      ((uint16_t)0xFFFF)            /*!< Injected data */
N
N/*******************  Bit definition for ADC_JDR2 register  *******************/
N#define  ADC_JDR2_JDATA                      ((uint16_t)0xFFFF)            /*!< Injected data */
N
N/*******************  Bit definition for ADC_JDR3 register  *******************/
N#define  ADC_JDR3_JDATA                      ((uint16_t)0xFFFF)            /*!< Injected data */
N
N/*******************  Bit definition for ADC_JDR4 register  *******************/
N#define  ADC_JDR4_JDATA                      ((uint16_t)0xFFFF)            /*!< Injected data */
N
N/********************  Bit definition for ADC_DR register  ********************/
N#define  ADC_DR_DATA                         ((uint32_t)0x0000FFFF)        /*!< Regular data */
N#define  ADC_DR_ADC2DATA                     ((uint32_t)0xFFFF0000)        /*!< ADC2 data */
N
N/******************************************************************************/
N/*                                                                            */
N/*                      Digital to Analog Converter                           */
N/*                                                                            */
N/******************************************************************************/
N
N/********************  Bit definition for DAC_CR register  ********************/
N#define  DAC_CR_EN1                          ((uint32_t)0x00000001)        /*!< DAC channel1 enable */
N#define  DAC_CR_BOFF1                        ((uint32_t)0x00000002)        /*!< DAC channel1 output buffer disable */
N#define  DAC_CR_TEN1                         ((uint32_t)0x00000004)        /*!< DAC channel1 Trigger enable */
N
N#define  DAC_CR_TSEL1                        ((uint32_t)0x00000038)        /*!< TSEL1[2:0] (DAC channel1 Trigger selection) */
N#define  DAC_CR_TSEL1_0                      ((uint32_t)0x00000008)        /*!< Bit 0 */
N#define  DAC_CR_TSEL1_1                      ((uint32_t)0x00000010)        /*!< Bit 1 */
N#define  DAC_CR_TSEL1_2                      ((uint32_t)0x00000020)        /*!< Bit 2 */
N
N#define  DAC_CR_WAVE1                        ((uint32_t)0x000000C0)        /*!< WAVE1[1:0] (DAC channel1 noise/triangle wave generation enable) */
N#define  DAC_CR_WAVE1_0                      ((uint32_t)0x00000040)        /*!< Bit 0 */
N#define  DAC_CR_WAVE1_1                      ((uint32_t)0x00000080)        /*!< Bit 1 */
N
N#define  DAC_CR_MAMP1                        ((uint32_t)0x00000F00)        /*!< MAMP1[3:0] (DAC channel1 Mask/Amplitude selector) */
N#define  DAC_CR_MAMP1_0                      ((uint32_t)0x00000100)        /*!< Bit 0 */
N#define  DAC_CR_MAMP1_1                      ((uint32_t)0x00000200)        /*!< Bit 1 */
N#define  DAC_CR_MAMP1_2                      ((uint32_t)0x00000400)        /*!< Bit 2 */
N#define  DAC_CR_MAMP1_3                      ((uint32_t)0x00000800)        /*!< Bit 3 */
N
N#define  DAC_CR_DMAEN1                       ((uint32_t)0x00001000)        /*!< DAC channel1 DMA enable */
N#define  DAC_CR_EN2                          ((uint32_t)0x00010000)        /*!< DAC channel2 enable */
N#define  DAC_CR_BOFF2                        ((uint32_t)0x00020000)        /*!< DAC channel2 output buffer disable */
N#define  DAC_CR_TEN2                         ((uint32_t)0x00040000)        /*!< DAC channel2 Trigger enable */
N
N#define  DAC_CR_TSEL2                        ((uint32_t)0x00380000)        /*!< TSEL2[2:0] (DAC channel2 Trigger selection) */
N#define  DAC_CR_TSEL2_0                      ((uint32_t)0x00080000)        /*!< Bit 0 */
N#define  DAC_CR_TSEL2_1                      ((uint32_t)0x00100000)        /*!< Bit 1 */
N#define  DAC_CR_TSEL2_2                      ((uint32_t)0x00200000)        /*!< Bit 2 */
N
N#define  DAC_CR_WAVE2                        ((uint32_t)0x00C00000)        /*!< WAVE2[1:0] (DAC channel2 noise/triangle wave generation enable) */
N#define  DAC_CR_WAVE2_0                      ((uint32_t)0x00400000)        /*!< Bit 0 */
N#define  DAC_CR_WAVE2_1                      ((uint32_t)0x00800000)        /*!< Bit 1 */
N
N#define  DAC_CR_MAMP2                        ((uint32_t)0x0F000000)        /*!< MAMP2[3:0] (DAC channel2 Mask/Amplitude selector) */
N#define  DAC_CR_MAMP2_0                      ((uint32_t)0x01000000)        /*!< Bit 0 */
N#define  DAC_CR_MAMP2_1                      ((uint32_t)0x02000000)        /*!< Bit 1 */
N#define  DAC_CR_MAMP2_2                      ((uint32_t)0x04000000)        /*!< Bit 2 */
N#define  DAC_CR_MAMP2_3                      ((uint32_t)0x08000000)        /*!< Bit 3 */
N
N#define  DAC_CR_DMAEN2                       ((uint32_t)0x10000000)        /*!< DAC channel2 DMA enabled */
N
N/*****************  Bit definition for DAC_SWTRIGR register  ******************/
N#define  DAC_SWTRIGR_SWTRIG1                 ((uint8_t)0x01)               /*!< DAC channel1 software trigger */
N#define  DAC_SWTRIGR_SWTRIG2                 ((uint8_t)0x02)               /*!< DAC channel2 software trigger */
N
N/*****************  Bit definition for DAC_DHR12R1 register  ******************/
N#define  DAC_DHR12R1_DACC1DHR                ((uint16_t)0x0FFF)            /*!< DAC channel1 12-bit Right aligned data */
N
N/*****************  Bit definition for DAC_DHR12L1 register  ******************/
N#define  DAC_DHR12L1_DACC1DHR                ((uint16_t)0xFFF0)            /*!< DAC channel1 12-bit Left aligned data */
N
N/******************  Bit definition for DAC_DHR8R1 register  ******************/
N#define  DAC_DHR8R1_DACC1DHR                 ((uint8_t)0xFF)               /*!< DAC channel1 8-bit Right aligned data */
N
N/*****************  Bit definition for DAC_DHR12R2 register  ******************/
N#define  DAC_DHR12R2_DACC2DHR                ((uint16_t)0x0FFF)            /*!< DAC channel2 12-bit Right aligned data */
N
N/*****************  Bit definition for DAC_DHR12L2 register  ******************/
N#define  DAC_DHR12L2_DACC2DHR                ((uint16_t)0xFFF0)            /*!< DAC channel2 12-bit Left aligned data */
N
N/******************  Bit definition for DAC_DHR8R2 register  ******************/
N#define  DAC_DHR8R2_DACC2DHR                 ((uint8_t)0xFF)               /*!< DAC channel2 8-bit Right aligned data */
N
N/*****************  Bit definition for DAC_DHR12RD register  ******************/
N#define  DAC_DHR12RD_DACC1DHR                ((uint32_t)0x00000FFF)        /*!< DAC channel1 12-bit Right aligned data */
N#define  DAC_DHR12RD_DACC2DHR                ((uint32_t)0x0FFF0000)        /*!< DAC channel2 12-bit Right aligned data */
N
N/*****************  Bit definition for DAC_DHR12LD register  ******************/
N#define  DAC_DHR12LD_DACC1DHR                ((uint32_t)0x0000FFF0)        /*!< DAC channel1 12-bit Left aligned data */
N#define  DAC_DHR12LD_DACC2DHR                ((uint32_t)0xFFF00000)        /*!< DAC channel2 12-bit Left aligned data */
N
N/******************  Bit definition for DAC_DHR8RD register  ******************/
N#define  DAC_DHR8RD_DACC1DHR                 ((uint16_t)0x00FF)            /*!< DAC channel1 8-bit Right aligned data */
N#define  DAC_DHR8RD_DACC2DHR                 ((uint16_t)0xFF00)            /*!< DAC channel2 8-bit Right aligned data */
N
N/*******************  Bit definition for DAC_DOR1 register  *******************/
N#define  DAC_DOR1_DACC1DOR                   ((uint16_t)0x0FFF)            /*!< DAC channel1 data output */
N
N/*******************  Bit definition for DAC_DOR2 register  *******************/
N#define  DAC_DOR2_DACC2DOR                   ((uint16_t)0x0FFF)            /*!< DAC channel2 data output */
N
N/********************  Bit definition for DAC_SR register  ********************/
N#define  DAC_SR_DMAUDR1                      ((uint32_t)0x00002000)        /*!< DAC channel1 DMA underrun flag */
N#define  DAC_SR_DMAUDR2                      ((uint32_t)0x20000000)        /*!< DAC channel2 DMA underrun flag */
N
N/******************************************************************************/
N/*                                                                            */
N/*                                    CEC                                     */
N/*                                                                            */
N/******************************************************************************/
N/********************  Bit definition for CEC_CFGR register  ******************/
N#define  CEC_CFGR_PE              ((uint16_t)0x0001)     /*!<  Peripheral Enable */
N#define  CEC_CFGR_IE              ((uint16_t)0x0002)     /*!<  Interrupt Enable */
N#define  CEC_CFGR_BTEM            ((uint16_t)0x0004)     /*!<  Bit Timing Error Mode */
N#define  CEC_CFGR_BPEM            ((uint16_t)0x0008)     /*!<  Bit Period Error Mode */
N
N/********************  Bit definition for CEC_OAR register  ******************/
N#define  CEC_OAR_OA               ((uint16_t)0x000F)     /*!<  OA[3:0]: Own Address */
N#define  CEC_OAR_OA_0             ((uint16_t)0x0001)     /*!<  Bit 0 */
N#define  CEC_OAR_OA_1             ((uint16_t)0x0002)     /*!<  Bit 1 */
N#define  CEC_OAR_OA_2             ((uint16_t)0x0004)     /*!<  Bit 2 */
N#define  CEC_OAR_OA_3             ((uint16_t)0x0008)     /*!<  Bit 3 */
N
N/********************  Bit definition for CEC_PRES register  ******************/
N#define  CEC_PRES_PRES            ((uint16_t)0x3FFF)   /*!<  Prescaler Counter Value */
N
N/********************  Bit definition for CEC_ESR register  ******************/
N#define  CEC_ESR_BTE              ((uint16_t)0x0001)     /*!<  Bit Timing Error */
N#define  CEC_ESR_BPE              ((uint16_t)0x0002)     /*!<  Bit Period Error */
N#define  CEC_ESR_RBTFE            ((uint16_t)0x0004)     /*!<  Rx Block Transfer Finished Error */
N#define  CEC_ESR_SBE              ((uint16_t)0x0008)     /*!<  Start Bit Error */
N#define  CEC_ESR_ACKE             ((uint16_t)0x0010)     /*!<  Block Acknowledge Error */
N#define  CEC_ESR_LINE             ((uint16_t)0x0020)     /*!<  Line Error */
N#define  CEC_ESR_TBTFE            ((uint16_t)0x0040)     /*!<  Tx Block Transfer Finished Error */
N
N/********************  Bit definition for CEC_CSR register  ******************/
N#define  CEC_CSR_TSOM             ((uint16_t)0x0001)     /*!<  Tx Start Of Message */
N#define  CEC_CSR_TEOM             ((uint16_t)0x0002)     /*!<  Tx End Of Message */
N#define  CEC_CSR_TERR             ((uint16_t)0x0004)     /*!<  Tx Error */
N#define  CEC_CSR_TBTRF            ((uint16_t)0x0008)     /*!<  Tx Byte Transfer Request or Block Transfer Finished */
N#define  CEC_CSR_RSOM             ((uint16_t)0x0010)     /*!<  Rx Start Of Message */
N#define  CEC_CSR_REOM             ((uint16_t)0x0020)     /*!<  Rx End Of Message */
N#define  CEC_CSR_RERR             ((uint16_t)0x0040)     /*!<  Rx Error */
N#define  CEC_CSR_RBTF             ((uint16_t)0x0080)     /*!<  Rx Block Transfer Finished */
N
N/********************  Bit definition for CEC_TXD register  ******************/
N#define  CEC_TXD_TXD              ((uint16_t)0x00FF)     /*!<  Tx Data register */
N
N/********************  Bit definition for CEC_RXD register  ******************/
N#define  CEC_RXD_RXD              ((uint16_t)0x00FF)     /*!<  Rx Data register */
N
N/******************************************************************************/
N/*                                                                            */
N/*                                    TIM                                     */
N/*                                                                            */
N/******************************************************************************/
N
N/*******************  Bit definition for TIM_CR1 register  ********************/
N#define  TIM_CR1_CEN                         ((uint16_t)0x0001)            /*!< Counter enable */
N#define  TIM_CR1_UDIS                        ((uint16_t)0x0002)            /*!< Update disable */
N#define  TIM_CR1_URS                         ((uint16_t)0x0004)            /*!< Update request source */
N#define  TIM_CR1_OPM                         ((uint16_t)0x0008)            /*!< One pulse mode */
N#define  TIM_CR1_DIR                         ((uint16_t)0x0010)            /*!< Direction */
N
N#define  TIM_CR1_CMS                         ((uint16_t)0x0060)            /*!< CMS[1:0] bits (Center-aligned mode selection) */
N#define  TIM_CR1_CMS_0                       ((uint16_t)0x0020)            /*!< Bit 0 */
N#define  TIM_CR1_CMS_1                       ((uint16_t)0x0040)            /*!< Bit 1 */
N
N#define  TIM_CR1_ARPE                        ((uint16_t)0x0080)            /*!< Auto-reload preload enable */
N
N#define  TIM_CR1_CKD                         ((uint16_t)0x0300)            /*!< CKD[1:0] bits (clock division) */
N#define  TIM_CR1_CKD_0                       ((uint16_t)0x0100)            /*!< Bit 0 */
N#define  TIM_CR1_CKD_1                       ((uint16_t)0x0200)            /*!< Bit 1 */
N
N/*******************  Bit definition for TIM_CR2 register  ********************/
N#define  TIM_CR2_CCPC                        ((uint16_t)0x0001)            /*!< Capture/Compare Preloaded Control */
N#define  TIM_CR2_CCUS                        ((uint16_t)0x0004)            /*!< Capture/Compare Control Update Selection */
N#define  TIM_CR2_CCDS                        ((uint16_t)0x0008)            /*!< Capture/Compare DMA Selection */
N
N#define  TIM_CR2_MMS                         ((uint16_t)0x0070)            /*!< MMS[2:0] bits (Master Mode Selection) */
N#define  TIM_CR2_MMS_0                       ((uint16_t)0x0010)            /*!< Bit 0 */
N#define  TIM_CR2_MMS_1                       ((uint16_t)0x0020)            /*!< Bit 1 */
N#define  TIM_CR2_MMS_2                       ((uint16_t)0x0040)            /*!< Bit 2 */
N
N#define  TIM_CR2_TI1S                        ((uint16_t)0x0080)            /*!< TI1 Selection */
N#define  TIM_CR2_OIS1                        ((uint16_t)0x0100)            /*!< Output Idle state 1 (OC1 output) */
N#define  TIM_CR2_OIS1N                       ((uint16_t)0x0200)            /*!< Output Idle state 1 (OC1N output) */
N#define  TIM_CR2_OIS2                        ((uint16_t)0x0400)            /*!< Output Idle state 2 (OC2 output) */
N#define  TIM_CR2_OIS2N                       ((uint16_t)0x0800)            /*!< Output Idle state 2 (OC2N output) */
N#define  TIM_CR2_OIS3                        ((uint16_t)0x1000)            /*!< Output Idle state 3 (OC3 output) */
N#define  TIM_CR2_OIS3N                       ((uint16_t)0x2000)            /*!< Output Idle state 3 (OC3N output) */
N#define  TIM_CR2_OIS4                        ((uint16_t)0x4000)            /*!< Output Idle state 4 (OC4 output) */
N
N/*******************  Bit definition for TIM_SMCR register  *******************/
N#define  TIM_SMCR_SMS                        ((uint16_t)0x0007)            /*!< SMS[2:0] bits (Slave mode selection) */
N#define  TIM_SMCR_SMS_0                      ((uint16_t)0x0001)            /*!< Bit 0 */
N#define  TIM_SMCR_SMS_1                      ((uint16_t)0x0002)            /*!< Bit 1 */
N#define  TIM_SMCR_SMS_2                      ((uint16_t)0x0004)            /*!< Bit 2 */
N
N#define  TIM_SMCR_TS                         ((uint16_t)0x0070)            /*!< TS[2:0] bits (Trigger selection) */
N#define  TIM_SMCR_TS_0                       ((uint16_t)0x0010)            /*!< Bit 0 */
N#define  TIM_SMCR_TS_1                       ((uint16_t)0x0020)            /*!< Bit 1 */
N#define  TIM_SMCR_TS_2                       ((uint16_t)0x0040)            /*!< Bit 2 */
N
N#define  TIM_SMCR_MSM                        ((uint16_t)0x0080)            /*!< Master/slave mode */
N
N#define  TIM_SMCR_ETF                        ((uint16_t)0x0F00)            /*!< ETF[3:0] bits (External trigger filter) */
N#define  TIM_SMCR_ETF_0                      ((uint16_t)0x0100)            /*!< Bit 0 */
N#define  TIM_SMCR_ETF_1                      ((uint16_t)0x0200)            /*!< Bit 1 */
N#define  TIM_SMCR_ETF_2                      ((uint16_t)0x0400)            /*!< Bit 2 */
N#define  TIM_SMCR_ETF_3                      ((uint16_t)0x0800)            /*!< Bit 3 */
N
N#define  TIM_SMCR_ETPS                       ((uint16_t)0x3000)            /*!< ETPS[1:0] bits (External trigger prescaler) */
N#define  TIM_SMCR_ETPS_0                     ((uint16_t)0x1000)            /*!< Bit 0 */
N#define  TIM_SMCR_ETPS_1                     ((uint16_t)0x2000)            /*!< Bit 1 */
N
N#define  TIM_SMCR_ECE                        ((uint16_t)0x4000)            /*!< External clock enable */
N#define  TIM_SMCR_ETP                        ((uint16_t)0x8000)            /*!< External trigger polarity */
N
N/*******************  Bit definition for TIM_DIER register  *******************/
N#define  TIM_DIER_UIE                        ((uint16_t)0x0001)            /*!< Update interrupt enable */
N#define  TIM_DIER_CC1IE                      ((uint16_t)0x0002)            /*!< Capture/Compare 1 interrupt enable */
N#define  TIM_DIER_CC2IE                      ((uint16_t)0x0004)            /*!< Capture/Compare 2 interrupt enable */
N#define  TIM_DIER_CC3IE                      ((uint16_t)0x0008)            /*!< Capture/Compare 3 interrupt enable */
N#define  TIM_DIER_CC4IE                      ((uint16_t)0x0010)            /*!< Capture/Compare 4 interrupt enable */
N#define  TIM_DIER_COMIE                      ((uint16_t)0x0020)            /*!< COM interrupt enable */
N#define  TIM_DIER_TIE                        ((uint16_t)0x0040)            /*!< Trigger interrupt enable */
N#define  TIM_DIER_BIE                        ((uint16_t)0x0080)            /*!< Break interrupt enable */
N#define  TIM_DIER_UDE                        ((uint16_t)0x0100)            /*!< Update DMA request enable */
N#define  TIM_DIER_CC1DE                      ((uint16_t)0x0200)            /*!< Capture/Compare 1 DMA request enable */
N#define  TIM_DIER_CC2DE                      ((uint16_t)0x0400)            /*!< Capture/Compare 2 DMA request enable */
N#define  TIM_DIER_CC3DE                      ((uint16_t)0x0800)            /*!< Capture/Compare 3 DMA request enable */
N#define  TIM_DIER_CC4DE                      ((uint16_t)0x1000)            /*!< Capture/Compare 4 DMA request enable */
N#define  TIM_DIER_COMDE                      ((uint16_t)0x2000)            /*!< COM DMA request enable */
N#define  TIM_DIER_TDE                        ((uint16_t)0x4000)            /*!< Trigger DMA request enable */
N
N/********************  Bit definition for TIM_SR register  ********************/
N#define  TIM_SR_UIF                          ((uint16_t)0x0001)            /*!< Update interrupt Flag */
N#define  TIM_SR_CC1IF                        ((uint16_t)0x0002)            /*!< Capture/Compare 1 interrupt Flag */
N#define  TIM_SR_CC2IF                        ((uint16_t)0x0004)            /*!< Capture/Compare 2 interrupt Flag */
N#define  TIM_SR_CC3IF                        ((uint16_t)0x0008)            /*!< Capture/Compare 3 interrupt Flag */
N#define  TIM_SR_CC4IF                        ((uint16_t)0x0010)            /*!< Capture/Compare 4 interrupt Flag */
N#define  TIM_SR_COMIF                        ((uint16_t)0x0020)            /*!< COM interrupt Flag */
N#define  TIM_SR_TIF                          ((uint16_t)0x0040)            /*!< Trigger interrupt Flag */
N#define  TIM_SR_BIF                          ((uint16_t)0x0080)            /*!< Break interrupt Flag */
N#define  TIM_SR_CC1OF                        ((uint16_t)0x0200)            /*!< Capture/Compare 1 Overcapture Flag */
N#define  TIM_SR_CC2OF                        ((uint16_t)0x0400)            /*!< Capture/Compare 2 Overcapture Flag */
N#define  TIM_SR_CC3OF                        ((uint16_t)0x0800)            /*!< Capture/Compare 3 Overcapture Flag */
N#define  TIM_SR_CC4OF                        ((uint16_t)0x1000)            /*!< Capture/Compare 4 Overcapture Flag */
N
N/*******************  Bit definition for TIM_EGR register  ********************/
N#define  TIM_EGR_UG                          ((uint8_t)0x01)               /*!< Update Generation */
N#define  TIM_EGR_CC1G                        ((uint8_t)0x02)               /*!< Capture/Compare 1 Generation */
N#define  TIM_EGR_CC2G                        ((uint8_t)0x04)               /*!< Capture/Compare 2 Generation */
N#define  TIM_EGR_CC3G                        ((uint8_t)0x08)               /*!< Capture/Compare 3 Generation */
N#define  TIM_EGR_CC4G                        ((uint8_t)0x10)               /*!< Capture/Compare 4 Generation */
N#define  TIM_EGR_COMG                        ((uint8_t)0x20)               /*!< Capture/Compare Control Update Generation */
N#define  TIM_EGR_TG                          ((uint8_t)0x40)               /*!< Trigger Generation */
N#define  TIM_EGR_BG                          ((uint8_t)0x80)               /*!< Break Generation */
N
N/******************  Bit definition for TIM_CCMR1 register  *******************/
N#define  TIM_CCMR1_CC1S                      ((uint16_t)0x0003)            /*!< CC1S[1:0] bits (Capture/Compare 1 Selection) */
N#define  TIM_CCMR1_CC1S_0                    ((uint16_t)0x0001)            /*!< Bit 0 */
N#define  TIM_CCMR1_CC1S_1                    ((uint16_t)0x0002)            /*!< Bit 1 */
N
N#define  TIM_CCMR1_OC1FE                     ((uint16_t)0x0004)            /*!< Output Compare 1 Fast enable */
N#define  TIM_CCMR1_OC1PE                     ((uint16_t)0x0008)            /*!< Output Compare 1 Preload enable */
N
N#define  TIM_CCMR1_OC1M                      ((uint16_t)0x0070)            /*!< OC1M[2:0] bits (Output Compare 1 Mode) */
N#define  TIM_CCMR1_OC1M_0                    ((uint16_t)0x0010)            /*!< Bit 0 */
N#define  TIM_CCMR1_OC1M_1                    ((uint16_t)0x0020)            /*!< Bit 1 */
N#define  TIM_CCMR1_OC1M_2                    ((uint16_t)0x0040)            /*!< Bit 2 */
N
N#define  TIM_CCMR1_OC1CE                     ((uint16_t)0x0080)            /*!< Output Compare 1Clear Enable */
N
N#define  TIM_CCMR1_CC2S                      ((uint16_t)0x0300)            /*!< CC2S[1:0] bits (Capture/Compare 2 Selection) */
N#define  TIM_CCMR1_CC2S_0                    ((uint16_t)0x0100)            /*!< Bit 0 */
N#define  TIM_CCMR1_CC2S_1                    ((uint16_t)0x0200)            /*!< Bit 1 */
N
N#define  TIM_CCMR1_OC2FE                     ((uint16_t)0x0400)            /*!< Output Compare 2 Fast enable */
N#define  TIM_CCMR1_OC2PE                     ((uint16_t)0x0800)            /*!< Output Compare 2 Preload enable */
N
N#define  TIM_CCMR1_OC2M                      ((uint16_t)0x7000)            /*!< OC2M[2:0] bits (Output Compare 2 Mode) */
N#define  TIM_CCMR1_OC2M_0                    ((uint16_t)0x1000)            /*!< Bit 0 */
N#define  TIM_CCMR1_OC2M_1                    ((uint16_t)0x2000)            /*!< Bit 1 */
N#define  TIM_CCMR1_OC2M_2                    ((uint16_t)0x4000)            /*!< Bit 2 */
N
N#define  TIM_CCMR1_OC2CE                     ((uint16_t)0x8000)            /*!< Output Compare 2 Clear Enable */
N
N/*----------------------------------------------------------------------------*/
N
N#define  TIM_CCMR1_IC1PSC                    ((uint16_t)0x000C)            /*!< IC1PSC[1:0] bits (Input Capture 1 Prescaler) */
N#define  TIM_CCMR1_IC1PSC_0                  ((uint16_t)0x0004)            /*!< Bit 0 */
N#define  TIM_CCMR1_IC1PSC_1                  ((uint16_t)0x0008)            /*!< Bit 1 */
N
N#define  TIM_CCMR1_IC1F                      ((uint16_t)0x00F0)            /*!< IC1F[3:0] bits (Input Capture 1 Filter) */
N#define  TIM_CCMR1_IC1F_0                    ((uint16_t)0x0010)            /*!< Bit 0 */
N#define  TIM_CCMR1_IC1F_1                    ((uint16_t)0x0020)            /*!< Bit 1 */
N#define  TIM_CCMR1_IC1F_2                    ((uint16_t)0x0040)            /*!< Bit 2 */
N#define  TIM_CCMR1_IC1F_3                    ((uint16_t)0x0080)            /*!< Bit 3 */
N
N#define  TIM_CCMR1_IC2PSC                    ((uint16_t)0x0C00)            /*!< IC2PSC[1:0] bits (Input Capture 2 Prescaler) */
N#define  TIM_CCMR1_IC2PSC_0                  ((uint16_t)0x0400)            /*!< Bit 0 */
N#define  TIM_CCMR1_IC2PSC_1                  ((uint16_t)0x0800)            /*!< Bit 1 */
N
N#define  TIM_CCMR1_IC2F                      ((uint16_t)0xF000)            /*!< IC2F[3:0] bits (Input Capture 2 Filter) */
N#define  TIM_CCMR1_IC2F_0                    ((uint16_t)0x1000)            /*!< Bit 0 */
N#define  TIM_CCMR1_IC2F_1                    ((uint16_t)0x2000)            /*!< Bit 1 */
N#define  TIM_CCMR1_IC2F_2                    ((uint16_t)0x4000)            /*!< Bit 2 */
N#define  TIM_CCMR1_IC2F_3                    ((uint16_t)0x8000)            /*!< Bit 3 */
N
N/******************  Bit definition for TIM_CCMR2 register  *******************/
N#define  TIM_CCMR2_CC3S                      ((uint16_t)0x0003)            /*!< CC3S[1:0] bits (Capture/Compare 3 Selection) */
N#define  TIM_CCMR2_CC3S_0                    ((uint16_t)0x0001)            /*!< Bit 0 */
N#define  TIM_CCMR2_CC3S_1                    ((uint16_t)0x0002)            /*!< Bit 1 */
N
N#define  TIM_CCMR2_OC3FE                     ((uint16_t)0x0004)            /*!< Output Compare 3 Fast enable */
N#define  TIM_CCMR2_OC3PE                     ((uint16_t)0x0008)            /*!< Output Compare 3 Preload enable */
N
N#define  TIM_CCMR2_OC3M                      ((uint16_t)0x0070)            /*!< OC3M[2:0] bits (Output Compare 3 Mode) */
N#define  TIM_CCMR2_OC3M_0                    ((uint16_t)0x0010)            /*!< Bit 0 */
N#define  TIM_CCMR2_OC3M_1                    ((uint16_t)0x0020)            /*!< Bit 1 */
N#define  TIM_CCMR2_OC3M_2                    ((uint16_t)0x0040)            /*!< Bit 2 */
N
N#define  TIM_CCMR2_OC3CE                     ((uint16_t)0x0080)            /*!< Output Compare 3 Clear Enable */
N
N#define  TIM_CCMR2_CC4S                      ((uint16_t)0x0300)            /*!< CC4S[1:0] bits (Capture/Compare 4 Selection) */
N#define  TIM_CCMR2_CC4S_0                    ((uint16_t)0x0100)            /*!< Bit 0 */
N#define  TIM_CCMR2_CC4S_1                    ((uint16_t)0x0200)            /*!< Bit 1 */
N
N#define  TIM_CCMR2_OC4FE                     ((uint16_t)0x0400)            /*!< Output Compare 4 Fast enable */
N#define  TIM_CCMR2_OC4PE                     ((uint16_t)0x0800)            /*!< Output Compare 4 Preload enable */
N
N#define  TIM_CCMR2_OC4M                      ((uint16_t)0x7000)            /*!< OC4M[2:0] bits (Output Compare 4 Mode) */
N#define  TIM_CCMR2_OC4M_0                    ((uint16_t)0x1000)            /*!< Bit 0 */
N#define  TIM_CCMR2_OC4M_1                    ((uint16_t)0x2000)            /*!< Bit 1 */
N#define  TIM_CCMR2_OC4M_2                    ((uint16_t)0x4000)            /*!< Bit 2 */
N
N#define  TIM_CCMR2_OC4CE                     ((uint16_t)0x8000)            /*!< Output Compare 4 Clear Enable */
N
N/*----------------------------------------------------------------------------*/
N
N#define  TIM_CCMR2_IC3PSC                    ((uint16_t)0x000C)            /*!< IC3PSC[1:0] bits (Input Capture 3 Prescaler) */
N#define  TIM_CCMR2_IC3PSC_0                  ((uint16_t)0x0004)            /*!< Bit 0 */
N#define  TIM_CCMR2_IC3PSC_1                  ((uint16_t)0x0008)            /*!< Bit 1 */
N
N#define  TIM_CCMR2_IC3F                      ((uint16_t)0x00F0)            /*!< IC3F[3:0] bits (Input Capture 3 Filter) */
N#define  TIM_CCMR2_IC3F_0                    ((uint16_t)0x0010)            /*!< Bit 0 */
N#define  TIM_CCMR2_IC3F_1                    ((uint16_t)0x0020)            /*!< Bit 1 */
N#define  TIM_CCMR2_IC3F_2                    ((uint16_t)0x0040)            /*!< Bit 2 */
N#define  TIM_CCMR2_IC3F_3                    ((uint16_t)0x0080)            /*!< Bit 3 */
N
N#define  TIM_CCMR2_IC4PSC                    ((uint16_t)0x0C00)            /*!< IC4PSC[1:0] bits (Input Capture 4 Prescaler) */
N#define  TIM_CCMR2_IC4PSC_0                  ((uint16_t)0x0400)            /*!< Bit 0 */
N#define  TIM_CCMR2_IC4PSC_1                  ((uint16_t)0x0800)            /*!< Bit 1 */
N
N#define  TIM_CCMR2_IC4F                      ((uint16_t)0xF000)            /*!< IC4F[3:0] bits (Input Capture 4 Filter) */
N#define  TIM_CCMR2_IC4F_0                    ((uint16_t)0x1000)            /*!< Bit 0 */
N#define  TIM_CCMR2_IC4F_1                    ((uint16_t)0x2000)            /*!< Bit 1 */
N#define  TIM_CCMR2_IC4F_2                    ((uint16_t)0x4000)            /*!< Bit 2 */
N#define  TIM_CCMR2_IC4F_3                    ((uint16_t)0x8000)            /*!< Bit 3 */
N
N/*******************  Bit definition for TIM_CCER register  *******************/
N#define  TIM_CCER_CC1E                       ((uint16_t)0x0001)            /*!< Capture/Compare 1 output enable */
N#define  TIM_CCER_CC1P                       ((uint16_t)0x0002)            /*!< Capture/Compare 1 output Polarity */
N#define  TIM_CCER_CC1NE                      ((uint16_t)0x0004)            /*!< Capture/Compare 1 Complementary output enable */
N#define  TIM_CCER_CC1NP                      ((uint16_t)0x0008)            /*!< Capture/Compare 1 Complementary output Polarity */
N#define  TIM_CCER_CC2E                       ((uint16_t)0x0010)            /*!< Capture/Compare 2 output enable */
N#define  TIM_CCER_CC2P                       ((uint16_t)0x0020)            /*!< Capture/Compare 2 output Polarity */
N#define  TIM_CCER_CC2NE                      ((uint16_t)0x0040)            /*!< Capture/Compare 2 Complementary output enable */
N#define  TIM_CCER_CC2NP                      ((uint16_t)0x0080)            /*!< Capture/Compare 2 Complementary output Polarity */
N#define  TIM_CCER_CC3E                       ((uint16_t)0x0100)            /*!< Capture/Compare 3 output enable */
N#define  TIM_CCER_CC3P                       ((uint16_t)0x0200)            /*!< Capture/Compare 3 output Polarity */
N#define  TIM_CCER_CC3NE                      ((uint16_t)0x0400)            /*!< Capture/Compare 3 Complementary output enable */
N#define  TIM_CCER_CC3NP                      ((uint16_t)0x0800)            /*!< Capture/Compare 3 Complementary output Polarity */
N#define  TIM_CCER_CC4E                       ((uint16_t)0x1000)            /*!< Capture/Compare 4 output enable */
N#define  TIM_CCER_CC4P                       ((uint16_t)0x2000)            /*!< Capture/Compare 4 output Polarity */
N#define  TIM_CCER_CC4NP                      ((uint16_t)0x8000)            /*!< Capture/Compare 4 Complementary output Polarity */
N
N/*******************  Bit definition for TIM_CNT register  ********************/
N#define  TIM_CNT_CNT                         ((uint16_t)0xFFFF)            /*!< Counter Value */
N
N/*******************  Bit definition for TIM_PSC register  ********************/
N#define  TIM_PSC_PSC                         ((uint16_t)0xFFFF)            /*!< Prescaler Value */
N
N/*******************  Bit definition for TIM_ARR register  ********************/
N#define  TIM_ARR_ARR                         ((uint16_t)0xFFFF)            /*!< actual auto-reload Value */
N
N/*******************  Bit definition for TIM_RCR register  ********************/
N#define  TIM_RCR_REP                         ((uint8_t)0xFF)               /*!< Repetition Counter Value */
N
N/*******************  Bit definition for TIM_CCR1 register  *******************/
N#define  TIM_CCR1_CCR1                       ((uint16_t)0xFFFF)            /*!< Capture/Compare 1 Value */
N
N/*******************  Bit definition for TIM_CCR2 register  *******************/
N#define  TIM_CCR2_CCR2                       ((uint16_t)0xFFFF)            /*!< Capture/Compare 2 Value */
N
N/*******************  Bit definition for TIM_CCR3 register  *******************/
N#define  TIM_CCR3_CCR3                       ((uint16_t)0xFFFF)            /*!< Capture/Compare 3 Value */
N
N/*******************  Bit definition for TIM_CCR4 register  *******************/
N#define  TIM_CCR4_CCR4                       ((uint16_t)0xFFFF)            /*!< Capture/Compare 4 Value */
N
N/*******************  Bit definition for TIM_BDTR register  *******************/
N#define  TIM_BDTR_DTG                        ((uint16_t)0x00FF)            /*!< DTG[0:7] bits (Dead-Time Generator set-up) */
N#define  TIM_BDTR_DTG_0                      ((uint16_t)0x0001)            /*!< Bit 0 */
N#define  TIM_BDTR_DTG_1                      ((uint16_t)0x0002)            /*!< Bit 1 */
N#define  TIM_BDTR_DTG_2                      ((uint16_t)0x0004)            /*!< Bit 2 */
N#define  TIM_BDTR_DTG_3                      ((uint16_t)0x0008)            /*!< Bit 3 */
N#define  TIM_BDTR_DTG_4                      ((uint16_t)0x0010)            /*!< Bit 4 */
N#define  TIM_BDTR_DTG_5                      ((uint16_t)0x0020)            /*!< Bit 5 */
N#define  TIM_BDTR_DTG_6                      ((uint16_t)0x0040)            /*!< Bit 6 */
N#define  TIM_BDTR_DTG_7                      ((uint16_t)0x0080)            /*!< Bit 7 */
N
N#define  TIM_BDTR_LOCK                       ((uint16_t)0x0300)            /*!< LOCK[1:0] bits (Lock Configuration) */
N#define  TIM_BDTR_LOCK_0                     ((uint16_t)0x0100)            /*!< Bit 0 */
N#define  TIM_BDTR_LOCK_1                     ((uint16_t)0x0200)            /*!< Bit 1 */
N
N#define  TIM_BDTR_OSSI                       ((uint16_t)0x0400)            /*!< Off-State Selection for Idle mode */
N#define  TIM_BDTR_OSSR                       ((uint16_t)0x0800)            /*!< Off-State Selection for Run mode */
N#define  TIM_BDTR_BKE                        ((uint16_t)0x1000)            /*!< Break enable */
N#define  TIM_BDTR_BKP                        ((uint16_t)0x2000)            /*!< Break Polarity */
N#define  TIM_BDTR_AOE                        ((uint16_t)0x4000)            /*!< Automatic Output enable */
N#define  TIM_BDTR_MOE                        ((uint16_t)0x8000)            /*!< Main Output enable */
N
N/*******************  Bit definition for TIM_DCR register  ********************/
N#define  TIM_DCR_DBA                         ((uint16_t)0x001F)            /*!< DBA[4:0] bits (DMA Base Address) */
N#define  TIM_DCR_DBA_0                       ((uint16_t)0x0001)            /*!< Bit 0 */
N#define  TIM_DCR_DBA_1                       ((uint16_t)0x0002)            /*!< Bit 1 */
N#define  TIM_DCR_DBA_2                       ((uint16_t)0x0004)            /*!< Bit 2 */
N#define  TIM_DCR_DBA_3                       ((uint16_t)0x0008)            /*!< Bit 3 */
N#define  TIM_DCR_DBA_4                       ((uint16_t)0x0010)            /*!< Bit 4 */
N
N#define  TIM_DCR_DBL                         ((uint16_t)0x1F00)            /*!< DBL[4:0] bits (DMA Burst Length) */
N#define  TIM_DCR_DBL_0                       ((uint16_t)0x0100)            /*!< Bit 0 */
N#define  TIM_DCR_DBL_1                       ((uint16_t)0x0200)            /*!< Bit 1 */
N#define  TIM_DCR_DBL_2                       ((uint16_t)0x0400)            /*!< Bit 2 */
N#define  TIM_DCR_DBL_3                       ((uint16_t)0x0800)            /*!< Bit 3 */
N#define  TIM_DCR_DBL_4                       ((uint16_t)0x1000)            /*!< Bit 4 */
N
N/*******************  Bit definition for TIM_DMAR register  *******************/
N#define  TIM_DMAR_DMAB                       ((uint16_t)0xFFFF)            /*!< DMA register for burst accesses */
N
N/******************************************************************************/
N/*                                                                            */
N/*                             Real-Time Clock                                */
N/*                                                                            */
N/******************************************************************************/
N
N/*******************  Bit definition for RTC_CRH register  ********************/
N#define  RTC_CRH_SECIE                       ((uint8_t)0x01)               /*!< Second Interrupt Enable */
N#define  RTC_CRH_ALRIE                       ((uint8_t)0x02)               /*!< Alarm Interrupt Enable */
N#define  RTC_CRH_OWIE                        ((uint8_t)0x04)               /*!< OverfloW Interrupt Enable */
N
N/*******************  Bit definition for RTC_CRL register  ********************/
N#define  RTC_CRL_SECF                        ((uint8_t)0x01)               /*!< Second Flag */
N#define  RTC_CRL_ALRF                        ((uint8_t)0x02)               /*!< Alarm Flag */
N#define  RTC_CRL_OWF                         ((uint8_t)0x04)               /*!< OverfloW Flag */
N#define  RTC_CRL_RSF                         ((uint8_t)0x08)               /*!< Registers Synchronized Flag */
N#define  RTC_CRL_CNF                         ((uint8_t)0x10)               /*!< Configuration Flag */
N#define  RTC_CRL_RTOFF                       ((uint8_t)0x20)               /*!< RTC operation OFF */
N
N/*******************  Bit definition for RTC_PRLH register  *******************/
N#define  RTC_PRLH_PRL                        ((uint16_t)0x000F)            /*!< RTC Prescaler Reload Value High */
N
N/*******************  Bit definition for RTC_PRLL register  *******************/
N#define  RTC_PRLL_PRL                        ((uint16_t)0xFFFF)            /*!< RTC Prescaler Reload Value Low */
N
N/*******************  Bit definition for RTC_DIVH register  *******************/
N#define  RTC_DIVH_RTC_DIV                    ((uint16_t)0x000F)            /*!< RTC Clock Divider High */
N
N/*******************  Bit definition for RTC_DIVL register  *******************/
N#define  RTC_DIVL_RTC_DIV                    ((uint16_t)0xFFFF)            /*!< RTC Clock Divider Low */
N
N/*******************  Bit definition for RTC_CNTH register  *******************/
N#define  RTC_CNTH_RTC_CNT                    ((uint16_t)0xFFFF)            /*!< RTC Counter High */
N
N/*******************  Bit definition for RTC_CNTL register  *******************/
N#define  RTC_CNTL_RTC_CNT                    ((uint16_t)0xFFFF)            /*!< RTC Counter Low */
N
N/*******************  Bit definition for RTC_ALRH register  *******************/
N#define  RTC_ALRH_RTC_ALR                    ((uint16_t)0xFFFF)            /*!< RTC Alarm High */
N
N/*******************  Bit definition for RTC_ALRL register  *******************/
N#define  RTC_ALRL_RTC_ALR                    ((uint16_t)0xFFFF)            /*!< RTC Alarm Low */
N
N/******************************************************************************/
N/*                                                                            */
N/*                           Independent WATCHDOG                             */
N/*                                                                            */
N/******************************************************************************/
N
N/*******************  Bit definition for IWDG_KR register  ********************/
N#define  IWDG_KR_KEY                         ((uint16_t)0xFFFF)            /*!< Key value (write only, read 0000h) */
N
N/*******************  Bit definition for IWDG_PR register  ********************/
N#define  IWDG_PR_PR                          ((uint8_t)0x07)               /*!< PR[2:0] (Prescaler divider) */
N#define  IWDG_PR_PR_0                        ((uint8_t)0x01)               /*!< Bit 0 */
N#define  IWDG_PR_PR_1                        ((uint8_t)0x02)               /*!< Bit 1 */
N#define  IWDG_PR_PR_2                        ((uint8_t)0x04)               /*!< Bit 2 */
N
N/*******************  Bit definition for IWDG_RLR register  *******************/
N#define  IWDG_RLR_RL                         ((uint16_t)0x0FFF)            /*!< Watchdog counter reload value */
N
N/*******************  Bit definition for IWDG_SR register  ********************/
N#define  IWDG_SR_PVU                         ((uint8_t)0x01)               /*!< Watchdog prescaler value update */
N#define  IWDG_SR_RVU                         ((uint8_t)0x02)               /*!< Watchdog counter reload value update */
N
N/******************************************************************************/
N/*                                                                            */
N/*                            Window WATCHDOG                                 */
N/*                                                                            */
N/******************************************************************************/
N
N/*******************  Bit definition for WWDG_CR register  ********************/
N#define  WWDG_CR_T                           ((uint8_t)0x7F)               /*!< T[6:0] bits (7-Bit counter (MSB to LSB)) */
N#define  WWDG_CR_T0                          ((uint8_t)0x01)               /*!< Bit 0 */
N#define  WWDG_CR_T1                          ((uint8_t)0x02)               /*!< Bit 1 */
N#define  WWDG_CR_T2                          ((uint8_t)0x04)               /*!< Bit 2 */
N#define  WWDG_CR_T3                          ((uint8_t)0x08)               /*!< Bit 3 */
N#define  WWDG_CR_T4                          ((uint8_t)0x10)               /*!< Bit 4 */
N#define  WWDG_CR_T5                          ((uint8_t)0x20)               /*!< Bit 5 */
N#define  WWDG_CR_T6                          ((uint8_t)0x40)               /*!< Bit 6 */
N
N#define  WWDG_CR_WDGA                        ((uint8_t)0x80)               /*!< Activation bit */
N
N/*******************  Bit definition for WWDG_CFR register  *******************/
N#define  WWDG_CFR_W                          ((uint16_t)0x007F)            /*!< W[6:0] bits (7-bit window value) */
N#define  WWDG_CFR_W0                         ((uint16_t)0x0001)            /*!< Bit 0 */
N#define  WWDG_CFR_W1                         ((uint16_t)0x0002)            /*!< Bit 1 */
N#define  WWDG_CFR_W2                         ((uint16_t)0x0004)            /*!< Bit 2 */
N#define  WWDG_CFR_W3                         ((uint16_t)0x0008)            /*!< Bit 3 */
N#define  WWDG_CFR_W4                         ((uint16_t)0x0010)            /*!< Bit 4 */
N#define  WWDG_CFR_W5                         ((uint16_t)0x0020)            /*!< Bit 5 */
N#define  WWDG_CFR_W6                         ((uint16_t)0x0040)            /*!< Bit 6 */
N
N#define  WWDG_CFR_WDGTB                      ((uint16_t)0x0180)            /*!< WDGTB[1:0] bits (Timer Base) */
N#define  WWDG_CFR_WDGTB0                     ((uint16_t)0x0080)            /*!< Bit 0 */
N#define  WWDG_CFR_WDGTB1                     ((uint16_t)0x0100)            /*!< Bit 1 */
N
N#define  WWDG_CFR_EWI                        ((uint16_t)0x0200)            /*!< Early Wakeup Interrupt */
N
N/*******************  Bit definition for WWDG_SR register  ********************/
N#define  WWDG_SR_EWIF                        ((uint8_t)0x01)               /*!< Early Wakeup Interrupt Flag */
N
N/******************************************************************************/
N/*                                                                            */
N/*                       Flexible Static Memory Controller                    */
N/*                                                                            */
N/******************************************************************************/
N
N/******************  Bit definition for FSMC_BCR1 register  *******************/
N#define  FSMC_BCR1_MBKEN                     ((uint32_t)0x00000001)        /*!< Memory bank enable bit */
N#define  FSMC_BCR1_MUXEN                     ((uint32_t)0x00000002)        /*!< Address/data multiplexing enable bit */
N
N#define  FSMC_BCR1_MTYP                      ((uint32_t)0x0000000C)        /*!< MTYP[1:0] bits (Memory type) */
N#define  FSMC_BCR1_MTYP_0                    ((uint32_t)0x00000004)        /*!< Bit 0 */
N#define  FSMC_BCR1_MTYP_1                    ((uint32_t)0x00000008)        /*!< Bit 1 */
N
N#define  FSMC_BCR1_MWID                      ((uint32_t)0x00000030)        /*!< MWID[1:0] bits (Memory data bus width) */
N#define  FSMC_BCR1_MWID_0                    ((uint32_t)0x00000010)        /*!< Bit 0 */
N#define  FSMC_BCR1_MWID_1                    ((uint32_t)0x00000020)        /*!< Bit 1 */
N
N#define  FSMC_BCR1_FACCEN                    ((uint32_t)0x00000040)        /*!< Flash access enable */
N#define  FSMC_BCR1_BURSTEN                   ((uint32_t)0x00000100)        /*!< Burst enable bit */
N#define  FSMC_BCR1_WAITPOL                   ((uint32_t)0x00000200)        /*!< Wait signal polarity bit */
N#define  FSMC_BCR1_WRAPMOD                   ((uint32_t)0x00000400)        /*!< Wrapped burst mode support */
N#define  FSMC_BCR1_WAITCFG                   ((uint32_t)0x00000800)        /*!< Wait timing configuration */
N#define  FSMC_BCR1_WREN                      ((uint32_t)0x00001000)        /*!< Write enable bit */
N#define  FSMC_BCR1_WAITEN                    ((uint32_t)0x00002000)        /*!< Wait enable bit */
N#define  FSMC_BCR1_EXTMOD                    ((uint32_t)0x00004000)        /*!< Extended mode enable */
N#define  FSMC_BCR1_ASYNCWAIT                 ((uint32_t)0x00008000)       /*!< Asynchronous wait */
N#define  FSMC_BCR1_CBURSTRW                  ((uint32_t)0x00080000)        /*!< Write burst enable */
N
N/******************  Bit definition for FSMC_BCR2 register  *******************/
N#define  FSMC_BCR2_MBKEN                     ((uint32_t)0x00000001)        /*!< Memory bank enable bit */
N#define  FSMC_BCR2_MUXEN                     ((uint32_t)0x00000002)        /*!< Address/data multiplexing enable bit */
N
N#define  FSMC_BCR2_MTYP                      ((uint32_t)0x0000000C)        /*!< MTYP[1:0] bits (Memory type) */
N#define  FSMC_BCR2_MTYP_0                    ((uint32_t)0x00000004)        /*!< Bit 0 */
N#define  FSMC_BCR2_MTYP_1                    ((uint32_t)0x00000008)        /*!< Bit 1 */
N
N#define  FSMC_BCR2_MWID                      ((uint32_t)0x00000030)        /*!< MWID[1:0] bits (Memory data bus width) */
N#define  FSMC_BCR2_MWID_0                    ((uint32_t)0x00000010)        /*!< Bit 0 */
N#define  FSMC_BCR2_MWID_1                    ((uint32_t)0x00000020)        /*!< Bit 1 */
N
N#define  FSMC_BCR2_FACCEN                    ((uint32_t)0x00000040)        /*!< Flash access enable */
N#define  FSMC_BCR2_BURSTEN                   ((uint32_t)0x00000100)        /*!< Burst enable bit */
N#define  FSMC_BCR2_WAITPOL                   ((uint32_t)0x00000200)        /*!< Wait signal polarity bit */
N#define  FSMC_BCR2_WRAPMOD                   ((uint32_t)0x00000400)        /*!< Wrapped burst mode support */
N#define  FSMC_BCR2_WAITCFG                   ((uint32_t)0x00000800)        /*!< Wait timing configuration */
N#define  FSMC_BCR2_WREN                      ((uint32_t)0x00001000)        /*!< Write enable bit */
N#define  FSMC_BCR2_WAITEN                    ((uint32_t)0x00002000)        /*!< Wait enable bit */
N#define  FSMC_BCR2_EXTMOD                    ((uint32_t)0x00004000)        /*!< Extended mode enable */
N#define  FSMC_BCR2_ASYNCWAIT                 ((uint32_t)0x00008000)       /*!< Asynchronous wait */
N#define  FSMC_BCR2_CBURSTRW                  ((uint32_t)0x00080000)        /*!< Write burst enable */
N
N/******************  Bit definition for FSMC_BCR3 register  *******************/
N#define  FSMC_BCR3_MBKEN                     ((uint32_t)0x00000001)        /*!< Memory bank enable bit */
N#define  FSMC_BCR3_MUXEN                     ((uint32_t)0x00000002)        /*!< Address/data multiplexing enable bit */
N
N#define  FSMC_BCR3_MTYP                      ((uint32_t)0x0000000C)        /*!< MTYP[1:0] bits (Memory type) */
N#define  FSMC_BCR3_MTYP_0                    ((uint32_t)0x00000004)        /*!< Bit 0 */
N#define  FSMC_BCR3_MTYP_1                    ((uint32_t)0x00000008)        /*!< Bit 1 */
N
N#define  FSMC_BCR3_MWID                      ((uint32_t)0x00000030)        /*!< MWID[1:0] bits (Memory data bus width) */
N#define  FSMC_BCR3_MWID_0                    ((uint32_t)0x00000010)        /*!< Bit 0 */
N#define  FSMC_BCR3_MWID_1                    ((uint32_t)0x00000020)        /*!< Bit 1 */
N
N#define  FSMC_BCR3_FACCEN                    ((uint32_t)0x00000040)        /*!< Flash access enable */
N#define  FSMC_BCR3_BURSTEN                   ((uint32_t)0x00000100)        /*!< Burst enable bit */
N#define  FSMC_BCR3_WAITPOL                   ((uint32_t)0x00000200)        /*!< Wait signal polarity bit. */
N#define  FSMC_BCR3_WRAPMOD                   ((uint32_t)0x00000400)        /*!< Wrapped burst mode support */
N#define  FSMC_BCR3_WAITCFG                   ((uint32_t)0x00000800)        /*!< Wait timing configuration */
N#define  FSMC_BCR3_WREN                      ((uint32_t)0x00001000)        /*!< Write enable bit */
N#define  FSMC_BCR3_WAITEN                    ((uint32_t)0x00002000)        /*!< Wait enable bit */
N#define  FSMC_BCR3_EXTMOD                    ((uint32_t)0x00004000)        /*!< Extended mode enable */
N#define  FSMC_BCR3_ASYNCWAIT                 ((uint32_t)0x00008000)       /*!< Asynchronous wait */
N#define  FSMC_BCR3_CBURSTRW                  ((uint32_t)0x00080000)        /*!< Write burst enable */
N
N/******************  Bit definition for FSMC_BCR4 register  *******************/
N#define  FSMC_BCR4_MBKEN                     ((uint32_t)0x00000001)        /*!< Memory bank enable bit */
N#define  FSMC_BCR4_MUXEN                     ((uint32_t)0x00000002)        /*!< Address/data multiplexing enable bit */
N
N#define  FSMC_BCR4_MTYP                      ((uint32_t)0x0000000C)        /*!< MTYP[1:0] bits (Memory type) */
N#define  FSMC_BCR4_MTYP_0                    ((uint32_t)0x00000004)        /*!< Bit 0 */
N#define  FSMC_BCR4_MTYP_1                    ((uint32_t)0x00000008)        /*!< Bit 1 */
N
N#define  FSMC_BCR4_MWID                      ((uint32_t)0x00000030)        /*!< MWID[1:0] bits (Memory data bus width) */
N#define  FSMC_BCR4_MWID_0                    ((uint32_t)0x00000010)        /*!< Bit 0 */
N#define  FSMC_BCR4_MWID_1                    ((uint32_t)0x00000020)        /*!< Bit 1 */
N
N#define  FSMC_BCR4_FACCEN                    ((uint32_t)0x00000040)        /*!< Flash access enable */
N#define  FSMC_BCR4_BURSTEN                   ((uint32_t)0x00000100)        /*!< Burst enable bit */
N#define  FSMC_BCR4_WAITPOL                   ((uint32_t)0x00000200)        /*!< Wait signal polarity bit */
N#define  FSMC_BCR4_WRAPMOD                   ((uint32_t)0x00000400)        /*!< Wrapped burst mode support */
N#define  FSMC_BCR4_WAITCFG                   ((uint32_t)0x00000800)        /*!< Wait timing configuration */
N#define  FSMC_BCR4_WREN                      ((uint32_t)0x00001000)        /*!< Write enable bit */
N#define  FSMC_BCR4_WAITEN                    ((uint32_t)0x00002000)        /*!< Wait enable bit */
N#define  FSMC_BCR4_EXTMOD                    ((uint32_t)0x00004000)        /*!< Extended mode enable */
N#define  FSMC_BCR4_ASYNCWAIT                 ((uint32_t)0x00008000)       /*!< Asynchronous wait */
N#define  FSMC_BCR4_CBURSTRW                  ((uint32_t)0x00080000)        /*!< Write burst enable */
N
N/******************  Bit definition for FSMC_BTR1 register  ******************/
N#define  FSMC_BTR1_ADDSET                    ((uint32_t)0x0000000F)        /*!< ADDSET[3:0] bits (Address setup phase duration) */
N#define  FSMC_BTR1_ADDSET_0                  ((uint32_t)0x00000001)        /*!< Bit 0 */
N#define  FSMC_BTR1_ADDSET_1                  ((uint32_t)0x00000002)        /*!< Bit 1 */
N#define  FSMC_BTR1_ADDSET_2                  ((uint32_t)0x00000004)        /*!< Bit 2 */
N#define  FSMC_BTR1_ADDSET_3                  ((uint32_t)0x00000008)        /*!< Bit 3 */
N
N#define  FSMC_BTR1_ADDHLD                    ((uint32_t)0x000000F0)        /*!< ADDHLD[3:0] bits (Address-hold phase duration) */
N#define  FSMC_BTR1_ADDHLD_0                  ((uint32_t)0x00000010)        /*!< Bit 0 */
N#define  FSMC_BTR1_ADDHLD_1                  ((uint32_t)0x00000020)        /*!< Bit 1 */
N#define  FSMC_BTR1_ADDHLD_2                  ((uint32_t)0x00000040)        /*!< Bit 2 */
N#define  FSMC_BTR1_ADDHLD_3                  ((uint32_t)0x00000080)        /*!< Bit 3 */
N
N#define  FSMC_BTR1_DATAST                    ((uint32_t)0x0000FF00)        /*!< DATAST [3:0] bits (Data-phase duration) */
N#define  FSMC_BTR1_DATAST_0                  ((uint32_t)0x00000100)        /*!< Bit 0 */
N#define  FSMC_BTR1_DATAST_1                  ((uint32_t)0x00000200)        /*!< Bit 1 */
N#define  FSMC_BTR1_DATAST_2                  ((uint32_t)0x00000400)        /*!< Bit 2 */
N#define  FSMC_BTR1_DATAST_3                  ((uint32_t)0x00000800)        /*!< Bit 3 */
N
N#define  FSMC_BTR1_BUSTURN                   ((uint32_t)0x000F0000)        /*!< BUSTURN[3:0] bits (Bus turnaround phase duration) */
N#define  FSMC_BTR1_BUSTURN_0                 ((uint32_t)0x00010000)        /*!< Bit 0 */
N#define  FSMC_BTR1_BUSTURN_1                 ((uint32_t)0x00020000)        /*!< Bit 1 */
N#define  FSMC_BTR1_BUSTURN_2                 ((uint32_t)0x00040000)        /*!< Bit 2 */
N#define  FSMC_BTR1_BUSTURN_3                 ((uint32_t)0x00080000)        /*!< Bit 3 */
N
N#define  FSMC_BTR1_CLKDIV                    ((uint32_t)0x00F00000)        /*!< CLKDIV[3:0] bits (Clock divide ratio) */
N#define  FSMC_BTR1_CLKDIV_0                  ((uint32_t)0x00100000)        /*!< Bit 0 */
N#define  FSMC_BTR1_CLKDIV_1                  ((uint32_t)0x00200000)        /*!< Bit 1 */
N#define  FSMC_BTR1_CLKDIV_2                  ((uint32_t)0x00400000)        /*!< Bit 2 */
N#define  FSMC_BTR1_CLKDIV_3                  ((uint32_t)0x00800000)        /*!< Bit 3 */
N
N#define  FSMC_BTR1_DATLAT                    ((uint32_t)0x0F000000)        /*!< DATLA[3:0] bits (Data latency) */
N#define  FSMC_BTR1_DATLAT_0                  ((uint32_t)0x01000000)        /*!< Bit 0 */
N#define  FSMC_BTR1_DATLAT_1                  ((uint32_t)0x02000000)        /*!< Bit 1 */
N#define  FSMC_BTR1_DATLAT_2                  ((uint32_t)0x04000000)        /*!< Bit 2 */
N#define  FSMC_BTR1_DATLAT_3                  ((uint32_t)0x08000000)        /*!< Bit 3 */
N
N#define  FSMC_BTR1_ACCMOD                    ((uint32_t)0x30000000)        /*!< ACCMOD[1:0] bits (Access mode) */
N#define  FSMC_BTR1_ACCMOD_0                  ((uint32_t)0x10000000)        /*!< Bit 0 */
N#define  FSMC_BTR1_ACCMOD_1                  ((uint32_t)0x20000000)        /*!< Bit 1 */
N
N/******************  Bit definition for FSMC_BTR2 register  *******************/
N#define  FSMC_BTR2_ADDSET                    ((uint32_t)0x0000000F)        /*!< ADDSET[3:0] bits (Address setup phase duration) */
N#define  FSMC_BTR2_ADDSET_0                  ((uint32_t)0x00000001)        /*!< Bit 0 */
N#define  FSMC_BTR2_ADDSET_1                  ((uint32_t)0x00000002)        /*!< Bit 1 */
N#define  FSMC_BTR2_ADDSET_2                  ((uint32_t)0x00000004)        /*!< Bit 2 */
N#define  FSMC_BTR2_ADDSET_3                  ((uint32_t)0x00000008)        /*!< Bit 3 */
N
N#define  FSMC_BTR2_ADDHLD                    ((uint32_t)0x000000F0)        /*!< ADDHLD[3:0] bits (Address-hold phase duration) */
N#define  FSMC_BTR2_ADDHLD_0                  ((uint32_t)0x00000010)        /*!< Bit 0 */
N#define  FSMC_BTR2_ADDHLD_1                  ((uint32_t)0x00000020)        /*!< Bit 1 */
N#define  FSMC_BTR2_ADDHLD_2                  ((uint32_t)0x00000040)        /*!< Bit 2 */
N#define  FSMC_BTR2_ADDHLD_3                  ((uint32_t)0x00000080)        /*!< Bit 3 */
N
N#define  FSMC_BTR2_DATAST                    ((uint32_t)0x0000FF00)        /*!< DATAST [3:0] bits (Data-phase duration) */
N#define  FSMC_BTR2_DATAST_0                  ((uint32_t)0x00000100)        /*!< Bit 0 */
N#define  FSMC_BTR2_DATAST_1                  ((uint32_t)0x00000200)        /*!< Bit 1 */
N#define  FSMC_BTR2_DATAST_2                  ((uint32_t)0x00000400)        /*!< Bit 2 */
N#define  FSMC_BTR2_DATAST_3                  ((uint32_t)0x00000800)        /*!< Bit 3 */
N
N#define  FSMC_BTR2_BUSTURN                   ((uint32_t)0x000F0000)        /*!< BUSTURN[3:0] bits (Bus turnaround phase duration) */
N#define  FSMC_BTR2_BUSTURN_0                 ((uint32_t)0x00010000)        /*!< Bit 0 */
N#define  FSMC_BTR2_BUSTURN_1                 ((uint32_t)0x00020000)        /*!< Bit 1 */
N#define  FSMC_BTR2_BUSTURN_2                 ((uint32_t)0x00040000)        /*!< Bit 2 */
N#define  FSMC_BTR2_BUSTURN_3                 ((uint32_t)0x00080000)        /*!< Bit 3 */
N
N#define  FSMC_BTR2_CLKDIV                    ((uint32_t)0x00F00000)        /*!< CLKDIV[3:0] bits (Clock divide ratio) */
N#define  FSMC_BTR2_CLKDIV_0                  ((uint32_t)0x00100000)        /*!< Bit 0 */
N#define  FSMC_BTR2_CLKDIV_1                  ((uint32_t)0x00200000)        /*!< Bit 1 */
N#define  FSMC_BTR2_CLKDIV_2                  ((uint32_t)0x00400000)        /*!< Bit 2 */
N#define  FSMC_BTR2_CLKDIV_3                  ((uint32_t)0x00800000)        /*!< Bit 3 */
N
N#define  FSMC_BTR2_DATLAT                    ((uint32_t)0x0F000000)        /*!< DATLA[3:0] bits (Data latency) */
N#define  FSMC_BTR2_DATLAT_0                  ((uint32_t)0x01000000)        /*!< Bit 0 */
N#define  FSMC_BTR2_DATLAT_1                  ((uint32_t)0x02000000)        /*!< Bit 1 */
N#define  FSMC_BTR2_DATLAT_2                  ((uint32_t)0x04000000)        /*!< Bit 2 */
N#define  FSMC_BTR2_DATLAT_3                  ((uint32_t)0x08000000)        /*!< Bit 3 */
N
N#define  FSMC_BTR2_ACCMOD                    ((uint32_t)0x30000000)        /*!< ACCMOD[1:0] bits (Access mode) */
N#define  FSMC_BTR2_ACCMOD_0                  ((uint32_t)0x10000000)        /*!< Bit 0 */
N#define  FSMC_BTR2_ACCMOD_1                  ((uint32_t)0x20000000)        /*!< Bit 1 */
N
N/*******************  Bit definition for FSMC_BTR3 register  *******************/
N#define  FSMC_BTR3_ADDSET                    ((uint32_t)0x0000000F)        /*!< ADDSET[3:0] bits (Address setup phase duration) */
N#define  FSMC_BTR3_ADDSET_0                  ((uint32_t)0x00000001)        /*!< Bit 0 */
N#define  FSMC_BTR3_ADDSET_1                  ((uint32_t)0x00000002)        /*!< Bit 1 */
N#define  FSMC_BTR3_ADDSET_2                  ((uint32_t)0x00000004)        /*!< Bit 2 */
N#define  FSMC_BTR3_ADDSET_3                  ((uint32_t)0x00000008)        /*!< Bit 3 */
N
N#define  FSMC_BTR3_ADDHLD                    ((uint32_t)0x000000F0)        /*!< ADDHLD[3:0] bits (Address-hold phase duration) */
N#define  FSMC_BTR3_ADDHLD_0                  ((uint32_t)0x00000010)        /*!< Bit 0 */
N#define  FSMC_BTR3_ADDHLD_1                  ((uint32_t)0x00000020)        /*!< Bit 1 */
N#define  FSMC_BTR3_ADDHLD_2                  ((uint32_t)0x00000040)        /*!< Bit 2 */
N#define  FSMC_BTR3_ADDHLD_3                  ((uint32_t)0x00000080)        /*!< Bit 3 */
N
N#define  FSMC_BTR3_DATAST                    ((uint32_t)0x0000FF00)        /*!< DATAST [3:0] bits (Data-phase duration) */
N#define  FSMC_BTR3_DATAST_0                  ((uint32_t)0x00000100)        /*!< Bit 0 */
N#define  FSMC_BTR3_DATAST_1                  ((uint32_t)0x00000200)        /*!< Bit 1 */
N#define  FSMC_BTR3_DATAST_2                  ((uint32_t)0x00000400)        /*!< Bit 2 */
N#define  FSMC_BTR3_DATAST_3                  ((uint32_t)0x00000800)        /*!< Bit 3 */
N
N#define  FSMC_BTR3_BUSTURN                   ((uint32_t)0x000F0000)        /*!< BUSTURN[3:0] bits (Bus turnaround phase duration) */
N#define  FSMC_BTR3_BUSTURN_0                 ((uint32_t)0x00010000)        /*!< Bit 0 */
N#define  FSMC_BTR3_BUSTURN_1                 ((uint32_t)0x00020000)        /*!< Bit 1 */
N#define  FSMC_BTR3_BUSTURN_2                 ((uint32_t)0x00040000)        /*!< Bit 2 */
N#define  FSMC_BTR3_BUSTURN_3                 ((uint32_t)0x00080000)        /*!< Bit 3 */
N
N#define  FSMC_BTR3_CLKDIV                    ((uint32_t)0x00F00000)        /*!< CLKDIV[3:0] bits (Clock divide ratio) */
N#define  FSMC_BTR3_CLKDIV_0                  ((uint32_t)0x00100000)        /*!< Bit 0 */
N#define  FSMC_BTR3_CLKDIV_1                  ((uint32_t)0x00200000)        /*!< Bit 1 */
N#define  FSMC_BTR3_CLKDIV_2                  ((uint32_t)0x00400000)        /*!< Bit 2 */
N#define  FSMC_BTR3_CLKDIV_3                  ((uint32_t)0x00800000)        /*!< Bit 3 */
N
N#define  FSMC_BTR3_DATLAT                    ((uint32_t)0x0F000000)        /*!< DATLA[3:0] bits (Data latency) */
N#define  FSMC_BTR3_DATLAT_0                  ((uint32_t)0x01000000)        /*!< Bit 0 */
N#define  FSMC_BTR3_DATLAT_1                  ((uint32_t)0x02000000)        /*!< Bit 1 */
N#define  FSMC_BTR3_DATLAT_2                  ((uint32_t)0x04000000)        /*!< Bit 2 */
N#define  FSMC_BTR3_DATLAT_3                  ((uint32_t)0x08000000)        /*!< Bit 3 */
N
N#define  FSMC_BTR3_ACCMOD                    ((uint32_t)0x30000000)        /*!< ACCMOD[1:0] bits (Access mode) */
N#define  FSMC_BTR3_ACCMOD_0                  ((uint32_t)0x10000000)        /*!< Bit 0 */
N#define  FSMC_BTR3_ACCMOD_1                  ((uint32_t)0x20000000)        /*!< Bit 1 */
N
N/******************  Bit definition for FSMC_BTR4 register  *******************/
N#define  FSMC_BTR4_ADDSET                    ((uint32_t)0x0000000F)        /*!< ADDSET[3:0] bits (Address setup phase duration) */
N#define  FSMC_BTR4_ADDSET_0                  ((uint32_t)0x00000001)        /*!< Bit 0 */
N#define  FSMC_BTR4_ADDSET_1                  ((uint32_t)0x00000002)        /*!< Bit 1 */
N#define  FSMC_BTR4_ADDSET_2                  ((uint32_t)0x00000004)        /*!< Bit 2 */
N#define  FSMC_BTR4_ADDSET_3                  ((uint32_t)0x00000008)        /*!< Bit 3 */
N
N#define  FSMC_BTR4_ADDHLD                    ((uint32_t)0x000000F0)        /*!< ADDHLD[3:0] bits (Address-hold phase duration) */
N#define  FSMC_BTR4_ADDHLD_0                  ((uint32_t)0x00000010)        /*!< Bit 0 */
N#define  FSMC_BTR4_ADDHLD_1                  ((uint32_t)0x00000020)        /*!< Bit 1 */
N#define  FSMC_BTR4_ADDHLD_2                  ((uint32_t)0x00000040)        /*!< Bit 2 */
N#define  FSMC_BTR4_ADDHLD_3                  ((uint32_t)0x00000080)        /*!< Bit 3 */
N
N#define  FSMC_BTR4_DATAST                    ((uint32_t)0x0000FF00)        /*!< DATAST [3:0] bits (Data-phase duration) */
N#define  FSMC_BTR4_DATAST_0                  ((uint32_t)0x00000100)        /*!< Bit 0 */
N#define  FSMC_BTR4_DATAST_1                  ((uint32_t)0x00000200)        /*!< Bit 1 */
N#define  FSMC_BTR4_DATAST_2                  ((uint32_t)0x00000400)        /*!< Bit 2 */
N#define  FSMC_BTR4_DATAST_3                  ((uint32_t)0x00000800)        /*!< Bit 3 */
N
N#define  FSMC_BTR4_BUSTURN                   ((uint32_t)0x000F0000)        /*!< BUSTURN[3:0] bits (Bus turnaround phase duration) */
N#define  FSMC_BTR4_BUSTURN_0                 ((uint32_t)0x00010000)        /*!< Bit 0 */
N#define  FSMC_BTR4_BUSTURN_1                 ((uint32_t)0x00020000)        /*!< Bit 1 */
N#define  FSMC_BTR4_BUSTURN_2                 ((uint32_t)0x00040000)        /*!< Bit 2 */
N#define  FSMC_BTR4_BUSTURN_3                 ((uint32_t)0x00080000)        /*!< Bit 3 */
N
N#define  FSMC_BTR4_CLKDIV                    ((uint32_t)0x00F00000)        /*!< CLKDIV[3:0] bits (Clock divide ratio) */
N#define  FSMC_BTR4_CLKDIV_0                  ((uint32_t)0x00100000)        /*!< Bit 0 */
N#define  FSMC_BTR4_CLKDIV_1                  ((uint32_t)0x00200000)        /*!< Bit 1 */
N#define  FSMC_BTR4_CLKDIV_2                  ((uint32_t)0x00400000)        /*!< Bit 2 */
N#define  FSMC_BTR4_CLKDIV_3                  ((uint32_t)0x00800000)        /*!< Bit 3 */
N
N#define  FSMC_BTR4_DATLAT                    ((uint32_t)0x0F000000)        /*!< DATLA[3:0] bits (Data latency) */
N#define  FSMC_BTR4_DATLAT_0                  ((uint32_t)0x01000000)        /*!< Bit 0 */
N#define  FSMC_BTR4_DATLAT_1                  ((uint32_t)0x02000000)        /*!< Bit 1 */
N#define  FSMC_BTR4_DATLAT_2                  ((uint32_t)0x04000000)        /*!< Bit 2 */
N#define  FSMC_BTR4_DATLAT_3                  ((uint32_t)0x08000000)        /*!< Bit 3 */
N
N#define  FSMC_BTR4_ACCMOD                    ((uint32_t)0x30000000)        /*!< ACCMOD[1:0] bits (Access mode) */
N#define  FSMC_BTR4_ACCMOD_0                  ((uint32_t)0x10000000)        /*!< Bit 0 */
N#define  FSMC_BTR4_ACCMOD_1                  ((uint32_t)0x20000000)        /*!< Bit 1 */
N
N/******************  Bit definition for FSMC_BWTR1 register  ******************/
N#define  FSMC_BWTR1_ADDSET                   ((uint32_t)0x0000000F)        /*!< ADDSET[3:0] bits (Address setup phase duration) */
N#define  FSMC_BWTR1_ADDSET_0                 ((uint32_t)0x00000001)        /*!< Bit 0 */
N#define  FSMC_BWTR1_ADDSET_1                 ((uint32_t)0x00000002)        /*!< Bit 1 */
N#define  FSMC_BWTR1_ADDSET_2                 ((uint32_t)0x00000004)        /*!< Bit 2 */
N#define  FSMC_BWTR1_ADDSET_3                 ((uint32_t)0x00000008)        /*!< Bit 3 */
N
N#define  FSMC_BWTR1_ADDHLD                   ((uint32_t)0x000000F0)        /*!< ADDHLD[3:0] bits (Address-hold phase duration) */
N#define  FSMC_BWTR1_ADDHLD_0                 ((uint32_t)0x00000010)        /*!< Bit 0 */
N#define  FSMC_BWTR1_ADDHLD_1                 ((uint32_t)0x00000020)        /*!< Bit 1 */
N#define  FSMC_BWTR1_ADDHLD_2                 ((uint32_t)0x00000040)        /*!< Bit 2 */
N#define  FSMC_BWTR1_ADDHLD_3                 ((uint32_t)0x00000080)        /*!< Bit 3 */
N
N#define  FSMC_BWTR1_DATAST                   ((uint32_t)0x0000FF00)        /*!< DATAST [3:0] bits (Data-phase duration) */
N#define  FSMC_BWTR1_DATAST_0                 ((uint32_t)0x00000100)        /*!< Bit 0 */
N#define  FSMC_BWTR1_DATAST_1                 ((uint32_t)0x00000200)        /*!< Bit 1 */
N#define  FSMC_BWTR1_DATAST_2                 ((uint32_t)0x00000400)        /*!< Bit 2 */
N#define  FSMC_BWTR1_DATAST_3                 ((uint32_t)0x00000800)        /*!< Bit 3 */
N
N#define  FSMC_BWTR1_CLKDIV                   ((uint32_t)0x00F00000)        /*!< CLKDIV[3:0] bits (Clock divide ratio) */
N#define  FSMC_BWTR1_CLKDIV_0                 ((uint32_t)0x00100000)        /*!< Bit 0 */
N#define  FSMC_BWTR1_CLKDIV_1                 ((uint32_t)0x00200000)        /*!< Bit 1 */
N#define  FSMC_BWTR1_CLKDIV_2                 ((uint32_t)0x00400000)        /*!< Bit 2 */
N#define  FSMC_BWTR1_CLKDIV_3                 ((uint32_t)0x00800000)        /*!< Bit 3 */
N
N#define  FSMC_BWTR1_DATLAT                   ((uint32_t)0x0F000000)        /*!< DATLA[3:0] bits (Data latency) */
N#define  FSMC_BWTR1_DATLAT_0                 ((uint32_t)0x01000000)        /*!< Bit 0 */
N#define  FSMC_BWTR1_DATLAT_1                 ((uint32_t)0x02000000)        /*!< Bit 1 */
N#define  FSMC_BWTR1_DATLAT_2                 ((uint32_t)0x04000000)        /*!< Bit 2 */
N#define  FSMC_BWTR1_DATLAT_3                 ((uint32_t)0x08000000)        /*!< Bit 3 */
N
N#define  FSMC_BWTR1_ACCMOD                   ((uint32_t)0x30000000)        /*!< ACCMOD[1:0] bits (Access mode) */
N#define  FSMC_BWTR1_ACCMOD_0                 ((uint32_t)0x10000000)        /*!< Bit 0 */
N#define  FSMC_BWTR1_ACCMOD_1                 ((uint32_t)0x20000000)        /*!< Bit 1 */
N
N/******************  Bit definition for FSMC_BWTR2 register  ******************/
N#define  FSMC_BWTR2_ADDSET                   ((uint32_t)0x0000000F)        /*!< ADDSET[3:0] bits (Address setup phase duration) */
N#define  FSMC_BWTR2_ADDSET_0                 ((uint32_t)0x00000001)        /*!< Bit 0 */
N#define  FSMC_BWTR2_ADDSET_1                 ((uint32_t)0x00000002)        /*!< Bit 1 */
N#define  FSMC_BWTR2_ADDSET_2                 ((uint32_t)0x00000004)        /*!< Bit 2 */
N#define  FSMC_BWTR2_ADDSET_3                 ((uint32_t)0x00000008)        /*!< Bit 3 */
N
N#define  FSMC_BWTR2_ADDHLD                   ((uint32_t)0x000000F0)        /*!< ADDHLD[3:0] bits (Address-hold phase duration) */
N#define  FSMC_BWTR2_ADDHLD_0                 ((uint32_t)0x00000010)        /*!< Bit 0 */
N#define  FSMC_BWTR2_ADDHLD_1                 ((uint32_t)0x00000020)        /*!< Bit 1 */
N#define  FSMC_BWTR2_ADDHLD_2                 ((uint32_t)0x00000040)        /*!< Bit 2 */
N#define  FSMC_BWTR2_ADDHLD_3                 ((uint32_t)0x00000080)        /*!< Bit 3 */
N
N#define  FSMC_BWTR2_DATAST                   ((uint32_t)0x0000FF00)        /*!< DATAST [3:0] bits (Data-phase duration) */
N#define  FSMC_BWTR2_DATAST_0                 ((uint32_t)0x00000100)        /*!< Bit 0 */
N#define  FSMC_BWTR2_DATAST_1                 ((uint32_t)0x00000200)        /*!< Bit 1 */
N#define  FSMC_BWTR2_DATAST_2                 ((uint32_t)0x00000400)        /*!< Bit 2 */
N#define  FSMC_BWTR2_DATAST_3                 ((uint32_t)0x00000800)        /*!< Bit 3 */
N
N#define  FSMC_BWTR2_CLKDIV                   ((uint32_t)0x00F00000)        /*!< CLKDIV[3:0] bits (Clock divide ratio) */
N#define  FSMC_BWTR2_CLKDIV_0                 ((uint32_t)0x00100000)        /*!< Bit 0 */
N#define  FSMC_BWTR2_CLKDIV_1                 ((uint32_t)0x00200000)        /*!< Bit 1*/
N#define  FSMC_BWTR2_CLKDIV_2                 ((uint32_t)0x00400000)        /*!< Bit 2 */
N#define  FSMC_BWTR2_CLKDIV_3                 ((uint32_t)0x00800000)        /*!< Bit 3 */
N
N#define  FSMC_BWTR2_DATLAT                   ((uint32_t)0x0F000000)        /*!< DATLA[3:0] bits (Data latency) */
N#define  FSMC_BWTR2_DATLAT_0                 ((uint32_t)0x01000000)        /*!< Bit 0 */
N#define  FSMC_BWTR2_DATLAT_1                 ((uint32_t)0x02000000)        /*!< Bit 1 */
N#define  FSMC_BWTR2_DATLAT_2                 ((uint32_t)0x04000000)        /*!< Bit 2 */
N#define  FSMC_BWTR2_DATLAT_3                 ((uint32_t)0x08000000)        /*!< Bit 3 */
N
N#define  FSMC_BWTR2_ACCMOD                   ((uint32_t)0x30000000)        /*!< ACCMOD[1:0] bits (Access mode) */
N#define  FSMC_BWTR2_ACCMOD_0                 ((uint32_t)0x10000000)        /*!< Bit 0 */
N#define  FSMC_BWTR2_ACCMOD_1                 ((uint32_t)0x20000000)        /*!< Bit 1 */
N
N/******************  Bit definition for FSMC_BWTR3 register  ******************/
N#define  FSMC_BWTR3_ADDSET                   ((uint32_t)0x0000000F)        /*!< ADDSET[3:0] bits (Address setup phase duration) */
N#define  FSMC_BWTR3_ADDSET_0                 ((uint32_t)0x00000001)        /*!< Bit 0 */
N#define  FSMC_BWTR3_ADDSET_1                 ((uint32_t)0x00000002)        /*!< Bit 1 */
N#define  FSMC_BWTR3_ADDSET_2                 ((uint32_t)0x00000004)        /*!< Bit 2 */
N#define  FSMC_BWTR3_ADDSET_3                 ((uint32_t)0x00000008)        /*!< Bit 3 */
N
N#define  FSMC_BWTR3_ADDHLD                   ((uint32_t)0x000000F0)        /*!< ADDHLD[3:0] bits (Address-hold phase duration) */
N#define  FSMC_BWTR3_ADDHLD_0                 ((uint32_t)0x00000010)        /*!< Bit 0 */
N#define  FSMC_BWTR3_ADDHLD_1                 ((uint32_t)0x00000020)        /*!< Bit 1 */
N#define  FSMC_BWTR3_ADDHLD_2                 ((uint32_t)0x00000040)        /*!< Bit 2 */
N#define  FSMC_BWTR3_ADDHLD_3                 ((uint32_t)0x00000080)        /*!< Bit 3 */
N
N#define  FSMC_BWTR3_DATAST                   ((uint32_t)0x0000FF00)        /*!< DATAST [3:0] bits (Data-phase duration) */
N#define  FSMC_BWTR3_DATAST_0                 ((uint32_t)0x00000100)        /*!< Bit 0 */
N#define  FSMC_BWTR3_DATAST_1                 ((uint32_t)0x00000200)        /*!< Bit 1 */
N#define  FSMC_BWTR3_DATAST_2                 ((uint32_t)0x00000400)        /*!< Bit 2 */
N#define  FSMC_BWTR3_DATAST_3                 ((uint32_t)0x00000800)        /*!< Bit 3 */
N
N#define  FSMC_BWTR3_CLKDIV                   ((uint32_t)0x00F00000)        /*!< CLKDIV[3:0] bits (Clock divide ratio) */
N#define  FSMC_BWTR3_CLKDIV_0                 ((uint32_t)0x00100000)        /*!< Bit 0 */
N#define  FSMC_BWTR3_CLKDIV_1                 ((uint32_t)0x00200000)        /*!< Bit 1 */
N#define  FSMC_BWTR3_CLKDIV_2                 ((uint32_t)0x00400000)        /*!< Bit 2 */
N#define  FSMC_BWTR3_CLKDIV_3                 ((uint32_t)0x00800000)        /*!< Bit 3 */
N
N#define  FSMC_BWTR3_DATLAT                   ((uint32_t)0x0F000000)        /*!< DATLA[3:0] bits (Data latency) */
N#define  FSMC_BWTR3_DATLAT_0                 ((uint32_t)0x01000000)        /*!< Bit 0 */
N#define  FSMC_BWTR3_DATLAT_1                 ((uint32_t)0x02000000)        /*!< Bit 1 */
N#define  FSMC_BWTR3_DATLAT_2                 ((uint32_t)0x04000000)        /*!< Bit 2 */
N#define  FSMC_BWTR3_DATLAT_3                 ((uint32_t)0x08000000)        /*!< Bit 3 */
N
N#define  FSMC_BWTR3_ACCMOD                   ((uint32_t)0x30000000)        /*!< ACCMOD[1:0] bits (Access mode) */
N#define  FSMC_BWTR3_ACCMOD_0                 ((uint32_t)0x10000000)        /*!< Bit 0 */
N#define  FSMC_BWTR3_ACCMOD_1                 ((uint32_t)0x20000000)        /*!< Bit 1 */
N
N/******************  Bit definition for FSMC_BWTR4 register  ******************/
N#define  FSMC_BWTR4_ADDSET                   ((uint32_t)0x0000000F)        /*!< ADDSET[3:0] bits (Address setup phase duration) */
N#define  FSMC_BWTR4_ADDSET_0                 ((uint32_t)0x00000001)        /*!< Bit 0 */
N#define  FSMC_BWTR4_ADDSET_1                 ((uint32_t)0x00000002)        /*!< Bit 1 */
N#define  FSMC_BWTR4_ADDSET_2                 ((uint32_t)0x00000004)        /*!< Bit 2 */
N#define  FSMC_BWTR4_ADDSET_3                 ((uint32_t)0x00000008)        /*!< Bit 3 */
N
N#define  FSMC_BWTR4_ADDHLD                   ((uint32_t)0x000000F0)        /*!< ADDHLD[3:0] bits (Address-hold phase duration) */
N#define  FSMC_BWTR4_ADDHLD_0                 ((uint32_t)0x00000010)        /*!< Bit 0 */
N#define  FSMC_BWTR4_ADDHLD_1                 ((uint32_t)0x00000020)        /*!< Bit 1 */
N#define  FSMC_BWTR4_ADDHLD_2                 ((uint32_t)0x00000040)        /*!< Bit 2 */
N#define  FSMC_BWTR4_ADDHLD_3                 ((uint32_t)0x00000080)        /*!< Bit 3 */
N
N#define  FSMC_BWTR4_DATAST                   ((uint32_t)0x0000FF00)        /*!< DATAST [3:0] bits (Data-phase duration) */
N#define  FSMC_BWTR4_DATAST_0                 ((uint32_t)0x00000100)        /*!< Bit 0 */
N#define  FSMC_BWTR4_DATAST_1                 ((uint32_t)0x00000200)        /*!< Bit 1 */
N#define  FSMC_BWTR4_DATAST_2                 ((uint32_t)0x00000400)        /*!< Bit 2 */
N#define  FSMC_BWTR4_DATAST_3                 ((uint32_t)0x00000800)        /*!< Bit 3 */
N
N#define  FSMC_BWTR4_CLKDIV                   ((uint32_t)0x00F00000)        /*!< CLKDIV[3:0] bits (Clock divide ratio) */
N#define  FSMC_BWTR4_CLKDIV_0                 ((uint32_t)0x00100000)        /*!< Bit 0 */
N#define  FSMC_BWTR4_CLKDIV_1                 ((uint32_t)0x00200000)        /*!< Bit 1 */
N#define  FSMC_BWTR4_CLKDIV_2                 ((uint32_t)0x00400000)        /*!< Bit 2 */
N#define  FSMC_BWTR4_CLKDIV_3                 ((uint32_t)0x00800000)        /*!< Bit 3 */
N
N#define  FSMC_BWTR4_DATLAT                   ((uint32_t)0x0F000000)        /*!< DATLA[3:0] bits (Data latency) */
N#define  FSMC_BWTR4_DATLAT_0                 ((uint32_t)0x01000000)        /*!< Bit 0 */
N#define  FSMC_BWTR4_DATLAT_1                 ((uint32_t)0x02000000)        /*!< Bit 1 */
N#define  FSMC_BWTR4_DATLAT_2                 ((uint32_t)0x04000000)        /*!< Bit 2 */
N#define  FSMC_BWTR4_DATLAT_3                 ((uint32_t)0x08000000)        /*!< Bit 3 */
N
N#define  FSMC_BWTR4_ACCMOD                   ((uint32_t)0x30000000)        /*!< ACCMOD[1:0] bits (Access mode) */
N#define  FSMC_BWTR4_ACCMOD_0                 ((uint32_t)0x10000000)        /*!< Bit 0 */
N#define  FSMC_BWTR4_ACCMOD_1                 ((uint32_t)0x20000000)        /*!< Bit 1 */
N
N/******************  Bit definition for FSMC_PCR2 register  *******************/
N#define  FSMC_PCR2_PWAITEN                   ((uint32_t)0x00000002)        /*!< Wait feature enable bit */
N#define  FSMC_PCR2_PBKEN                     ((uint32_t)0x00000004)        /*!< PC Card/NAND Flash memory bank enable bit */
N#define  FSMC_PCR2_PTYP                      ((uint32_t)0x00000008)        /*!< Memory type */
N
N#define  FSMC_PCR2_PWID                      ((uint32_t)0x00000030)        /*!< PWID[1:0] bits (NAND Flash databus width) */
N#define  FSMC_PCR2_PWID_0                    ((uint32_t)0x00000010)        /*!< Bit 0 */
N#define  FSMC_PCR2_PWID_1                    ((uint32_t)0x00000020)        /*!< Bit 1 */
N
N#define  FSMC_PCR2_ECCEN                     ((uint32_t)0x00000040)        /*!< ECC computation logic enable bit */
N
N#define  FSMC_PCR2_TCLR                      ((uint32_t)0x00001E00)        /*!< TCLR[3:0] bits (CLE to RE delay) */
N#define  FSMC_PCR2_TCLR_0                    ((uint32_t)0x00000200)        /*!< Bit 0 */
N#define  FSMC_PCR2_TCLR_1                    ((uint32_t)0x00000400)        /*!< Bit 1 */
N#define  FSMC_PCR2_TCLR_2                    ((uint32_t)0x00000800)        /*!< Bit 2 */
N#define  FSMC_PCR2_TCLR_3                    ((uint32_t)0x00001000)        /*!< Bit 3 */
N
N#define  FSMC_PCR2_TAR                       ((uint32_t)0x0001E000)        /*!< TAR[3:0] bits (ALE to RE delay) */
N#define  FSMC_PCR2_TAR_0                     ((uint32_t)0x00002000)        /*!< Bit 0 */
N#define  FSMC_PCR2_TAR_1                     ((uint32_t)0x00004000)        /*!< Bit 1 */
N#define  FSMC_PCR2_TAR_2                     ((uint32_t)0x00008000)        /*!< Bit 2 */
N#define  FSMC_PCR2_TAR_3                     ((uint32_t)0x00010000)        /*!< Bit 3 */
N
N#define  FSMC_PCR2_ECCPS                     ((uint32_t)0x000E0000)        /*!< ECCPS[1:0] bits (ECC page size) */
N#define  FSMC_PCR2_ECCPS_0                   ((uint32_t)0x00020000)        /*!< Bit 0 */
N#define  FSMC_PCR2_ECCPS_1                   ((uint32_t)0x00040000)        /*!< Bit 1 */
N#define  FSMC_PCR2_ECCPS_2                   ((uint32_t)0x00080000)        /*!< Bit 2 */
N
N/******************  Bit definition for FSMC_PCR3 register  *******************/
N#define  FSMC_PCR3_PWAITEN                   ((uint32_t)0x00000002)        /*!< Wait feature enable bit */
N#define  FSMC_PCR3_PBKEN                     ((uint32_t)0x00000004)        /*!< PC Card/NAND Flash memory bank enable bit */
N#define  FSMC_PCR3_PTYP                      ((uint32_t)0x00000008)        /*!< Memory type */
N
N#define  FSMC_PCR3_PWID                      ((uint32_t)0x00000030)        /*!< PWID[1:0] bits (NAND Flash databus width) */
N#define  FSMC_PCR3_PWID_0                    ((uint32_t)0x00000010)        /*!< Bit 0 */
N#define  FSMC_PCR3_PWID_1                    ((uint32_t)0x00000020)        /*!< Bit 1 */
N
N#define  FSMC_PCR3_ECCEN                     ((uint32_t)0x00000040)        /*!< ECC computation logic enable bit */
N
N#define  FSMC_PCR3_TCLR                      ((uint32_t)0x00001E00)        /*!< TCLR[3:0] bits (CLE to RE delay) */
N#define  FSMC_PCR3_TCLR_0                    ((uint32_t)0x00000200)        /*!< Bit 0 */
N#define  FSMC_PCR3_TCLR_1                    ((uint32_t)0x00000400)        /*!< Bit 1 */
N#define  FSMC_PCR3_TCLR_2                    ((uint32_t)0x00000800)        /*!< Bit 2 */
N#define  FSMC_PCR3_TCLR_3                    ((uint32_t)0x00001000)        /*!< Bit 3 */
N
N#define  FSMC_PCR3_TAR                       ((uint32_t)0x0001E000)        /*!< TAR[3:0] bits (ALE to RE delay) */
N#define  FSMC_PCR3_TAR_0                     ((uint32_t)0x00002000)        /*!< Bit 0 */
N#define  FSMC_PCR3_TAR_1                     ((uint32_t)0x00004000)        /*!< Bit 1 */
N#define  FSMC_PCR3_TAR_2                     ((uint32_t)0x00008000)        /*!< Bit 2 */
N#define  FSMC_PCR3_TAR_3                     ((uint32_t)0x00010000)        /*!< Bit 3 */
N
N#define  FSMC_PCR3_ECCPS                     ((uint32_t)0x000E0000)        /*!< ECCPS[2:0] bits (ECC page size) */
N#define  FSMC_PCR3_ECCPS_0                   ((uint32_t)0x00020000)        /*!< Bit 0 */
N#define  FSMC_PCR3_ECCPS_1                   ((uint32_t)0x00040000)        /*!< Bit 1 */
N#define  FSMC_PCR3_ECCPS_2                   ((uint32_t)0x00080000)        /*!< Bit 2 */
N
N/******************  Bit definition for FSMC_PCR4 register  *******************/
N#define  FSMC_PCR4_PWAITEN                   ((uint32_t)0x00000002)        /*!< Wait feature enable bit */
N#define  FSMC_PCR4_PBKEN                     ((uint32_t)0x00000004)        /*!< PC Card/NAND Flash memory bank enable bit */
N#define  FSMC_PCR4_PTYP                      ((uint32_t)0x00000008)        /*!< Memory type */
N
N#define  FSMC_PCR4_PWID                      ((uint32_t)0x00000030)        /*!< PWID[1:0] bits (NAND Flash databus width) */
N#define  FSMC_PCR4_PWID_0                    ((uint32_t)0x00000010)        /*!< Bit 0 */
N#define  FSMC_PCR4_PWID_1                    ((uint32_t)0x00000020)        /*!< Bit 1 */
N
N#define  FSMC_PCR4_ECCEN                     ((uint32_t)0x00000040)        /*!< ECC computation logic enable bit */
N
N#define  FSMC_PCR4_TCLR                      ((uint32_t)0x00001E00)        /*!< TCLR[3:0] bits (CLE to RE delay) */
N#define  FSMC_PCR4_TCLR_0                    ((uint32_t)0x00000200)        /*!< Bit 0 */
N#define  FSMC_PCR4_TCLR_1                    ((uint32_t)0x00000400)        /*!< Bit 1 */
N#define  FSMC_PCR4_TCLR_2                    ((uint32_t)0x00000800)        /*!< Bit 2 */
N#define  FSMC_PCR4_TCLR_3                    ((uint32_t)0x00001000)        /*!< Bit 3 */
N
N#define  FSMC_PCR4_TAR                       ((uint32_t)0x0001E000)        /*!< TAR[3:0] bits (ALE to RE delay) */
N#define  FSMC_PCR4_TAR_0                     ((uint32_t)0x00002000)        /*!< Bit 0 */
N#define  FSMC_PCR4_TAR_1                     ((uint32_t)0x00004000)        /*!< Bit 1 */
N#define  FSMC_PCR4_TAR_2                     ((uint32_t)0x00008000)        /*!< Bit 2 */
N#define  FSMC_PCR4_TAR_3                     ((uint32_t)0x00010000)        /*!< Bit 3 */
N
N#define  FSMC_PCR4_ECCPS                     ((uint32_t)0x000E0000)        /*!< ECCPS[2:0] bits (ECC page size) */
N#define  FSMC_PCR4_ECCPS_0                   ((uint32_t)0x00020000)        /*!< Bit 0 */
N#define  FSMC_PCR4_ECCPS_1                   ((uint32_t)0x00040000)        /*!< Bit 1 */
N#define  FSMC_PCR4_ECCPS_2                   ((uint32_t)0x00080000)        /*!< Bit 2 */
N
N/*******************  Bit definition for FSMC_SR2 register  *******************/
N#define  FSMC_SR2_IRS                        ((uint8_t)0x01)               /*!< Interrupt Rising Edge status */
N#define  FSMC_SR2_ILS                        ((uint8_t)0x02)               /*!< Interrupt Level status */
N#define  FSMC_SR2_IFS                        ((uint8_t)0x04)               /*!< Interrupt Falling Edge status */
N#define  FSMC_SR2_IREN                       ((uint8_t)0x08)               /*!< Interrupt Rising Edge detection Enable bit */
N#define  FSMC_SR2_ILEN                       ((uint8_t)0x10)               /*!< Interrupt Level detection Enable bit */
N#define  FSMC_SR2_IFEN                       ((uint8_t)0x20)               /*!< Interrupt Falling Edge detection Enable bit */
N#define  FSMC_SR2_FEMPT                      ((uint8_t)0x40)               /*!< FIFO empty */
N
N/*******************  Bit definition for FSMC_SR3 register  *******************/
N#define  FSMC_SR3_IRS                        ((uint8_t)0x01)               /*!< Interrupt Rising Edge status */
N#define  FSMC_SR3_ILS                        ((uint8_t)0x02)               /*!< Interrupt Level status */
N#define  FSMC_SR3_IFS                        ((uint8_t)0x04)               /*!< Interrupt Falling Edge status */
N#define  FSMC_SR3_IREN                       ((uint8_t)0x08)               /*!< Interrupt Rising Edge detection Enable bit */
N#define  FSMC_SR3_ILEN                       ((uint8_t)0x10)               /*!< Interrupt Level detection Enable bit */
N#define  FSMC_SR3_IFEN                       ((uint8_t)0x20)               /*!< Interrupt Falling Edge detection Enable bit */
N#define  FSMC_SR3_FEMPT                      ((uint8_t)0x40)               /*!< FIFO empty */
N
N/*******************  Bit definition for FSMC_SR4 register  *******************/
N#define  FSMC_SR4_IRS                        ((uint8_t)0x01)               /*!< Interrupt Rising Edge status */
N#define  FSMC_SR4_ILS                        ((uint8_t)0x02)               /*!< Interrupt Level status */
N#define  FSMC_SR4_IFS                        ((uint8_t)0x04)               /*!< Interrupt Falling Edge status */
N#define  FSMC_SR4_IREN                       ((uint8_t)0x08)               /*!< Interrupt Rising Edge detection Enable bit */
N#define  FSMC_SR4_ILEN                       ((uint8_t)0x10)               /*!< Interrupt Level detection Enable bit */
N#define  FSMC_SR4_IFEN                       ((uint8_t)0x20)               /*!< Interrupt Falling Edge detection Enable bit */
N#define  FSMC_SR4_FEMPT                      ((uint8_t)0x40)               /*!< FIFO empty */
N
N/******************  Bit definition for FSMC_PMEM2 register  ******************/
N#define  FSMC_PMEM2_MEMSET2                  ((uint32_t)0x000000FF)        /*!< MEMSET2[7:0] bits (Common memory 2 setup time) */
N#define  FSMC_PMEM2_MEMSET2_0                ((uint32_t)0x00000001)        /*!< Bit 0 */
N#define  FSMC_PMEM2_MEMSET2_1                ((uint32_t)0x00000002)        /*!< Bit 1 */
N#define  FSMC_PMEM2_MEMSET2_2                ((uint32_t)0x00000004)        /*!< Bit 2 */
N#define  FSMC_PMEM2_MEMSET2_3                ((uint32_t)0x00000008)        /*!< Bit 3 */
N#define  FSMC_PMEM2_MEMSET2_4                ((uint32_t)0x00000010)        /*!< Bit 4 */
N#define  FSMC_PMEM2_MEMSET2_5                ((uint32_t)0x00000020)        /*!< Bit 5 */
N#define  FSMC_PMEM2_MEMSET2_6                ((uint32_t)0x00000040)        /*!< Bit 6 */
N#define  FSMC_PMEM2_MEMSET2_7                ((uint32_t)0x00000080)        /*!< Bit 7 */
N
N#define  FSMC_PMEM2_MEMWAIT2                 ((uint32_t)0x0000FF00)        /*!< MEMWAIT2[7:0] bits (Common memory 2 wait time) */
N#define  FSMC_PMEM2_MEMWAIT2_0               ((uint32_t)0x00000100)        /*!< Bit 0 */
N#define  FSMC_PMEM2_MEMWAIT2_1               ((uint32_t)0x00000200)        /*!< Bit 1 */
N#define  FSMC_PMEM2_MEMWAIT2_2               ((uint32_t)0x00000400)        /*!< Bit 2 */
N#define  FSMC_PMEM2_MEMWAIT2_3               ((uint32_t)0x00000800)        /*!< Bit 3 */
N#define  FSMC_PMEM2_MEMWAIT2_4               ((uint32_t)0x00001000)        /*!< Bit 4 */
N#define  FSMC_PMEM2_MEMWAIT2_5               ((uint32_t)0x00002000)        /*!< Bit 5 */
N#define  FSMC_PMEM2_MEMWAIT2_6               ((uint32_t)0x00004000)        /*!< Bit 6 */
N#define  FSMC_PMEM2_MEMWAIT2_7               ((uint32_t)0x00008000)        /*!< Bit 7 */
N
N#define  FSMC_PMEM2_MEMHOLD2                 ((uint32_t)0x00FF0000)        /*!< MEMHOLD2[7:0] bits (Common memory 2 hold time) */
N#define  FSMC_PMEM2_MEMHOLD2_0               ((uint32_t)0x00010000)        /*!< Bit 0 */
N#define  FSMC_PMEM2_MEMHOLD2_1               ((uint32_t)0x00020000)        /*!< Bit 1 */
N#define  FSMC_PMEM2_MEMHOLD2_2               ((uint32_t)0x00040000)        /*!< Bit 2 */
N#define  FSMC_PMEM2_MEMHOLD2_3               ((uint32_t)0x00080000)        /*!< Bit 3 */
N#define  FSMC_PMEM2_MEMHOLD2_4               ((uint32_t)0x00100000)        /*!< Bit 4 */
N#define  FSMC_PMEM2_MEMHOLD2_5               ((uint32_t)0x00200000)        /*!< Bit 5 */
N#define  FSMC_PMEM2_MEMHOLD2_6               ((uint32_t)0x00400000)        /*!< Bit 6 */
N#define  FSMC_PMEM2_MEMHOLD2_7               ((uint32_t)0x00800000)        /*!< Bit 7 */
N
N#define  FSMC_PMEM2_MEMHIZ2                  ((uint32_t)0xFF000000)        /*!< MEMHIZ2[7:0] bits (Common memory 2 databus HiZ time) */
N#define  FSMC_PMEM2_MEMHIZ2_0                ((uint32_t)0x01000000)        /*!< Bit 0 */
N#define  FSMC_PMEM2_MEMHIZ2_1                ((uint32_t)0x02000000)        /*!< Bit 1 */
N#define  FSMC_PMEM2_MEMHIZ2_2                ((uint32_t)0x04000000)        /*!< Bit 2 */
N#define  FSMC_PMEM2_MEMHIZ2_3                ((uint32_t)0x08000000)        /*!< Bit 3 */
N#define  FSMC_PMEM2_MEMHIZ2_4                ((uint32_t)0x10000000)        /*!< Bit 4 */
N#define  FSMC_PMEM2_MEMHIZ2_5                ((uint32_t)0x20000000)        /*!< Bit 5 */
N#define  FSMC_PMEM2_MEMHIZ2_6                ((uint32_t)0x40000000)        /*!< Bit 6 */
N#define  FSMC_PMEM2_MEMHIZ2_7                ((uint32_t)0x80000000)        /*!< Bit 7 */
N
N/******************  Bit definition for FSMC_PMEM3 register  ******************/
N#define  FSMC_PMEM3_MEMSET3                  ((uint32_t)0x000000FF)        /*!< MEMSET3[7:0] bits (Common memory 3 setup time) */
N#define  FSMC_PMEM3_MEMSET3_0                ((uint32_t)0x00000001)        /*!< Bit 0 */
N#define  FSMC_PMEM3_MEMSET3_1                ((uint32_t)0x00000002)        /*!< Bit 1 */
N#define  FSMC_PMEM3_MEMSET3_2                ((uint32_t)0x00000004)        /*!< Bit 2 */
N#define  FSMC_PMEM3_MEMSET3_3                ((uint32_t)0x00000008)        /*!< Bit 3 */
N#define  FSMC_PMEM3_MEMSET3_4                ((uint32_t)0x00000010)        /*!< Bit 4 */
N#define  FSMC_PMEM3_MEMSET3_5                ((uint32_t)0x00000020)        /*!< Bit 5 */
N#define  FSMC_PMEM3_MEMSET3_6                ((uint32_t)0x00000040)        /*!< Bit 6 */
N#define  FSMC_PMEM3_MEMSET3_7                ((uint32_t)0x00000080)        /*!< Bit 7 */
N
N#define  FSMC_PMEM3_MEMWAIT3                 ((uint32_t)0x0000FF00)        /*!< MEMWAIT3[7:0] bits (Common memory 3 wait time) */
N#define  FSMC_PMEM3_MEMWAIT3_0               ((uint32_t)0x00000100)        /*!< Bit 0 */
N#define  FSMC_PMEM3_MEMWAIT3_1               ((uint32_t)0x00000200)        /*!< Bit 1 */
N#define  FSMC_PMEM3_MEMWAIT3_2               ((uint32_t)0x00000400)        /*!< Bit 2 */
N#define  FSMC_PMEM3_MEMWAIT3_3               ((uint32_t)0x00000800)        /*!< Bit 3 */
N#define  FSMC_PMEM3_MEMWAIT3_4               ((uint32_t)0x00001000)        /*!< Bit 4 */
N#define  FSMC_PMEM3_MEMWAIT3_5               ((uint32_t)0x00002000)        /*!< Bit 5 */
N#define  FSMC_PMEM3_MEMWAIT3_6               ((uint32_t)0x00004000)        /*!< Bit 6 */
N#define  FSMC_PMEM3_MEMWAIT3_7               ((uint32_t)0x00008000)        /*!< Bit 7 */
N
N#define  FSMC_PMEM3_MEMHOLD3                 ((uint32_t)0x00FF0000)        /*!< MEMHOLD3[7:0] bits (Common memory 3 hold time) */
N#define  FSMC_PMEM3_MEMHOLD3_0               ((uint32_t)0x00010000)        /*!< Bit 0 */
N#define  FSMC_PMEM3_MEMHOLD3_1               ((uint32_t)0x00020000)        /*!< Bit 1 */
N#define  FSMC_PMEM3_MEMHOLD3_2               ((uint32_t)0x00040000)        /*!< Bit 2 */
N#define  FSMC_PMEM3_MEMHOLD3_3               ((uint32_t)0x00080000)        /*!< Bit 3 */
N#define  FSMC_PMEM3_MEMHOLD3_4               ((uint32_t)0x00100000)        /*!< Bit 4 */
N#define  FSMC_PMEM3_MEMHOLD3_5               ((uint32_t)0x00200000)        /*!< Bit 5 */
N#define  FSMC_PMEM3_MEMHOLD3_6               ((uint32_t)0x00400000)        /*!< Bit 6 */
N#define  FSMC_PMEM3_MEMHOLD3_7               ((uint32_t)0x00800000)        /*!< Bit 7 */
N
N#define  FSMC_PMEM3_MEMHIZ3                  ((uint32_t)0xFF000000)        /*!< MEMHIZ3[7:0] bits (Common memory 3 databus HiZ time) */
N#define  FSMC_PMEM3_MEMHIZ3_0                ((uint32_t)0x01000000)        /*!< Bit 0 */
N#define  FSMC_PMEM3_MEMHIZ3_1                ((uint32_t)0x02000000)        /*!< Bit 1 */
N#define  FSMC_PMEM3_MEMHIZ3_2                ((uint32_t)0x04000000)        /*!< Bit 2 */
N#define  FSMC_PMEM3_MEMHIZ3_3                ((uint32_t)0x08000000)        /*!< Bit 3 */
N#define  FSMC_PMEM3_MEMHIZ3_4                ((uint32_t)0x10000000)        /*!< Bit 4 */
N#define  FSMC_PMEM3_MEMHIZ3_5                ((uint32_t)0x20000000)        /*!< Bit 5 */
N#define  FSMC_PMEM3_MEMHIZ3_6                ((uint32_t)0x40000000)        /*!< Bit 6 */
N#define  FSMC_PMEM3_MEMHIZ3_7                ((uint32_t)0x80000000)        /*!< Bit 7 */
N
N/******************  Bit definition for FSMC_PMEM4 register  ******************/
N#define  FSMC_PMEM4_MEMSET4                  ((uint32_t)0x000000FF)        /*!< MEMSET4[7:0] bits (Common memory 4 setup time) */
N#define  FSMC_PMEM4_MEMSET4_0                ((uint32_t)0x00000001)        /*!< Bit 0 */
N#define  FSMC_PMEM4_MEMSET4_1                ((uint32_t)0x00000002)        /*!< Bit 1 */
N#define  FSMC_PMEM4_MEMSET4_2                ((uint32_t)0x00000004)        /*!< Bit 2 */
N#define  FSMC_PMEM4_MEMSET4_3                ((uint32_t)0x00000008)        /*!< Bit 3 */
N#define  FSMC_PMEM4_MEMSET4_4                ((uint32_t)0x00000010)        /*!< Bit 4 */
N#define  FSMC_PMEM4_MEMSET4_5                ((uint32_t)0x00000020)        /*!< Bit 5 */
N#define  FSMC_PMEM4_MEMSET4_6                ((uint32_t)0x00000040)        /*!< Bit 6 */
N#define  FSMC_PMEM4_MEMSET4_7                ((uint32_t)0x00000080)        /*!< Bit 7 */
N
N#define  FSMC_PMEM4_MEMWAIT4                 ((uint32_t)0x0000FF00)        /*!< MEMWAIT4[7:0] bits (Common memory 4 wait time) */
N#define  FSMC_PMEM4_MEMWAIT4_0               ((uint32_t)0x00000100)        /*!< Bit 0 */
N#define  FSMC_PMEM4_MEMWAIT4_1               ((uint32_t)0x00000200)        /*!< Bit 1 */
N#define  FSMC_PMEM4_MEMWAIT4_2               ((uint32_t)0x00000400)        /*!< Bit 2 */
N#define  FSMC_PMEM4_MEMWAIT4_3               ((uint32_t)0x00000800)        /*!< Bit 3 */
N#define  FSMC_PMEM4_MEMWAIT4_4               ((uint32_t)0x00001000)        /*!< Bit 4 */
N#define  FSMC_PMEM4_MEMWAIT4_5               ((uint32_t)0x00002000)        /*!< Bit 5 */
N#define  FSMC_PMEM4_MEMWAIT4_6               ((uint32_t)0x00004000)        /*!< Bit 6 */
N#define  FSMC_PMEM4_MEMWAIT4_7               ((uint32_t)0x00008000)        /*!< Bit 7 */
N
N#define  FSMC_PMEM4_MEMHOLD4                 ((uint32_t)0x00FF0000)        /*!< MEMHOLD4[7:0] bits (Common memory 4 hold time) */
N#define  FSMC_PMEM4_MEMHOLD4_0               ((uint32_t)0x00010000)        /*!< Bit 0 */
N#define  FSMC_PMEM4_MEMHOLD4_1               ((uint32_t)0x00020000)        /*!< Bit 1 */
N#define  FSMC_PMEM4_MEMHOLD4_2               ((uint32_t)0x00040000)        /*!< Bit 2 */
N#define  FSMC_PMEM4_MEMHOLD4_3               ((uint32_t)0x00080000)        /*!< Bit 3 */
N#define  FSMC_PMEM4_MEMHOLD4_4               ((uint32_t)0x00100000)        /*!< Bit 4 */
N#define  FSMC_PMEM4_MEMHOLD4_5               ((uint32_t)0x00200000)        /*!< Bit 5 */
N#define  FSMC_PMEM4_MEMHOLD4_6               ((uint32_t)0x00400000)        /*!< Bit 6 */
N#define  FSMC_PMEM4_MEMHOLD4_7               ((uint32_t)0x00800000)        /*!< Bit 7 */
N
N#define  FSMC_PMEM4_MEMHIZ4                  ((uint32_t)0xFF000000)        /*!< MEMHIZ4[7:0] bits (Common memory 4 databus HiZ time) */
N#define  FSMC_PMEM4_MEMHIZ4_0                ((uint32_t)0x01000000)        /*!< Bit 0 */
N#define  FSMC_PMEM4_MEMHIZ4_1                ((uint32_t)0x02000000)        /*!< Bit 1 */
N#define  FSMC_PMEM4_MEMHIZ4_2                ((uint32_t)0x04000000)        /*!< Bit 2 */
N#define  FSMC_PMEM4_MEMHIZ4_3                ((uint32_t)0x08000000)        /*!< Bit 3 */
N#define  FSMC_PMEM4_MEMHIZ4_4                ((uint32_t)0x10000000)        /*!< Bit 4 */
N#define  FSMC_PMEM4_MEMHIZ4_5                ((uint32_t)0x20000000)        /*!< Bit 5 */
N#define  FSMC_PMEM4_MEMHIZ4_6                ((uint32_t)0x40000000)        /*!< Bit 6 */
N#define  FSMC_PMEM4_MEMHIZ4_7                ((uint32_t)0x80000000)        /*!< Bit 7 */
N
N/******************  Bit definition for FSMC_PATT2 register  ******************/
N#define  FSMC_PATT2_ATTSET2                  ((uint32_t)0x000000FF)        /*!< ATTSET2[7:0] bits (Attribute memory 2 setup time) */
N#define  FSMC_PATT2_ATTSET2_0                ((uint32_t)0x00000001)        /*!< Bit 0 */
N#define  FSMC_PATT2_ATTSET2_1                ((uint32_t)0x00000002)        /*!< Bit 1 */
N#define  FSMC_PATT2_ATTSET2_2                ((uint32_t)0x00000004)        /*!< Bit 2 */
N#define  FSMC_PATT2_ATTSET2_3                ((uint32_t)0x00000008)        /*!< Bit 3 */
N#define  FSMC_PATT2_ATTSET2_4                ((uint32_t)0x00000010)        /*!< Bit 4 */
N#define  FSMC_PATT2_ATTSET2_5                ((uint32_t)0x00000020)        /*!< Bit 5 */
N#define  FSMC_PATT2_ATTSET2_6                ((uint32_t)0x00000040)        /*!< Bit 6 */
N#define  FSMC_PATT2_ATTSET2_7                ((uint32_t)0x00000080)        /*!< Bit 7 */
N
N#define  FSMC_PATT2_ATTWAIT2                 ((uint32_t)0x0000FF00)        /*!< ATTWAIT2[7:0] bits (Attribute memory 2 wait time) */
N#define  FSMC_PATT2_ATTWAIT2_0               ((uint32_t)0x00000100)        /*!< Bit 0 */
N#define  FSMC_PATT2_ATTWAIT2_1               ((uint32_t)0x00000200)        /*!< Bit 1 */
N#define  FSMC_PATT2_ATTWAIT2_2               ((uint32_t)0x00000400)        /*!< Bit 2 */
N#define  FSMC_PATT2_ATTWAIT2_3               ((uint32_t)0x00000800)        /*!< Bit 3 */
N#define  FSMC_PATT2_ATTWAIT2_4               ((uint32_t)0x00001000)        /*!< Bit 4 */
N#define  FSMC_PATT2_ATTWAIT2_5               ((uint32_t)0x00002000)        /*!< Bit 5 */
N#define  FSMC_PATT2_ATTWAIT2_6               ((uint32_t)0x00004000)        /*!< Bit 6 */
N#define  FSMC_PATT2_ATTWAIT2_7               ((uint32_t)0x00008000)        /*!< Bit 7 */
N
N#define  FSMC_PATT2_ATTHOLD2                 ((uint32_t)0x00FF0000)        /*!< ATTHOLD2[7:0] bits (Attribute memory 2 hold time) */
N#define  FSMC_PATT2_ATTHOLD2_0               ((uint32_t)0x00010000)        /*!< Bit 0 */
N#define  FSMC_PATT2_ATTHOLD2_1               ((uint32_t)0x00020000)        /*!< Bit 1 */
N#define  FSMC_PATT2_ATTHOLD2_2               ((uint32_t)0x00040000)        /*!< Bit 2 */
N#define  FSMC_PATT2_ATTHOLD2_3               ((uint32_t)0x00080000)        /*!< Bit 3 */
N#define  FSMC_PATT2_ATTHOLD2_4               ((uint32_t)0x00100000)        /*!< Bit 4 */
N#define  FSMC_PATT2_ATTHOLD2_5               ((uint32_t)0x00200000)        /*!< Bit 5 */
N#define  FSMC_PATT2_ATTHOLD2_6               ((uint32_t)0x00400000)        /*!< Bit 6 */
N#define  FSMC_PATT2_ATTHOLD2_7               ((uint32_t)0x00800000)        /*!< Bit 7 */
N
N#define  FSMC_PATT2_ATTHIZ2                  ((uint32_t)0xFF000000)        /*!< ATTHIZ2[7:0] bits (Attribute memory 2 databus HiZ time) */
N#define  FSMC_PATT2_ATTHIZ2_0                ((uint32_t)0x01000000)        /*!< Bit 0 */
N#define  FSMC_PATT2_ATTHIZ2_1                ((uint32_t)0x02000000)        /*!< Bit 1 */
N#define  FSMC_PATT2_ATTHIZ2_2                ((uint32_t)0x04000000)        /*!< Bit 2 */
N#define  FSMC_PATT2_ATTHIZ2_3                ((uint32_t)0x08000000)        /*!< Bit 3 */
N#define  FSMC_PATT2_ATTHIZ2_4                ((uint32_t)0x10000000)        /*!< Bit 4 */
N#define  FSMC_PATT2_ATTHIZ2_5                ((uint32_t)0x20000000)        /*!< Bit 5 */
N#define  FSMC_PATT2_ATTHIZ2_6                ((uint32_t)0x40000000)        /*!< Bit 6 */
N#define  FSMC_PATT2_ATTHIZ2_7                ((uint32_t)0x80000000)        /*!< Bit 7 */
N
N/******************  Bit definition for FSMC_PATT3 register  ******************/
N#define  FSMC_PATT3_ATTSET3                  ((uint32_t)0x000000FF)        /*!< ATTSET3[7:0] bits (Attribute memory 3 setup time) */
N#define  FSMC_PATT3_ATTSET3_0                ((uint32_t)0x00000001)        /*!< Bit 0 */
N#define  FSMC_PATT3_ATTSET3_1                ((uint32_t)0x00000002)        /*!< Bit 1 */
N#define  FSMC_PATT3_ATTSET3_2                ((uint32_t)0x00000004)        /*!< Bit 2 */
N#define  FSMC_PATT3_ATTSET3_3                ((uint32_t)0x00000008)        /*!< Bit 3 */
N#define  FSMC_PATT3_ATTSET3_4                ((uint32_t)0x00000010)        /*!< Bit 4 */
N#define  FSMC_PATT3_ATTSET3_5                ((uint32_t)0x00000020)        /*!< Bit 5 */
N#define  FSMC_PATT3_ATTSET3_6                ((uint32_t)0x00000040)        /*!< Bit 6 */
N#define  FSMC_PATT3_ATTSET3_7                ((uint32_t)0x00000080)        /*!< Bit 7 */
N
N#define  FSMC_PATT3_ATTWAIT3                 ((uint32_t)0x0000FF00)        /*!< ATTWAIT3[7:0] bits (Attribute memory 3 wait time) */
N#define  FSMC_PATT3_ATTWAIT3_0               ((uint32_t)0x00000100)        /*!< Bit 0 */
N#define  FSMC_PATT3_ATTWAIT3_1               ((uint32_t)0x00000200)        /*!< Bit 1 */
N#define  FSMC_PATT3_ATTWAIT3_2               ((uint32_t)0x00000400)        /*!< Bit 2 */
N#define  FSMC_PATT3_ATTWAIT3_3               ((uint32_t)0x00000800)        /*!< Bit 3 */
N#define  FSMC_PATT3_ATTWAIT3_4               ((uint32_t)0x00001000)        /*!< Bit 4 */
N#define  FSMC_PATT3_ATTWAIT3_5               ((uint32_t)0x00002000)        /*!< Bit 5 */
N#define  FSMC_PATT3_ATTWAIT3_6               ((uint32_t)0x00004000)        /*!< Bit 6 */
N#define  FSMC_PATT3_ATTWAIT3_7               ((uint32_t)0x00008000)        /*!< Bit 7 */
N
N#define  FSMC_PATT3_ATTHOLD3                 ((uint32_t)0x00FF0000)        /*!< ATTHOLD3[7:0] bits (Attribute memory 3 hold time) */
N#define  FSMC_PATT3_ATTHOLD3_0               ((uint32_t)0x00010000)        /*!< Bit 0 */
N#define  FSMC_PATT3_ATTHOLD3_1               ((uint32_t)0x00020000)        /*!< Bit 1 */
N#define  FSMC_PATT3_ATTHOLD3_2               ((uint32_t)0x00040000)        /*!< Bit 2 */
N#define  FSMC_PATT3_ATTHOLD3_3               ((uint32_t)0x00080000)        /*!< Bit 3 */
N#define  FSMC_PATT3_ATTHOLD3_4               ((uint32_t)0x00100000)        /*!< Bit 4 */
N#define  FSMC_PATT3_ATTHOLD3_5               ((uint32_t)0x00200000)        /*!< Bit 5 */
N#define  FSMC_PATT3_ATTHOLD3_6               ((uint32_t)0x00400000)        /*!< Bit 6 */
N#define  FSMC_PATT3_ATTHOLD3_7               ((uint32_t)0x00800000)        /*!< Bit 7 */
N
N#define  FSMC_PATT3_ATTHIZ3                  ((uint32_t)0xFF000000)        /*!< ATTHIZ3[7:0] bits (Attribute memory 3 databus HiZ time) */
N#define  FSMC_PATT3_ATTHIZ3_0                ((uint32_t)0x01000000)        /*!< Bit 0 */
N#define  FSMC_PATT3_ATTHIZ3_1                ((uint32_t)0x02000000)        /*!< Bit 1 */
N#define  FSMC_PATT3_ATTHIZ3_2                ((uint32_t)0x04000000)        /*!< Bit 2 */
N#define  FSMC_PATT3_ATTHIZ3_3                ((uint32_t)0x08000000)        /*!< Bit 3 */
N#define  FSMC_PATT3_ATTHIZ3_4                ((uint32_t)0x10000000)        /*!< Bit 4 */
N#define  FSMC_PATT3_ATTHIZ3_5                ((uint32_t)0x20000000)        /*!< Bit 5 */
N#define  FSMC_PATT3_ATTHIZ3_6                ((uint32_t)0x40000000)        /*!< Bit 6 */
N#define  FSMC_PATT3_ATTHIZ3_7                ((uint32_t)0x80000000)        /*!< Bit 7 */
N
N/******************  Bit definition for FSMC_PATT4 register  ******************/
N#define  FSMC_PATT4_ATTSET4                  ((uint32_t)0x000000FF)        /*!< ATTSET4[7:0] bits (Attribute memory 4 setup time) */
N#define  FSMC_PATT4_ATTSET4_0                ((uint32_t)0x00000001)        /*!< Bit 0 */
N#define  FSMC_PATT4_ATTSET4_1                ((uint32_t)0x00000002)        /*!< Bit 1 */
N#define  FSMC_PATT4_ATTSET4_2                ((uint32_t)0x00000004)        /*!< Bit 2 */
N#define  FSMC_PATT4_ATTSET4_3                ((uint32_t)0x00000008)        /*!< Bit 3 */
N#define  FSMC_PATT4_ATTSET4_4                ((uint32_t)0x00000010)        /*!< Bit 4 */
N#define  FSMC_PATT4_ATTSET4_5                ((uint32_t)0x00000020)        /*!< Bit 5 */
N#define  FSMC_PATT4_ATTSET4_6                ((uint32_t)0x00000040)        /*!< Bit 6 */
N#define  FSMC_PATT4_ATTSET4_7                ((uint32_t)0x00000080)        /*!< Bit 7 */
N
N#define  FSMC_PATT4_ATTWAIT4                 ((uint32_t)0x0000FF00)        /*!< ATTWAIT4[7:0] bits (Attribute memory 4 wait time) */
N#define  FSMC_PATT4_ATTWAIT4_0               ((uint32_t)0x00000100)        /*!< Bit 0 */
N#define  FSMC_PATT4_ATTWAIT4_1               ((uint32_t)0x00000200)        /*!< Bit 1 */
N#define  FSMC_PATT4_ATTWAIT4_2               ((uint32_t)0x00000400)        /*!< Bit 2 */
N#define  FSMC_PATT4_ATTWAIT4_3               ((uint32_t)0x00000800)        /*!< Bit 3 */
N#define  FSMC_PATT4_ATTWAIT4_4               ((uint32_t)0x00001000)        /*!< Bit 4 */
N#define  FSMC_PATT4_ATTWAIT4_5               ((uint32_t)0x00002000)        /*!< Bit 5 */
N#define  FSMC_PATT4_ATTWAIT4_6               ((uint32_t)0x00004000)        /*!< Bit 6 */
N#define  FSMC_PATT4_ATTWAIT4_7               ((uint32_t)0x00008000)        /*!< Bit 7 */
N
N#define  FSMC_PATT4_ATTHOLD4                 ((uint32_t)0x00FF0000)        /*!< ATTHOLD4[7:0] bits (Attribute memory 4 hold time) */
N#define  FSMC_PATT4_ATTHOLD4_0               ((uint32_t)0x00010000)        /*!< Bit 0 */
N#define  FSMC_PATT4_ATTHOLD4_1               ((uint32_t)0x00020000)        /*!< Bit 1 */
N#define  FSMC_PATT4_ATTHOLD4_2               ((uint32_t)0x00040000)        /*!< Bit 2 */
N#define  FSMC_PATT4_ATTHOLD4_3               ((uint32_t)0x00080000)        /*!< Bit 3 */
N#define  FSMC_PATT4_ATTHOLD4_4               ((uint32_t)0x00100000)        /*!< Bit 4 */
N#define  FSMC_PATT4_ATTHOLD4_5               ((uint32_t)0x00200000)        /*!< Bit 5 */
N#define  FSMC_PATT4_ATTHOLD4_6               ((uint32_t)0x00400000)        /*!< Bit 6 */
N#define  FSMC_PATT4_ATTHOLD4_7               ((uint32_t)0x00800000)        /*!< Bit 7 */
N
N#define  FSMC_PATT4_ATTHIZ4                  ((uint32_t)0xFF000000)        /*!< ATTHIZ4[7:0] bits (Attribute memory 4 databus HiZ time) */
N#define  FSMC_PATT4_ATTHIZ4_0                ((uint32_t)0x01000000)        /*!< Bit 0 */
N#define  FSMC_PATT4_ATTHIZ4_1                ((uint32_t)0x02000000)        /*!< Bit 1 */
N#define  FSMC_PATT4_ATTHIZ4_2                ((uint32_t)0x04000000)        /*!< Bit 2 */
N#define  FSMC_PATT4_ATTHIZ4_3                ((uint32_t)0x08000000)        /*!< Bit 3 */
N#define  FSMC_PATT4_ATTHIZ4_4                ((uint32_t)0x10000000)        /*!< Bit 4 */
N#define  FSMC_PATT4_ATTHIZ4_5                ((uint32_t)0x20000000)        /*!< Bit 5 */
N#define  FSMC_PATT4_ATTHIZ4_6                ((uint32_t)0x40000000)        /*!< Bit 6 */
N#define  FSMC_PATT4_ATTHIZ4_7                ((uint32_t)0x80000000)        /*!< Bit 7 */
N
N/******************  Bit definition for FSMC_PIO4 register  *******************/
N#define  FSMC_PIO4_IOSET4                    ((uint32_t)0x000000FF)        /*!< IOSET4[7:0] bits (I/O 4 setup time) */
N#define  FSMC_PIO4_IOSET4_0                  ((uint32_t)0x00000001)        /*!< Bit 0 */
N#define  FSMC_PIO4_IOSET4_1                  ((uint32_t)0x00000002)        /*!< Bit 1 */
N#define  FSMC_PIO4_IOSET4_2                  ((uint32_t)0x00000004)        /*!< Bit 2 */
N#define  FSMC_PIO4_IOSET4_3                  ((uint32_t)0x00000008)        /*!< Bit 3 */
N#define  FSMC_PIO4_IOSET4_4                  ((uint32_t)0x00000010)        /*!< Bit 4 */
N#define  FSMC_PIO4_IOSET4_5                  ((uint32_t)0x00000020)        /*!< Bit 5 */
N#define  FSMC_PIO4_IOSET4_6                  ((uint32_t)0x00000040)        /*!< Bit 6 */
N#define  FSMC_PIO4_IOSET4_7                  ((uint32_t)0x00000080)        /*!< Bit 7 */
N
N#define  FSMC_PIO4_IOWAIT4                   ((uint32_t)0x0000FF00)        /*!< IOWAIT4[7:0] bits (I/O 4 wait time) */
N#define  FSMC_PIO4_IOWAIT4_0                 ((uint32_t)0x00000100)        /*!< Bit 0 */
N#define  FSMC_PIO4_IOWAIT4_1                 ((uint32_t)0x00000200)        /*!< Bit 1 */
N#define  FSMC_PIO4_IOWAIT4_2                 ((uint32_t)0x00000400)        /*!< Bit 2 */
N#define  FSMC_PIO4_IOWAIT4_3                 ((uint32_t)0x00000800)        /*!< Bit 3 */
N#define  FSMC_PIO4_IOWAIT4_4                 ((uint32_t)0x00001000)        /*!< Bit 4 */
N#define  FSMC_PIO4_IOWAIT4_5                 ((uint32_t)0x00002000)        /*!< Bit 5 */
N#define  FSMC_PIO4_IOWAIT4_6                 ((uint32_t)0x00004000)        /*!< Bit 6 */
N#define  FSMC_PIO4_IOWAIT4_7                 ((uint32_t)0x00008000)        /*!< Bit 7 */
N
N#define  FSMC_PIO4_IOHOLD4                   ((uint32_t)0x00FF0000)        /*!< IOHOLD4[7:0] bits (I/O 4 hold time) */
N#define  FSMC_PIO4_IOHOLD4_0                 ((uint32_t)0x00010000)        /*!< Bit 0 */
N#define  FSMC_PIO4_IOHOLD4_1                 ((uint32_t)0x00020000)        /*!< Bit 1 */
N#define  FSMC_PIO4_IOHOLD4_2                 ((uint32_t)0x00040000)        /*!< Bit 2 */
N#define  FSMC_PIO4_IOHOLD4_3                 ((uint32_t)0x00080000)        /*!< Bit 3 */
N#define  FSMC_PIO4_IOHOLD4_4                 ((uint32_t)0x00100000)        /*!< Bit 4 */
N#define  FSMC_PIO4_IOHOLD4_5                 ((uint32_t)0x00200000)        /*!< Bit 5 */
N#define  FSMC_PIO4_IOHOLD4_6                 ((uint32_t)0x00400000)        /*!< Bit 6 */
N#define  FSMC_PIO4_IOHOLD4_7                 ((uint32_t)0x00800000)        /*!< Bit 7 */
N
N#define  FSMC_PIO4_IOHIZ4                    ((uint32_t)0xFF000000)        /*!< IOHIZ4[7:0] bits (I/O 4 databus HiZ time) */
N#define  FSMC_PIO4_IOHIZ4_0                  ((uint32_t)0x01000000)        /*!< Bit 0 */
N#define  FSMC_PIO4_IOHIZ4_1                  ((uint32_t)0x02000000)        /*!< Bit 1 */
N#define  FSMC_PIO4_IOHIZ4_2                  ((uint32_t)0x04000000)        /*!< Bit 2 */
N#define  FSMC_PIO4_IOHIZ4_3                  ((uint32_t)0x08000000)        /*!< Bit 3 */
N#define  FSMC_PIO4_IOHIZ4_4                  ((uint32_t)0x10000000)        /*!< Bit 4 */
N#define  FSMC_PIO4_IOHIZ4_5                  ((uint32_t)0x20000000)        /*!< Bit 5 */
N#define  FSMC_PIO4_IOHIZ4_6                  ((uint32_t)0x40000000)        /*!< Bit 6 */
N#define  FSMC_PIO4_IOHIZ4_7                  ((uint32_t)0x80000000)        /*!< Bit 7 */
N
N/******************  Bit definition for FSMC_ECCR2 register  ******************/
N#define  FSMC_ECCR2_ECC2                     ((uint32_t)0xFFFFFFFF)        /*!< ECC result */
N
N/******************  Bit definition for FSMC_ECCR3 register  ******************/
N#define  FSMC_ECCR3_ECC3                     ((uint32_t)0xFFFFFFFF)        /*!< ECC result */
N
N/******************************************************************************/
N/*                                                                            */
N/*                          SD host Interface                                 */
N/*                                                                            */
N/******************************************************************************/
N
N/******************  Bit definition for SDIO_POWER register  ******************/
N#define  SDIO_POWER_PWRCTRL                  ((uint8_t)0x03)               /*!< PWRCTRL[1:0] bits (Power supply control bits) */
N#define  SDIO_POWER_PWRCTRL_0                ((uint8_t)0x01)               /*!< Bit 0 */
N#define  SDIO_POWER_PWRCTRL_1                ((uint8_t)0x02)               /*!< Bit 1 */
N
N/******************  Bit definition for SDIO_CLKCR register  ******************/
N#define  SDIO_CLKCR_CLKDIV                   ((uint16_t)0x00FF)            /*!< Clock divide factor */
N#define  SDIO_CLKCR_CLKEN                    ((uint16_t)0x0100)            /*!< Clock enable bit */
N#define  SDIO_CLKCR_PWRSAV                   ((uint16_t)0x0200)            /*!< Power saving configuration bit */
N#define  SDIO_CLKCR_BYPASS                   ((uint16_t)0x0400)            /*!< Clock divider bypass enable bit */
N
N#define  SDIO_CLKCR_WIDBUS                   ((uint16_t)0x1800)            /*!< WIDBUS[1:0] bits (Wide bus mode enable bit) */
N#define  SDIO_CLKCR_WIDBUS_0                 ((uint16_t)0x0800)            /*!< Bit 0 */
N#define  SDIO_CLKCR_WIDBUS_1                 ((uint16_t)0x1000)            /*!< Bit 1 */
N
N#define  SDIO_CLKCR_NEGEDGE                  ((uint16_t)0x2000)            /*!< SDIO_CK dephasing selection bit */
N#define  SDIO_CLKCR_HWFC_EN                  ((uint16_t)0x4000)            /*!< HW Flow Control enable */
N
N/*******************  Bit definition for SDIO_ARG register  *******************/
N#define  SDIO_ARG_CMDARG                     ((uint32_t)0xFFFFFFFF)            /*!< Command argument */
N
N/*******************  Bit definition for SDIO_CMD register  *******************/
N#define  SDIO_CMD_CMDINDEX                   ((uint16_t)0x003F)            /*!< Command Index */
N
N#define  SDIO_CMD_WAITRESP                   ((uint16_t)0x00C0)            /*!< WAITRESP[1:0] bits (Wait for response bits) */
N#define  SDIO_CMD_WAITRESP_0                 ((uint16_t)0x0040)            /*!<  Bit 0 */
N#define  SDIO_CMD_WAITRESP_1                 ((uint16_t)0x0080)            /*!<  Bit 1 */
N
N#define  SDIO_CMD_WAITINT                    ((uint16_t)0x0100)            /*!< CPSM Waits for Interrupt Request */
N#define  SDIO_CMD_WAITPEND                   ((uint16_t)0x0200)            /*!< CPSM Waits for ends of data transfer (CmdPend internal signal) */
N#define  SDIO_CMD_CPSMEN                     ((uint16_t)0x0400)            /*!< Command path state machine (CPSM) Enable bit */
N#define  SDIO_CMD_SDIOSUSPEND                ((uint16_t)0x0800)            /*!< SD I/O suspend command */
N#define  SDIO_CMD_ENCMDCOMPL                 ((uint16_t)0x1000)            /*!< Enable CMD completion */
N#define  SDIO_CMD_NIEN                       ((uint16_t)0x2000)            /*!< Not Interrupt Enable */
N#define  SDIO_CMD_CEATACMD                   ((uint16_t)0x4000)            /*!< CE-ATA command */
N
N/*****************  Bit definition for SDIO_RESPCMD register  *****************/
N#define  SDIO_RESPCMD_RESPCMD                ((uint8_t)0x3F)               /*!< Response command index */
N
N/******************  Bit definition for SDIO_RESP0 register  ******************/
N#define  SDIO_RESP0_CARDSTATUS0              ((uint32_t)0xFFFFFFFF)        /*!< Card Status */
N
N/******************  Bit definition for SDIO_RESP1 register  ******************/
N#define  SDIO_RESP1_CARDSTATUS1              ((uint32_t)0xFFFFFFFF)        /*!< Card Status */
N
N/******************  Bit definition for SDIO_RESP2 register  ******************/
N#define  SDIO_RESP2_CARDSTATUS2              ((uint32_t)0xFFFFFFFF)        /*!< Card Status */
N
N/******************  Bit definition for SDIO_RESP3 register  ******************/
N#define  SDIO_RESP3_CARDSTATUS3              ((uint32_t)0xFFFFFFFF)        /*!< Card Status */
N
N/******************  Bit definition for SDIO_RESP4 register  ******************/
N#define  SDIO_RESP4_CARDSTATUS4              ((uint32_t)0xFFFFFFFF)        /*!< Card Status */
N
N/******************  Bit definition for SDIO_DTIMER register  *****************/
N#define  SDIO_DTIMER_DATATIME                ((uint32_t)0xFFFFFFFF)        /*!< Data timeout period. */
N
N/******************  Bit definition for SDIO_DLEN register  *******************/
N#define  SDIO_DLEN_DATALENGTH                ((uint32_t)0x01FFFFFF)        /*!< Data length value */
N
N/******************  Bit definition for SDIO_DCTRL register  ******************/
N#define  SDIO_DCTRL_DTEN                     ((uint16_t)0x0001)            /*!< Data transfer enabled bit */
N#define  SDIO_DCTRL_DTDIR                    ((uint16_t)0x0002)            /*!< Data transfer direction selection */
N#define  SDIO_DCTRL_DTMODE                   ((uint16_t)0x0004)            /*!< Data transfer mode selection */
N#define  SDIO_DCTRL_DMAEN                    ((uint16_t)0x0008)            /*!< DMA enabled bit */
N
N#define  SDIO_DCTRL_DBLOCKSIZE               ((uint16_t)0x00F0)            /*!< DBLOCKSIZE[3:0] bits (Data block size) */
N#define  SDIO_DCTRL_DBLOCKSIZE_0             ((uint16_t)0x0010)            /*!< Bit 0 */
N#define  SDIO_DCTRL_DBLOCKSIZE_1             ((uint16_t)0x0020)            /*!< Bit 1 */
N#define  SDIO_DCTRL_DBLOCKSIZE_2             ((uint16_t)0x0040)            /*!< Bit 2 */
N#define  SDIO_DCTRL_DBLOCKSIZE_3             ((uint16_t)0x0080)            /*!< Bit 3 */
N
N#define  SDIO_DCTRL_RWSTART                  ((uint16_t)0x0100)            /*!< Read wait start */
N#define  SDIO_DCTRL_RWSTOP                   ((uint16_t)0x0200)            /*!< Read wait stop */
N#define  SDIO_DCTRL_RWMOD                    ((uint16_t)0x0400)            /*!< Read wait mode */
N#define  SDIO_DCTRL_SDIOEN                   ((uint16_t)0x0800)            /*!< SD I/O enable functions */
N
N/******************  Bit definition for SDIO_DCOUNT register  *****************/
N#define  SDIO_DCOUNT_DATACOUNT               ((uint32_t)0x01FFFFFF)        /*!< Data count value */
N
N/******************  Bit definition for SDIO_STA register  ********************/
N#define  SDIO_STA_CCRCFAIL                   ((uint32_t)0x00000001)        /*!< Command response received (CRC check failed) */
N#define  SDIO_STA_DCRCFAIL                   ((uint32_t)0x00000002)        /*!< Data block sent/received (CRC check failed) */
N#define  SDIO_STA_CTIMEOUT                   ((uint32_t)0x00000004)        /*!< Command response timeout */
N#define  SDIO_STA_DTIMEOUT                   ((uint32_t)0x00000008)        /*!< Data timeout */
N#define  SDIO_STA_TXUNDERR                   ((uint32_t)0x00000010)        /*!< Transmit FIFO underrun error */
N#define  SDIO_STA_RXOVERR                    ((uint32_t)0x00000020)        /*!< Received FIFO overrun error */
N#define  SDIO_STA_CMDREND                    ((uint32_t)0x00000040)        /*!< Command response received (CRC check passed) */
N#define  SDIO_STA_CMDSENT                    ((uint32_t)0x00000080)        /*!< Command sent (no response required) */
N#define  SDIO_STA_DATAEND                    ((uint32_t)0x00000100)        /*!< Data end (data counter, SDIDCOUNT, is zero) */
N#define  SDIO_STA_STBITERR                   ((uint32_t)0x00000200)        /*!< Start bit not detected on all data signals in wide bus mode */
N#define  SDIO_STA_DBCKEND                    ((uint32_t)0x00000400)        /*!< Data block sent/received (CRC check passed) */
N#define  SDIO_STA_CMDACT                     ((uint32_t)0x00000800)        /*!< Command transfer in progress */
N#define  SDIO_STA_TXACT                      ((uint32_t)0x00001000)        /*!< Data transmit in progress */
N#define  SDIO_STA_RXACT                      ((uint32_t)0x00002000)        /*!< Data receive in progress */
N#define  SDIO_STA_TXFIFOHE                   ((uint32_t)0x00004000)        /*!< Transmit FIFO Half Empty: at least 8 words can be written into the FIFO */
N#define  SDIO_STA_RXFIFOHF                   ((uint32_t)0x00008000)        /*!< Receive FIFO Half Full: there are at least 8 words in the FIFO */
N#define  SDIO_STA_TXFIFOF                    ((uint32_t)0x00010000)        /*!< Transmit FIFO full */
N#define  SDIO_STA_RXFIFOF                    ((uint32_t)0x00020000)        /*!< Receive FIFO full */
N#define  SDIO_STA_TXFIFOE                    ((uint32_t)0x00040000)        /*!< Transmit FIFO empty */
N#define  SDIO_STA_RXFIFOE                    ((uint32_t)0x00080000)        /*!< Receive FIFO empty */
N#define  SDIO_STA_TXDAVL                     ((uint32_t)0x00100000)        /*!< Data available in transmit FIFO */
N#define  SDIO_STA_RXDAVL                     ((uint32_t)0x00200000)        /*!< Data available in receive FIFO */
N#define  SDIO_STA_SDIOIT                     ((uint32_t)0x00400000)        /*!< SDIO interrupt received */
N#define  SDIO_STA_CEATAEND                   ((uint32_t)0x00800000)        /*!< CE-ATA command completion signal received for CMD61 */
N
N/*******************  Bit definition for SDIO_ICR register  *******************/
N#define  SDIO_ICR_CCRCFAILC                  ((uint32_t)0x00000001)        /*!< CCRCFAIL flag clear bit */
N#define  SDIO_ICR_DCRCFAILC                  ((uint32_t)0x00000002)        /*!< DCRCFAIL flag clear bit */
N#define  SDIO_ICR_CTIMEOUTC                  ((uint32_t)0x00000004)        /*!< CTIMEOUT flag clear bit */
N#define  SDIO_ICR_DTIMEOUTC                  ((uint32_t)0x00000008)        /*!< DTIMEOUT flag clear bit */
N#define  SDIO_ICR_TXUNDERRC                  ((uint32_t)0x00000010)        /*!< TXUNDERR flag clear bit */
N#define  SDIO_ICR_RXOVERRC                   ((uint32_t)0x00000020)        /*!< RXOVERR flag clear bit */
N#define  SDIO_ICR_CMDRENDC                   ((uint32_t)0x00000040)        /*!< CMDREND flag clear bit */
N#define  SDIO_ICR_CMDSENTC                   ((uint32_t)0x00000080)        /*!< CMDSENT flag clear bit */
N#define  SDIO_ICR_DATAENDC                   ((uint32_t)0x00000100)        /*!< DATAEND flag clear bit */
N#define  SDIO_ICR_STBITERRC                  ((uint32_t)0x00000200)        /*!< STBITERR flag clear bit */
N#define  SDIO_ICR_DBCKENDC                   ((uint32_t)0x00000400)        /*!< DBCKEND flag clear bit */
N#define  SDIO_ICR_SDIOITC                    ((uint32_t)0x00400000)        /*!< SDIOIT flag clear bit */
N#define  SDIO_ICR_CEATAENDC                  ((uint32_t)0x00800000)        /*!< CEATAEND flag clear bit */
N
N/******************  Bit definition for SDIO_MASK register  *******************/
N#define  SDIO_MASK_CCRCFAILIE                ((uint32_t)0x00000001)        /*!< Command CRC Fail Interrupt Enable */
N#define  SDIO_MASK_DCRCFAILIE                ((uint32_t)0x00000002)        /*!< Data CRC Fail Interrupt Enable */
N#define  SDIO_MASK_CTIMEOUTIE                ((uint32_t)0x00000004)        /*!< Command TimeOut Interrupt Enable */
N#define  SDIO_MASK_DTIMEOUTIE                ((uint32_t)0x00000008)        /*!< Data TimeOut Interrupt Enable */
N#define  SDIO_MASK_TXUNDERRIE                ((uint32_t)0x00000010)        /*!< Tx FIFO UnderRun Error Interrupt Enable */
N#define  SDIO_MASK_RXOVERRIE                 ((uint32_t)0x00000020)        /*!< Rx FIFO OverRun Error Interrupt Enable */
N#define  SDIO_MASK_CMDRENDIE                 ((uint32_t)0x00000040)        /*!< Command Response Received Interrupt Enable */
N#define  SDIO_MASK_CMDSENTIE                 ((uint32_t)0x00000080)        /*!< Command Sent Interrupt Enable */
N#define  SDIO_MASK_DATAENDIE                 ((uint32_t)0x00000100)        /*!< Data End Interrupt Enable */
N#define  SDIO_MASK_STBITERRIE                ((uint32_t)0x00000200)        /*!< Start Bit Error Interrupt Enable */
N#define  SDIO_MASK_DBCKENDIE                 ((uint32_t)0x00000400)        /*!< Data Block End Interrupt Enable */
N#define  SDIO_MASK_CMDACTIE                  ((uint32_t)0x00000800)        /*!< Command Acting Interrupt Enable */
N#define  SDIO_MASK_TXACTIE                   ((uint32_t)0x00001000)        /*!< Data Transmit Acting Interrupt Enable */
N#define  SDIO_MASK_RXACTIE                   ((uint32_t)0x00002000)        /*!< Data receive acting interrupt enabled */
N#define  SDIO_MASK_TXFIFOHEIE                ((uint32_t)0x00004000)        /*!< Tx FIFO Half Empty interrupt Enable */
N#define  SDIO_MASK_RXFIFOHFIE                ((uint32_t)0x00008000)        /*!< Rx FIFO Half Full interrupt Enable */
N#define  SDIO_MASK_TXFIFOFIE                 ((uint32_t)0x00010000)        /*!< Tx FIFO Full interrupt Enable */
N#define  SDIO_MASK_RXFIFOFIE                 ((uint32_t)0x00020000)        /*!< Rx FIFO Full interrupt Enable */
N#define  SDIO_MASK_TXFIFOEIE                 ((uint32_t)0x00040000)        /*!< Tx FIFO Empty interrupt Enable */
N#define  SDIO_MASK_RXFIFOEIE                 ((uint32_t)0x00080000)        /*!< Rx FIFO Empty interrupt Enable */
N#define  SDIO_MASK_TXDAVLIE                  ((uint32_t)0x00100000)        /*!< Data available in Tx FIFO interrupt Enable */
N#define  SDIO_MASK_RXDAVLIE                  ((uint32_t)0x00200000)        /*!< Data available in Rx FIFO interrupt Enable */
N#define  SDIO_MASK_SDIOITIE                  ((uint32_t)0x00400000)        /*!< SDIO Mode Interrupt Received interrupt Enable */
N#define  SDIO_MASK_CEATAENDIE                ((uint32_t)0x00800000)        /*!< CE-ATA command completion signal received Interrupt Enable */
N
N/*****************  Bit definition for SDIO_FIFOCNT register  *****************/
N#define  SDIO_FIFOCNT_FIFOCOUNT              ((uint32_t)0x00FFFFFF)        /*!< Remaining number of words to be written to or read from the FIFO */
N
N/******************  Bit definition for SDIO_FIFO register  *******************/
N#define  SDIO_FIFO_FIFODATA                  ((uint32_t)0xFFFFFFFF)        /*!< Receive and transmit FIFO data */
N
N/******************************************************************************/
N/*                                                                            */
N/*                                   USB Device FS                            */
N/*                                                                            */
N/******************************************************************************/
N
N/*!< Endpoint-specific registers */
N/*******************  Bit definition for USB_EP0R register  *******************/
N#define  USB_EP0R_EA                         ((uint16_t)0x000F)            /*!< Endpoint Address */
N
N#define  USB_EP0R_STAT_TX                    ((uint16_t)0x0030)            /*!< STAT_TX[1:0] bits (Status bits, for transmission transfers) */
N#define  USB_EP0R_STAT_TX_0                  ((uint16_t)0x0010)            /*!< Bit 0 */
N#define  USB_EP0R_STAT_TX_1                  ((uint16_t)0x0020)            /*!< Bit 1 */
N
N#define  USB_EP0R_DTOG_TX                    ((uint16_t)0x0040)            /*!< Data Toggle, for transmission transfers */
N#define  USB_EP0R_CTR_TX                     ((uint16_t)0x0080)            /*!< Correct Transfer for transmission */
N#define  USB_EP0R_EP_KIND                    ((uint16_t)0x0100)            /*!< Endpoint Kind */
N
N#define  USB_EP0R_EP_TYPE                    ((uint16_t)0x0600)            /*!< EP_TYPE[1:0] bits (Endpoint type) */
N#define  USB_EP0R_EP_TYPE_0                  ((uint16_t)0x0200)            /*!< Bit 0 */
N#define  USB_EP0R_EP_TYPE_1                  ((uint16_t)0x0400)            /*!< Bit 1 */
N
N#define  USB_EP0R_SETUP                      ((uint16_t)0x0800)            /*!< Setup transaction completed */
N
N#define  USB_EP0R_STAT_RX                    ((uint16_t)0x3000)            /*!< STAT_RX[1:0] bits (Status bits, for reception transfers) */
N#define  USB_EP0R_STAT_RX_0                  ((uint16_t)0x1000)            /*!< Bit 0 */
N#define  USB_EP0R_STAT_RX_1                  ((uint16_t)0x2000)            /*!< Bit 1 */
N
N#define  USB_EP0R_DTOG_RX                    ((uint16_t)0x4000)            /*!< Data Toggle, for reception transfers */
N#define  USB_EP0R_CTR_RX                     ((uint16_t)0x8000)            /*!< Correct Transfer for reception */
N
N/*******************  Bit definition for USB_EP1R register  *******************/
N#define  USB_EP1R_EA                         ((uint16_t)0x000F)            /*!< Endpoint Address */
N
N#define  USB_EP1R_STAT_TX                    ((uint16_t)0x0030)            /*!< STAT_TX[1:0] bits (Status bits, for transmission transfers) */
N#define  USB_EP1R_STAT_TX_0                  ((uint16_t)0x0010)            /*!< Bit 0 */
N#define  USB_EP1R_STAT_TX_1                  ((uint16_t)0x0020)            /*!< Bit 1 */
N
N#define  USB_EP1R_DTOG_TX                    ((uint16_t)0x0040)            /*!< Data Toggle, for transmission transfers */
N#define  USB_EP1R_CTR_TX                     ((uint16_t)0x0080)            /*!< Correct Transfer for transmission */
N#define  USB_EP1R_EP_KIND                    ((uint16_t)0x0100)            /*!< Endpoint Kind */
N
N#define  USB_EP1R_EP_TYPE                    ((uint16_t)0x0600)            /*!< EP_TYPE[1:0] bits (Endpoint type) */
N#define  USB_EP1R_EP_TYPE_0                  ((uint16_t)0x0200)            /*!< Bit 0 */
N#define  USB_EP1R_EP_TYPE_1                  ((uint16_t)0x0400)            /*!< Bit 1 */
N
N#define  USB_EP1R_SETUP                      ((uint16_t)0x0800)            /*!< Setup transaction completed */
N
N#define  USB_EP1R_STAT_RX                    ((uint16_t)0x3000)            /*!< STAT_RX[1:0] bits (Status bits, for reception transfers) */
N#define  USB_EP1R_STAT_RX_0                  ((uint16_t)0x1000)            /*!< Bit 0 */
N#define  USB_EP1R_STAT_RX_1                  ((uint16_t)0x2000)            /*!< Bit 1 */
N
N#define  USB_EP1R_DTOG_RX                    ((uint16_t)0x4000)            /*!< Data Toggle, for reception transfers */
N#define  USB_EP1R_CTR_RX                     ((uint16_t)0x8000)            /*!< Correct Transfer for reception */
N
N/*******************  Bit definition for USB_EP2R register  *******************/
N#define  USB_EP2R_EA                         ((uint16_t)0x000F)            /*!< Endpoint Address */
N
N#define  USB_EP2R_STAT_TX                    ((uint16_t)0x0030)            /*!< STAT_TX[1:0] bits (Status bits, for transmission transfers) */
N#define  USB_EP2R_STAT_TX_0                  ((uint16_t)0x0010)            /*!< Bit 0 */
N#define  USB_EP2R_STAT_TX_1                  ((uint16_t)0x0020)            /*!< Bit 1 */
N
N#define  USB_EP2R_DTOG_TX                    ((uint16_t)0x0040)            /*!< Data Toggle, for transmission transfers */
N#define  USB_EP2R_CTR_TX                     ((uint16_t)0x0080)            /*!< Correct Transfer for transmission */
N#define  USB_EP2R_EP_KIND                    ((uint16_t)0x0100)            /*!< Endpoint Kind */
N
N#define  USB_EP2R_EP_TYPE                    ((uint16_t)0x0600)            /*!< EP_TYPE[1:0] bits (Endpoint type) */
N#define  USB_EP2R_EP_TYPE_0                  ((uint16_t)0x0200)            /*!< Bit 0 */
N#define  USB_EP2R_EP_TYPE_1                  ((uint16_t)0x0400)            /*!< Bit 1 */
N
N#define  USB_EP2R_SETUP                      ((uint16_t)0x0800)            /*!< Setup transaction completed */
N
N#define  USB_EP2R_STAT_RX                    ((uint16_t)0x3000)            /*!< STAT_RX[1:0] bits (Status bits, for reception transfers) */
N#define  USB_EP2R_STAT_RX_0                  ((uint16_t)0x1000)            /*!< Bit 0 */
N#define  USB_EP2R_STAT_RX_1                  ((uint16_t)0x2000)            /*!< Bit 1 */
N
N#define  USB_EP2R_DTOG_RX                    ((uint16_t)0x4000)            /*!< Data Toggle, for reception transfers */
N#define  USB_EP2R_CTR_RX                     ((uint16_t)0x8000)            /*!< Correct Transfer for reception */
N
N/*******************  Bit definition for USB_EP3R register  *******************/
N#define  USB_EP3R_EA                         ((uint16_t)0x000F)            /*!< Endpoint Address */
N
N#define  USB_EP3R_STAT_TX                    ((uint16_t)0x0030)            /*!< STAT_TX[1:0] bits (Status bits, for transmission transfers) */
N#define  USB_EP3R_STAT_TX_0                  ((uint16_t)0x0010)            /*!< Bit 0 */
N#define  USB_EP3R_STAT_TX_1                  ((uint16_t)0x0020)            /*!< Bit 1 */
N
N#define  USB_EP3R_DTOG_TX                    ((uint16_t)0x0040)            /*!< Data Toggle, for transmission transfers */
N#define  USB_EP3R_CTR_TX                     ((uint16_t)0x0080)            /*!< Correct Transfer for transmission */
N#define  USB_EP3R_EP_KIND                    ((uint16_t)0x0100)            /*!< Endpoint Kind */
N
N#define  USB_EP3R_EP_TYPE                    ((uint16_t)0x0600)            /*!< EP_TYPE[1:0] bits (Endpoint type) */
N#define  USB_EP3R_EP_TYPE_0                  ((uint16_t)0x0200)            /*!< Bit 0 */
N#define  USB_EP3R_EP_TYPE_1                  ((uint16_t)0x0400)            /*!< Bit 1 */
N
N#define  USB_EP3R_SETUP                      ((uint16_t)0x0800)            /*!< Setup transaction completed */
N
N#define  USB_EP3R_STAT_RX                    ((uint16_t)0x3000)            /*!< STAT_RX[1:0] bits (Status bits, for reception transfers) */
N#define  USB_EP3R_STAT_RX_0                  ((uint16_t)0x1000)            /*!< Bit 0 */
N#define  USB_EP3R_STAT_RX_1                  ((uint16_t)0x2000)            /*!< Bit 1 */
N
N#define  USB_EP3R_DTOG_RX                    ((uint16_t)0x4000)            /*!< Data Toggle, for reception transfers */
N#define  USB_EP3R_CTR_RX                     ((uint16_t)0x8000)            /*!< Correct Transfer for reception */
N
N/*******************  Bit definition for USB_EP4R register  *******************/
N#define  USB_EP4R_EA                         ((uint16_t)0x000F)            /*!< Endpoint Address */
N
N#define  USB_EP4R_STAT_TX                    ((uint16_t)0x0030)            /*!< STAT_TX[1:0] bits (Status bits, for transmission transfers) */
N#define  USB_EP4R_STAT_TX_0                  ((uint16_t)0x0010)            /*!< Bit 0 */
N#define  USB_EP4R_STAT_TX_1                  ((uint16_t)0x0020)            /*!< Bit 1 */
N
N#define  USB_EP4R_DTOG_TX                    ((uint16_t)0x0040)            /*!< Data Toggle, for transmission transfers */
N#define  USB_EP4R_CTR_TX                     ((uint16_t)0x0080)            /*!< Correct Transfer for transmission */
N#define  USB_EP4R_EP_KIND                    ((uint16_t)0x0100)            /*!< Endpoint Kind */
N
N#define  USB_EP4R_EP_TYPE                    ((uint16_t)0x0600)            /*!< EP_TYPE[1:0] bits (Endpoint type) */
N#define  USB_EP4R_EP_TYPE_0                  ((uint16_t)0x0200)            /*!< Bit 0 */
N#define  USB_EP4R_EP_TYPE_1                  ((uint16_t)0x0400)            /*!< Bit 1 */
N
N#define  USB_EP4R_SETUP                      ((uint16_t)0x0800)            /*!< Setup transaction completed */
N
N#define  USB_EP4R_STAT_RX                    ((uint16_t)0x3000)            /*!< STAT_RX[1:0] bits (Status bits, for reception transfers) */
N#define  USB_EP4R_STAT_RX_0                  ((uint16_t)0x1000)            /*!< Bit 0 */
N#define  USB_EP4R_STAT_RX_1                  ((uint16_t)0x2000)            /*!< Bit 1 */
N
N#define  USB_EP4R_DTOG_RX                    ((uint16_t)0x4000)            /*!< Data Toggle, for reception transfers */
N#define  USB_EP4R_CTR_RX                     ((uint16_t)0x8000)            /*!< Correct Transfer for reception */
N
N/*******************  Bit definition for USB_EP5R register  *******************/
N#define  USB_EP5R_EA                         ((uint16_t)0x000F)            /*!< Endpoint Address */
N
N#define  USB_EP5R_STAT_TX                    ((uint16_t)0x0030)            /*!< STAT_TX[1:0] bits (Status bits, for transmission transfers) */
N#define  USB_EP5R_STAT_TX_0                  ((uint16_t)0x0010)            /*!< Bit 0 */
N#define  USB_EP5R_STAT_TX_1                  ((uint16_t)0x0020)            /*!< Bit 1 */
N
N#define  USB_EP5R_DTOG_TX                    ((uint16_t)0x0040)            /*!< Data Toggle, for transmission transfers */
N#define  USB_EP5R_CTR_TX                     ((uint16_t)0x0080)            /*!< Correct Transfer for transmission */
N#define  USB_EP5R_EP_KIND                    ((uint16_t)0x0100)            /*!< Endpoint Kind */
N
N#define  USB_EP5R_EP_TYPE                    ((uint16_t)0x0600)            /*!< EP_TYPE[1:0] bits (Endpoint type) */
N#define  USB_EP5R_EP_TYPE_0                  ((uint16_t)0x0200)            /*!< Bit 0 */
N#define  USB_EP5R_EP_TYPE_1                  ((uint16_t)0x0400)            /*!< Bit 1 */
N
N#define  USB_EP5R_SETUP                      ((uint16_t)0x0800)            /*!< Setup transaction completed */
N
N#define  USB_EP5R_STAT_RX                    ((uint16_t)0x3000)            /*!< STAT_RX[1:0] bits (Status bits, for reception transfers) */
N#define  USB_EP5R_STAT_RX_0                  ((uint16_t)0x1000)            /*!< Bit 0 */
N#define  USB_EP5R_STAT_RX_1                  ((uint16_t)0x2000)            /*!< Bit 1 */
N
N#define  USB_EP5R_DTOG_RX                    ((uint16_t)0x4000)            /*!< Data Toggle, for reception transfers */
N#define  USB_EP5R_CTR_RX                     ((uint16_t)0x8000)            /*!< Correct Transfer for reception */
N
N/*******************  Bit definition for USB_EP6R register  *******************/
N#define  USB_EP6R_EA                         ((uint16_t)0x000F)            /*!< Endpoint Address */
N
N#define  USB_EP6R_STAT_TX                    ((uint16_t)0x0030)            /*!< STAT_TX[1:0] bits (Status bits, for transmission transfers) */
N#define  USB_EP6R_STAT_TX_0                  ((uint16_t)0x0010)            /*!< Bit 0 */
N#define  USB_EP6R_STAT_TX_1                  ((uint16_t)0x0020)            /*!< Bit 1 */
N
N#define  USB_EP6R_DTOG_TX                    ((uint16_t)0x0040)            /*!< Data Toggle, for transmission transfers */
N#define  USB_EP6R_CTR_TX                     ((uint16_t)0x0080)            /*!< Correct Transfer for transmission */
N#define  USB_EP6R_EP_KIND                    ((uint16_t)0x0100)            /*!< Endpoint Kind */
N
N#define  USB_EP6R_EP_TYPE                    ((uint16_t)0x0600)            /*!< EP_TYPE[1:0] bits (Endpoint type) */
N#define  USB_EP6R_EP_TYPE_0                  ((uint16_t)0x0200)            /*!< Bit 0 */
N#define  USB_EP6R_EP_TYPE_1                  ((uint16_t)0x0400)            /*!< Bit 1 */
N
N#define  USB_EP6R_SETUP                      ((uint16_t)0x0800)            /*!< Setup transaction completed */
N
N#define  USB_EP6R_STAT_RX                    ((uint16_t)0x3000)            /*!< STAT_RX[1:0] bits (Status bits, for reception transfers) */
N#define  USB_EP6R_STAT_RX_0                  ((uint16_t)0x1000)            /*!< Bit 0 */
N#define  USB_EP6R_STAT_RX_1                  ((uint16_t)0x2000)            /*!< Bit 1 */
N
N#define  USB_EP6R_DTOG_RX                    ((uint16_t)0x4000)            /*!< Data Toggle, for reception transfers */
N#define  USB_EP6R_CTR_RX                     ((uint16_t)0x8000)            /*!< Correct Transfer for reception */
N
N/*******************  Bit definition for USB_EP7R register  *******************/
N#define  USB_EP7R_EA                         ((uint16_t)0x000F)            /*!< Endpoint Address */
N
N#define  USB_EP7R_STAT_TX                    ((uint16_t)0x0030)            /*!< STAT_TX[1:0] bits (Status bits, for transmission transfers) */
N#define  USB_EP7R_STAT_TX_0                  ((uint16_t)0x0010)            /*!< Bit 0 */
N#define  USB_EP7R_STAT_TX_1                  ((uint16_t)0x0020)            /*!< Bit 1 */
N
N#define  USB_EP7R_DTOG_TX                    ((uint16_t)0x0040)            /*!< Data Toggle, for transmission transfers */
N#define  USB_EP7R_CTR_TX                     ((uint16_t)0x0080)            /*!< Correct Transfer for transmission */
N#define  USB_EP7R_EP_KIND                    ((uint16_t)0x0100)            /*!< Endpoint Kind */
N
N#define  USB_EP7R_EP_TYPE                    ((uint16_t)0x0600)            /*!< EP_TYPE[1:0] bits (Endpoint type) */
N#define  USB_EP7R_EP_TYPE_0                  ((uint16_t)0x0200)            /*!< Bit 0 */
N#define  USB_EP7R_EP_TYPE_1                  ((uint16_t)0x0400)            /*!< Bit 1 */
N
N#define  USB_EP7R_SETUP                      ((uint16_t)0x0800)            /*!< Setup transaction completed */
N
N#define  USB_EP7R_STAT_RX                    ((uint16_t)0x3000)            /*!< STAT_RX[1:0] bits (Status bits, for reception transfers) */
N#define  USB_EP7R_STAT_RX_0                  ((uint16_t)0x1000)            /*!< Bit 0 */
N#define  USB_EP7R_STAT_RX_1                  ((uint16_t)0x2000)            /*!< Bit 1 */
N
N#define  USB_EP7R_DTOG_RX                    ((uint16_t)0x4000)            /*!< Data Toggle, for reception transfers */
N#define  USB_EP7R_CTR_RX                     ((uint16_t)0x8000)            /*!< Correct Transfer for reception */
N
N/*!< Common registers */
N/*******************  Bit definition for USB_CNTR register  *******************/
N#define  USB_CNTR_FRES                       ((uint16_t)0x0001)            /*!< Force USB Reset */
N#define  USB_CNTR_PDWN                       ((uint16_t)0x0002)            /*!< Power down */
N#define  USB_CNTR_LP_MODE                    ((uint16_t)0x0004)            /*!< Low-power mode */
N#define  USB_CNTR_FSUSP                      ((uint16_t)0x0008)            /*!< Force suspend */
N#define  USB_CNTR_RESUME                     ((uint16_t)0x0010)            /*!< Resume request */
N#define  USB_CNTR_ESOFM                      ((uint16_t)0x0100)            /*!< Expected Start Of Frame Interrupt Mask */
N#define  USB_CNTR_SOFM                       ((uint16_t)0x0200)            /*!< Start Of Frame Interrupt Mask */
N#define  USB_CNTR_RESETM                     ((uint16_t)0x0400)            /*!< RESET Interrupt Mask */
N#define  USB_CNTR_SUSPM                      ((uint16_t)0x0800)            /*!< Suspend mode Interrupt Mask */
N#define  USB_CNTR_WKUPM                      ((uint16_t)0x1000)            /*!< Wakeup Interrupt Mask */
N#define  USB_CNTR_ERRM                       ((uint16_t)0x2000)            /*!< Error Interrupt Mask */
N#define  USB_CNTR_PMAOVRM                    ((uint16_t)0x4000)            /*!< Packet Memory Area Over / Underrun Interrupt Mask */
N#define  USB_CNTR_CTRM                       ((uint16_t)0x8000)            /*!< Correct Transfer Interrupt Mask */
N
N/*******************  Bit definition for USB_ISTR register  *******************/
N#define  USB_ISTR_EP_ID                      ((uint16_t)0x000F)            /*!< Endpoint Identifier */
N#define  USB_ISTR_DIR                        ((uint16_t)0x0010)            /*!< Direction of transaction */
N#define  USB_ISTR_ESOF                       ((uint16_t)0x0100)            /*!< Expected Start Of Frame */
N#define  USB_ISTR_SOF                        ((uint16_t)0x0200)            /*!< Start Of Frame */
N#define  USB_ISTR_RESET                      ((uint16_t)0x0400)            /*!< USB RESET request */
N#define  USB_ISTR_SUSP                       ((uint16_t)0x0800)            /*!< Suspend mode request */
N#define  USB_ISTR_WKUP                       ((uint16_t)0x1000)            /*!< Wake up */
N#define  USB_ISTR_ERR                        ((uint16_t)0x2000)            /*!< Error */
N#define  USB_ISTR_PMAOVR                     ((uint16_t)0x4000)            /*!< Packet Memory Area Over / Underrun */
N#define  USB_ISTR_CTR                        ((uint16_t)0x8000)            /*!< Correct Transfer */
N
N/*******************  Bit definition for USB_FNR register  ********************/
N#define  USB_FNR_FN                          ((uint16_t)0x07FF)            /*!< Frame Number */
N#define  USB_FNR_LSOF                        ((uint16_t)0x1800)            /*!< Lost SOF */
N#define  USB_FNR_LCK                         ((uint16_t)0x2000)            /*!< Locked */
N#define  USB_FNR_RXDM                        ((uint16_t)0x4000)            /*!< Receive Data - Line Status */
N#define  USB_FNR_RXDP                        ((uint16_t)0x8000)            /*!< Receive Data + Line Status */
N
N/******************  Bit definition for USB_DADDR register  *******************/
N#define  USB_DADDR_ADD                       ((uint8_t)0x7F)               /*!< ADD[6:0] bits (Device Address) */
N#define  USB_DADDR_ADD0                      ((uint8_t)0x01)               /*!< Bit 0 */
N#define  USB_DADDR_ADD1                      ((uint8_t)0x02)               /*!< Bit 1 */
N#define  USB_DADDR_ADD2                      ((uint8_t)0x04)               /*!< Bit 2 */
N#define  USB_DADDR_ADD3                      ((uint8_t)0x08)               /*!< Bit 3 */
N#define  USB_DADDR_ADD4                      ((uint8_t)0x10)               /*!< Bit 4 */
N#define  USB_DADDR_ADD5                      ((uint8_t)0x20)               /*!< Bit 5 */
N#define  USB_DADDR_ADD6                      ((uint8_t)0x40)               /*!< Bit 6 */
N
N#define  USB_DADDR_EF                        ((uint8_t)0x80)               /*!< Enable Function */
N
N/******************  Bit definition for USB_BTABLE register  ******************/    
N#define  USB_BTABLE_BTABLE                   ((uint16_t)0xFFF8)            /*!< Buffer Table */
N
N/*!< Buffer descriptor table */
N/*****************  Bit definition for USB_ADDR0_TX register  *****************/
N#define  USB_ADDR0_TX_ADDR0_TX               ((uint16_t)0xFFFE)            /*!< Transmission Buffer Address 0 */
N
N/*****************  Bit definition for USB_ADDR1_TX register  *****************/
N#define  USB_ADDR1_TX_ADDR1_TX               ((uint16_t)0xFFFE)            /*!< Transmission Buffer Address 1 */
N
N/*****************  Bit definition for USB_ADDR2_TX register  *****************/
N#define  USB_ADDR2_TX_ADDR2_TX               ((uint16_t)0xFFFE)            /*!< Transmission Buffer Address 2 */
N
N/*****************  Bit definition for USB_ADDR3_TX register  *****************/
N#define  USB_ADDR3_TX_ADDR3_TX               ((uint16_t)0xFFFE)            /*!< Transmission Buffer Address 3 */
N
N/*****************  Bit definition for USB_ADDR4_TX register  *****************/
N#define  USB_ADDR4_TX_ADDR4_TX               ((uint16_t)0xFFFE)            /*!< Transmission Buffer Address 4 */
N
N/*****************  Bit definition for USB_ADDR5_TX register  *****************/
N#define  USB_ADDR5_TX_ADDR5_TX               ((uint16_t)0xFFFE)            /*!< Transmission Buffer Address 5 */
N
N/*****************  Bit definition for USB_ADDR6_TX register  *****************/
N#define  USB_ADDR6_TX_ADDR6_TX               ((uint16_t)0xFFFE)            /*!< Transmission Buffer Address 6 */
N
N/*****************  Bit definition for USB_ADDR7_TX register  *****************/
N#define  USB_ADDR7_TX_ADDR7_TX               ((uint16_t)0xFFFE)            /*!< Transmission Buffer Address 7 */
N
N/*----------------------------------------------------------------------------*/
N
N/*****************  Bit definition for USB_COUNT0_TX register  ****************/
N#define  USB_COUNT0_TX_COUNT0_TX             ((uint16_t)0x03FF)            /*!< Transmission Byte Count 0 */
N
N/*****************  Bit definition for USB_COUNT1_TX register  ****************/
N#define  USB_COUNT1_TX_COUNT1_TX             ((uint16_t)0x03FF)            /*!< Transmission Byte Count 1 */
N
N/*****************  Bit definition for USB_COUNT2_TX register  ****************/
N#define  USB_COUNT2_TX_COUNT2_TX             ((uint16_t)0x03FF)            /*!< Transmission Byte Count 2 */
N
N/*****************  Bit definition for USB_COUNT3_TX register  ****************/
N#define  USB_COUNT3_TX_COUNT3_TX             ((uint16_t)0x03FF)            /*!< Transmission Byte Count 3 */
N
N/*****************  Bit definition for USB_COUNT4_TX register  ****************/
N#define  USB_COUNT4_TX_COUNT4_TX             ((uint16_t)0x03FF)            /*!< Transmission Byte Count 4 */
N
N/*****************  Bit definition for USB_COUNT5_TX register  ****************/
N#define  USB_COUNT5_TX_COUNT5_TX             ((uint16_t)0x03FF)            /*!< Transmission Byte Count 5 */
N
N/*****************  Bit definition for USB_COUNT6_TX register  ****************/
N#define  USB_COUNT6_TX_COUNT6_TX             ((uint16_t)0x03FF)            /*!< Transmission Byte Count 6 */
N
N/*****************  Bit definition for USB_COUNT7_TX register  ****************/
N#define  USB_COUNT7_TX_COUNT7_TX             ((uint16_t)0x03FF)            /*!< Transmission Byte Count 7 */
N
N/*----------------------------------------------------------------------------*/
N
N/****************  Bit definition for USB_COUNT0_TX_0 register  ***************/
N#define  USB_COUNT0_TX_0_COUNT0_TX_0         ((uint32_t)0x000003FF)        /*!< Transmission Byte Count 0 (low) */
N
N/****************  Bit definition for USB_COUNT0_TX_1 register  ***************/
N#define  USB_COUNT0_TX_1_COUNT0_TX_1         ((uint32_t)0x03FF0000)        /*!< Transmission Byte Count 0 (high) */
N
N/****************  Bit definition for USB_COUNT1_TX_0 register  ***************/
N#define  USB_COUNT1_TX_0_COUNT1_TX_0          ((uint32_t)0x000003FF)        /*!< Transmission Byte Count 1 (low) */
N
N/****************  Bit definition for USB_COUNT1_TX_1 register  ***************/
N#define  USB_COUNT1_TX_1_COUNT1_TX_1          ((uint32_t)0x03FF0000)        /*!< Transmission Byte Count 1 (high) */
N
N/****************  Bit definition for USB_COUNT2_TX_0 register  ***************/
N#define  USB_COUNT2_TX_0_COUNT2_TX_0         ((uint32_t)0x000003FF)        /*!< Transmission Byte Count 2 (low) */
N
N/****************  Bit definition for USB_COUNT2_TX_1 register  ***************/
N#define  USB_COUNT2_TX_1_COUNT2_TX_1         ((uint32_t)0x03FF0000)        /*!< Transmission Byte Count 2 (high) */
N
N/****************  Bit definition for USB_COUNT3_TX_0 register  ***************/
N#define  USB_COUNT3_TX_0_COUNT3_TX_0         ((uint16_t)0x000003FF)        /*!< Transmission Byte Count 3 (low) */
N
N/****************  Bit definition for USB_COUNT3_TX_1 register  ***************/
N#define  USB_COUNT3_TX_1_COUNT3_TX_1         ((uint16_t)0x03FF0000)        /*!< Transmission Byte Count 3 (high) */
N
N/****************  Bit definition for USB_COUNT4_TX_0 register  ***************/
N#define  USB_COUNT4_TX_0_COUNT4_TX_0         ((uint32_t)0x000003FF)        /*!< Transmission Byte Count 4 (low) */
N
N/****************  Bit definition for USB_COUNT4_TX_1 register  ***************/
N#define  USB_COUNT4_TX_1_COUNT4_TX_1         ((uint32_t)0x03FF0000)        /*!< Transmission Byte Count 4 (high) */
N
N/****************  Bit definition for USB_COUNT5_TX_0 register  ***************/
N#define  USB_COUNT5_TX_0_COUNT5_TX_0         ((uint32_t)0x000003FF)        /*!< Transmission Byte Count 5 (low) */
N
N/****************  Bit definition for USB_COUNT5_TX_1 register  ***************/
N#define  USB_COUNT5_TX_1_COUNT5_TX_1         ((uint32_t)0x03FF0000)        /*!< Transmission Byte Count 5 (high) */
N
N/****************  Bit definition for USB_COUNT6_TX_0 register  ***************/
N#define  USB_COUNT6_TX_0_COUNT6_TX_0         ((uint32_t)0x000003FF)        /*!< Transmission Byte Count 6 (low) */
N
N/****************  Bit definition for USB_COUNT6_TX_1 register  ***************/
N#define  USB_COUNT6_TX_1_COUNT6_TX_1         ((uint32_t)0x03FF0000)        /*!< Transmission Byte Count 6 (high) */
N
N/****************  Bit definition for USB_COUNT7_TX_0 register  ***************/
N#define  USB_COUNT7_TX_0_COUNT7_TX_0         ((uint32_t)0x000003FF)        /*!< Transmission Byte Count 7 (low) */
N
N/****************  Bit definition for USB_COUNT7_TX_1 register  ***************/
N#define  USB_COUNT7_TX_1_COUNT7_TX_1         ((uint32_t)0x03FF0000)        /*!< Transmission Byte Count 7 (high) */
N
N/*----------------------------------------------------------------------------*/
N
N/*****************  Bit definition for USB_ADDR0_RX register  *****************/
N#define  USB_ADDR0_RX_ADDR0_RX               ((uint16_t)0xFFFE)            /*!< Reception Buffer Address 0 */
N
N/*****************  Bit definition for USB_ADDR1_RX register  *****************/
N#define  USB_ADDR1_RX_ADDR1_RX               ((uint16_t)0xFFFE)            /*!< Reception Buffer Address 1 */
N
N/*****************  Bit definition for USB_ADDR2_RX register  *****************/
N#define  USB_ADDR2_RX_ADDR2_RX               ((uint16_t)0xFFFE)            /*!< Reception Buffer Address 2 */
N
N/*****************  Bit definition for USB_ADDR3_RX register  *****************/
N#define  USB_ADDR3_RX_ADDR3_RX               ((uint16_t)0xFFFE)            /*!< Reception Buffer Address 3 */
N
N/*****************  Bit definition for USB_ADDR4_RX register  *****************/
N#define  USB_ADDR4_RX_ADDR4_RX               ((uint16_t)0xFFFE)            /*!< Reception Buffer Address 4 */
N
N/*****************  Bit definition for USB_ADDR5_RX register  *****************/
N#define  USB_ADDR5_RX_ADDR5_RX               ((uint16_t)0xFFFE)            /*!< Reception Buffer Address 5 */
N
N/*****************  Bit definition for USB_ADDR6_RX register  *****************/
N#define  USB_ADDR6_RX_ADDR6_RX               ((uint16_t)0xFFFE)            /*!< Reception Buffer Address 6 */
N
N/*****************  Bit definition for USB_ADDR7_RX register  *****************/
N#define  USB_ADDR7_RX_ADDR7_RX               ((uint16_t)0xFFFE)            /*!< Reception Buffer Address 7 */
N
N/*----------------------------------------------------------------------------*/
N
N/*****************  Bit definition for USB_COUNT0_RX register  ****************/
N#define  USB_COUNT0_RX_COUNT0_RX             ((uint16_t)0x03FF)            /*!< Reception Byte Count */
N
N#define  USB_COUNT0_RX_NUM_BLOCK             ((uint16_t)0x7C00)            /*!< NUM_BLOCK[4:0] bits (Number of blocks) */
N#define  USB_COUNT0_RX_NUM_BLOCK_0           ((uint16_t)0x0400)            /*!< Bit 0 */
N#define  USB_COUNT0_RX_NUM_BLOCK_1           ((uint16_t)0x0800)            /*!< Bit 1 */
N#define  USB_COUNT0_RX_NUM_BLOCK_2           ((uint16_t)0x1000)            /*!< Bit 2 */
N#define  USB_COUNT0_RX_NUM_BLOCK_3           ((uint16_t)0x2000)            /*!< Bit 3 */
N#define  USB_COUNT0_RX_NUM_BLOCK_4           ((uint16_t)0x4000)            /*!< Bit 4 */
N
N#define  USB_COUNT0_RX_BLSIZE                ((uint16_t)0x8000)            /*!< BLock SIZE */
N
N/*****************  Bit definition for USB_COUNT1_RX register  ****************/
N#define  USB_COUNT1_RX_COUNT1_RX             ((uint16_t)0x03FF)            /*!< Reception Byte Count */
N
N#define  USB_COUNT1_RX_NUM_BLOCK             ((uint16_t)0x7C00)            /*!< NUM_BLOCK[4:0] bits (Number of blocks) */
N#define  USB_COUNT1_RX_NUM_BLOCK_0           ((uint16_t)0x0400)            /*!< Bit 0 */
N#define  USB_COUNT1_RX_NUM_BLOCK_1           ((uint16_t)0x0800)            /*!< Bit 1 */
N#define  USB_COUNT1_RX_NUM_BLOCK_2           ((uint16_t)0x1000)            /*!< Bit 2 */
N#define  USB_COUNT1_RX_NUM_BLOCK_3           ((uint16_t)0x2000)            /*!< Bit 3 */
N#define  USB_COUNT1_RX_NUM_BLOCK_4           ((uint16_t)0x4000)            /*!< Bit 4 */
N
N#define  USB_COUNT1_RX_BLSIZE                ((uint16_t)0x8000)            /*!< BLock SIZE */
N
N/*****************  Bit definition for USB_COUNT2_RX register  ****************/
N#define  USB_COUNT2_RX_COUNT2_RX             ((uint16_t)0x03FF)            /*!< Reception Byte Count */
N
N#define  USB_COUNT2_RX_NUM_BLOCK             ((uint16_t)0x7C00)            /*!< NUM_BLOCK[4:0] bits (Number of blocks) */
N#define  USB_COUNT2_RX_NUM_BLOCK_0           ((uint16_t)0x0400)            /*!< Bit 0 */
N#define  USB_COUNT2_RX_NUM_BLOCK_1           ((uint16_t)0x0800)            /*!< Bit 1 */
N#define  USB_COUNT2_RX_NUM_BLOCK_2           ((uint16_t)0x1000)            /*!< Bit 2 */
N#define  USB_COUNT2_RX_NUM_BLOCK_3           ((uint16_t)0x2000)            /*!< Bit 3 */
N#define  USB_COUNT2_RX_NUM_BLOCK_4           ((uint16_t)0x4000)            /*!< Bit 4 */
N
N#define  USB_COUNT2_RX_BLSIZE                ((uint16_t)0x8000)            /*!< BLock SIZE */
N
N/*****************  Bit definition for USB_COUNT3_RX register  ****************/
N#define  USB_COUNT3_RX_COUNT3_RX             ((uint16_t)0x03FF)            /*!< Reception Byte Count */
N
N#define  USB_COUNT3_RX_NUM_BLOCK             ((uint16_t)0x7C00)            /*!< NUM_BLOCK[4:0] bits (Number of blocks) */
N#define  USB_COUNT3_RX_NUM_BLOCK_0           ((uint16_t)0x0400)            /*!< Bit 0 */
N#define  USB_COUNT3_RX_NUM_BLOCK_1           ((uint16_t)0x0800)            /*!< Bit 1 */
N#define  USB_COUNT3_RX_NUM_BLOCK_2           ((uint16_t)0x1000)            /*!< Bit 2 */
N#define  USB_COUNT3_RX_NUM_BLOCK_3           ((uint16_t)0x2000)            /*!< Bit 3 */
N#define  USB_COUNT3_RX_NUM_BLOCK_4           ((uint16_t)0x4000)            /*!< Bit 4 */
N
N#define  USB_COUNT3_RX_BLSIZE                ((uint16_t)0x8000)            /*!< BLock SIZE */
N
N/*****************  Bit definition for USB_COUNT4_RX register  ****************/
N#define  USB_COUNT4_RX_COUNT4_RX             ((uint16_t)0x03FF)            /*!< Reception Byte Count */
N
N#define  USB_COUNT4_RX_NUM_BLOCK             ((uint16_t)0x7C00)            /*!< NUM_BLOCK[4:0] bits (Number of blocks) */
N#define  USB_COUNT4_RX_NUM_BLOCK_0           ((uint16_t)0x0400)            /*!< Bit 0 */
N#define  USB_COUNT4_RX_NUM_BLOCK_1           ((uint16_t)0x0800)            /*!< Bit 1 */
N#define  USB_COUNT4_RX_NUM_BLOCK_2           ((uint16_t)0x1000)            /*!< Bit 2 */
N#define  USB_COUNT4_RX_NUM_BLOCK_3           ((uint16_t)0x2000)            /*!< Bit 3 */
N#define  USB_COUNT4_RX_NUM_BLOCK_4           ((uint16_t)0x4000)            /*!< Bit 4 */
N
N#define  USB_COUNT4_RX_BLSIZE                ((uint16_t)0x8000)            /*!< BLock SIZE */
N
N/*****************  Bit definition for USB_COUNT5_RX register  ****************/
N#define  USB_COUNT5_RX_COUNT5_RX             ((uint16_t)0x03FF)            /*!< Reception Byte Count */
N
N#define  USB_COUNT5_RX_NUM_BLOCK             ((uint16_t)0x7C00)            /*!< NUM_BLOCK[4:0] bits (Number of blocks) */
N#define  USB_COUNT5_RX_NUM_BLOCK_0           ((uint16_t)0x0400)            /*!< Bit 0 */
N#define  USB_COUNT5_RX_NUM_BLOCK_1           ((uint16_t)0x0800)            /*!< Bit 1 */
N#define  USB_COUNT5_RX_NUM_BLOCK_2           ((uint16_t)0x1000)            /*!< Bit 2 */
N#define  USB_COUNT5_RX_NUM_BLOCK_3           ((uint16_t)0x2000)            /*!< Bit 3 */
N#define  USB_COUNT5_RX_NUM_BLOCK_4           ((uint16_t)0x4000)            /*!< Bit 4 */
N
N#define  USB_COUNT5_RX_BLSIZE                ((uint16_t)0x8000)            /*!< BLock SIZE */
N
N/*****************  Bit definition for USB_COUNT6_RX register  ****************/
N#define  USB_COUNT6_RX_COUNT6_RX             ((uint16_t)0x03FF)            /*!< Reception Byte Count */
N
N#define  USB_COUNT6_RX_NUM_BLOCK             ((uint16_t)0x7C00)            /*!< NUM_BLOCK[4:0] bits (Number of blocks) */
N#define  USB_COUNT6_RX_NUM_BLOCK_0           ((uint16_t)0x0400)            /*!< Bit 0 */
N#define  USB_COUNT6_RX_NUM_BLOCK_1           ((uint16_t)0x0800)            /*!< Bit 1 */
N#define  USB_COUNT6_RX_NUM_BLOCK_2           ((uint16_t)0x1000)            /*!< Bit 2 */
N#define  USB_COUNT6_RX_NUM_BLOCK_3           ((uint16_t)0x2000)            /*!< Bit 3 */
N#define  USB_COUNT6_RX_NUM_BLOCK_4           ((uint16_t)0x4000)            /*!< Bit 4 */
N
N#define  USB_COUNT6_RX_BLSIZE                ((uint16_t)0x8000)            /*!< BLock SIZE */
N
N/*****************  Bit definition for USB_COUNT7_RX register  ****************/
N#define  USB_COUNT7_RX_COUNT7_RX             ((uint16_t)0x03FF)            /*!< Reception Byte Count */
N
N#define  USB_COUNT7_RX_NUM_BLOCK             ((uint16_t)0x7C00)            /*!< NUM_BLOCK[4:0] bits (Number of blocks) */
N#define  USB_COUNT7_RX_NUM_BLOCK_0           ((uint16_t)0x0400)            /*!< Bit 0 */
N#define  USB_COUNT7_RX_NUM_BLOCK_1           ((uint16_t)0x0800)            /*!< Bit 1 */
N#define  USB_COUNT7_RX_NUM_BLOCK_2           ((uint16_t)0x1000)            /*!< Bit 2 */
N#define  USB_COUNT7_RX_NUM_BLOCK_3           ((uint16_t)0x2000)            /*!< Bit 3 */
N#define  USB_COUNT7_RX_NUM_BLOCK_4           ((uint16_t)0x4000)            /*!< Bit 4 */
N
N#define  USB_COUNT7_RX_BLSIZE                ((uint16_t)0x8000)            /*!< BLock SIZE */
N
N/*----------------------------------------------------------------------------*/
N
N/****************  Bit definition for USB_COUNT0_RX_0 register  ***************/
N#define  USB_COUNT0_RX_0_COUNT0_RX_0         ((uint32_t)0x000003FF)        /*!< Reception Byte Count (low) */
N
N#define  USB_COUNT0_RX_0_NUM_BLOCK_0         ((uint32_t)0x00007C00)        /*!< NUM_BLOCK_0[4:0] bits (Number of blocks) (low) */
N#define  USB_COUNT0_RX_0_NUM_BLOCK_0_0       ((uint32_t)0x00000400)        /*!< Bit 0 */
N#define  USB_COUNT0_RX_0_NUM_BLOCK_0_1       ((uint32_t)0x00000800)        /*!< Bit 1 */
N#define  USB_COUNT0_RX_0_NUM_BLOCK_0_2       ((uint32_t)0x00001000)        /*!< Bit 2 */
N#define  USB_COUNT0_RX_0_NUM_BLOCK_0_3       ((uint32_t)0x00002000)        /*!< Bit 3 */
N#define  USB_COUNT0_RX_0_NUM_BLOCK_0_4       ((uint32_t)0x00004000)        /*!< Bit 4 */
N
N#define  USB_COUNT0_RX_0_BLSIZE_0            ((uint32_t)0x00008000)        /*!< BLock SIZE (low) */
N
N/****************  Bit definition for USB_COUNT0_RX_1 register  ***************/
N#define  USB_COUNT0_RX_1_COUNT0_RX_1         ((uint32_t)0x03FF0000)        /*!< Reception Byte Count (high) */
N
N#define  USB_COUNT0_RX_1_NUM_BLOCK_1         ((uint32_t)0x7C000000)        /*!< NUM_BLOCK_1[4:0] bits (Number of blocks) (high) */
N#define  USB_COUNT0_RX_1_NUM_BLOCK_1_0       ((uint32_t)0x04000000)        /*!< Bit 1 */
N#define  USB_COUNT0_RX_1_NUM_BLOCK_1_1       ((uint32_t)0x08000000)        /*!< Bit 1 */
N#define  USB_COUNT0_RX_1_NUM_BLOCK_1_2       ((uint32_t)0x10000000)        /*!< Bit 2 */
N#define  USB_COUNT0_RX_1_NUM_BLOCK_1_3       ((uint32_t)0x20000000)        /*!< Bit 3 */
N#define  USB_COUNT0_RX_1_NUM_BLOCK_1_4       ((uint32_t)0x40000000)        /*!< Bit 4 */
N
N#define  USB_COUNT0_RX_1_BLSIZE_1            ((uint32_t)0x80000000)        /*!< BLock SIZE (high) */
N
N/****************  Bit definition for USB_COUNT1_RX_0 register  ***************/
N#define  USB_COUNT1_RX_0_COUNT1_RX_0         ((uint32_t)0x000003FF)        /*!< Reception Byte Count (low) */
N
N#define  USB_COUNT1_RX_0_NUM_BLOCK_0         ((uint32_t)0x00007C00)        /*!< NUM_BLOCK_0[4:0] bits (Number of blocks) (low) */
N#define  USB_COUNT1_RX_0_NUM_BLOCK_0_0       ((uint32_t)0x00000400)        /*!< Bit 0 */
N#define  USB_COUNT1_RX_0_NUM_BLOCK_0_1       ((uint32_t)0x00000800)        /*!< Bit 1 */
N#define  USB_COUNT1_RX_0_NUM_BLOCK_0_2       ((uint32_t)0x00001000)        /*!< Bit 2 */
N#define  USB_COUNT1_RX_0_NUM_BLOCK_0_3       ((uint32_t)0x00002000)        /*!< Bit 3 */
N#define  USB_COUNT1_RX_0_NUM_BLOCK_0_4       ((uint32_t)0x00004000)        /*!< Bit 4 */
N
N#define  USB_COUNT1_RX_0_BLSIZE_0            ((uint32_t)0x00008000)        /*!< BLock SIZE (low) */
N
N/****************  Bit definition for USB_COUNT1_RX_1 register  ***************/
N#define  USB_COUNT1_RX_1_COUNT1_RX_1         ((uint32_t)0x03FF0000)        /*!< Reception Byte Count (high) */
N
N#define  USB_COUNT1_RX_1_NUM_BLOCK_1         ((uint32_t)0x7C000000)        /*!< NUM_BLOCK_1[4:0] bits (Number of blocks) (high) */
N#define  USB_COUNT1_RX_1_NUM_BLOCK_1_0       ((uint32_t)0x04000000)        /*!< Bit 0 */
N#define  USB_COUNT1_RX_1_NUM_BLOCK_1_1       ((uint32_t)0x08000000)        /*!< Bit 1 */
N#define  USB_COUNT1_RX_1_NUM_BLOCK_1_2       ((uint32_t)0x10000000)        /*!< Bit 2 */
N#define  USB_COUNT1_RX_1_NUM_BLOCK_1_3       ((uint32_t)0x20000000)        /*!< Bit 3 */
N#define  USB_COUNT1_RX_1_NUM_BLOCK_1_4       ((uint32_t)0x40000000)        /*!< Bit 4 */
N
N#define  USB_COUNT1_RX_1_BLSIZE_1            ((uint32_t)0x80000000)        /*!< BLock SIZE (high) */
N
N/****************  Bit definition for USB_COUNT2_RX_0 register  ***************/
N#define  USB_COUNT2_RX_0_COUNT2_RX_0         ((uint32_t)0x000003FF)        /*!< Reception Byte Count (low) */
N
N#define  USB_COUNT2_RX_0_NUM_BLOCK_0         ((uint32_t)0x00007C00)        /*!< NUM_BLOCK_0[4:0] bits (Number of blocks) (low) */
N#define  USB_COUNT2_RX_0_NUM_BLOCK_0_0       ((uint32_t)0x00000400)        /*!< Bit 0 */
N#define  USB_COUNT2_RX_0_NUM_BLOCK_0_1       ((uint32_t)0x00000800)        /*!< Bit 1 */
N#define  USB_COUNT2_RX_0_NUM_BLOCK_0_2       ((uint32_t)0x00001000)        /*!< Bit 2 */
N#define  USB_COUNT2_RX_0_NUM_BLOCK_0_3       ((uint32_t)0x00002000)        /*!< Bit 3 */
N#define  USB_COUNT2_RX_0_NUM_BLOCK_0_4       ((uint32_t)0x00004000)        /*!< Bit 4 */
N
N#define  USB_COUNT2_RX_0_BLSIZE_0            ((uint32_t)0x00008000)        /*!< BLock SIZE (low) */
N
N/****************  Bit definition for USB_COUNT2_RX_1 register  ***************/
N#define  USB_COUNT2_RX_1_COUNT2_RX_1         ((uint32_t)0x03FF0000)        /*!< Reception Byte Count (high) */
N
N#define  USB_COUNT2_RX_1_NUM_BLOCK_1         ((uint32_t)0x7C000000)        /*!< NUM_BLOCK_1[4:0] bits (Number of blocks) (high) */
N#define  USB_COUNT2_RX_1_NUM_BLOCK_1_0       ((uint32_t)0x04000000)        /*!< Bit 0 */
N#define  USB_COUNT2_RX_1_NUM_BLOCK_1_1       ((uint32_t)0x08000000)        /*!< Bit 1 */
N#define  USB_COUNT2_RX_1_NUM_BLOCK_1_2       ((uint32_t)0x10000000)        /*!< Bit 2 */
N#define  USB_COUNT2_RX_1_NUM_BLOCK_1_3       ((uint32_t)0x20000000)        /*!< Bit 3 */
N#define  USB_COUNT2_RX_1_NUM_BLOCK_1_4       ((uint32_t)0x40000000)        /*!< Bit 4 */
N
N#define  USB_COUNT2_RX_1_BLSIZE_1            ((uint32_t)0x80000000)        /*!< BLock SIZE (high) */
N
N/****************  Bit definition for USB_COUNT3_RX_0 register  ***************/
N#define  USB_COUNT3_RX_0_COUNT3_RX_0         ((uint32_t)0x000003FF)        /*!< Reception Byte Count (low) */
N
N#define  USB_COUNT3_RX_0_NUM_BLOCK_0         ((uint32_t)0x00007C00)        /*!< NUM_BLOCK_0[4:0] bits (Number of blocks) (low) */
N#define  USB_COUNT3_RX_0_NUM_BLOCK_0_0       ((uint32_t)0x00000400)        /*!< Bit 0 */
N#define  USB_COUNT3_RX_0_NUM_BLOCK_0_1       ((uint32_t)0x00000800)        /*!< Bit 1 */
N#define  USB_COUNT3_RX_0_NUM_BLOCK_0_2       ((uint32_t)0x00001000)        /*!< Bit 2 */
N#define  USB_COUNT3_RX_0_NUM_BLOCK_0_3       ((uint32_t)0x00002000)        /*!< Bit 3 */
N#define  USB_COUNT3_RX_0_NUM_BLOCK_0_4       ((uint32_t)0x00004000)        /*!< Bit 4 */
N
N#define  USB_COUNT3_RX_0_BLSIZE_0            ((uint32_t)0x00008000)        /*!< BLock SIZE (low) */
N
N/****************  Bit definition for USB_COUNT3_RX_1 register  ***************/
N#define  USB_COUNT3_RX_1_COUNT3_RX_1         ((uint32_t)0x03FF0000)        /*!< Reception Byte Count (high) */
N
N#define  USB_COUNT3_RX_1_NUM_BLOCK_1         ((uint32_t)0x7C000000)        /*!< NUM_BLOCK_1[4:0] bits (Number of blocks) (high) */
N#define  USB_COUNT3_RX_1_NUM_BLOCK_1_0       ((uint32_t)0x04000000)        /*!< Bit 0 */
N#define  USB_COUNT3_RX_1_NUM_BLOCK_1_1       ((uint32_t)0x08000000)        /*!< Bit 1 */
N#define  USB_COUNT3_RX_1_NUM_BLOCK_1_2       ((uint32_t)0x10000000)        /*!< Bit 2 */
N#define  USB_COUNT3_RX_1_NUM_BLOCK_1_3       ((uint32_t)0x20000000)        /*!< Bit 3 */
N#define  USB_COUNT3_RX_1_NUM_BLOCK_1_4       ((uint32_t)0x40000000)        /*!< Bit 4 */
N
N#define  USB_COUNT3_RX_1_BLSIZE_1            ((uint32_t)0x80000000)        /*!< BLock SIZE (high) */
N
N/****************  Bit definition for USB_COUNT4_RX_0 register  ***************/
N#define  USB_COUNT4_RX_0_COUNT4_RX_0         ((uint32_t)0x000003FF)        /*!< Reception Byte Count (low) */
N
N#define  USB_COUNT4_RX_0_NUM_BLOCK_0         ((uint32_t)0x00007C00)        /*!< NUM_BLOCK_0[4:0] bits (Number of blocks) (low) */
N#define  USB_COUNT4_RX_0_NUM_BLOCK_0_0      ((uint32_t)0x00000400)        /*!< Bit 0 */
N#define  USB_COUNT4_RX_0_NUM_BLOCK_0_1      ((uint32_t)0x00000800)        /*!< Bit 1 */
N#define  USB_COUNT4_RX_0_NUM_BLOCK_0_2      ((uint32_t)0x00001000)        /*!< Bit 2 */
N#define  USB_COUNT4_RX_0_NUM_BLOCK_0_3      ((uint32_t)0x00002000)        /*!< Bit 3 */
N#define  USB_COUNT4_RX_0_NUM_BLOCK_0_4      ((uint32_t)0x00004000)        /*!< Bit 4 */
N
N#define  USB_COUNT4_RX_0_BLSIZE_0            ((uint32_t)0x00008000)        /*!< BLock SIZE (low) */
N
N/****************  Bit definition for USB_COUNT4_RX_1 register  ***************/
N#define  USB_COUNT4_RX_1_COUNT4_RX_1         ((uint32_t)0x03FF0000)        /*!< Reception Byte Count (high) */
N
N#define  USB_COUNT4_RX_1_NUM_BLOCK_1         ((uint32_t)0x7C000000)        /*!< NUM_BLOCK_1[4:0] bits (Number of blocks) (high) */
N#define  USB_COUNT4_RX_1_NUM_BLOCK_1_0       ((uint32_t)0x04000000)        /*!< Bit 0 */
N#define  USB_COUNT4_RX_1_NUM_BLOCK_1_1       ((uint32_t)0x08000000)        /*!< Bit 1 */
N#define  USB_COUNT4_RX_1_NUM_BLOCK_1_2       ((uint32_t)0x10000000)        /*!< Bit 2 */
N#define  USB_COUNT4_RX_1_NUM_BLOCK_1_3       ((uint32_t)0x20000000)        /*!< Bit 3 */
N#define  USB_COUNT4_RX_1_NUM_BLOCK_1_4       ((uint32_t)0x40000000)        /*!< Bit 4 */
N
N#define  USB_COUNT4_RX_1_BLSIZE_1            ((uint32_t)0x80000000)        /*!< BLock SIZE (high) */
N
N/****************  Bit definition for USB_COUNT5_RX_0 register  ***************/
N#define  USB_COUNT5_RX_0_COUNT5_RX_0         ((uint32_t)0x000003FF)        /*!< Reception Byte Count (low) */
N
N#define  USB_COUNT5_RX_0_NUM_BLOCK_0         ((uint32_t)0x00007C00)        /*!< NUM_BLOCK_0[4:0] bits (Number of blocks) (low) */
N#define  USB_COUNT5_RX_0_NUM_BLOCK_0_0       ((uint32_t)0x00000400)        /*!< Bit 0 */
N#define  USB_COUNT5_RX_0_NUM_BLOCK_0_1       ((uint32_t)0x00000800)        /*!< Bit 1 */
N#define  USB_COUNT5_RX_0_NUM_BLOCK_0_2       ((uint32_t)0x00001000)        /*!< Bit 2 */
N#define  USB_COUNT5_RX_0_NUM_BLOCK_0_3       ((uint32_t)0x00002000)        /*!< Bit 3 */
N#define  USB_COUNT5_RX_0_NUM_BLOCK_0_4       ((uint32_t)0x00004000)        /*!< Bit 4 */
N
N#define  USB_COUNT5_RX_0_BLSIZE_0            ((uint32_t)0x00008000)        /*!< BLock SIZE (low) */
N
N/****************  Bit definition for USB_COUNT5_RX_1 register  ***************/
N#define  USB_COUNT5_RX_1_COUNT5_RX_1         ((uint32_t)0x03FF0000)        /*!< Reception Byte Count (high) */
N
N#define  USB_COUNT5_RX_1_NUM_BLOCK_1         ((uint32_t)0x7C000000)        /*!< NUM_BLOCK_1[4:0] bits (Number of blocks) (high) */
N#define  USB_COUNT5_RX_1_NUM_BLOCK_1_0       ((uint32_t)0x04000000)        /*!< Bit 0 */
N#define  USB_COUNT5_RX_1_NUM_BLOCK_1_1       ((uint32_t)0x08000000)        /*!< Bit 1 */
N#define  USB_COUNT5_RX_1_NUM_BLOCK_1_2       ((uint32_t)0x10000000)        /*!< Bit 2 */
N#define  USB_COUNT5_RX_1_NUM_BLOCK_1_3       ((uint32_t)0x20000000)        /*!< Bit 3 */
N#define  USB_COUNT5_RX_1_NUM_BLOCK_1_4       ((uint32_t)0x40000000)        /*!< Bit 4 */
N
N#define  USB_COUNT5_RX_1_BLSIZE_1            ((uint32_t)0x80000000)        /*!< BLock SIZE (high) */
N
N/***************  Bit definition for USB_COUNT6_RX_0  register  ***************/
N#define  USB_COUNT6_RX_0_COUNT6_RX_0         ((uint32_t)0x000003FF)        /*!< Reception Byte Count (low) */
N
N#define  USB_COUNT6_RX_0_NUM_BLOCK_0         ((uint32_t)0x00007C00)        /*!< NUM_BLOCK_0[4:0] bits (Number of blocks) (low) */
N#define  USB_COUNT6_RX_0_NUM_BLOCK_0_0       ((uint32_t)0x00000400)        /*!< Bit 0 */
N#define  USB_COUNT6_RX_0_NUM_BLOCK_0_1       ((uint32_t)0x00000800)        /*!< Bit 1 */
N#define  USB_COUNT6_RX_0_NUM_BLOCK_0_2       ((uint32_t)0x00001000)        /*!< Bit 2 */
N#define  USB_COUNT6_RX_0_NUM_BLOCK_0_3       ((uint32_t)0x00002000)        /*!< Bit 3 */
N#define  USB_COUNT6_RX_0_NUM_BLOCK_0_4       ((uint32_t)0x00004000)        /*!< Bit 4 */
N
N#define  USB_COUNT6_RX_0_BLSIZE_0            ((uint32_t)0x00008000)        /*!< BLock SIZE (low) */
N
N/****************  Bit definition for USB_COUNT6_RX_1 register  ***************/
N#define  USB_COUNT6_RX_1_COUNT6_RX_1         ((uint32_t)0x03FF0000)        /*!< Reception Byte Count (high) */
N
N#define  USB_COUNT6_RX_1_NUM_BLOCK_1         ((uint32_t)0x7C000000)        /*!< NUM_BLOCK_1[4:0] bits (Number of blocks) (high) */
N#define  USB_COUNT6_RX_1_NUM_BLOCK_1_0       ((uint32_t)0x04000000)        /*!< Bit 0 */
N#define  USB_COUNT6_RX_1_NUM_BLOCK_1_1       ((uint32_t)0x08000000)        /*!< Bit 1 */
N#define  USB_COUNT6_RX_1_NUM_BLOCK_1_2       ((uint32_t)0x10000000)        /*!< Bit 2 */
N#define  USB_COUNT6_RX_1_NUM_BLOCK_1_3       ((uint32_t)0x20000000)        /*!< Bit 3 */
N#define  USB_COUNT6_RX_1_NUM_BLOCK_1_4       ((uint32_t)0x40000000)        /*!< Bit 4 */
N
N#define  USB_COUNT6_RX_1_BLSIZE_1            ((uint32_t)0x80000000)        /*!< BLock SIZE (high) */
N
N/***************  Bit definition for USB_COUNT7_RX_0 register  ****************/
N#define  USB_COUNT7_RX_0_COUNT7_RX_0         ((uint32_t)0x000003FF)        /*!< Reception Byte Count (low) */
N
N#define  USB_COUNT7_RX_0_NUM_BLOCK_0         ((uint32_t)0x00007C00)        /*!< NUM_BLOCK_0[4:0] bits (Number of blocks) (low) */
N#define  USB_COUNT7_RX_0_NUM_BLOCK_0_0       ((uint32_t)0x00000400)        /*!< Bit 0 */
N#define  USB_COUNT7_RX_0_NUM_BLOCK_0_1       ((uint32_t)0x00000800)        /*!< Bit 1 */
N#define  USB_COUNT7_RX_0_NUM_BLOCK_0_2       ((uint32_t)0x00001000)        /*!< Bit 2 */
N#define  USB_COUNT7_RX_0_NUM_BLOCK_0_3       ((uint32_t)0x00002000)        /*!< Bit 3 */
N#define  USB_COUNT7_RX_0_NUM_BLOCK_0_4       ((uint32_t)0x00004000)        /*!< Bit 4 */
N
N#define  USB_COUNT7_RX_0_BLSIZE_0            ((uint32_t)0x00008000)        /*!< BLock SIZE (low) */
N
N/***************  Bit definition for USB_COUNT7_RX_1 register  ****************/
N#define  USB_COUNT7_RX_1_COUNT7_RX_1         ((uint32_t)0x03FF0000)        /*!< Reception Byte Count (high) */
N
N#define  USB_COUNT7_RX_1_NUM_BLOCK_1         ((uint32_t)0x7C000000)        /*!< NUM_BLOCK_1[4:0] bits (Number of blocks) (high) */
N#define  USB_COUNT7_RX_1_NUM_BLOCK_1_0       ((uint32_t)0x04000000)        /*!< Bit 0 */
N#define  USB_COUNT7_RX_1_NUM_BLOCK_1_1       ((uint32_t)0x08000000)        /*!< Bit 1 */
N#define  USB_COUNT7_RX_1_NUM_BLOCK_1_2       ((uint32_t)0x10000000)        /*!< Bit 2 */
N#define  USB_COUNT7_RX_1_NUM_BLOCK_1_3       ((uint32_t)0x20000000)        /*!< Bit 3 */
N#define  USB_COUNT7_RX_1_NUM_BLOCK_1_4       ((uint32_t)0x40000000)        /*!< Bit 4 */
N
N#define  USB_COUNT7_RX_1_BLSIZE_1            ((uint32_t)0x80000000)        /*!< BLock SIZE (high) */
N
N/******************************************************************************/
N/*                                                                            */
N/*                         Controller Area Network                            */
N/*                                                                            */
N/******************************************************************************/
N
N/*!< CAN control and status registers */
N/*******************  Bit definition for CAN_MCR register  ********************/
N#define  CAN_MCR_INRQ                        ((uint16_t)0x0001)            /*!< Initialization Request */
N#define  CAN_MCR_SLEEP                       ((uint16_t)0x0002)            /*!< Sleep Mode Request */
N#define  CAN_MCR_TXFP                        ((uint16_t)0x0004)            /*!< Transmit FIFO Priority */
N#define  CAN_MCR_RFLM                        ((uint16_t)0x0008)            /*!< Receive FIFO Locked Mode */
N#define  CAN_MCR_NART                        ((uint16_t)0x0010)            /*!< No Automatic Retransmission */
N#define  CAN_MCR_AWUM                        ((uint16_t)0x0020)            /*!< Automatic Wakeup Mode */
N#define  CAN_MCR_ABOM                        ((uint16_t)0x0040)            /*!< Automatic Bus-Off Management */
N#define  CAN_MCR_TTCM                        ((uint16_t)0x0080)            /*!< Time Triggered Communication Mode */
N#define  CAN_MCR_RESET                       ((uint16_t)0x8000)            /*!< CAN software master reset */
N
N/*******************  Bit definition for CAN_MSR register  ********************/
N#define  CAN_MSR_INAK                        ((uint16_t)0x0001)            /*!< Initialization Acknowledge */
N#define  CAN_MSR_SLAK                        ((uint16_t)0x0002)            /*!< Sleep Acknowledge */
N#define  CAN_MSR_ERRI                        ((uint16_t)0x0004)            /*!< Error Interrupt */
N#define  CAN_MSR_WKUI                        ((uint16_t)0x0008)            /*!< Wakeup Interrupt */
N#define  CAN_MSR_SLAKI                       ((uint16_t)0x0010)            /*!< Sleep Acknowledge Interrupt */
N#define  CAN_MSR_TXM                         ((uint16_t)0x0100)            /*!< Transmit Mode */
N#define  CAN_MSR_RXM                         ((uint16_t)0x0200)            /*!< Receive Mode */
N#define  CAN_MSR_SAMP                        ((uint16_t)0x0400)            /*!< Last Sample Point */
N#define  CAN_MSR_RX                          ((uint16_t)0x0800)            /*!< CAN Rx Signal */
N
N/*******************  Bit definition for CAN_TSR register  ********************/
N#define  CAN_TSR_RQCP0                       ((uint32_t)0x00000001)        /*!< Request Completed Mailbox0 */
N#define  CAN_TSR_TXOK0                       ((uint32_t)0x00000002)        /*!< Transmission OK of Mailbox0 */
N#define  CAN_TSR_ALST0                       ((uint32_t)0x00000004)        /*!< Arbitration Lost for Mailbox0 */
N#define  CAN_TSR_TERR0                       ((uint32_t)0x00000008)        /*!< Transmission Error of Mailbox0 */
N#define  CAN_TSR_ABRQ0                       ((uint32_t)0x00000080)        /*!< Abort Request for Mailbox0 */
N#define  CAN_TSR_RQCP1                       ((uint32_t)0x00000100)        /*!< Request Completed Mailbox1 */
N#define  CAN_TSR_TXOK1                       ((uint32_t)0x00000200)        /*!< Transmission OK of Mailbox1 */
N#define  CAN_TSR_ALST1                       ((uint32_t)0x00000400)        /*!< Arbitration Lost for Mailbox1 */
N#define  CAN_TSR_TERR1                       ((uint32_t)0x00000800)        /*!< Transmission Error of Mailbox1 */
N#define  CAN_TSR_ABRQ1                       ((uint32_t)0x00008000)        /*!< Abort Request for Mailbox 1 */
N#define  CAN_TSR_RQCP2                       ((uint32_t)0x00010000)        /*!< Request Completed Mailbox2 */
N#define  CAN_TSR_TXOK2                       ((uint32_t)0x00020000)        /*!< Transmission OK of Mailbox 2 */
N#define  CAN_TSR_ALST2                       ((uint32_t)0x00040000)        /*!< Arbitration Lost for mailbox 2 */
N#define  CAN_TSR_TERR2                       ((uint32_t)0x00080000)        /*!< Transmission Error of Mailbox 2 */
N#define  CAN_TSR_ABRQ2                       ((uint32_t)0x00800000)        /*!< Abort Request for Mailbox 2 */
N#define  CAN_TSR_CODE                        ((uint32_t)0x03000000)        /*!< Mailbox Code */
N
N#define  CAN_TSR_TME                         ((uint32_t)0x1C000000)        /*!< TME[2:0] bits */
N#define  CAN_TSR_TME0                        ((uint32_t)0x04000000)        /*!< Transmit Mailbox 0 Empty */
N#define  CAN_TSR_TME1                        ((uint32_t)0x08000000)        /*!< Transmit Mailbox 1 Empty */
N#define  CAN_TSR_TME2                        ((uint32_t)0x10000000)        /*!< Transmit Mailbox 2 Empty */
N
N#define  CAN_TSR_LOW                         ((uint32_t)0xE0000000)        /*!< LOW[2:0] bits */
N#define  CAN_TSR_LOW0                        ((uint32_t)0x20000000)        /*!< Lowest Priority Flag for Mailbox 0 */
N#define  CAN_TSR_LOW1                        ((uint32_t)0x40000000)        /*!< Lowest Priority Flag for Mailbox 1 */
N#define  CAN_TSR_LOW2                        ((uint32_t)0x80000000)        /*!< Lowest Priority Flag for Mailbox 2 */
N
N/*******************  Bit definition for CAN_RF0R register  *******************/
N#define  CAN_RF0R_FMP0                       ((uint8_t)0x03)               /*!< FIFO 0 Message Pending */
N#define  CAN_RF0R_FULL0                      ((uint8_t)0x08)               /*!< FIFO 0 Full */
N#define  CAN_RF0R_FOVR0                      ((uint8_t)0x10)               /*!< FIFO 0 Overrun */
N#define  CAN_RF0R_RFOM0                      ((uint8_t)0x20)               /*!< Release FIFO 0 Output Mailbox */
N
N/*******************  Bit definition for CAN_RF1R register  *******************/
N#define  CAN_RF1R_FMP1                       ((uint8_t)0x03)               /*!< FIFO 1 Message Pending */
N#define  CAN_RF1R_FULL1                      ((uint8_t)0x08)               /*!< FIFO 1 Full */
N#define  CAN_RF1R_FOVR1                      ((uint8_t)0x10)               /*!< FIFO 1 Overrun */
N#define  CAN_RF1R_RFOM1                      ((uint8_t)0x20)               /*!< Release FIFO 1 Output Mailbox */
N
N/********************  Bit definition for CAN_IER register  *******************/
N#define  CAN_IER_TMEIE                       ((uint32_t)0x00000001)        /*!< Transmit Mailbox Empty Interrupt Enable */
N#define  CAN_IER_FMPIE0                      ((uint32_t)0x00000002)        /*!< FIFO Message Pending Interrupt Enable */
N#define  CAN_IER_FFIE0                       ((uint32_t)0x00000004)        /*!< FIFO Full Interrupt Enable */
N#define  CAN_IER_FOVIE0                      ((uint32_t)0x00000008)        /*!< FIFO Overrun Interrupt Enable */
N#define  CAN_IER_FMPIE1                      ((uint32_t)0x00000010)        /*!< FIFO Message Pending Interrupt Enable */
N#define  CAN_IER_FFIE1                       ((uint32_t)0x00000020)        /*!< FIFO Full Interrupt Enable */
N#define  CAN_IER_FOVIE1                      ((uint32_t)0x00000040)        /*!< FIFO Overrun Interrupt Enable */
N#define  CAN_IER_EWGIE                       ((uint32_t)0x00000100)        /*!< Error Warning Interrupt Enable */
N#define  CAN_IER_EPVIE                       ((uint32_t)0x00000200)        /*!< Error Passive Interrupt Enable */
N#define  CAN_IER_BOFIE                       ((uint32_t)0x00000400)        /*!< Bus-Off Interrupt Enable */
N#define  CAN_IER_LECIE                       ((uint32_t)0x00000800)        /*!< Last Error Code Interrupt Enable */
N#define  CAN_IER_ERRIE                       ((uint32_t)0x00008000)        /*!< Error Interrupt Enable */
N#define  CAN_IER_WKUIE                       ((uint32_t)0x00010000)        /*!< Wakeup Interrupt Enable */
N#define  CAN_IER_SLKIE                       ((uint32_t)0x00020000)        /*!< Sleep Interrupt Enable */
N
N/********************  Bit definition for CAN_ESR register  *******************/
N#define  CAN_ESR_EWGF                        ((uint32_t)0x00000001)        /*!< Error Warning Flag */
N#define  CAN_ESR_EPVF                        ((uint32_t)0x00000002)        /*!< Error Passive Flag */
N#define  CAN_ESR_BOFF                        ((uint32_t)0x00000004)        /*!< Bus-Off Flag */
N
N#define  CAN_ESR_LEC                         ((uint32_t)0x00000070)        /*!< LEC[2:0] bits (Last Error Code) */
N#define  CAN_ESR_LEC_0                       ((uint32_t)0x00000010)        /*!< Bit 0 */
N#define  CAN_ESR_LEC_1                       ((uint32_t)0x00000020)        /*!< Bit 1 */
N#define  CAN_ESR_LEC_2                       ((uint32_t)0x00000040)        /*!< Bit 2 */
N
N#define  CAN_ESR_TEC                         ((uint32_t)0x00FF0000)        /*!< Least significant byte of the 9-bit Transmit Error Counter */
N#define  CAN_ESR_REC                         ((uint32_t)0xFF000000)        /*!< Receive Error Counter */
N
N/*******************  Bit definition for CAN_BTR register  ********************/
N#define  CAN_BTR_BRP                         ((uint32_t)0x000003FF)        /*!< Baud Rate Prescaler */
N#define  CAN_BTR_TS1                         ((uint32_t)0x000F0000)        /*!< Time Segment 1 */
N#define  CAN_BTR_TS2                         ((uint32_t)0x00700000)        /*!< Time Segment 2 */
N#define  CAN_BTR_SJW                         ((uint32_t)0x03000000)        /*!< Resynchronization Jump Width */
N#define  CAN_BTR_LBKM                        ((uint32_t)0x40000000)        /*!< Loop Back Mode (Debug) */
N#define  CAN_BTR_SILM                        ((uint32_t)0x80000000)        /*!< Silent Mode */
N
N/*!< Mailbox registers */
N/******************  Bit definition for CAN_TI0R register  ********************/
N#define  CAN_TI0R_TXRQ                       ((uint32_t)0x00000001)        /*!< Transmit Mailbox Request */
N#define  CAN_TI0R_RTR                        ((uint32_t)0x00000002)        /*!< Remote Transmission Request */
N#define  CAN_TI0R_IDE                        ((uint32_t)0x00000004)        /*!< Identifier Extension */
N#define  CAN_TI0R_EXID                       ((uint32_t)0x001FFFF8)        /*!< Extended Identifier */
N#define  CAN_TI0R_STID                       ((uint32_t)0xFFE00000)        /*!< Standard Identifier or Extended Identifier */
N
N/******************  Bit definition for CAN_TDT0R register  *******************/
N#define  CAN_TDT0R_DLC                       ((uint32_t)0x0000000F)        /*!< Data Length Code */
N#define  CAN_TDT0R_TGT                       ((uint32_t)0x00000100)        /*!< Transmit Global Time */
N#define  CAN_TDT0R_TIME                      ((uint32_t)0xFFFF0000)        /*!< Message Time Stamp */
N
N/******************  Bit definition for CAN_TDL0R register  *******************/
N#define  CAN_TDL0R_DATA0                     ((uint32_t)0x000000FF)        /*!< Data byte 0 */
N#define  CAN_TDL0R_DATA1                     ((uint32_t)0x0000FF00)        /*!< Data byte 1 */
N#define  CAN_TDL0R_DATA2                     ((uint32_t)0x00FF0000)        /*!< Data byte 2 */
N#define  CAN_TDL0R_DATA3                     ((uint32_t)0xFF000000)        /*!< Data byte 3 */
N
N/******************  Bit definition for CAN_TDH0R register  *******************/
N#define  CAN_TDH0R_DATA4                     ((uint32_t)0x000000FF)        /*!< Data byte 4 */
N#define  CAN_TDH0R_DATA5                     ((uint32_t)0x0000FF00)        /*!< Data byte 5 */
N#define  CAN_TDH0R_DATA6                     ((uint32_t)0x00FF0000)        /*!< Data byte 6 */
N#define  CAN_TDH0R_DATA7                     ((uint32_t)0xFF000000)        /*!< Data byte 7 */
N
N/*******************  Bit definition for CAN_TI1R register  *******************/
N#define  CAN_TI1R_TXRQ                       ((uint32_t)0x00000001)        /*!< Transmit Mailbox Request */
N#define  CAN_TI1R_RTR                        ((uint32_t)0x00000002)        /*!< Remote Transmission Request */
N#define  CAN_TI1R_IDE                        ((uint32_t)0x00000004)        /*!< Identifier Extension */
N#define  CAN_TI1R_EXID                       ((uint32_t)0x001FFFF8)        /*!< Extended Identifier */
N#define  CAN_TI1R_STID                       ((uint32_t)0xFFE00000)        /*!< Standard Identifier or Extended Identifier */
N
N/*******************  Bit definition for CAN_TDT1R register  ******************/
N#define  CAN_TDT1R_DLC                       ((uint32_t)0x0000000F)        /*!< Data Length Code */
N#define  CAN_TDT1R_TGT                       ((uint32_t)0x00000100)        /*!< Transmit Global Time */
N#define  CAN_TDT1R_TIME                      ((uint32_t)0xFFFF0000)        /*!< Message Time Stamp */
N
N/*******************  Bit definition for CAN_TDL1R register  ******************/
N#define  CAN_TDL1R_DATA0                     ((uint32_t)0x000000FF)        /*!< Data byte 0 */
N#define  CAN_TDL1R_DATA1                     ((uint32_t)0x0000FF00)        /*!< Data byte 1 */
N#define  CAN_TDL1R_DATA2                     ((uint32_t)0x00FF0000)        /*!< Data byte 2 */
N#define  CAN_TDL1R_DATA3                     ((uint32_t)0xFF000000)        /*!< Data byte 3 */
N
N/*******************  Bit definition for CAN_TDH1R register  ******************/
N#define  CAN_TDH1R_DATA4                     ((uint32_t)0x000000FF)        /*!< Data byte 4 */
N#define  CAN_TDH1R_DATA5                     ((uint32_t)0x0000FF00)        /*!< Data byte 5 */
N#define  CAN_TDH1R_DATA6                     ((uint32_t)0x00FF0000)        /*!< Data byte 6 */
N#define  CAN_TDH1R_DATA7                     ((uint32_t)0xFF000000)        /*!< Data byte 7 */
N
N/*******************  Bit definition for CAN_TI2R register  *******************/
N#define  CAN_TI2R_TXRQ                       ((uint32_t)0x00000001)        /*!< Transmit Mailbox Request */
N#define  CAN_TI2R_RTR                        ((uint32_t)0x00000002)        /*!< Remote Transmission Request */
N#define  CAN_TI2R_IDE                        ((uint32_t)0x00000004)        /*!< Identifier Extension */
N#define  CAN_TI2R_EXID                       ((uint32_t)0x001FFFF8)        /*!< Extended identifier */
N#define  CAN_TI2R_STID                       ((uint32_t)0xFFE00000)        /*!< Standard Identifier or Extended Identifier */
N
N/*******************  Bit definition for CAN_TDT2R register  ******************/  
N#define  CAN_TDT2R_DLC                       ((uint32_t)0x0000000F)        /*!< Data Length Code */
N#define  CAN_TDT2R_TGT                       ((uint32_t)0x00000100)        /*!< Transmit Global Time */
N#define  CAN_TDT2R_TIME                      ((uint32_t)0xFFFF0000)        /*!< Message Time Stamp */
N
N/*******************  Bit definition for CAN_TDL2R register  ******************/
N#define  CAN_TDL2R_DATA0                     ((uint32_t)0x000000FF)        /*!< Data byte 0 */
N#define  CAN_TDL2R_DATA1                     ((uint32_t)0x0000FF00)        /*!< Data byte 1 */
N#define  CAN_TDL2R_DATA2                     ((uint32_t)0x00FF0000)        /*!< Data byte 2 */
N#define  CAN_TDL2R_DATA3                     ((uint32_t)0xFF000000)        /*!< Data byte 3 */
N
N/*******************  Bit definition for CAN_TDH2R register  ******************/
N#define  CAN_TDH2R_DATA4                     ((uint32_t)0x000000FF)        /*!< Data byte 4 */
N#define  CAN_TDH2R_DATA5                     ((uint32_t)0x0000FF00)        /*!< Data byte 5 */
N#define  CAN_TDH2R_DATA6                     ((uint32_t)0x00FF0000)        /*!< Data byte 6 */
N#define  CAN_TDH2R_DATA7                     ((uint32_t)0xFF000000)        /*!< Data byte 7 */
N
N/*******************  Bit definition for CAN_RI0R register  *******************/
N#define  CAN_RI0R_RTR                        ((uint32_t)0x00000002)        /*!< Remote Transmission Request */
N#define  CAN_RI0R_IDE                        ((uint32_t)0x00000004)        /*!< Identifier Extension */
N#define  CAN_RI0R_EXID                       ((uint32_t)0x001FFFF8)        /*!< Extended Identifier */
N#define  CAN_RI0R_STID                       ((uint32_t)0xFFE00000)        /*!< Standard Identifier or Extended Identifier */
N
N/*******************  Bit definition for CAN_RDT0R register  ******************/
N#define  CAN_RDT0R_DLC                       ((uint32_t)0x0000000F)        /*!< Data Length Code */
N#define  CAN_RDT0R_FMI                       ((uint32_t)0x0000FF00)        /*!< Filter Match Index */
N#define  CAN_RDT0R_TIME                      ((uint32_t)0xFFFF0000)        /*!< Message Time Stamp */
N
N/*******************  Bit definition for CAN_RDL0R register  ******************/
N#define  CAN_RDL0R_DATA0                     ((uint32_t)0x000000FF)        /*!< Data byte 0 */
N#define  CAN_RDL0R_DATA1                     ((uint32_t)0x0000FF00)        /*!< Data byte 1 */
N#define  CAN_RDL0R_DATA2                     ((uint32_t)0x00FF0000)        /*!< Data byte 2 */
N#define  CAN_RDL0R_DATA3                     ((uint32_t)0xFF000000)        /*!< Data byte 3 */
N
N/*******************  Bit definition for CAN_RDH0R register  ******************/
N#define  CAN_RDH0R_DATA4                     ((uint32_t)0x000000FF)        /*!< Data byte 4 */
N#define  CAN_RDH0R_DATA5                     ((uint32_t)0x0000FF00)        /*!< Data byte 5 */
N#define  CAN_RDH0R_DATA6                     ((uint32_t)0x00FF0000)        /*!< Data byte 6 */
N#define  CAN_RDH0R_DATA7                     ((uint32_t)0xFF000000)        /*!< Data byte 7 */
N
N/*******************  Bit definition for CAN_RI1R register  *******************/
N#define  CAN_RI1R_RTR                        ((uint32_t)0x00000002)        /*!< Remote Transmission Request */
N#define  CAN_RI1R_IDE                        ((uint32_t)0x00000004)        /*!< Identifier Extension */
N#define  CAN_RI1R_EXID                       ((uint32_t)0x001FFFF8)        /*!< Extended identifier */
N#define  CAN_RI1R_STID                       ((uint32_t)0xFFE00000)        /*!< Standard Identifier or Extended Identifier */
N
N/*******************  Bit definition for CAN_RDT1R register  ******************/
N#define  CAN_RDT1R_DLC                       ((uint32_t)0x0000000F)        /*!< Data Length Code */
N#define  CAN_RDT1R_FMI                       ((uint32_t)0x0000FF00)        /*!< Filter Match Index */
N#define  CAN_RDT1R_TIME                      ((uint32_t)0xFFFF0000)        /*!< Message Time Stamp */
N
N/*******************  Bit definition for CAN_RDL1R register  ******************/
N#define  CAN_RDL1R_DATA0                     ((uint32_t)0x000000FF)        /*!< Data byte 0 */
N#define  CAN_RDL1R_DATA1                     ((uint32_t)0x0000FF00)        /*!< Data byte 1 */
N#define  CAN_RDL1R_DATA2                     ((uint32_t)0x00FF0000)        /*!< Data byte 2 */
N#define  CAN_RDL1R_DATA3                     ((uint32_t)0xFF000000)        /*!< Data byte 3 */
N
N/*******************  Bit definition for CAN_RDH1R register  ******************/
N#define  CAN_RDH1R_DATA4                     ((uint32_t)0x000000FF)        /*!< Data byte 4 */
N#define  CAN_RDH1R_DATA5                     ((uint32_t)0x0000FF00)        /*!< Data byte 5 */
N#define  CAN_RDH1R_DATA6                     ((uint32_t)0x00FF0000)        /*!< Data byte 6 */
N#define  CAN_RDH1R_DATA7                     ((uint32_t)0xFF000000)        /*!< Data byte 7 */
N
N/*!< CAN filter registers */
N/*******************  Bit definition for CAN_FMR register  ********************/
N#define  CAN_FMR_FINIT                       ((uint8_t)0x01)               /*!< Filter Init Mode */
N
N/*******************  Bit definition for CAN_FM1R register  *******************/
N#define  CAN_FM1R_FBM                        ((uint16_t)0x3FFF)            /*!< Filter Mode */
N#define  CAN_FM1R_FBM0                       ((uint16_t)0x0001)            /*!< Filter Init Mode bit 0 */
N#define  CAN_FM1R_FBM1                       ((uint16_t)0x0002)            /*!< Filter Init Mode bit 1 */
N#define  CAN_FM1R_FBM2                       ((uint16_t)0x0004)            /*!< Filter Init Mode bit 2 */
N#define  CAN_FM1R_FBM3                       ((uint16_t)0x0008)            /*!< Filter Init Mode bit 3 */
N#define  CAN_FM1R_FBM4                       ((uint16_t)0x0010)            /*!< Filter Init Mode bit 4 */
N#define  CAN_FM1R_FBM5                       ((uint16_t)0x0020)            /*!< Filter Init Mode bit 5 */
N#define  CAN_FM1R_FBM6                       ((uint16_t)0x0040)            /*!< Filter Init Mode bit 6 */
N#define  CAN_FM1R_FBM7                       ((uint16_t)0x0080)            /*!< Filter Init Mode bit 7 */
N#define  CAN_FM1R_FBM8                       ((uint16_t)0x0100)            /*!< Filter Init Mode bit 8 */
N#define  CAN_FM1R_FBM9                       ((uint16_t)0x0200)            /*!< Filter Init Mode bit 9 */
N#define  CAN_FM1R_FBM10                      ((uint16_t)0x0400)            /*!< Filter Init Mode bit 10 */
N#define  CAN_FM1R_FBM11                      ((uint16_t)0x0800)            /*!< Filter Init Mode bit 11 */
N#define  CAN_FM1R_FBM12                      ((uint16_t)0x1000)            /*!< Filter Init Mode bit 12 */
N#define  CAN_FM1R_FBM13                      ((uint16_t)0x2000)            /*!< Filter Init Mode bit 13 */
N
N/*******************  Bit definition for CAN_FS1R register  *******************/
N#define  CAN_FS1R_FSC                        ((uint16_t)0x3FFF)            /*!< Filter Scale Configuration */
N#define  CAN_FS1R_FSC0                       ((uint16_t)0x0001)            /*!< Filter Scale Configuration bit 0 */
N#define  CAN_FS1R_FSC1                       ((uint16_t)0x0002)            /*!< Filter Scale Configuration bit 1 */
N#define  CAN_FS1R_FSC2                       ((uint16_t)0x0004)            /*!< Filter Scale Configuration bit 2 */
N#define  CAN_FS1R_FSC3                       ((uint16_t)0x0008)            /*!< Filter Scale Configuration bit 3 */
N#define  CAN_FS1R_FSC4                       ((uint16_t)0x0010)            /*!< Filter Scale Configuration bit 4 */
N#define  CAN_FS1R_FSC5                       ((uint16_t)0x0020)            /*!< Filter Scale Configuration bit 5 */
N#define  CAN_FS1R_FSC6                       ((uint16_t)0x0040)            /*!< Filter Scale Configuration bit 6 */
N#define  CAN_FS1R_FSC7                       ((uint16_t)0x0080)            /*!< Filter Scale Configuration bit 7 */
N#define  CAN_FS1R_FSC8                       ((uint16_t)0x0100)            /*!< Filter Scale Configuration bit 8 */
N#define  CAN_FS1R_FSC9                       ((uint16_t)0x0200)            /*!< Filter Scale Configuration bit 9 */
N#define  CAN_FS1R_FSC10                      ((uint16_t)0x0400)            /*!< Filter Scale Configuration bit 10 */
N#define  CAN_FS1R_FSC11                      ((uint16_t)0x0800)            /*!< Filter Scale Configuration bit 11 */
N#define  CAN_FS1R_FSC12                      ((uint16_t)0x1000)            /*!< Filter Scale Configuration bit 12 */
N#define  CAN_FS1R_FSC13                      ((uint16_t)0x2000)            /*!< Filter Scale Configuration bit 13 */
N
N/******************  Bit definition for CAN_FFA1R register  *******************/
N#define  CAN_FFA1R_FFA                       ((uint16_t)0x3FFF)            /*!< Filter FIFO Assignment */
N#define  CAN_FFA1R_FFA0                      ((uint16_t)0x0001)            /*!< Filter FIFO Assignment for Filter 0 */
N#define  CAN_FFA1R_FFA1                      ((uint16_t)0x0002)            /*!< Filter FIFO Assignment for Filter 1 */
N#define  CAN_FFA1R_FFA2                      ((uint16_t)0x0004)            /*!< Filter FIFO Assignment for Filter 2 */
N#define  CAN_FFA1R_FFA3                      ((uint16_t)0x0008)            /*!< Filter FIFO Assignment for Filter 3 */
N#define  CAN_FFA1R_FFA4                      ((uint16_t)0x0010)            /*!< Filter FIFO Assignment for Filter 4 */
N#define  CAN_FFA1R_FFA5                      ((uint16_t)0x0020)            /*!< Filter FIFO Assignment for Filter 5 */
N#define  CAN_FFA1R_FFA6                      ((uint16_t)0x0040)            /*!< Filter FIFO Assignment for Filter 6 */
N#define  CAN_FFA1R_FFA7                      ((uint16_t)0x0080)            /*!< Filter FIFO Assignment for Filter 7 */
N#define  CAN_FFA1R_FFA8                      ((uint16_t)0x0100)            /*!< Filter FIFO Assignment for Filter 8 */
N#define  CAN_FFA1R_FFA9                      ((uint16_t)0x0200)            /*!< Filter FIFO Assignment for Filter 9 */
N#define  CAN_FFA1R_FFA10                     ((uint16_t)0x0400)            /*!< Filter FIFO Assignment for Filter 10 */
N#define  CAN_FFA1R_FFA11                     ((uint16_t)0x0800)            /*!< Filter FIFO Assignment for Filter 11 */
N#define  CAN_FFA1R_FFA12                     ((uint16_t)0x1000)            /*!< Filter FIFO Assignment for Filter 12 */
N#define  CAN_FFA1R_FFA13                     ((uint16_t)0x2000)            /*!< Filter FIFO Assignment for Filter 13 */
N
N/*******************  Bit definition for CAN_FA1R register  *******************/
N#define  CAN_FA1R_FACT                       ((uint16_t)0x3FFF)            /*!< Filter Active */
N#define  CAN_FA1R_FACT0                      ((uint16_t)0x0001)            /*!< Filter 0 Active */
N#define  CAN_FA1R_FACT1                      ((uint16_t)0x0002)            /*!< Filter 1 Active */
N#define  CAN_FA1R_FACT2                      ((uint16_t)0x0004)            /*!< Filter 2 Active */
N#define  CAN_FA1R_FACT3                      ((uint16_t)0x0008)            /*!< Filter 3 Active */
N#define  CAN_FA1R_FACT4                      ((uint16_t)0x0010)            /*!< Filter 4 Active */
N#define  CAN_FA1R_FACT5                      ((uint16_t)0x0020)            /*!< Filter 5 Active */
N#define  CAN_FA1R_FACT6                      ((uint16_t)0x0040)            /*!< Filter 6 Active */
N#define  CAN_FA1R_FACT7                      ((uint16_t)0x0080)            /*!< Filter 7 Active */
N#define  CAN_FA1R_FACT8                      ((uint16_t)0x0100)            /*!< Filter 8 Active */
N#define  CAN_FA1R_FACT9                      ((uint16_t)0x0200)            /*!< Filter 9 Active */
N#define  CAN_FA1R_FACT10                     ((uint16_t)0x0400)            /*!< Filter 10 Active */
N#define  CAN_FA1R_FACT11                     ((uint16_t)0x0800)            /*!< Filter 11 Active */
N#define  CAN_FA1R_FACT12                     ((uint16_t)0x1000)            /*!< Filter 12 Active */
N#define  CAN_FA1R_FACT13                     ((uint16_t)0x2000)            /*!< Filter 13 Active */
N
N/*******************  Bit definition for CAN_F0R1 register  *******************/
N#define  CAN_F0R1_FB0                        ((uint32_t)0x00000001)        /*!< Filter bit 0 */
N#define  CAN_F0R1_FB1                        ((uint32_t)0x00000002)        /*!< Filter bit 1 */
N#define  CAN_F0R1_FB2                        ((uint32_t)0x00000004)        /*!< Filter bit 2 */
N#define  CAN_F0R1_FB3                        ((uint32_t)0x00000008)        /*!< Filter bit 3 */
N#define  CAN_F0R1_FB4                        ((uint32_t)0x00000010)        /*!< Filter bit 4 */
N#define  CAN_F0R1_FB5                        ((uint32_t)0x00000020)        /*!< Filter bit 5 */
N#define  CAN_F0R1_FB6                        ((uint32_t)0x00000040)        /*!< Filter bit 6 */
N#define  CAN_F0R1_FB7                        ((uint32_t)0x00000080)        /*!< Filter bit 7 */
N#define  CAN_F0R1_FB8                        ((uint32_t)0x00000100)        /*!< Filter bit 8 */
N#define  CAN_F0R1_FB9                        ((uint32_t)0x00000200)        /*!< Filter bit 9 */
N#define  CAN_F0R1_FB10                       ((uint32_t)0x00000400)        /*!< Filter bit 10 */
N#define  CAN_F0R1_FB11                       ((uint32_t)0x00000800)        /*!< Filter bit 11 */
N#define  CAN_F0R1_FB12                       ((uint32_t)0x00001000)        /*!< Filter bit 12 */
N#define  CAN_F0R1_FB13                       ((uint32_t)0x00002000)        /*!< Filter bit 13 */
N#define  CAN_F0R1_FB14                       ((uint32_t)0x00004000)        /*!< Filter bit 14 */
N#define  CAN_F0R1_FB15                       ((uint32_t)0x00008000)        /*!< Filter bit 15 */
N#define  CAN_F0R1_FB16                       ((uint32_t)0x00010000)        /*!< Filter bit 16 */
N#define  CAN_F0R1_FB17                       ((uint32_t)0x00020000)        /*!< Filter bit 17 */
N#define  CAN_F0R1_FB18                       ((uint32_t)0x00040000)        /*!< Filter bit 18 */
N#define  CAN_F0R1_FB19                       ((uint32_t)0x00080000)        /*!< Filter bit 19 */
N#define  CAN_F0R1_FB20                       ((uint32_t)0x00100000)        /*!< Filter bit 20 */
N#define  CAN_F0R1_FB21                       ((uint32_t)0x00200000)        /*!< Filter bit 21 */
N#define  CAN_F0R1_FB22                       ((uint32_t)0x00400000)        /*!< Filter bit 22 */
N#define  CAN_F0R1_FB23                       ((uint32_t)0x00800000)        /*!< Filter bit 23 */
N#define  CAN_F0R1_FB24                       ((uint32_t)0x01000000)        /*!< Filter bit 24 */
N#define  CAN_F0R1_FB25                       ((uint32_t)0x02000000)        /*!< Filter bit 25 */
N#define  CAN_F0R1_FB26                       ((uint32_t)0x04000000)        /*!< Filter bit 26 */
N#define  CAN_F0R1_FB27                       ((uint32_t)0x08000000)        /*!< Filter bit 27 */
N#define  CAN_F0R1_FB28                       ((uint32_t)0x10000000)        /*!< Filter bit 28 */
N#define  CAN_F0R1_FB29                       ((uint32_t)0x20000000)        /*!< Filter bit 29 */
N#define  CAN_F0R1_FB30                       ((uint32_t)0x40000000)        /*!< Filter bit 30 */
N#define  CAN_F0R1_FB31                       ((uint32_t)0x80000000)        /*!< Filter bit 31 */
N
N/*******************  Bit definition for CAN_F1R1 register  *******************/
N#define  CAN_F1R1_FB0                        ((uint32_t)0x00000001)        /*!< Filter bit 0 */
N#define  CAN_F1R1_FB1                        ((uint32_t)0x00000002)        /*!< Filter bit 1 */
N#define  CAN_F1R1_FB2                        ((uint32_t)0x00000004)        /*!< Filter bit 2 */
N#define  CAN_F1R1_FB3                        ((uint32_t)0x00000008)        /*!< Filter bit 3 */
N#define  CAN_F1R1_FB4                        ((uint32_t)0x00000010)        /*!< Filter bit 4 */
N#define  CAN_F1R1_FB5                        ((uint32_t)0x00000020)        /*!< Filter bit 5 */
N#define  CAN_F1R1_FB6                        ((uint32_t)0x00000040)        /*!< Filter bit 6 */
N#define  CAN_F1R1_FB7                        ((uint32_t)0x00000080)        /*!< Filter bit 7 */
N#define  CAN_F1R1_FB8                        ((uint32_t)0x00000100)        /*!< Filter bit 8 */
N#define  CAN_F1R1_FB9                        ((uint32_t)0x00000200)        /*!< Filter bit 9 */
N#define  CAN_F1R1_FB10                       ((uint32_t)0x00000400)        /*!< Filter bit 10 */
N#define  CAN_F1R1_FB11                       ((uint32_t)0x00000800)        /*!< Filter bit 11 */
N#define  CAN_F1R1_FB12                       ((uint32_t)0x00001000)        /*!< Filter bit 12 */
N#define  CAN_F1R1_FB13                       ((uint32_t)0x00002000)        /*!< Filter bit 13 */
N#define  CAN_F1R1_FB14                       ((uint32_t)0x00004000)        /*!< Filter bit 14 */
N#define  CAN_F1R1_FB15                       ((uint32_t)0x00008000)        /*!< Filter bit 15 */
N#define  CAN_F1R1_FB16                       ((uint32_t)0x00010000)        /*!< Filter bit 16 */
N#define  CAN_F1R1_FB17                       ((uint32_t)0x00020000)        /*!< Filter bit 17 */
N#define  CAN_F1R1_FB18                       ((uint32_t)0x00040000)        /*!< Filter bit 18 */
N#define  CAN_F1R1_FB19                       ((uint32_t)0x00080000)        /*!< Filter bit 19 */
N#define  CAN_F1R1_FB20                       ((uint32_t)0x00100000)        /*!< Filter bit 20 */
N#define  CAN_F1R1_FB21                       ((uint32_t)0x00200000)        /*!< Filter bit 21 */
N#define  CAN_F1R1_FB22                       ((uint32_t)0x00400000)        /*!< Filter bit 22 */
N#define  CAN_F1R1_FB23                       ((uint32_t)0x00800000)        /*!< Filter bit 23 */
N#define  CAN_F1R1_FB24                       ((uint32_t)0x01000000)        /*!< Filter bit 24 */
N#define  CAN_F1R1_FB25                       ((uint32_t)0x02000000)        /*!< Filter bit 25 */
N#define  CAN_F1R1_FB26                       ((uint32_t)0x04000000)        /*!< Filter bit 26 */
N#define  CAN_F1R1_FB27                       ((uint32_t)0x08000000)        /*!< Filter bit 27 */
N#define  CAN_F1R1_FB28                       ((uint32_t)0x10000000)        /*!< Filter bit 28 */
N#define  CAN_F1R1_FB29                       ((uint32_t)0x20000000)        /*!< Filter bit 29 */
N#define  CAN_F1R1_FB30                       ((uint32_t)0x40000000)        /*!< Filter bit 30 */
N#define  CAN_F1R1_FB31                       ((uint32_t)0x80000000)        /*!< Filter bit 31 */
N
N/*******************  Bit definition for CAN_F2R1 register  *******************/
N#define  CAN_F2R1_FB0                        ((uint32_t)0x00000001)        /*!< Filter bit 0 */
N#define  CAN_F2R1_FB1                        ((uint32_t)0x00000002)        /*!< Filter bit 1 */
N#define  CAN_F2R1_FB2                        ((uint32_t)0x00000004)        /*!< Filter bit 2 */
N#define  CAN_F2R1_FB3                        ((uint32_t)0x00000008)        /*!< Filter bit 3 */
N#define  CAN_F2R1_FB4                        ((uint32_t)0x00000010)        /*!< Filter bit 4 */
N#define  CAN_F2R1_FB5                        ((uint32_t)0x00000020)        /*!< Filter bit 5 */
N#define  CAN_F2R1_FB6                        ((uint32_t)0x00000040)        /*!< Filter bit 6 */
N#define  CAN_F2R1_FB7                        ((uint32_t)0x00000080)        /*!< Filter bit 7 */
N#define  CAN_F2R1_FB8                        ((uint32_t)0x00000100)        /*!< Filter bit 8 */
N#define  CAN_F2R1_FB9                        ((uint32_t)0x00000200)        /*!< Filter bit 9 */
N#define  CAN_F2R1_FB10                       ((uint32_t)0x00000400)        /*!< Filter bit 10 */
N#define  CAN_F2R1_FB11                       ((uint32_t)0x00000800)        /*!< Filter bit 11 */
N#define  CAN_F2R1_FB12                       ((uint32_t)0x00001000)        /*!< Filter bit 12 */
N#define  CAN_F2R1_FB13                       ((uint32_t)0x00002000)        /*!< Filter bit 13 */
N#define  CAN_F2R1_FB14                       ((uint32_t)0x00004000)        /*!< Filter bit 14 */
N#define  CAN_F2R1_FB15                       ((uint32_t)0x00008000)        /*!< Filter bit 15 */
N#define  CAN_F2R1_FB16                       ((uint32_t)0x00010000)        /*!< Filter bit 16 */
N#define  CAN_F2R1_FB17                       ((uint32_t)0x00020000)        /*!< Filter bit 17 */
N#define  CAN_F2R1_FB18                       ((uint32_t)0x00040000)        /*!< Filter bit 18 */
N#define  CAN_F2R1_FB19                       ((uint32_t)0x00080000)        /*!< Filter bit 19 */
N#define  CAN_F2R1_FB20                       ((uint32_t)0x00100000)        /*!< Filter bit 20 */
N#define  CAN_F2R1_FB21                       ((uint32_t)0x00200000)        /*!< Filter bit 21 */
N#define  CAN_F2R1_FB22                       ((uint32_t)0x00400000)        /*!< Filter bit 22 */
N#define  CAN_F2R1_FB23                       ((uint32_t)0x00800000)        /*!< Filter bit 23 */
N#define  CAN_F2R1_FB24                       ((uint32_t)0x01000000)        /*!< Filter bit 24 */
N#define  CAN_F2R1_FB25                       ((uint32_t)0x02000000)        /*!< Filter bit 25 */
N#define  CAN_F2R1_FB26                       ((uint32_t)0x04000000)        /*!< Filter bit 26 */
N#define  CAN_F2R1_FB27                       ((uint32_t)0x08000000)        /*!< Filter bit 27 */
N#define  CAN_F2R1_FB28                       ((uint32_t)0x10000000)        /*!< Filter bit 28 */
N#define  CAN_F2R1_FB29                       ((uint32_t)0x20000000)        /*!< Filter bit 29 */
N#define  CAN_F2R1_FB30                       ((uint32_t)0x40000000)        /*!< Filter bit 30 */
N#define  CAN_F2R1_FB31                       ((uint32_t)0x80000000)        /*!< Filter bit 31 */
N
N/*******************  Bit definition for CAN_F3R1 register  *******************/
N#define  CAN_F3R1_FB0                        ((uint32_t)0x00000001)        /*!< Filter bit 0 */
N#define  CAN_F3R1_FB1                        ((uint32_t)0x00000002)        /*!< Filter bit 1 */
N#define  CAN_F3R1_FB2                        ((uint32_t)0x00000004)        /*!< Filter bit 2 */
N#define  CAN_F3R1_FB3                        ((uint32_t)0x00000008)        /*!< Filter bit 3 */
N#define  CAN_F3R1_FB4                        ((uint32_t)0x00000010)        /*!< Filter bit 4 */
N#define  CAN_F3R1_FB5                        ((uint32_t)0x00000020)        /*!< Filter bit 5 */
N#define  CAN_F3R1_FB6                        ((uint32_t)0x00000040)        /*!< Filter bit 6 */
N#define  CAN_F3R1_FB7                        ((uint32_t)0x00000080)        /*!< Filter bit 7 */
N#define  CAN_F3R1_FB8                        ((uint32_t)0x00000100)        /*!< Filter bit 8 */
N#define  CAN_F3R1_FB9                        ((uint32_t)0x00000200)        /*!< Filter bit 9 */
N#define  CAN_F3R1_FB10                       ((uint32_t)0x00000400)        /*!< Filter bit 10 */
N#define  CAN_F3R1_FB11                       ((uint32_t)0x00000800)        /*!< Filter bit 11 */
N#define  CAN_F3R1_FB12                       ((uint32_t)0x00001000)        /*!< Filter bit 12 */
N#define  CAN_F3R1_FB13                       ((uint32_t)0x00002000)        /*!< Filter bit 13 */
N#define  CAN_F3R1_FB14                       ((uint32_t)0x00004000)        /*!< Filter bit 14 */
N#define  CAN_F3R1_FB15                       ((uint32_t)0x00008000)        /*!< Filter bit 15 */
N#define  CAN_F3R1_FB16                       ((uint32_t)0x00010000)        /*!< Filter bit 16 */
N#define  CAN_F3R1_FB17                       ((uint32_t)0x00020000)        /*!< Filter bit 17 */
N#define  CAN_F3R1_FB18                       ((uint32_t)0x00040000)        /*!< Filter bit 18 */
N#define  CAN_F3R1_FB19                       ((uint32_t)0x00080000)        /*!< Filter bit 19 */
N#define  CAN_F3R1_FB20                       ((uint32_t)0x00100000)        /*!< Filter bit 20 */
N#define  CAN_F3R1_FB21                       ((uint32_t)0x00200000)        /*!< Filter bit 21 */
N#define  CAN_F3R1_FB22                       ((uint32_t)0x00400000)        /*!< Filter bit 22 */
N#define  CAN_F3R1_FB23                       ((uint32_t)0x00800000)        /*!< Filter bit 23 */
N#define  CAN_F3R1_FB24                       ((uint32_t)0x01000000)        /*!< Filter bit 24 */
N#define  CAN_F3R1_FB25                       ((uint32_t)0x02000000)        /*!< Filter bit 25 */
N#define  CAN_F3R1_FB26                       ((uint32_t)0x04000000)        /*!< Filter bit 26 */
N#define  CAN_F3R1_FB27                       ((uint32_t)0x08000000)        /*!< Filter bit 27 */
N#define  CAN_F3R1_FB28                       ((uint32_t)0x10000000)        /*!< Filter bit 28 */
N#define  CAN_F3R1_FB29                       ((uint32_t)0x20000000)        /*!< Filter bit 29 */
N#define  CAN_F3R1_FB30                       ((uint32_t)0x40000000)        /*!< Filter bit 30 */
N#define  CAN_F3R1_FB31                       ((uint32_t)0x80000000)        /*!< Filter bit 31 */
N
N/*******************  Bit definition for CAN_F4R1 register  *******************/
N#define  CAN_F4R1_FB0                        ((uint32_t)0x00000001)        /*!< Filter bit 0 */
N#define  CAN_F4R1_FB1                        ((uint32_t)0x00000002)        /*!< Filter bit 1 */
N#define  CAN_F4R1_FB2                        ((uint32_t)0x00000004)        /*!< Filter bit 2 */
N#define  CAN_F4R1_FB3                        ((uint32_t)0x00000008)        /*!< Filter bit 3 */
N#define  CAN_F4R1_FB4                        ((uint32_t)0x00000010)        /*!< Filter bit 4 */
N#define  CAN_F4R1_FB5                        ((uint32_t)0x00000020)        /*!< Filter bit 5 */
N#define  CAN_F4R1_FB6                        ((uint32_t)0x00000040)        /*!< Filter bit 6 */
N#define  CAN_F4R1_FB7                        ((uint32_t)0x00000080)        /*!< Filter bit 7 */
N#define  CAN_F4R1_FB8                        ((uint32_t)0x00000100)        /*!< Filter bit 8 */
N#define  CAN_F4R1_FB9                        ((uint32_t)0x00000200)        /*!< Filter bit 9 */
N#define  CAN_F4R1_FB10                       ((uint32_t)0x00000400)        /*!< Filter bit 10 */
N#define  CAN_F4R1_FB11                       ((uint32_t)0x00000800)        /*!< Filter bit 11 */
N#define  CAN_F4R1_FB12                       ((uint32_t)0x00001000)        /*!< Filter bit 12 */
N#define  CAN_F4R1_FB13                       ((uint32_t)0x00002000)        /*!< Filter bit 13 */
N#define  CAN_F4R1_FB14                       ((uint32_t)0x00004000)        /*!< Filter bit 14 */
N#define  CAN_F4R1_FB15                       ((uint32_t)0x00008000)        /*!< Filter bit 15 */
N#define  CAN_F4R1_FB16                       ((uint32_t)0x00010000)        /*!< Filter bit 16 */
N#define  CAN_F4R1_FB17                       ((uint32_t)0x00020000)        /*!< Filter bit 17 */
N#define  CAN_F4R1_FB18                       ((uint32_t)0x00040000)        /*!< Filter bit 18 */
N#define  CAN_F4R1_FB19                       ((uint32_t)0x00080000)        /*!< Filter bit 19 */
N#define  CAN_F4R1_FB20                       ((uint32_t)0x00100000)        /*!< Filter bit 20 */
N#define  CAN_F4R1_FB21                       ((uint32_t)0x00200000)        /*!< Filter bit 21 */
N#define  CAN_F4R1_FB22                       ((uint32_t)0x00400000)        /*!< Filter bit 22 */
N#define  CAN_F4R1_FB23                       ((uint32_t)0x00800000)        /*!< Filter bit 23 */
N#define  CAN_F4R1_FB24                       ((uint32_t)0x01000000)        /*!< Filter bit 24 */
N#define  CAN_F4R1_FB25                       ((uint32_t)0x02000000)        /*!< Filter bit 25 */
N#define  CAN_F4R1_FB26                       ((uint32_t)0x04000000)        /*!< Filter bit 26 */
N#define  CAN_F4R1_FB27                       ((uint32_t)0x08000000)        /*!< Filter bit 27 */
N#define  CAN_F4R1_FB28                       ((uint32_t)0x10000000)        /*!< Filter bit 28 */
N#define  CAN_F4R1_FB29                       ((uint32_t)0x20000000)        /*!< Filter bit 29 */
N#define  CAN_F4R1_FB30                       ((uint32_t)0x40000000)        /*!< Filter bit 30 */
N#define  CAN_F4R1_FB31                       ((uint32_t)0x80000000)        /*!< Filter bit 31 */
N
N/*******************  Bit definition for CAN_F5R1 register  *******************/
N#define  CAN_F5R1_FB0                        ((uint32_t)0x00000001)        /*!< Filter bit 0 */
N#define  CAN_F5R1_FB1                        ((uint32_t)0x00000002)        /*!< Filter bit 1 */
N#define  CAN_F5R1_FB2                        ((uint32_t)0x00000004)        /*!< Filter bit 2 */
N#define  CAN_F5R1_FB3                        ((uint32_t)0x00000008)        /*!< Filter bit 3 */
N#define  CAN_F5R1_FB4                        ((uint32_t)0x00000010)        /*!< Filter bit 4 */
N#define  CAN_F5R1_FB5                        ((uint32_t)0x00000020)        /*!< Filter bit 5 */
N#define  CAN_F5R1_FB6                        ((uint32_t)0x00000040)        /*!< Filter bit 6 */
N#define  CAN_F5R1_FB7                        ((uint32_t)0x00000080)        /*!< Filter bit 7 */
N#define  CAN_F5R1_FB8                        ((uint32_t)0x00000100)        /*!< Filter bit 8 */
N#define  CAN_F5R1_FB9                        ((uint32_t)0x00000200)        /*!< Filter bit 9 */
N#define  CAN_F5R1_FB10                       ((uint32_t)0x00000400)        /*!< Filter bit 10 */
N#define  CAN_F5R1_FB11                       ((uint32_t)0x00000800)        /*!< Filter bit 11 */
N#define  CAN_F5R1_FB12                       ((uint32_t)0x00001000)        /*!< Filter bit 12 */
N#define  CAN_F5R1_FB13                       ((uint32_t)0x00002000)        /*!< Filter bit 13 */
N#define  CAN_F5R1_FB14                       ((uint32_t)0x00004000)        /*!< Filter bit 14 */
N#define  CAN_F5R1_FB15                       ((uint32_t)0x00008000)        /*!< Filter bit 15 */
N#define  CAN_F5R1_FB16                       ((uint32_t)0x00010000)        /*!< Filter bit 16 */
N#define  CAN_F5R1_FB17                       ((uint32_t)0x00020000)        /*!< Filter bit 17 */
N#define  CAN_F5R1_FB18                       ((uint32_t)0x00040000)        /*!< Filter bit 18 */
N#define  CAN_F5R1_FB19                       ((uint32_t)0x00080000)        /*!< Filter bit 19 */
N#define  CAN_F5R1_FB20                       ((uint32_t)0x00100000)        /*!< Filter bit 20 */
N#define  CAN_F5R1_FB21                       ((uint32_t)0x00200000)        /*!< Filter bit 21 */
N#define  CAN_F5R1_FB22                       ((uint32_t)0x00400000)        /*!< Filter bit 22 */
N#define  CAN_F5R1_FB23                       ((uint32_t)0x00800000)        /*!< Filter bit 23 */
N#define  CAN_F5R1_FB24                       ((uint32_t)0x01000000)        /*!< Filter bit 24 */
N#define  CAN_F5R1_FB25                       ((uint32_t)0x02000000)        /*!< Filter bit 25 */
N#define  CAN_F5R1_FB26                       ((uint32_t)0x04000000)        /*!< Filter bit 26 */
N#define  CAN_F5R1_FB27                       ((uint32_t)0x08000000)        /*!< Filter bit 27 */
N#define  CAN_F5R1_FB28                       ((uint32_t)0x10000000)        /*!< Filter bit 28 */
N#define  CAN_F5R1_FB29                       ((uint32_t)0x20000000)        /*!< Filter bit 29 */
N#define  CAN_F5R1_FB30                       ((uint32_t)0x40000000)        /*!< Filter bit 30 */
N#define  CAN_F5R1_FB31                       ((uint32_t)0x80000000)        /*!< Filter bit 31 */
N
N/*******************  Bit definition for CAN_F6R1 register  *******************/
N#define  CAN_F6R1_FB0                        ((uint32_t)0x00000001)        /*!< Filter bit 0 */
N#define  CAN_F6R1_FB1                        ((uint32_t)0x00000002)        /*!< Filter bit 1 */
N#define  CAN_F6R1_FB2                        ((uint32_t)0x00000004)        /*!< Filter bit 2 */
N#define  CAN_F6R1_FB3                        ((uint32_t)0x00000008)        /*!< Filter bit 3 */
N#define  CAN_F6R1_FB4                        ((uint32_t)0x00000010)        /*!< Filter bit 4 */
N#define  CAN_F6R1_FB5                        ((uint32_t)0x00000020)        /*!< Filter bit 5 */
N#define  CAN_F6R1_FB6                        ((uint32_t)0x00000040)        /*!< Filter bit 6 */
N#define  CAN_F6R1_FB7                        ((uint32_t)0x00000080)        /*!< Filter bit 7 */
N#define  CAN_F6R1_FB8                        ((uint32_t)0x00000100)        /*!< Filter bit 8 */
N#define  CAN_F6R1_FB9                        ((uint32_t)0x00000200)        /*!< Filter bit 9 */
N#define  CAN_F6R1_FB10                       ((uint32_t)0x00000400)        /*!< Filter bit 10 */
N#define  CAN_F6R1_FB11                       ((uint32_t)0x00000800)        /*!< Filter bit 11 */
N#define  CAN_F6R1_FB12                       ((uint32_t)0x00001000)        /*!< Filter bit 12 */
N#define  CAN_F6R1_FB13                       ((uint32_t)0x00002000)        /*!< Filter bit 13 */
N#define  CAN_F6R1_FB14                       ((uint32_t)0x00004000)        /*!< Filter bit 14 */
N#define  CAN_F6R1_FB15                       ((uint32_t)0x00008000)        /*!< Filter bit 15 */
N#define  CAN_F6R1_FB16                       ((uint32_t)0x00010000)        /*!< Filter bit 16 */
N#define  CAN_F6R1_FB17                       ((uint32_t)0x00020000)        /*!< Filter bit 17 */
N#define  CAN_F6R1_FB18                       ((uint32_t)0x00040000)        /*!< Filter bit 18 */
N#define  CAN_F6R1_FB19                       ((uint32_t)0x00080000)        /*!< Filter bit 19 */
N#define  CAN_F6R1_FB20                       ((uint32_t)0x00100000)        /*!< Filter bit 20 */
N#define  CAN_F6R1_FB21                       ((uint32_t)0x00200000)        /*!< Filter bit 21 */
N#define  CAN_F6R1_FB22                       ((uint32_t)0x00400000)        /*!< Filter bit 22 */
N#define  CAN_F6R1_FB23                       ((uint32_t)0x00800000)        /*!< Filter bit 23 */
N#define  CAN_F6R1_FB24                       ((uint32_t)0x01000000)        /*!< Filter bit 24 */
N#define  CAN_F6R1_FB25                       ((uint32_t)0x02000000)        /*!< Filter bit 25 */
N#define  CAN_F6R1_FB26                       ((uint32_t)0x04000000)        /*!< Filter bit 26 */
N#define  CAN_F6R1_FB27                       ((uint32_t)0x08000000)        /*!< Filter bit 27 */
N#define  CAN_F6R1_FB28                       ((uint32_t)0x10000000)        /*!< Filter bit 28 */
N#define  CAN_F6R1_FB29                       ((uint32_t)0x20000000)        /*!< Filter bit 29 */
N#define  CAN_F6R1_FB30                       ((uint32_t)0x40000000)        /*!< Filter bit 30 */
N#define  CAN_F6R1_FB31                       ((uint32_t)0x80000000)        /*!< Filter bit 31 */
N
N/*******************  Bit definition for CAN_F7R1 register  *******************/
N#define  CAN_F7R1_FB0                        ((uint32_t)0x00000001)        /*!< Filter bit 0 */
N#define  CAN_F7R1_FB1                        ((uint32_t)0x00000002)        /*!< Filter bit 1 */
N#define  CAN_F7R1_FB2                        ((uint32_t)0x00000004)        /*!< Filter bit 2 */
N#define  CAN_F7R1_FB3                        ((uint32_t)0x00000008)        /*!< Filter bit 3 */
N#define  CAN_F7R1_FB4                        ((uint32_t)0x00000010)        /*!< Filter bit 4 */
N#define  CAN_F7R1_FB5                        ((uint32_t)0x00000020)        /*!< Filter bit 5 */
N#define  CAN_F7R1_FB6                        ((uint32_t)0x00000040)        /*!< Filter bit 6 */
N#define  CAN_F7R1_FB7                        ((uint32_t)0x00000080)        /*!< Filter bit 7 */
N#define  CAN_F7R1_FB8                        ((uint32_t)0x00000100)        /*!< Filter bit 8 */
N#define  CAN_F7R1_FB9                        ((uint32_t)0x00000200)        /*!< Filter bit 9 */
N#define  CAN_F7R1_FB10                       ((uint32_t)0x00000400)        /*!< Filter bit 10 */
N#define  CAN_F7R1_FB11                       ((uint32_t)0x00000800)        /*!< Filter bit 11 */
N#define  CAN_F7R1_FB12                       ((uint32_t)0x00001000)        /*!< Filter bit 12 */
N#define  CAN_F7R1_FB13                       ((uint32_t)0x00002000)        /*!< Filter bit 13 */
N#define  CAN_F7R1_FB14                       ((uint32_t)0x00004000)        /*!< Filter bit 14 */
N#define  CAN_F7R1_FB15                       ((uint32_t)0x00008000)        /*!< Filter bit 15 */
N#define  CAN_F7R1_FB16                       ((uint32_t)0x00010000)        /*!< Filter bit 16 */
N#define  CAN_F7R1_FB17                       ((uint32_t)0x00020000)        /*!< Filter bit 17 */
N#define  CAN_F7R1_FB18                       ((uint32_t)0x00040000)        /*!< Filter bit 18 */
N#define  CAN_F7R1_FB19                       ((uint32_t)0x00080000)        /*!< Filter bit 19 */
N#define  CAN_F7R1_FB20                       ((uint32_t)0x00100000)        /*!< Filter bit 20 */
N#define  CAN_F7R1_FB21                       ((uint32_t)0x00200000)        /*!< Filter bit 21 */
N#define  CAN_F7R1_FB22                       ((uint32_t)0x00400000)        /*!< Filter bit 22 */
N#define  CAN_F7R1_FB23                       ((uint32_t)0x00800000)        /*!< Filter bit 23 */
N#define  CAN_F7R1_FB24                       ((uint32_t)0x01000000)        /*!< Filter bit 24 */
N#define  CAN_F7R1_FB25                       ((uint32_t)0x02000000)        /*!< Filter bit 25 */
N#define  CAN_F7R1_FB26                       ((uint32_t)0x04000000)        /*!< Filter bit 26 */
N#define  CAN_F7R1_FB27                       ((uint32_t)0x08000000)        /*!< Filter bit 27 */
N#define  CAN_F7R1_FB28                       ((uint32_t)0x10000000)        /*!< Filter bit 28 */
N#define  CAN_F7R1_FB29                       ((uint32_t)0x20000000)        /*!< Filter bit 29 */
N#define  CAN_F7R1_FB30                       ((uint32_t)0x40000000)        /*!< Filter bit 30 */
N#define  CAN_F7R1_FB31                       ((uint32_t)0x80000000)        /*!< Filter bit 31 */
N
N/*******************  Bit definition for CAN_F8R1 register  *******************/
N#define  CAN_F8R1_FB0                        ((uint32_t)0x00000001)        /*!< Filter bit 0 */
N#define  CAN_F8R1_FB1                        ((uint32_t)0x00000002)        /*!< Filter bit 1 */
N#define  CAN_F8R1_FB2                        ((uint32_t)0x00000004)        /*!< Filter bit 2 */
N#define  CAN_F8R1_FB3                        ((uint32_t)0x00000008)        /*!< Filter bit 3 */
N#define  CAN_F8R1_FB4                        ((uint32_t)0x00000010)        /*!< Filter bit 4 */
N#define  CAN_F8R1_FB5                        ((uint32_t)0x00000020)        /*!< Filter bit 5 */
N#define  CAN_F8R1_FB6                        ((uint32_t)0x00000040)        /*!< Filter bit 6 */
N#define  CAN_F8R1_FB7                        ((uint32_t)0x00000080)        /*!< Filter bit 7 */
N#define  CAN_F8R1_FB8                        ((uint32_t)0x00000100)        /*!< Filter bit 8 */
N#define  CAN_F8R1_FB9                        ((uint32_t)0x00000200)        /*!< Filter bit 9 */
N#define  CAN_F8R1_FB10                       ((uint32_t)0x00000400)        /*!< Filter bit 10 */
N#define  CAN_F8R1_FB11                       ((uint32_t)0x00000800)        /*!< Filter bit 11 */
N#define  CAN_F8R1_FB12                       ((uint32_t)0x00001000)        /*!< Filter bit 12 */
N#define  CAN_F8R1_FB13                       ((uint32_t)0x00002000)        /*!< Filter bit 13 */
N#define  CAN_F8R1_FB14                       ((uint32_t)0x00004000)        /*!< Filter bit 14 */
N#define  CAN_F8R1_FB15                       ((uint32_t)0x00008000)        /*!< Filter bit 15 */
N#define  CAN_F8R1_FB16                       ((uint32_t)0x00010000)        /*!< Filter bit 16 */
N#define  CAN_F8R1_FB17                       ((uint32_t)0x00020000)        /*!< Filter bit 17 */
N#define  CAN_F8R1_FB18                       ((uint32_t)0x00040000)        /*!< Filter bit 18 */
N#define  CAN_F8R1_FB19                       ((uint32_t)0x00080000)        /*!< Filter bit 19 */
N#define  CAN_F8R1_FB20                       ((uint32_t)0x00100000)        /*!< Filter bit 20 */
N#define  CAN_F8R1_FB21                       ((uint32_t)0x00200000)        /*!< Filter bit 21 */
N#define  CAN_F8R1_FB22                       ((uint32_t)0x00400000)        /*!< Filter bit 22 */
N#define  CAN_F8R1_FB23                       ((uint32_t)0x00800000)        /*!< Filter bit 23 */
N#define  CAN_F8R1_FB24                       ((uint32_t)0x01000000)        /*!< Filter bit 24 */
N#define  CAN_F8R1_FB25                       ((uint32_t)0x02000000)        /*!< Filter bit 25 */
N#define  CAN_F8R1_FB26                       ((uint32_t)0x04000000)        /*!< Filter bit 26 */
N#define  CAN_F8R1_FB27                       ((uint32_t)0x08000000)        /*!< Filter bit 27 */
N#define  CAN_F8R1_FB28                       ((uint32_t)0x10000000)        /*!< Filter bit 28 */
N#define  CAN_F8R1_FB29                       ((uint32_t)0x20000000)        /*!< Filter bit 29 */
N#define  CAN_F8R1_FB30                       ((uint32_t)0x40000000)        /*!< Filter bit 30 */
N#define  CAN_F8R1_FB31                       ((uint32_t)0x80000000)        /*!< Filter bit 31 */
N
N/*******************  Bit definition for CAN_F9R1 register  *******************/
N#define  CAN_F9R1_FB0                        ((uint32_t)0x00000001)        /*!< Filter bit 0 */
N#define  CAN_F9R1_FB1                        ((uint32_t)0x00000002)        /*!< Filter bit 1 */
N#define  CAN_F9R1_FB2                        ((uint32_t)0x00000004)        /*!< Filter bit 2 */
N#define  CAN_F9R1_FB3                        ((uint32_t)0x00000008)        /*!< Filter bit 3 */
N#define  CAN_F9R1_FB4                        ((uint32_t)0x00000010)        /*!< Filter bit 4 */
N#define  CAN_F9R1_FB5                        ((uint32_t)0x00000020)        /*!< Filter bit 5 */
N#define  CAN_F9R1_FB6                        ((uint32_t)0x00000040)        /*!< Filter bit 6 */
N#define  CAN_F9R1_FB7                        ((uint32_t)0x00000080)        /*!< Filter bit 7 */
N#define  CAN_F9R1_FB8                        ((uint32_t)0x00000100)        /*!< Filter bit 8 */
N#define  CAN_F9R1_FB9                        ((uint32_t)0x00000200)        /*!< Filter bit 9 */
N#define  CAN_F9R1_FB10                       ((uint32_t)0x00000400)        /*!< Filter bit 10 */
N#define  CAN_F9R1_FB11                       ((uint32_t)0x00000800)        /*!< Filter bit 11 */
N#define  CAN_F9R1_FB12                       ((uint32_t)0x00001000)        /*!< Filter bit 12 */
N#define  CAN_F9R1_FB13                       ((uint32_t)0x00002000)        /*!< Filter bit 13 */
N#define  CAN_F9R1_FB14                       ((uint32_t)0x00004000)        /*!< Filter bit 14 */
N#define  CAN_F9R1_FB15                       ((uint32_t)0x00008000)        /*!< Filter bit 15 */
N#define  CAN_F9R1_FB16                       ((uint32_t)0x00010000)        /*!< Filter bit 16 */
N#define  CAN_F9R1_FB17                       ((uint32_t)0x00020000)        /*!< Filter bit 17 */
N#define  CAN_F9R1_FB18                       ((uint32_t)0x00040000)        /*!< Filter bit 18 */
N#define  CAN_F9R1_FB19                       ((uint32_t)0x00080000)        /*!< Filter bit 19 */
N#define  CAN_F9R1_FB20                       ((uint32_t)0x00100000)        /*!< Filter bit 20 */
N#define  CAN_F9R1_FB21                       ((uint32_t)0x00200000)        /*!< Filter bit 21 */
N#define  CAN_F9R1_FB22                       ((uint32_t)0x00400000)        /*!< Filter bit 22 */
N#define  CAN_F9R1_FB23                       ((uint32_t)0x00800000)        /*!< Filter bit 23 */
N#define  CAN_F9R1_FB24                       ((uint32_t)0x01000000)        /*!< Filter bit 24 */
N#define  CAN_F9R1_FB25                       ((uint32_t)0x02000000)        /*!< Filter bit 25 */
N#define  CAN_F9R1_FB26                       ((uint32_t)0x04000000)        /*!< Filter bit 26 */
N#define  CAN_F9R1_FB27                       ((uint32_t)0x08000000)        /*!< Filter bit 27 */
N#define  CAN_F9R1_FB28                       ((uint32_t)0x10000000)        /*!< Filter bit 28 */
N#define  CAN_F9R1_FB29                       ((uint32_t)0x20000000)        /*!< Filter bit 29 */
N#define  CAN_F9R1_FB30                       ((uint32_t)0x40000000)        /*!< Filter bit 30 */
N#define  CAN_F9R1_FB31                       ((uint32_t)0x80000000)        /*!< Filter bit 31 */
N
N/*******************  Bit definition for CAN_F10R1 register  ******************/
N#define  CAN_F10R1_FB0                       ((uint32_t)0x00000001)        /*!< Filter bit 0 */
N#define  CAN_F10R1_FB1                       ((uint32_t)0x00000002)        /*!< Filter bit 1 */
N#define  CAN_F10R1_FB2                       ((uint32_t)0x00000004)        /*!< Filter bit 2 */
N#define  CAN_F10R1_FB3                       ((uint32_t)0x00000008)        /*!< Filter bit 3 */
N#define  CAN_F10R1_FB4                       ((uint32_t)0x00000010)        /*!< Filter bit 4 */
N#define  CAN_F10R1_FB5                       ((uint32_t)0x00000020)        /*!< Filter bit 5 */
N#define  CAN_F10R1_FB6                       ((uint32_t)0x00000040)        /*!< Filter bit 6 */
N#define  CAN_F10R1_FB7                       ((uint32_t)0x00000080)        /*!< Filter bit 7 */
N#define  CAN_F10R1_FB8                       ((uint32_t)0x00000100)        /*!< Filter bit 8 */
N#define  CAN_F10R1_FB9                       ((uint32_t)0x00000200)        /*!< Filter bit 9 */
N#define  CAN_F10R1_FB10                      ((uint32_t)0x00000400)        /*!< Filter bit 10 */
N#define  CAN_F10R1_FB11                      ((uint32_t)0x00000800)        /*!< Filter bit 11 */
N#define  CAN_F10R1_FB12                      ((uint32_t)0x00001000)        /*!< Filter bit 12 */
N#define  CAN_F10R1_FB13                      ((uint32_t)0x00002000)        /*!< Filter bit 13 */
N#define  CAN_F10R1_FB14                      ((uint32_t)0x00004000)        /*!< Filter bit 14 */
N#define  CAN_F10R1_FB15                      ((uint32_t)0x00008000)        /*!< Filter bit 15 */
N#define  CAN_F10R1_FB16                      ((uint32_t)0x00010000)        /*!< Filter bit 16 */
N#define  CAN_F10R1_FB17                      ((uint32_t)0x00020000)        /*!< Filter bit 17 */
N#define  CAN_F10R1_FB18                      ((uint32_t)0x00040000)        /*!< Filter bit 18 */
N#define  CAN_F10R1_FB19                      ((uint32_t)0x00080000)        /*!< Filter bit 19 */
N#define  CAN_F10R1_FB20                      ((uint32_t)0x00100000)        /*!< Filter bit 20 */
N#define  CAN_F10R1_FB21                      ((uint32_t)0x00200000)        /*!< Filter bit 21 */
N#define  CAN_F10R1_FB22                      ((uint32_t)0x00400000)        /*!< Filter bit 22 */
N#define  CAN_F10R1_FB23                      ((uint32_t)0x00800000)        /*!< Filter bit 23 */
N#define  CAN_F10R1_FB24                      ((uint32_t)0x01000000)        /*!< Filter bit 24 */
N#define  CAN_F10R1_FB25                      ((uint32_t)0x02000000)        /*!< Filter bit 25 */
N#define  CAN_F10R1_FB26                      ((uint32_t)0x04000000)        /*!< Filter bit 26 */
N#define  CAN_F10R1_FB27                      ((uint32_t)0x08000000)        /*!< Filter bit 27 */
N#define  CAN_F10R1_FB28                      ((uint32_t)0x10000000)        /*!< Filter bit 28 */
N#define  CAN_F10R1_FB29                      ((uint32_t)0x20000000)        /*!< Filter bit 29 */
N#define  CAN_F10R1_FB30                      ((uint32_t)0x40000000)        /*!< Filter bit 30 */
N#define  CAN_F10R1_FB31                      ((uint32_t)0x80000000)        /*!< Filter bit 31 */
N
N/*******************  Bit definition for CAN_F11R1 register  ******************/
N#define  CAN_F11R1_FB0                       ((uint32_t)0x00000001)        /*!< Filter bit 0 */
N#define  CAN_F11R1_FB1                       ((uint32_t)0x00000002)        /*!< Filter bit 1 */
N#define  CAN_F11R1_FB2                       ((uint32_t)0x00000004)        /*!< Filter bit 2 */
N#define  CAN_F11R1_FB3                       ((uint32_t)0x00000008)        /*!< Filter bit 3 */
N#define  CAN_F11R1_FB4                       ((uint32_t)0x00000010)        /*!< Filter bit 4 */
N#define  CAN_F11R1_FB5                       ((uint32_t)0x00000020)        /*!< Filter bit 5 */
N#define  CAN_F11R1_FB6                       ((uint32_t)0x00000040)        /*!< Filter bit 6 */
N#define  CAN_F11R1_FB7                       ((uint32_t)0x00000080)        /*!< Filter bit 7 */
N#define  CAN_F11R1_FB8                       ((uint32_t)0x00000100)        /*!< Filter bit 8 */
N#define  CAN_F11R1_FB9                       ((uint32_t)0x00000200)        /*!< Filter bit 9 */
N#define  CAN_F11R1_FB10                      ((uint32_t)0x00000400)        /*!< Filter bit 10 */
N#define  CAN_F11R1_FB11                      ((uint32_t)0x00000800)        /*!< Filter bit 11 */
N#define  CAN_F11R1_FB12                      ((uint32_t)0x00001000)        /*!< Filter bit 12 */
N#define  CAN_F11R1_FB13                      ((uint32_t)0x00002000)        /*!< Filter bit 13 */
N#define  CAN_F11R1_FB14                      ((uint32_t)0x00004000)        /*!< Filter bit 14 */
N#define  CAN_F11R1_FB15                      ((uint32_t)0x00008000)        /*!< Filter bit 15 */
N#define  CAN_F11R1_FB16                      ((uint32_t)0x00010000)        /*!< Filter bit 16 */
N#define  CAN_F11R1_FB17                      ((uint32_t)0x00020000)        /*!< Filter bit 17 */
N#define  CAN_F11R1_FB18                      ((uint32_t)0x00040000)        /*!< Filter bit 18 */
N#define  CAN_F11R1_FB19                      ((uint32_t)0x00080000)        /*!< Filter bit 19 */
N#define  CAN_F11R1_FB20                      ((uint32_t)0x00100000)        /*!< Filter bit 20 */
N#define  CAN_F11R1_FB21                      ((uint32_t)0x00200000)        /*!< Filter bit 21 */
N#define  CAN_F11R1_FB22                      ((uint32_t)0x00400000)        /*!< Filter bit 22 */
N#define  CAN_F11R1_FB23                      ((uint32_t)0x00800000)        /*!< Filter bit 23 */
N#define  CAN_F11R1_FB24                      ((uint32_t)0x01000000)        /*!< Filter bit 24 */
N#define  CAN_F11R1_FB25                      ((uint32_t)0x02000000)        /*!< Filter bit 25 */
N#define  CAN_F11R1_FB26                      ((uint32_t)0x04000000)        /*!< Filter bit 26 */
N#define  CAN_F11R1_FB27                      ((uint32_t)0x08000000)        /*!< Filter bit 27 */
N#define  CAN_F11R1_FB28                      ((uint32_t)0x10000000)        /*!< Filter bit 28 */
N#define  CAN_F11R1_FB29                      ((uint32_t)0x20000000)        /*!< Filter bit 29 */
N#define  CAN_F11R1_FB30                      ((uint32_t)0x40000000)        /*!< Filter bit 30 */
N#define  CAN_F11R1_FB31                      ((uint32_t)0x80000000)        /*!< Filter bit 31 */
N
N/*******************  Bit definition for CAN_F12R1 register  ******************/
N#define  CAN_F12R1_FB0                       ((uint32_t)0x00000001)        /*!< Filter bit 0 */
N#define  CAN_F12R1_FB1                       ((uint32_t)0x00000002)        /*!< Filter bit 1 */
N#define  CAN_F12R1_FB2                       ((uint32_t)0x00000004)        /*!< Filter bit 2 */
N#define  CAN_F12R1_FB3                       ((uint32_t)0x00000008)        /*!< Filter bit 3 */
N#define  CAN_F12R1_FB4                       ((uint32_t)0x00000010)        /*!< Filter bit 4 */
N#define  CAN_F12R1_FB5                       ((uint32_t)0x00000020)        /*!< Filter bit 5 */
N#define  CAN_F12R1_FB6                       ((uint32_t)0x00000040)        /*!< Filter bit 6 */
N#define  CAN_F12R1_FB7                       ((uint32_t)0x00000080)        /*!< Filter bit 7 */
N#define  CAN_F12R1_FB8                       ((uint32_t)0x00000100)        /*!< Filter bit 8 */
N#define  CAN_F12R1_FB9                       ((uint32_t)0x00000200)        /*!< Filter bit 9 */
N#define  CAN_F12R1_FB10                      ((uint32_t)0x00000400)        /*!< Filter bit 10 */
N#define  CAN_F12R1_FB11                      ((uint32_t)0x00000800)        /*!< Filter bit 11 */
N#define  CAN_F12R1_FB12                      ((uint32_t)0x00001000)        /*!< Filter bit 12 */
N#define  CAN_F12R1_FB13                      ((uint32_t)0x00002000)        /*!< Filter bit 13 */
N#define  CAN_F12R1_FB14                      ((uint32_t)0x00004000)        /*!< Filter bit 14 */
N#define  CAN_F12R1_FB15                      ((uint32_t)0x00008000)        /*!< Filter bit 15 */
N#define  CAN_F12R1_FB16                      ((uint32_t)0x00010000)        /*!< Filter bit 16 */
N#define  CAN_F12R1_FB17                      ((uint32_t)0x00020000)        /*!< Filter bit 17 */
N#define  CAN_F12R1_FB18                      ((uint32_t)0x00040000)        /*!< Filter bit 18 */
N#define  CAN_F12R1_FB19                      ((uint32_t)0x00080000)        /*!< Filter bit 19 */
N#define  CAN_F12R1_FB20                      ((uint32_t)0x00100000)        /*!< Filter bit 20 */
N#define  CAN_F12R1_FB21                      ((uint32_t)0x00200000)        /*!< Filter bit 21 */
N#define  CAN_F12R1_FB22                      ((uint32_t)0x00400000)        /*!< Filter bit 22 */
N#define  CAN_F12R1_FB23                      ((uint32_t)0x00800000)        /*!< Filter bit 23 */
N#define  CAN_F12R1_FB24                      ((uint32_t)0x01000000)        /*!< Filter bit 24 */
N#define  CAN_F12R1_FB25                      ((uint32_t)0x02000000)        /*!< Filter bit 25 */
N#define  CAN_F12R1_FB26                      ((uint32_t)0x04000000)        /*!< Filter bit 26 */
N#define  CAN_F12R1_FB27                      ((uint32_t)0x08000000)        /*!< Filter bit 27 */
N#define  CAN_F12R1_FB28                      ((uint32_t)0x10000000)        /*!< Filter bit 28 */
N#define  CAN_F12R1_FB29                      ((uint32_t)0x20000000)        /*!< Filter bit 29 */
N#define  CAN_F12R1_FB30                      ((uint32_t)0x40000000)        /*!< Filter bit 30 */
N#define  CAN_F12R1_FB31                      ((uint32_t)0x80000000)        /*!< Filter bit 31 */
N
N/*******************  Bit definition for CAN_F13R1 register  ******************/
N#define  CAN_F13R1_FB0                       ((uint32_t)0x00000001)        /*!< Filter bit 0 */
N#define  CAN_F13R1_FB1                       ((uint32_t)0x00000002)        /*!< Filter bit 1 */
N#define  CAN_F13R1_FB2                       ((uint32_t)0x00000004)        /*!< Filter bit 2 */
N#define  CAN_F13R1_FB3                       ((uint32_t)0x00000008)        /*!< Filter bit 3 */
N#define  CAN_F13R1_FB4                       ((uint32_t)0x00000010)        /*!< Filter bit 4 */
N#define  CAN_F13R1_FB5                       ((uint32_t)0x00000020)        /*!< Filter bit 5 */
N#define  CAN_F13R1_FB6                       ((uint32_t)0x00000040)        /*!< Filter bit 6 */
N#define  CAN_F13R1_FB7                       ((uint32_t)0x00000080)        /*!< Filter bit 7 */
N#define  CAN_F13R1_FB8                       ((uint32_t)0x00000100)        /*!< Filter bit 8 */
N#define  CAN_F13R1_FB9                       ((uint32_t)0x00000200)        /*!< Filter bit 9 */
N#define  CAN_F13R1_FB10                      ((uint32_t)0x00000400)        /*!< Filter bit 10 */
N#define  CAN_F13R1_FB11                      ((uint32_t)0x00000800)        /*!< Filter bit 11 */
N#define  CAN_F13R1_FB12                      ((uint32_t)0x00001000)        /*!< Filter bit 12 */
N#define  CAN_F13R1_FB13                      ((uint32_t)0x00002000)        /*!< Filter bit 13 */
N#define  CAN_F13R1_FB14                      ((uint32_t)0x00004000)        /*!< Filter bit 14 */
N#define  CAN_F13R1_FB15                      ((uint32_t)0x00008000)        /*!< Filter bit 15 */
N#define  CAN_F13R1_FB16                      ((uint32_t)0x00010000)        /*!< Filter bit 16 */
N#define  CAN_F13R1_FB17                      ((uint32_t)0x00020000)        /*!< Filter bit 17 */
N#define  CAN_F13R1_FB18                      ((uint32_t)0x00040000)        /*!< Filter bit 18 */
N#define  CAN_F13R1_FB19                      ((uint32_t)0x00080000)        /*!< Filter bit 19 */
N#define  CAN_F13R1_FB20                      ((uint32_t)0x00100000)        /*!< Filter bit 20 */
N#define  CAN_F13R1_FB21                      ((uint32_t)0x00200000)        /*!< Filter bit 21 */
N#define  CAN_F13R1_FB22                      ((uint32_t)0x00400000)        /*!< Filter bit 22 */
N#define  CAN_F13R1_FB23                      ((uint32_t)0x00800000)        /*!< Filter bit 23 */
N#define  CAN_F13R1_FB24                      ((uint32_t)0x01000000)        /*!< Filter bit 24 */
N#define  CAN_F13R1_FB25                      ((uint32_t)0x02000000)        /*!< Filter bit 25 */
N#define  CAN_F13R1_FB26                      ((uint32_t)0x04000000)        /*!< Filter bit 26 */
N#define  CAN_F13R1_FB27                      ((uint32_t)0x08000000)        /*!< Filter bit 27 */
N#define  CAN_F13R1_FB28                      ((uint32_t)0x10000000)        /*!< Filter bit 28 */
N#define  CAN_F13R1_FB29                      ((uint32_t)0x20000000)        /*!< Filter bit 29 */
N#define  CAN_F13R1_FB30                      ((uint32_t)0x40000000)        /*!< Filter bit 30 */
N#define  CAN_F13R1_FB31                      ((uint32_t)0x80000000)        /*!< Filter bit 31 */
N
N/*******************  Bit definition for CAN_F0R2 register  *******************/
N#define  CAN_F0R2_FB0                        ((uint32_t)0x00000001)        /*!< Filter bit 0 */
N#define  CAN_F0R2_FB1                        ((uint32_t)0x00000002)        /*!< Filter bit 1 */
N#define  CAN_F0R2_FB2                        ((uint32_t)0x00000004)        /*!< Filter bit 2 */
N#define  CAN_F0R2_FB3                        ((uint32_t)0x00000008)        /*!< Filter bit 3 */
N#define  CAN_F0R2_FB4                        ((uint32_t)0x00000010)        /*!< Filter bit 4 */
N#define  CAN_F0R2_FB5                        ((uint32_t)0x00000020)        /*!< Filter bit 5 */
N#define  CAN_F0R2_FB6                        ((uint32_t)0x00000040)        /*!< Filter bit 6 */
N#define  CAN_F0R2_FB7                        ((uint32_t)0x00000080)        /*!< Filter bit 7 */
N#define  CAN_F0R2_FB8                        ((uint32_t)0x00000100)        /*!< Filter bit 8 */
N#define  CAN_F0R2_FB9                        ((uint32_t)0x00000200)        /*!< Filter bit 9 */
N#define  CAN_F0R2_FB10                       ((uint32_t)0x00000400)        /*!< Filter bit 10 */
N#define  CAN_F0R2_FB11                       ((uint32_t)0x00000800)        /*!< Filter bit 11 */
N#define  CAN_F0R2_FB12                       ((uint32_t)0x00001000)        /*!< Filter bit 12 */
N#define  CAN_F0R2_FB13                       ((uint32_t)0x00002000)        /*!< Filter bit 13 */
N#define  CAN_F0R2_FB14                       ((uint32_t)0x00004000)        /*!< Filter bit 14 */
N#define  CAN_F0R2_FB15                       ((uint32_t)0x00008000)        /*!< Filter bit 15 */
N#define  CAN_F0R2_FB16                       ((uint32_t)0x00010000)        /*!< Filter bit 16 */
N#define  CAN_F0R2_FB17                       ((uint32_t)0x00020000)        /*!< Filter bit 17 */
N#define  CAN_F0R2_FB18                       ((uint32_t)0x00040000)        /*!< Filter bit 18 */
N#define  CAN_F0R2_FB19                       ((uint32_t)0x00080000)        /*!< Filter bit 19 */
N#define  CAN_F0R2_FB20                       ((uint32_t)0x00100000)        /*!< Filter bit 20 */
N#define  CAN_F0R2_FB21                       ((uint32_t)0x00200000)        /*!< Filter bit 21 */
N#define  CAN_F0R2_FB22                       ((uint32_t)0x00400000)        /*!< Filter bit 22 */
N#define  CAN_F0R2_FB23                       ((uint32_t)0x00800000)        /*!< Filter bit 23 */
N#define  CAN_F0R2_FB24                       ((uint32_t)0x01000000)        /*!< Filter bit 24 */
N#define  CAN_F0R2_FB25                       ((uint32_t)0x02000000)        /*!< Filter bit 25 */
N#define  CAN_F0R2_FB26                       ((uint32_t)0x04000000)        /*!< Filter bit 26 */
N#define  CAN_F0R2_FB27                       ((uint32_t)0x08000000)        /*!< Filter bit 27 */
N#define  CAN_F0R2_FB28                       ((uint32_t)0x10000000)        /*!< Filter bit 28 */
N#define  CAN_F0R2_FB29                       ((uint32_t)0x20000000)        /*!< Filter bit 29 */
N#define  CAN_F0R2_FB30                       ((uint32_t)0x40000000)        /*!< Filter bit 30 */
N#define  CAN_F0R2_FB31                       ((uint32_t)0x80000000)        /*!< Filter bit 31 */
N
N/*******************  Bit definition for CAN_F1R2 register  *******************/
N#define  CAN_F1R2_FB0                        ((uint32_t)0x00000001)        /*!< Filter bit 0 */
N#define  CAN_F1R2_FB1                        ((uint32_t)0x00000002)        /*!< Filter bit 1 */
N#define  CAN_F1R2_FB2                        ((uint32_t)0x00000004)        /*!< Filter bit 2 */
N#define  CAN_F1R2_FB3                        ((uint32_t)0x00000008)        /*!< Filter bit 3 */
N#define  CAN_F1R2_FB4                        ((uint32_t)0x00000010)        /*!< Filter bit 4 */
N#define  CAN_F1R2_FB5                        ((uint32_t)0x00000020)        /*!< Filter bit 5 */
N#define  CAN_F1R2_FB6                        ((uint32_t)0x00000040)        /*!< Filter bit 6 */
N#define  CAN_F1R2_FB7                        ((uint32_t)0x00000080)        /*!< Filter bit 7 */
N#define  CAN_F1R2_FB8                        ((uint32_t)0x00000100)        /*!< Filter bit 8 */
N#define  CAN_F1R2_FB9                        ((uint32_t)0x00000200)        /*!< Filter bit 9 */
N#define  CAN_F1R2_FB10                       ((uint32_t)0x00000400)        /*!< Filter bit 10 */
N#define  CAN_F1R2_FB11                       ((uint32_t)0x00000800)        /*!< Filter bit 11 */
N#define  CAN_F1R2_FB12                       ((uint32_t)0x00001000)        /*!< Filter bit 12 */
N#define  CAN_F1R2_FB13                       ((uint32_t)0x00002000)        /*!< Filter bit 13 */
N#define  CAN_F1R2_FB14                       ((uint32_t)0x00004000)        /*!< Filter bit 14 */
N#define  CAN_F1R2_FB15                       ((uint32_t)0x00008000)        /*!< Filter bit 15 */
N#define  CAN_F1R2_FB16                       ((uint32_t)0x00010000)        /*!< Filter bit 16 */
N#define  CAN_F1R2_FB17                       ((uint32_t)0x00020000)        /*!< Filter bit 17 */
N#define  CAN_F1R2_FB18                       ((uint32_t)0x00040000)        /*!< Filter bit 18 */
N#define  CAN_F1R2_FB19                       ((uint32_t)0x00080000)        /*!< Filter bit 19 */
N#define  CAN_F1R2_FB20                       ((uint32_t)0x00100000)        /*!< Filter bit 20 */
N#define  CAN_F1R2_FB21                       ((uint32_t)0x00200000)        /*!< Filter bit 21 */
N#define  CAN_F1R2_FB22                       ((uint32_t)0x00400000)        /*!< Filter bit 22 */
N#define  CAN_F1R2_FB23                       ((uint32_t)0x00800000)        /*!< Filter bit 23 */
N#define  CAN_F1R2_FB24                       ((uint32_t)0x01000000)        /*!< Filter bit 24 */
N#define  CAN_F1R2_FB25                       ((uint32_t)0x02000000)        /*!< Filter bit 25 */
N#define  CAN_F1R2_FB26                       ((uint32_t)0x04000000)        /*!< Filter bit 26 */
N#define  CAN_F1R2_FB27                       ((uint32_t)0x08000000)        /*!< Filter bit 27 */
N#define  CAN_F1R2_FB28                       ((uint32_t)0x10000000)        /*!< Filter bit 28 */
N#define  CAN_F1R2_FB29                       ((uint32_t)0x20000000)        /*!< Filter bit 29 */
N#define  CAN_F1R2_FB30                       ((uint32_t)0x40000000)        /*!< Filter bit 30 */
N#define  CAN_F1R2_FB31                       ((uint32_t)0x80000000)        /*!< Filter bit 31 */
N
N/*******************  Bit definition for CAN_F2R2 register  *******************/
N#define  CAN_F2R2_FB0                        ((uint32_t)0x00000001)        /*!< Filter bit 0 */
N#define  CAN_F2R2_FB1                        ((uint32_t)0x00000002)        /*!< Filter bit 1 */
N#define  CAN_F2R2_FB2                        ((uint32_t)0x00000004)        /*!< Filter bit 2 */
N#define  CAN_F2R2_FB3                        ((uint32_t)0x00000008)        /*!< Filter bit 3 */
N#define  CAN_F2R2_FB4                        ((uint32_t)0x00000010)        /*!< Filter bit 4 */
N#define  CAN_F2R2_FB5                        ((uint32_t)0x00000020)        /*!< Filter bit 5 */
N#define  CAN_F2R2_FB6                        ((uint32_t)0x00000040)        /*!< Filter bit 6 */
N#define  CAN_F2R2_FB7                        ((uint32_t)0x00000080)        /*!< Filter bit 7 */
N#define  CAN_F2R2_FB8                        ((uint32_t)0x00000100)        /*!< Filter bit 8 */
N#define  CAN_F2R2_FB9                        ((uint32_t)0x00000200)        /*!< Filter bit 9 */
N#define  CAN_F2R2_FB10                       ((uint32_t)0x00000400)        /*!< Filter bit 10 */
N#define  CAN_F2R2_FB11                       ((uint32_t)0x00000800)        /*!< Filter bit 11 */
N#define  CAN_F2R2_FB12                       ((uint32_t)0x00001000)        /*!< Filter bit 12 */
N#define  CAN_F2R2_FB13                       ((uint32_t)0x00002000)        /*!< Filter bit 13 */
N#define  CAN_F2R2_FB14                       ((uint32_t)0x00004000)        /*!< Filter bit 14 */
N#define  CAN_F2R2_FB15                       ((uint32_t)0x00008000)        /*!< Filter bit 15 */
N#define  CAN_F2R2_FB16                       ((uint32_t)0x00010000)        /*!< Filter bit 16 */
N#define  CAN_F2R2_FB17                       ((uint32_t)0x00020000)        /*!< Filter bit 17 */
N#define  CAN_F2R2_FB18                       ((uint32_t)0x00040000)        /*!< Filter bit 18 */
N#define  CAN_F2R2_FB19                       ((uint32_t)0x00080000)        /*!< Filter bit 19 */
N#define  CAN_F2R2_FB20                       ((uint32_t)0x00100000)        /*!< Filter bit 20 */
N#define  CAN_F2R2_FB21                       ((uint32_t)0x00200000)        /*!< Filter bit 21 */
N#define  CAN_F2R2_FB22                       ((uint32_t)0x00400000)        /*!< Filter bit 22 */
N#define  CAN_F2R2_FB23                       ((uint32_t)0x00800000)        /*!< Filter bit 23 */
N#define  CAN_F2R2_FB24                       ((uint32_t)0x01000000)        /*!< Filter bit 24 */
N#define  CAN_F2R2_FB25                       ((uint32_t)0x02000000)        /*!< Filter bit 25 */
N#define  CAN_F2R2_FB26                       ((uint32_t)0x04000000)        /*!< Filter bit 26 */
N#define  CAN_F2R2_FB27                       ((uint32_t)0x08000000)        /*!< Filter bit 27 */
N#define  CAN_F2R2_FB28                       ((uint32_t)0x10000000)        /*!< Filter bit 28 */
N#define  CAN_F2R2_FB29                       ((uint32_t)0x20000000)        /*!< Filter bit 29 */
N#define  CAN_F2R2_FB30                       ((uint32_t)0x40000000)        /*!< Filter bit 30 */
N#define  CAN_F2R2_FB31                       ((uint32_t)0x80000000)        /*!< Filter bit 31 */
N
N/*******************  Bit definition for CAN_F3R2 register  *******************/
N#define  CAN_F3R2_FB0                        ((uint32_t)0x00000001)        /*!< Filter bit 0 */
N#define  CAN_F3R2_FB1                        ((uint32_t)0x00000002)        /*!< Filter bit 1 */
N#define  CAN_F3R2_FB2                        ((uint32_t)0x00000004)        /*!< Filter bit 2 */
N#define  CAN_F3R2_FB3                        ((uint32_t)0x00000008)        /*!< Filter bit 3 */
N#define  CAN_F3R2_FB4                        ((uint32_t)0x00000010)        /*!< Filter bit 4 */
N#define  CAN_F3R2_FB5                        ((uint32_t)0x00000020)        /*!< Filter bit 5 */
N#define  CAN_F3R2_FB6                        ((uint32_t)0x00000040)        /*!< Filter bit 6 */
N#define  CAN_F3R2_FB7                        ((uint32_t)0x00000080)        /*!< Filter bit 7 */
N#define  CAN_F3R2_FB8                        ((uint32_t)0x00000100)        /*!< Filter bit 8 */
N#define  CAN_F3R2_FB9                        ((uint32_t)0x00000200)        /*!< Filter bit 9 */
N#define  CAN_F3R2_FB10                       ((uint32_t)0x00000400)        /*!< Filter bit 10 */
N#define  CAN_F3R2_FB11                       ((uint32_t)0x00000800)        /*!< Filter bit 11 */
N#define  CAN_F3R2_FB12                       ((uint32_t)0x00001000)        /*!< Filter bit 12 */
N#define  CAN_F3R2_FB13                       ((uint32_t)0x00002000)        /*!< Filter bit 13 */
N#define  CAN_F3R2_FB14                       ((uint32_t)0x00004000)        /*!< Filter bit 14 */
N#define  CAN_F3R2_FB15                       ((uint32_t)0x00008000)        /*!< Filter bit 15 */
N#define  CAN_F3R2_FB16                       ((uint32_t)0x00010000)        /*!< Filter bit 16 */
N#define  CAN_F3R2_FB17                       ((uint32_t)0x00020000)        /*!< Filter bit 17 */
N#define  CAN_F3R2_FB18                       ((uint32_t)0x00040000)        /*!< Filter bit 18 */
N#define  CAN_F3R2_FB19                       ((uint32_t)0x00080000)        /*!< Filter bit 19 */
N#define  CAN_F3R2_FB20                       ((uint32_t)0x00100000)        /*!< Filter bit 20 */
N#define  CAN_F3R2_FB21                       ((uint32_t)0x00200000)        /*!< Filter bit 21 */
N#define  CAN_F3R2_FB22                       ((uint32_t)0x00400000)        /*!< Filter bit 22 */
N#define  CAN_F3R2_FB23                       ((uint32_t)0x00800000)        /*!< Filter bit 23 */
N#define  CAN_F3R2_FB24                       ((uint32_t)0x01000000)        /*!< Filter bit 24 */
N#define  CAN_F3R2_FB25                       ((uint32_t)0x02000000)        /*!< Filter bit 25 */
N#define  CAN_F3R2_FB26                       ((uint32_t)0x04000000)        /*!< Filter bit 26 */
N#define  CAN_F3R2_FB27                       ((uint32_t)0x08000000)        /*!< Filter bit 27 */
N#define  CAN_F3R2_FB28                       ((uint32_t)0x10000000)        /*!< Filter bit 28 */
N#define  CAN_F3R2_FB29                       ((uint32_t)0x20000000)        /*!< Filter bit 29 */
N#define  CAN_F3R2_FB30                       ((uint32_t)0x40000000)        /*!< Filter bit 30 */
N#define  CAN_F3R2_FB31                       ((uint32_t)0x80000000)        /*!< Filter bit 31 */
N
N/*******************  Bit definition for CAN_F4R2 register  *******************/
N#define  CAN_F4R2_FB0                        ((uint32_t)0x00000001)        /*!< Filter bit 0 */
N#define  CAN_F4R2_FB1                        ((uint32_t)0x00000002)        /*!< Filter bit 1 */
N#define  CAN_F4R2_FB2                        ((uint32_t)0x00000004)        /*!< Filter bit 2 */
N#define  CAN_F4R2_FB3                        ((uint32_t)0x00000008)        /*!< Filter bit 3 */
N#define  CAN_F4R2_FB4                        ((uint32_t)0x00000010)        /*!< Filter bit 4 */
N#define  CAN_F4R2_FB5                        ((uint32_t)0x00000020)        /*!< Filter bit 5 */
N#define  CAN_F4R2_FB6                        ((uint32_t)0x00000040)        /*!< Filter bit 6 */
N#define  CAN_F4R2_FB7                        ((uint32_t)0x00000080)        /*!< Filter bit 7 */
N#define  CAN_F4R2_FB8                        ((uint32_t)0x00000100)        /*!< Filter bit 8 */
N#define  CAN_F4R2_FB9                        ((uint32_t)0x00000200)        /*!< Filter bit 9 */
N#define  CAN_F4R2_FB10                       ((uint32_t)0x00000400)        /*!< Filter bit 10 */
N#define  CAN_F4R2_FB11                       ((uint32_t)0x00000800)        /*!< Filter bit 11 */
N#define  CAN_F4R2_FB12                       ((uint32_t)0x00001000)        /*!< Filter bit 12 */
N#define  CAN_F4R2_FB13                       ((uint32_t)0x00002000)        /*!< Filter bit 13 */
N#define  CAN_F4R2_FB14                       ((uint32_t)0x00004000)        /*!< Filter bit 14 */
N#define  CAN_F4R2_FB15                       ((uint32_t)0x00008000)        /*!< Filter bit 15 */
N#define  CAN_F4R2_FB16                       ((uint32_t)0x00010000)        /*!< Filter bit 16 */
N#define  CAN_F4R2_FB17                       ((uint32_t)0x00020000)        /*!< Filter bit 17 */
N#define  CAN_F4R2_FB18                       ((uint32_t)0x00040000)        /*!< Filter bit 18 */
N#define  CAN_F4R2_FB19                       ((uint32_t)0x00080000)        /*!< Filter bit 19 */
N#define  CAN_F4R2_FB20                       ((uint32_t)0x00100000)        /*!< Filter bit 20 */
N#define  CAN_F4R2_FB21                       ((uint32_t)0x00200000)        /*!< Filter bit 21 */
N#define  CAN_F4R2_FB22                       ((uint32_t)0x00400000)        /*!< Filter bit 22 */
N#define  CAN_F4R2_FB23                       ((uint32_t)0x00800000)        /*!< Filter bit 23 */
N#define  CAN_F4R2_FB24                       ((uint32_t)0x01000000)        /*!< Filter bit 24 */
N#define  CAN_F4R2_FB25                       ((uint32_t)0x02000000)        /*!< Filter bit 25 */
N#define  CAN_F4R2_FB26                       ((uint32_t)0x04000000)        /*!< Filter bit 26 */
N#define  CAN_F4R2_FB27                       ((uint32_t)0x08000000)        /*!< Filter bit 27 */
N#define  CAN_F4R2_FB28                       ((uint32_t)0x10000000)        /*!< Filter bit 28 */
N#define  CAN_F4R2_FB29                       ((uint32_t)0x20000000)        /*!< Filter bit 29 */
N#define  CAN_F4R2_FB30                       ((uint32_t)0x40000000)        /*!< Filter bit 30 */
N#define  CAN_F4R2_FB31                       ((uint32_t)0x80000000)        /*!< Filter bit 31 */
N
N/*******************  Bit definition for CAN_F5R2 register  *******************/
N#define  CAN_F5R2_FB0                        ((uint32_t)0x00000001)        /*!< Filter bit 0 */
N#define  CAN_F5R2_FB1                        ((uint32_t)0x00000002)        /*!< Filter bit 1 */
N#define  CAN_F5R2_FB2                        ((uint32_t)0x00000004)        /*!< Filter bit 2 */
N#define  CAN_F5R2_FB3                        ((uint32_t)0x00000008)        /*!< Filter bit 3 */
N#define  CAN_F5R2_FB4                        ((uint32_t)0x00000010)        /*!< Filter bit 4 */
N#define  CAN_F5R2_FB5                        ((uint32_t)0x00000020)        /*!< Filter bit 5 */
N#define  CAN_F5R2_FB6                        ((uint32_t)0x00000040)        /*!< Filter bit 6 */
N#define  CAN_F5R2_FB7                        ((uint32_t)0x00000080)        /*!< Filter bit 7 */
N#define  CAN_F5R2_FB8                        ((uint32_t)0x00000100)        /*!< Filter bit 8 */
N#define  CAN_F5R2_FB9                        ((uint32_t)0x00000200)        /*!< Filter bit 9 */
N#define  CAN_F5R2_FB10                       ((uint32_t)0x00000400)        /*!< Filter bit 10 */
N#define  CAN_F5R2_FB11                       ((uint32_t)0x00000800)        /*!< Filter bit 11 */
N#define  CAN_F5R2_FB12                       ((uint32_t)0x00001000)        /*!< Filter bit 12 */
N#define  CAN_F5R2_FB13                       ((uint32_t)0x00002000)        /*!< Filter bit 13 */
N#define  CAN_F5R2_FB14                       ((uint32_t)0x00004000)        /*!< Filter bit 14 */
N#define  CAN_F5R2_FB15                       ((uint32_t)0x00008000)        /*!< Filter bit 15 */
N#define  CAN_F5R2_FB16                       ((uint32_t)0x00010000)        /*!< Filter bit 16 */
N#define  CAN_F5R2_FB17                       ((uint32_t)0x00020000)        /*!< Filter bit 17 */
N#define  CAN_F5R2_FB18                       ((uint32_t)0x00040000)        /*!< Filter bit 18 */
N#define  CAN_F5R2_FB19                       ((uint32_t)0x00080000)        /*!< Filter bit 19 */
N#define  CAN_F5R2_FB20                       ((uint32_t)0x00100000)        /*!< Filter bit 20 */
N#define  CAN_F5R2_FB21                       ((uint32_t)0x00200000)        /*!< Filter bit 21 */
N#define  CAN_F5R2_FB22                       ((uint32_t)0x00400000)        /*!< Filter bit 22 */
N#define  CAN_F5R2_FB23                       ((uint32_t)0x00800000)        /*!< Filter bit 23 */
N#define  CAN_F5R2_FB24                       ((uint32_t)0x01000000)        /*!< Filter bit 24 */
N#define  CAN_F5R2_FB25                       ((uint32_t)0x02000000)        /*!< Filter bit 25 */
N#define  CAN_F5R2_FB26                       ((uint32_t)0x04000000)        /*!< Filter bit 26 */
N#define  CAN_F5R2_FB27                       ((uint32_t)0x08000000)        /*!< Filter bit 27 */
N#define  CAN_F5R2_FB28                       ((uint32_t)0x10000000)        /*!< Filter bit 28 */
N#define  CAN_F5R2_FB29                       ((uint32_t)0x20000000)        /*!< Filter bit 29 */
N#define  CAN_F5R2_FB30                       ((uint32_t)0x40000000)        /*!< Filter bit 30 */
N#define  CAN_F5R2_FB31                       ((uint32_t)0x80000000)        /*!< Filter bit 31 */
N
N/*******************  Bit definition for CAN_F6R2 register  *******************/
N#define  CAN_F6R2_FB0                        ((uint32_t)0x00000001)        /*!< Filter bit 0 */
N#define  CAN_F6R2_FB1                        ((uint32_t)0x00000002)        /*!< Filter bit 1 */
N#define  CAN_F6R2_FB2                        ((uint32_t)0x00000004)        /*!< Filter bit 2 */
N#define  CAN_F6R2_FB3                        ((uint32_t)0x00000008)        /*!< Filter bit 3 */
N#define  CAN_F6R2_FB4                        ((uint32_t)0x00000010)        /*!< Filter bit 4 */
N#define  CAN_F6R2_FB5                        ((uint32_t)0x00000020)        /*!< Filter bit 5 */
N#define  CAN_F6R2_FB6                        ((uint32_t)0x00000040)        /*!< Filter bit 6 */
N#define  CAN_F6R2_FB7                        ((uint32_t)0x00000080)        /*!< Filter bit 7 */
N#define  CAN_F6R2_FB8                        ((uint32_t)0x00000100)        /*!< Filter bit 8 */
N#define  CAN_F6R2_FB9                        ((uint32_t)0x00000200)        /*!< Filter bit 9 */
N#define  CAN_F6R2_FB10                       ((uint32_t)0x00000400)        /*!< Filter bit 10 */
N#define  CAN_F6R2_FB11                       ((uint32_t)0x00000800)        /*!< Filter bit 11 */
N#define  CAN_F6R2_FB12                       ((uint32_t)0x00001000)        /*!< Filter bit 12 */
N#define  CAN_F6R2_FB13                       ((uint32_t)0x00002000)        /*!< Filter bit 13 */
N#define  CAN_F6R2_FB14                       ((uint32_t)0x00004000)        /*!< Filter bit 14 */
N#define  CAN_F6R2_FB15                       ((uint32_t)0x00008000)        /*!< Filter bit 15 */
N#define  CAN_F6R2_FB16                       ((uint32_t)0x00010000)        /*!< Filter bit 16 */
N#define  CAN_F6R2_FB17                       ((uint32_t)0x00020000)        /*!< Filter bit 17 */
N#define  CAN_F6R2_FB18                       ((uint32_t)0x00040000)        /*!< Filter bit 18 */
N#define  CAN_F6R2_FB19                       ((uint32_t)0x00080000)        /*!< Filter bit 19 */
N#define  CAN_F6R2_FB20                       ((uint32_t)0x00100000)        /*!< Filter bit 20 */
N#define  CAN_F6R2_FB21                       ((uint32_t)0x00200000)        /*!< Filter bit 21 */
N#define  CAN_F6R2_FB22                       ((uint32_t)0x00400000)        /*!< Filter bit 22 */
N#define  CAN_F6R2_FB23                       ((uint32_t)0x00800000)        /*!< Filter bit 23 */
N#define  CAN_F6R2_FB24                       ((uint32_t)0x01000000)        /*!< Filter bit 24 */
N#define  CAN_F6R2_FB25                       ((uint32_t)0x02000000)        /*!< Filter bit 25 */
N#define  CAN_F6R2_FB26                       ((uint32_t)0x04000000)        /*!< Filter bit 26 */
N#define  CAN_F6R2_FB27                       ((uint32_t)0x08000000)        /*!< Filter bit 27 */
N#define  CAN_F6R2_FB28                       ((uint32_t)0x10000000)        /*!< Filter bit 28 */
N#define  CAN_F6R2_FB29                       ((uint32_t)0x20000000)        /*!< Filter bit 29 */
N#define  CAN_F6R2_FB30                       ((uint32_t)0x40000000)        /*!< Filter bit 30 */
N#define  CAN_F6R2_FB31                       ((uint32_t)0x80000000)        /*!< Filter bit 31 */
N
N/*******************  Bit definition for CAN_F7R2 register  *******************/
N#define  CAN_F7R2_FB0                        ((uint32_t)0x00000001)        /*!< Filter bit 0 */
N#define  CAN_F7R2_FB1                        ((uint32_t)0x00000002)        /*!< Filter bit 1 */
N#define  CAN_F7R2_FB2                        ((uint32_t)0x00000004)        /*!< Filter bit 2 */
N#define  CAN_F7R2_FB3                        ((uint32_t)0x00000008)        /*!< Filter bit 3 */
N#define  CAN_F7R2_FB4                        ((uint32_t)0x00000010)        /*!< Filter bit 4 */
N#define  CAN_F7R2_FB5                        ((uint32_t)0x00000020)        /*!< Filter bit 5 */
N#define  CAN_F7R2_FB6                        ((uint32_t)0x00000040)        /*!< Filter bit 6 */
N#define  CAN_F7R2_FB7                        ((uint32_t)0x00000080)        /*!< Filter bit 7 */
N#define  CAN_F7R2_FB8                        ((uint32_t)0x00000100)        /*!< Filter bit 8 */
N#define  CAN_F7R2_FB9                        ((uint32_t)0x00000200)        /*!< Filter bit 9 */
N#define  CAN_F7R2_FB10                       ((uint32_t)0x00000400)        /*!< Filter bit 10 */
N#define  CAN_F7R2_FB11                       ((uint32_t)0x00000800)        /*!< Filter bit 11 */
N#define  CAN_F7R2_FB12                       ((uint32_t)0x00001000)        /*!< Filter bit 12 */
N#define  CAN_F7R2_FB13                       ((uint32_t)0x00002000)        /*!< Filter bit 13 */
N#define  CAN_F7R2_FB14                       ((uint32_t)0x00004000)        /*!< Filter bit 14 */
N#define  CAN_F7R2_FB15                       ((uint32_t)0x00008000)        /*!< Filter bit 15 */
N#define  CAN_F7R2_FB16                       ((uint32_t)0x00010000)        /*!< Filter bit 16 */
N#define  CAN_F7R2_FB17                       ((uint32_t)0x00020000)        /*!< Filter bit 17 */
N#define  CAN_F7R2_FB18                       ((uint32_t)0x00040000)        /*!< Filter bit 18 */
N#define  CAN_F7R2_FB19                       ((uint32_t)0x00080000)        /*!< Filter bit 19 */
N#define  CAN_F7R2_FB20                       ((uint32_t)0x00100000)        /*!< Filter bit 20 */
N#define  CAN_F7R2_FB21                       ((uint32_t)0x00200000)        /*!< Filter bit 21 */
N#define  CAN_F7R2_FB22                       ((uint32_t)0x00400000)        /*!< Filter bit 22 */
N#define  CAN_F7R2_FB23                       ((uint32_t)0x00800000)        /*!< Filter bit 23 */
N#define  CAN_F7R2_FB24                       ((uint32_t)0x01000000)        /*!< Filter bit 24 */
N#define  CAN_F7R2_FB25                       ((uint32_t)0x02000000)        /*!< Filter bit 25 */
N#define  CAN_F7R2_FB26                       ((uint32_t)0x04000000)        /*!< Filter bit 26 */
N#define  CAN_F7R2_FB27                       ((uint32_t)0x08000000)        /*!< Filter bit 27 */
N#define  CAN_F7R2_FB28                       ((uint32_t)0x10000000)        /*!< Filter bit 28 */
N#define  CAN_F7R2_FB29                       ((uint32_t)0x20000000)        /*!< Filter bit 29 */
N#define  CAN_F7R2_FB30                       ((uint32_t)0x40000000)        /*!< Filter bit 30 */
N#define  CAN_F7R2_FB31                       ((uint32_t)0x80000000)        /*!< Filter bit 31 */
N
N/*******************  Bit definition for CAN_F8R2 register  *******************/
N#define  CAN_F8R2_FB0                        ((uint32_t)0x00000001)        /*!< Filter bit 0 */
N#define  CAN_F8R2_FB1                        ((uint32_t)0x00000002)        /*!< Filter bit 1 */
N#define  CAN_F8R2_FB2                        ((uint32_t)0x00000004)        /*!< Filter bit 2 */
N#define  CAN_F8R2_FB3                        ((uint32_t)0x00000008)        /*!< Filter bit 3 */
N#define  CAN_F8R2_FB4                        ((uint32_t)0x00000010)        /*!< Filter bit 4 */
N#define  CAN_F8R2_FB5                        ((uint32_t)0x00000020)        /*!< Filter bit 5 */
N#define  CAN_F8R2_FB6                        ((uint32_t)0x00000040)        /*!< Filter bit 6 */
N#define  CAN_F8R2_FB7                        ((uint32_t)0x00000080)        /*!< Filter bit 7 */
N#define  CAN_F8R2_FB8                        ((uint32_t)0x00000100)        /*!< Filter bit 8 */
N#define  CAN_F8R2_FB9                        ((uint32_t)0x00000200)        /*!< Filter bit 9 */
N#define  CAN_F8R2_FB10                       ((uint32_t)0x00000400)        /*!< Filter bit 10 */
N#define  CAN_F8R2_FB11                       ((uint32_t)0x00000800)        /*!< Filter bit 11 */
N#define  CAN_F8R2_FB12                       ((uint32_t)0x00001000)        /*!< Filter bit 12 */
N#define  CAN_F8R2_FB13                       ((uint32_t)0x00002000)        /*!< Filter bit 13 */
N#define  CAN_F8R2_FB14                       ((uint32_t)0x00004000)        /*!< Filter bit 14 */
N#define  CAN_F8R2_FB15                       ((uint32_t)0x00008000)        /*!< Filter bit 15 */
N#define  CAN_F8R2_FB16                       ((uint32_t)0x00010000)        /*!< Filter bit 16 */
N#define  CAN_F8R2_FB17                       ((uint32_t)0x00020000)        /*!< Filter bit 17 */
N#define  CAN_F8R2_FB18                       ((uint32_t)0x00040000)        /*!< Filter bit 18 */
N#define  CAN_F8R2_FB19                       ((uint32_t)0x00080000)        /*!< Filter bit 19 */
N#define  CAN_F8R2_FB20                       ((uint32_t)0x00100000)        /*!< Filter bit 20 */
N#define  CAN_F8R2_FB21                       ((uint32_t)0x00200000)        /*!< Filter bit 21 */
N#define  CAN_F8R2_FB22                       ((uint32_t)0x00400000)        /*!< Filter bit 22 */
N#define  CAN_F8R2_FB23                       ((uint32_t)0x00800000)        /*!< Filter bit 23 */
N#define  CAN_F8R2_FB24                       ((uint32_t)0x01000000)        /*!< Filter bit 24 */
N#define  CAN_F8R2_FB25                       ((uint32_t)0x02000000)        /*!< Filter bit 25 */
N#define  CAN_F8R2_FB26                       ((uint32_t)0x04000000)        /*!< Filter bit 26 */
N#define  CAN_F8R2_FB27                       ((uint32_t)0x08000000)        /*!< Filter bit 27 */
N#define  CAN_F8R2_FB28                       ((uint32_t)0x10000000)        /*!< Filter bit 28 */
N#define  CAN_F8R2_FB29                       ((uint32_t)0x20000000)        /*!< Filter bit 29 */
N#define  CAN_F8R2_FB30                       ((uint32_t)0x40000000)        /*!< Filter bit 30 */
N#define  CAN_F8R2_FB31                       ((uint32_t)0x80000000)        /*!< Filter bit 31 */
N
N/*******************  Bit definition for CAN_F9R2 register  *******************/
N#define  CAN_F9R2_FB0                        ((uint32_t)0x00000001)        /*!< Filter bit 0 */
N#define  CAN_F9R2_FB1                        ((uint32_t)0x00000002)        /*!< Filter bit 1 */
N#define  CAN_F9R2_FB2                        ((uint32_t)0x00000004)        /*!< Filter bit 2 */
N#define  CAN_F9R2_FB3                        ((uint32_t)0x00000008)        /*!< Filter bit 3 */
N#define  CAN_F9R2_FB4                        ((uint32_t)0x00000010)        /*!< Filter bit 4 */
N#define  CAN_F9R2_FB5                        ((uint32_t)0x00000020)        /*!< Filter bit 5 */
N#define  CAN_F9R2_FB6                        ((uint32_t)0x00000040)        /*!< Filter bit 6 */
N#define  CAN_F9R2_FB7                        ((uint32_t)0x00000080)        /*!< Filter bit 7 */
N#define  CAN_F9R2_FB8                        ((uint32_t)0x00000100)        /*!< Filter bit 8 */
N#define  CAN_F9R2_FB9                        ((uint32_t)0x00000200)        /*!< Filter bit 9 */
N#define  CAN_F9R2_FB10                       ((uint32_t)0x00000400)        /*!< Filter bit 10 */
N#define  CAN_F9R2_FB11                       ((uint32_t)0x00000800)        /*!< Filter bit 11 */
N#define  CAN_F9R2_FB12                       ((uint32_t)0x00001000)        /*!< Filter bit 12 */
N#define  CAN_F9R2_FB13                       ((uint32_t)0x00002000)        /*!< Filter bit 13 */
N#define  CAN_F9R2_FB14                       ((uint32_t)0x00004000)        /*!< Filter bit 14 */
N#define  CAN_F9R2_FB15                       ((uint32_t)0x00008000)        /*!< Filter bit 15 */
N#define  CAN_F9R2_FB16                       ((uint32_t)0x00010000)        /*!< Filter bit 16 */
N#define  CAN_F9R2_FB17                       ((uint32_t)0x00020000)        /*!< Filter bit 17 */
N#define  CAN_F9R2_FB18                       ((uint32_t)0x00040000)        /*!< Filter bit 18 */
N#define  CAN_F9R2_FB19                       ((uint32_t)0x00080000)        /*!< Filter bit 19 */
N#define  CAN_F9R2_FB20                       ((uint32_t)0x00100000)        /*!< Filter bit 20 */
N#define  CAN_F9R2_FB21                       ((uint32_t)0x00200000)        /*!< Filter bit 21 */
N#define  CAN_F9R2_FB22                       ((uint32_t)0x00400000)        /*!< Filter bit 22 */
N#define  CAN_F9R2_FB23                       ((uint32_t)0x00800000)        /*!< Filter bit 23 */
N#define  CAN_F9R2_FB24                       ((uint32_t)0x01000000)        /*!< Filter bit 24 */
N#define  CAN_F9R2_FB25                       ((uint32_t)0x02000000)        /*!< Filter bit 25 */
N#define  CAN_F9R2_FB26                       ((uint32_t)0x04000000)        /*!< Filter bit 26 */
N#define  CAN_F9R2_FB27                       ((uint32_t)0x08000000)        /*!< Filter bit 27 */
N#define  CAN_F9R2_FB28                       ((uint32_t)0x10000000)        /*!< Filter bit 28 */
N#define  CAN_F9R2_FB29                       ((uint32_t)0x20000000)        /*!< Filter bit 29 */
N#define  CAN_F9R2_FB30                       ((uint32_t)0x40000000)        /*!< Filter bit 30 */
N#define  CAN_F9R2_FB31                       ((uint32_t)0x80000000)        /*!< Filter bit 31 */
N
N/*******************  Bit definition for CAN_F10R2 register  ******************/
N#define  CAN_F10R2_FB0                       ((uint32_t)0x00000001)        /*!< Filter bit 0 */
N#define  CAN_F10R2_FB1                       ((uint32_t)0x00000002)        /*!< Filter bit 1 */
N#define  CAN_F10R2_FB2                       ((uint32_t)0x00000004)        /*!< Filter bit 2 */
N#define  CAN_F10R2_FB3                       ((uint32_t)0x00000008)        /*!< Filter bit 3 */
N#define  CAN_F10R2_FB4                       ((uint32_t)0x00000010)        /*!< Filter bit 4 */
N#define  CAN_F10R2_FB5                       ((uint32_t)0x00000020)        /*!< Filter bit 5 */
N#define  CAN_F10R2_FB6                       ((uint32_t)0x00000040)        /*!< Filter bit 6 */
N#define  CAN_F10R2_FB7                       ((uint32_t)0x00000080)        /*!< Filter bit 7 */
N#define  CAN_F10R2_FB8                       ((uint32_t)0x00000100)        /*!< Filter bit 8 */
N#define  CAN_F10R2_FB9                       ((uint32_t)0x00000200)        /*!< Filter bit 9 */
N#define  CAN_F10R2_FB10                      ((uint32_t)0x00000400)        /*!< Filter bit 10 */
N#define  CAN_F10R2_FB11                      ((uint32_t)0x00000800)        /*!< Filter bit 11 */
N#define  CAN_F10R2_FB12                      ((uint32_t)0x00001000)        /*!< Filter bit 12 */
N#define  CAN_F10R2_FB13                      ((uint32_t)0x00002000)        /*!< Filter bit 13 */
N#define  CAN_F10R2_FB14                      ((uint32_t)0x00004000)        /*!< Filter bit 14 */
N#define  CAN_F10R2_FB15                      ((uint32_t)0x00008000)        /*!< Filter bit 15 */
N#define  CAN_F10R2_FB16                      ((uint32_t)0x00010000)        /*!< Filter bit 16 */
N#define  CAN_F10R2_FB17                      ((uint32_t)0x00020000)        /*!< Filter bit 17 */
N#define  CAN_F10R2_FB18                      ((uint32_t)0x00040000)        /*!< Filter bit 18 */
N#define  CAN_F10R2_FB19                      ((uint32_t)0x00080000)        /*!< Filter bit 19 */
N#define  CAN_F10R2_FB20                      ((uint32_t)0x00100000)        /*!< Filter bit 20 */
N#define  CAN_F10R2_FB21                      ((uint32_t)0x00200000)        /*!< Filter bit 21 */
N#define  CAN_F10R2_FB22                      ((uint32_t)0x00400000)        /*!< Filter bit 22 */
N#define  CAN_F10R2_FB23                      ((uint32_t)0x00800000)        /*!< Filter bit 23 */
N#define  CAN_F10R2_FB24                      ((uint32_t)0x01000000)        /*!< Filter bit 24 */
N#define  CAN_F10R2_FB25                      ((uint32_t)0x02000000)        /*!< Filter bit 25 */
N#define  CAN_F10R2_FB26                      ((uint32_t)0x04000000)        /*!< Filter bit 26 */
N#define  CAN_F10R2_FB27                      ((uint32_t)0x08000000)        /*!< Filter bit 27 */
N#define  CAN_F10R2_FB28                      ((uint32_t)0x10000000)        /*!< Filter bit 28 */
N#define  CAN_F10R2_FB29                      ((uint32_t)0x20000000)        /*!< Filter bit 29 */
N#define  CAN_F10R2_FB30                      ((uint32_t)0x40000000)        /*!< Filter bit 30 */
N#define  CAN_F10R2_FB31                      ((uint32_t)0x80000000)        /*!< Filter bit 31 */
N
N/*******************  Bit definition for CAN_F11R2 register  ******************/
N#define  CAN_F11R2_FB0                       ((uint32_t)0x00000001)        /*!< Filter bit 0 */
N#define  CAN_F11R2_FB1                       ((uint32_t)0x00000002)        /*!< Filter bit 1 */
N#define  CAN_F11R2_FB2                       ((uint32_t)0x00000004)        /*!< Filter bit 2 */
N#define  CAN_F11R2_FB3                       ((uint32_t)0x00000008)        /*!< Filter bit 3 */
N#define  CAN_F11R2_FB4                       ((uint32_t)0x00000010)        /*!< Filter bit 4 */
N#define  CAN_F11R2_FB5                       ((uint32_t)0x00000020)        /*!< Filter bit 5 */
N#define  CAN_F11R2_FB6                       ((uint32_t)0x00000040)        /*!< Filter bit 6 */
N#define  CAN_F11R2_FB7                       ((uint32_t)0x00000080)        /*!< Filter bit 7 */
N#define  CAN_F11R2_FB8                       ((uint32_t)0x00000100)        /*!< Filter bit 8 */
N#define  CAN_F11R2_FB9                       ((uint32_t)0x00000200)        /*!< Filter bit 9 */
N#define  CAN_F11R2_FB10                      ((uint32_t)0x00000400)        /*!< Filter bit 10 */
N#define  CAN_F11R2_FB11                      ((uint32_t)0x00000800)        /*!< Filter bit 11 */
N#define  CAN_F11R2_FB12                      ((uint32_t)0x00001000)        /*!< Filter bit 12 */
N#define  CAN_F11R2_FB13                      ((uint32_t)0x00002000)        /*!< Filter bit 13 */
N#define  CAN_F11R2_FB14                      ((uint32_t)0x00004000)        /*!< Filter bit 14 */
N#define  CAN_F11R2_FB15                      ((uint32_t)0x00008000)        /*!< Filter bit 15 */
N#define  CAN_F11R2_FB16                      ((uint32_t)0x00010000)        /*!< Filter bit 16 */
N#define  CAN_F11R2_FB17                      ((uint32_t)0x00020000)        /*!< Filter bit 17 */
N#define  CAN_F11R2_FB18                      ((uint32_t)0x00040000)        /*!< Filter bit 18 */
N#define  CAN_F11R2_FB19                      ((uint32_t)0x00080000)        /*!< Filter bit 19 */
N#define  CAN_F11R2_FB20                      ((uint32_t)0x00100000)        /*!< Filter bit 20 */
N#define  CAN_F11R2_FB21                      ((uint32_t)0x00200000)        /*!< Filter bit 21 */
N#define  CAN_F11R2_FB22                      ((uint32_t)0x00400000)        /*!< Filter bit 22 */
N#define  CAN_F11R2_FB23                      ((uint32_t)0x00800000)        /*!< Filter bit 23 */
N#define  CAN_F11R2_FB24                      ((uint32_t)0x01000000)        /*!< Filter bit 24 */
N#define  CAN_F11R2_FB25                      ((uint32_t)0x02000000)        /*!< Filter bit 25 */
N#define  CAN_F11R2_FB26                      ((uint32_t)0x04000000)        /*!< Filter bit 26 */
N#define  CAN_F11R2_FB27                      ((uint32_t)0x08000000)        /*!< Filter bit 27 */
N#define  CAN_F11R2_FB28                      ((uint32_t)0x10000000)        /*!< Filter bit 28 */
N#define  CAN_F11R2_FB29                      ((uint32_t)0x20000000)        /*!< Filter bit 29 */
N#define  CAN_F11R2_FB30                      ((uint32_t)0x40000000)        /*!< Filter bit 30 */
N#define  CAN_F11R2_FB31                      ((uint32_t)0x80000000)        /*!< Filter bit 31 */
N
N/*******************  Bit definition for CAN_F12R2 register  ******************/
N#define  CAN_F12R2_FB0                       ((uint32_t)0x00000001)        /*!< Filter bit 0 */
N#define  CAN_F12R2_FB1                       ((uint32_t)0x00000002)        /*!< Filter bit 1 */
N#define  CAN_F12R2_FB2                       ((uint32_t)0x00000004)        /*!< Filter bit 2 */
N#define  CAN_F12R2_FB3                       ((uint32_t)0x00000008)        /*!< Filter bit 3 */
N#define  CAN_F12R2_FB4                       ((uint32_t)0x00000010)        /*!< Filter bit 4 */
N#define  CAN_F12R2_FB5                       ((uint32_t)0x00000020)        /*!< Filter bit 5 */
N#define  CAN_F12R2_FB6                       ((uint32_t)0x00000040)        /*!< Filter bit 6 */
N#define  CAN_F12R2_FB7                       ((uint32_t)0x00000080)        /*!< Filter bit 7 */
N#define  CAN_F12R2_FB8                       ((uint32_t)0x00000100)        /*!< Filter bit 8 */
N#define  CAN_F12R2_FB9                       ((uint32_t)0x00000200)        /*!< Filter bit 9 */
N#define  CAN_F12R2_FB10                      ((uint32_t)0x00000400)        /*!< Filter bit 10 */
N#define  CAN_F12R2_FB11                      ((uint32_t)0x00000800)        /*!< Filter bit 11 */
N#define  CAN_F12R2_FB12                      ((uint32_t)0x00001000)        /*!< Filter bit 12 */
N#define  CAN_F12R2_FB13                      ((uint32_t)0x00002000)        /*!< Filter bit 13 */
N#define  CAN_F12R2_FB14                      ((uint32_t)0x00004000)        /*!< Filter bit 14 */
N#define  CAN_F12R2_FB15                      ((uint32_t)0x00008000)        /*!< Filter bit 15 */
N#define  CAN_F12R2_FB16                      ((uint32_t)0x00010000)        /*!< Filter bit 16 */
N#define  CAN_F12R2_FB17                      ((uint32_t)0x00020000)        /*!< Filter bit 17 */
N#define  CAN_F12R2_FB18                      ((uint32_t)0x00040000)        /*!< Filter bit 18 */
N#define  CAN_F12R2_FB19                      ((uint32_t)0x00080000)        /*!< Filter bit 19 */
N#define  CAN_F12R2_FB20                      ((uint32_t)0x00100000)        /*!< Filter bit 20 */
N#define  CAN_F12R2_FB21                      ((uint32_t)0x00200000)        /*!< Filter bit 21 */
N#define  CAN_F12R2_FB22                      ((uint32_t)0x00400000)        /*!< Filter bit 22 */
N#define  CAN_F12R2_FB23                      ((uint32_t)0x00800000)        /*!< Filter bit 23 */
N#define  CAN_F12R2_FB24                      ((uint32_t)0x01000000)        /*!< Filter bit 24 */
N#define  CAN_F12R2_FB25                      ((uint32_t)0x02000000)        /*!< Filter bit 25 */
N#define  CAN_F12R2_FB26                      ((uint32_t)0x04000000)        /*!< Filter bit 26 */
N#define  CAN_F12R2_FB27                      ((uint32_t)0x08000000)        /*!< Filter bit 27 */
N#define  CAN_F12R2_FB28                      ((uint32_t)0x10000000)        /*!< Filter bit 28 */
N#define  CAN_F12R2_FB29                      ((uint32_t)0x20000000)        /*!< Filter bit 29 */
N#define  CAN_F12R2_FB30                      ((uint32_t)0x40000000)        /*!< Filter bit 30 */
N#define  CAN_F12R2_FB31                      ((uint32_t)0x80000000)        /*!< Filter bit 31 */
N
N/*******************  Bit definition for CAN_F13R2 register  ******************/
N#define  CAN_F13R2_FB0                       ((uint32_t)0x00000001)        /*!< Filter bit 0 */
N#define  CAN_F13R2_FB1                       ((uint32_t)0x00000002)        /*!< Filter bit 1 */
N#define  CAN_F13R2_FB2                       ((uint32_t)0x00000004)        /*!< Filter bit 2 */
N#define  CAN_F13R2_FB3                       ((uint32_t)0x00000008)        /*!< Filter bit 3 */
N#define  CAN_F13R2_FB4                       ((uint32_t)0x00000010)        /*!< Filter bit 4 */
N#define  CAN_F13R2_FB5                       ((uint32_t)0x00000020)        /*!< Filter bit 5 */
N#define  CAN_F13R2_FB6                       ((uint32_t)0x00000040)        /*!< Filter bit 6 */
N#define  CAN_F13R2_FB7                       ((uint32_t)0x00000080)        /*!< Filter bit 7 */
N#define  CAN_F13R2_FB8                       ((uint32_t)0x00000100)        /*!< Filter bit 8 */
N#define  CAN_F13R2_FB9                       ((uint32_t)0x00000200)        /*!< Filter bit 9 */
N#define  CAN_F13R2_FB10                      ((uint32_t)0x00000400)        /*!< Filter bit 10 */
N#define  CAN_F13R2_FB11                      ((uint32_t)0x00000800)        /*!< Filter bit 11 */
N#define  CAN_F13R2_FB12                      ((uint32_t)0x00001000)        /*!< Filter bit 12 */
N#define  CAN_F13R2_FB13                      ((uint32_t)0x00002000)        /*!< Filter bit 13 */
N#define  CAN_F13R2_FB14                      ((uint32_t)0x00004000)        /*!< Filter bit 14 */
N#define  CAN_F13R2_FB15                      ((uint32_t)0x00008000)        /*!< Filter bit 15 */
N#define  CAN_F13R2_FB16                      ((uint32_t)0x00010000)        /*!< Filter bit 16 */
N#define  CAN_F13R2_FB17                      ((uint32_t)0x00020000)        /*!< Filter bit 17 */
N#define  CAN_F13R2_FB18                      ((uint32_t)0x00040000)        /*!< Filter bit 18 */
N#define  CAN_F13R2_FB19                      ((uint32_t)0x00080000)        /*!< Filter bit 19 */
N#define  CAN_F13R2_FB20                      ((uint32_t)0x00100000)        /*!< Filter bit 20 */
N#define  CAN_F13R2_FB21                      ((uint32_t)0x00200000)        /*!< Filter bit 21 */
N#define  CAN_F13R2_FB22                      ((uint32_t)0x00400000)        /*!< Filter bit 22 */
N#define  CAN_F13R2_FB23                      ((uint32_t)0x00800000)        /*!< Filter bit 23 */
N#define  CAN_F13R2_FB24                      ((uint32_t)0x01000000)        /*!< Filter bit 24 */
N#define  CAN_F13R2_FB25                      ((uint32_t)0x02000000)        /*!< Filter bit 25 */
N#define  CAN_F13R2_FB26                      ((uint32_t)0x04000000)        /*!< Filter bit 26 */
N#define  CAN_F13R2_FB27                      ((uint32_t)0x08000000)        /*!< Filter bit 27 */
N#define  CAN_F13R2_FB28                      ((uint32_t)0x10000000)        /*!< Filter bit 28 */
N#define  CAN_F13R2_FB29                      ((uint32_t)0x20000000)        /*!< Filter bit 29 */
N#define  CAN_F13R2_FB30                      ((uint32_t)0x40000000)        /*!< Filter bit 30 */
N#define  CAN_F13R2_FB31                      ((uint32_t)0x80000000)        /*!< Filter bit 31 */
N
N/******************************************************************************/
N/*                                                                            */
N/*                        Serial Peripheral Interface                         */
N/*                                                                            */
N/******************************************************************************/
N
N/*******************  Bit definition for SPI_CR1 register  ********************/
N#define  SPI_CR1_CPHA                        ((uint16_t)0x0001)            /*!< Clock Phase */
N#define  SPI_CR1_CPOL                        ((uint16_t)0x0002)            /*!< Clock Polarity */
N#define  SPI_CR1_MSTR                        ((uint16_t)0x0004)            /*!< Master Selection */
N
N#define  SPI_CR1_BR                          ((uint16_t)0x0038)            /*!< BR[2:0] bits (Baud Rate Control) */
N#define  SPI_CR1_BR_0                        ((uint16_t)0x0008)            /*!< Bit 0 */
N#define  SPI_CR1_BR_1                        ((uint16_t)0x0010)            /*!< Bit 1 */
N#define  SPI_CR1_BR_2                        ((uint16_t)0x0020)            /*!< Bit 2 */
N
N#define  SPI_CR1_SPE                         ((uint16_t)0x0040)            /*!< SPI Enable */
N#define  SPI_CR1_LSBFIRST                    ((uint16_t)0x0080)            /*!< Frame Format */
N#define  SPI_CR1_SSI                         ((uint16_t)0x0100)            /*!< Internal slave select */
N#define  SPI_CR1_SSM                         ((uint16_t)0x0200)            /*!< Software slave management */
N#define  SPI_CR1_RXONLY                      ((uint16_t)0x0400)            /*!< Receive only */
N#define  SPI_CR1_DFF                         ((uint16_t)0x0800)            /*!< Data Frame Format */
N#define  SPI_CR1_CRCNEXT                     ((uint16_t)0x1000)            /*!< Transmit CRC next */
N#define  SPI_CR1_CRCEN                       ((uint16_t)0x2000)            /*!< Hardware CRC calculation enable */
N#define  SPI_CR1_BIDIOE                      ((uint16_t)0x4000)            /*!< Output enable in bidirectional mode */
N#define  SPI_CR1_BIDIMODE                    ((uint16_t)0x8000)            /*!< Bidirectional data mode enable */
N
N/*******************  Bit definition for SPI_CR2 register  ********************/
N#define  SPI_CR2_RXDMAEN                     ((uint8_t)0x01)               /*!< Rx Buffer DMA Enable */
N#define  SPI_CR2_TXDMAEN                     ((uint8_t)0x02)               /*!< Tx Buffer DMA Enable */
N#define  SPI_CR2_SSOE                        ((uint8_t)0x04)               /*!< SS Output Enable */
N#define  SPI_CR2_ERRIE                       ((uint8_t)0x20)               /*!< Error Interrupt Enable */
N#define  SPI_CR2_RXNEIE                      ((uint8_t)0x40)               /*!< RX buffer Not Empty Interrupt Enable */
N#define  SPI_CR2_TXEIE                       ((uint8_t)0x80)               /*!< Tx buffer Empty Interrupt Enable */
N
N/********************  Bit definition for SPI_SR register  ********************/
N#define  SPI_SR_RXNE                         ((uint8_t)0x01)               /*!< Receive buffer Not Empty */
N#define  SPI_SR_TXE                          ((uint8_t)0x02)               /*!< Transmit buffer Empty */
N#define  SPI_SR_CHSIDE                       ((uint8_t)0x04)               /*!< Channel side */
N#define  SPI_SR_UDR                          ((uint8_t)0x08)               /*!< Underrun flag */
N#define  SPI_SR_CRCERR                       ((uint8_t)0x10)               /*!< CRC Error flag */
N#define  SPI_SR_MODF                         ((uint8_t)0x20)               /*!< Mode fault */
N#define  SPI_SR_OVR                          ((uint8_t)0x40)               /*!< Overrun flag */
N#define  SPI_SR_BSY                          ((uint8_t)0x80)               /*!< Busy flag */
N
N/********************  Bit definition for SPI_DR register  ********************/
N#define  SPI_DR_DR                           ((uint16_t)0xFFFF)            /*!< Data Register */
N
N/*******************  Bit definition for SPI_CRCPR register  ******************/
N#define  SPI_CRCPR_CRCPOLY                   ((uint16_t)0xFFFF)            /*!< CRC polynomial register */
N
N/******************  Bit definition for SPI_RXCRCR register  ******************/
N#define  SPI_RXCRCR_RXCRC                    ((uint16_t)0xFFFF)            /*!< Rx CRC Register */
N
N/******************  Bit definition for SPI_TXCRCR register  ******************/
N#define  SPI_TXCRCR_TXCRC                    ((uint16_t)0xFFFF)            /*!< Tx CRC Register */
N
N/******************  Bit definition for SPI_I2SCFGR register  *****************/
N#define  SPI_I2SCFGR_CHLEN                   ((uint16_t)0x0001)            /*!< Channel length (number of bits per audio channel) */
N
N#define  SPI_I2SCFGR_DATLEN                  ((uint16_t)0x0006)            /*!< DATLEN[1:0] bits (Data length to be transferred) */
N#define  SPI_I2SCFGR_DATLEN_0                ((uint16_t)0x0002)            /*!< Bit 0 */
N#define  SPI_I2SCFGR_DATLEN_1                ((uint16_t)0x0004)            /*!< Bit 1 */
N
N#define  SPI_I2SCFGR_CKPOL                   ((uint16_t)0x0008)            /*!< steady state clock polarity */
N
N#define  SPI_I2SCFGR_I2SSTD                  ((uint16_t)0x0030)            /*!< I2SSTD[1:0] bits (I2S standard selection) */
N#define  SPI_I2SCFGR_I2SSTD_0                ((uint16_t)0x0010)            /*!< Bit 0 */
N#define  SPI_I2SCFGR_I2SSTD_1                ((uint16_t)0x0020)            /*!< Bit 1 */
N
N#define  SPI_I2SCFGR_PCMSYNC                 ((uint16_t)0x0080)            /*!< PCM frame synchronization */
N
N#define  SPI_I2SCFGR_I2SCFG                  ((uint16_t)0x0300)            /*!< I2SCFG[1:0] bits (I2S configuration mode) */
N#define  SPI_I2SCFGR_I2SCFG_0                ((uint16_t)0x0100)            /*!< Bit 0 */
N#define  SPI_I2SCFGR_I2SCFG_1                ((uint16_t)0x0200)            /*!< Bit 1 */
N
N#define  SPI_I2SCFGR_I2SE                    ((uint16_t)0x0400)            /*!< I2S Enable */
N#define  SPI_I2SCFGR_I2SMOD                  ((uint16_t)0x0800)            /*!< I2S mode selection */
N
N/******************  Bit definition for SPI_I2SPR register  *******************/
N#define  SPI_I2SPR_I2SDIV                    ((uint16_t)0x00FF)            /*!< I2S Linear prescaler */
N#define  SPI_I2SPR_ODD                       ((uint16_t)0x0100)            /*!< Odd factor for the prescaler */
N#define  SPI_I2SPR_MCKOE                     ((uint16_t)0x0200)            /*!< Master Clock Output Enable */
N
N/******************************************************************************/
N/*                                                                            */
N/*                      Inter-integrated Circuit Interface                    */
N/*                                                                            */
N/******************************************************************************/
N
N/*******************  Bit definition for I2C_CR1 register  ********************/
N#define  I2C_CR1_PE                          ((uint16_t)0x0001)            /*!< Peripheral Enable */
N#define  I2C_CR1_SMBUS                       ((uint16_t)0x0002)            /*!< SMBus Mode */
N#define  I2C_CR1_SMBTYPE                     ((uint16_t)0x0008)            /*!< SMBus Type */
N#define  I2C_CR1_ENARP                       ((uint16_t)0x0010)            /*!< ARP Enable */
N#define  I2C_CR1_ENPEC                       ((uint16_t)0x0020)            /*!< PEC Enable */
N#define  I2C_CR1_ENGC                        ((uint16_t)0x0040)            /*!< General Call Enable */
N#define  I2C_CR1_NOSTRETCH                   ((uint16_t)0x0080)            /*!< Clock Stretching Disable (Slave mode) */
N#define  I2C_CR1_START                       ((uint16_t)0x0100)            /*!< Start Generation */
N#define  I2C_CR1_STOP                        ((uint16_t)0x0200)            /*!< Stop Generation */
N#define  I2C_CR1_ACK                         ((uint16_t)0x0400)            /*!< Acknowledge Enable */
N#define  I2C_CR1_POS                         ((uint16_t)0x0800)            /*!< Acknowledge/PEC Position (for data reception) */
N#define  I2C_CR1_PEC                         ((uint16_t)0x1000)            /*!< Packet Error Checking */
N#define  I2C_CR1_ALERT                       ((uint16_t)0x2000)            /*!< SMBus Alert */
N#define  I2C_CR1_SWRST                       ((uint16_t)0x8000)            /*!< Software Reset */
N
N/*******************  Bit definition for I2C_CR2 register  ********************/
N#define  I2C_CR2_FREQ                        ((uint16_t)0x003F)            /*!< FREQ[5:0] bits (Peripheral Clock Frequency) */
N#define  I2C_CR2_FREQ_0                      ((uint16_t)0x0001)            /*!< Bit 0 */
N#define  I2C_CR2_FREQ_1                      ((uint16_t)0x0002)            /*!< Bit 1 */
N#define  I2C_CR2_FREQ_2                      ((uint16_t)0x0004)            /*!< Bit 2 */
N#define  I2C_CR2_FREQ_3                      ((uint16_t)0x0008)            /*!< Bit 3 */
N#define  I2C_CR2_FREQ_4                      ((uint16_t)0x0010)            /*!< Bit 4 */
N#define  I2C_CR2_FREQ_5                      ((uint16_t)0x0020)            /*!< Bit 5 */
N
N#define  I2C_CR2_ITERREN                     ((uint16_t)0x0100)            /*!< Error Interrupt Enable */
N#define  I2C_CR2_ITEVTEN                     ((uint16_t)0x0200)            /*!< Event Interrupt Enable */
N#define  I2C_CR2_ITBUFEN                     ((uint16_t)0x0400)            /*!< Buffer Interrupt Enable */
N#define  I2C_CR2_DMAEN                       ((uint16_t)0x0800)            /*!< DMA Requests Enable */
N#define  I2C_CR2_LAST                        ((uint16_t)0x1000)            /*!< DMA Last Transfer */
N
N/*******************  Bit definition for I2C_OAR1 register  *******************/
N#define  I2C_OAR1_ADD1_7                     ((uint16_t)0x00FE)            /*!< Interface Address */
N#define  I2C_OAR1_ADD8_9                     ((uint16_t)0x0300)            /*!< Interface Address */
N
N#define  I2C_OAR1_ADD0                       ((uint16_t)0x0001)            /*!< Bit 0 */
N#define  I2C_OAR1_ADD1                       ((uint16_t)0x0002)            /*!< Bit 1 */
N#define  I2C_OAR1_ADD2                       ((uint16_t)0x0004)            /*!< Bit 2 */
N#define  I2C_OAR1_ADD3                       ((uint16_t)0x0008)            /*!< Bit 3 */
N#define  I2C_OAR1_ADD4                       ((uint16_t)0x0010)            /*!< Bit 4 */
N#define  I2C_OAR1_ADD5                       ((uint16_t)0x0020)            /*!< Bit 5 */
N#define  I2C_OAR1_ADD6                       ((uint16_t)0x0040)            /*!< Bit 6 */
N#define  I2C_OAR1_ADD7                       ((uint16_t)0x0080)            /*!< Bit 7 */
N#define  I2C_OAR1_ADD8                       ((uint16_t)0x0100)            /*!< Bit 8 */
N#define  I2C_OAR1_ADD9                       ((uint16_t)0x0200)            /*!< Bit 9 */
N
N#define  I2C_OAR1_ADDMODE                    ((uint16_t)0x8000)            /*!< Addressing Mode (Slave mode) */
N
N/*******************  Bit definition for I2C_OAR2 register  *******************/
N#define  I2C_OAR2_ENDUAL                     ((uint8_t)0x01)               /*!< Dual addressing mode enable */
N#define  I2C_OAR2_ADD2                       ((uint8_t)0xFE)               /*!< Interface address */
N
N/********************  Bit definition for I2C_DR register  ********************/
N#define  I2C_DR_DR                           ((uint8_t)0xFF)               /*!< 8-bit Data Register */
N
N/*******************  Bit definition for I2C_SR1 register  ********************/
N#define  I2C_SR1_SB                          ((uint16_t)0x0001)            /*!< Start Bit (Master mode) */
N#define  I2C_SR1_ADDR                        ((uint16_t)0x0002)            /*!< Address sent (master mode)/matched (slave mode) */
N#define  I2C_SR1_BTF                         ((uint16_t)0x0004)            /*!< Byte Transfer Finished */
N#define  I2C_SR1_ADD10                       ((uint16_t)0x0008)            /*!< 10-bit header sent (Master mode) */
N#define  I2C_SR1_STOPF                       ((uint16_t)0x0010)            /*!< Stop detection (Slave mode) */
N#define  I2C_SR1_RXNE                        ((uint16_t)0x0040)            /*!< Data Register not Empty (receivers) */
N#define  I2C_SR1_TXE                         ((uint16_t)0x0080)            /*!< Data Register Empty (transmitters) */
N#define  I2C_SR1_BERR                        ((uint16_t)0x0100)            /*!< Bus Error */
N#define  I2C_SR1_ARLO                        ((uint16_t)0x0200)            /*!< Arbitration Lost (master mode) */
N#define  I2C_SR1_AF                          ((uint16_t)0x0400)            /*!< Acknowledge Failure */
N#define  I2C_SR1_OVR                         ((uint16_t)0x0800)            /*!< Overrun/Underrun */
N#define  I2C_SR1_PECERR                      ((uint16_t)0x1000)            /*!< PEC Error in reception */
N#define  I2C_SR1_TIMEOUT                     ((uint16_t)0x4000)            /*!< Timeout or Tlow Error */
N#define  I2C_SR1_SMBALERT                    ((uint16_t)0x8000)            /*!< SMBus Alert */
N
N/*******************  Bit definition for I2C_SR2 register  ********************/
N#define  I2C_SR2_MSL                         ((uint16_t)0x0001)            /*!< Master/Slave */
N#define  I2C_SR2_BUSY                        ((uint16_t)0x0002)            /*!< Bus Busy */
N#define  I2C_SR2_TRA                         ((uint16_t)0x0004)            /*!< Transmitter/Receiver */
N#define  I2C_SR2_GENCALL                     ((uint16_t)0x0010)            /*!< General Call Address (Slave mode) */
N#define  I2C_SR2_SMBDEFAULT                  ((uint16_t)0x0020)            /*!< SMBus Device Default Address (Slave mode) */
N#define  I2C_SR2_SMBHOST                     ((uint16_t)0x0040)            /*!< SMBus Host Header (Slave mode) */
N#define  I2C_SR2_DUALF                       ((uint16_t)0x0080)            /*!< Dual Flag (Slave mode) */
N#define  I2C_SR2_PEC                         ((uint16_t)0xFF00)            /*!< Packet Error Checking Register */
N
N/*******************  Bit definition for I2C_CCR register  ********************/
N#define  I2C_CCR_CCR                         ((uint16_t)0x0FFF)            /*!< Clock Control Register in Fast/Standard mode (Master mode) */
N#define  I2C_CCR_DUTY                        ((uint16_t)0x4000)            /*!< Fast Mode Duty Cycle */
N#define  I2C_CCR_FS                          ((uint16_t)0x8000)            /*!< I2C Master Mode Selection */
N
N/******************  Bit definition for I2C_TRISE register  *******************/
N#define  I2C_TRISE_TRISE                     ((uint8_t)0x3F)               /*!< Maximum Rise Time in Fast/Standard mode (Master mode) */
N
N/******************************************************************************/
N/*                                                                            */
N/*         Universal Synchronous Asynchronous Receiver Transmitter            */
N/*                                                                            */
N/******************************************************************************/
N
N/*******************  Bit definition for USART_SR register  *******************/
N#define  USART_SR_PE                         ((uint16_t)0x0001)            /*!< Parity Error */
N#define  USART_SR_FE                         ((uint16_t)0x0002)            /*!< Framing Error */
N#define  USART_SR_NE                         ((uint16_t)0x0004)            /*!< Noise Error Flag */
N#define  USART_SR_ORE                        ((uint16_t)0x0008)            /*!< OverRun Error */
N#define  USART_SR_IDLE                       ((uint16_t)0x0010)            /*!< IDLE line detected */
N#define  USART_SR_RXNE                       ((uint16_t)0x0020)            /*!< Read Data Register Not Empty */
N#define  USART_SR_TC                         ((uint16_t)0x0040)            /*!< Transmission Complete */
N#define  USART_SR_TXE                        ((uint16_t)0x0080)            /*!< Transmit Data Register Empty */
N#define  USART_SR_LBD                        ((uint16_t)0x0100)            /*!< LIN Break Detection Flag */
N#define  USART_SR_CTS                        ((uint16_t)0x0200)            /*!< CTS Flag */
N
N/*******************  Bit definition for USART_DR register  *******************/
N#define  USART_DR_DR                         ((uint16_t)0x01FF)            /*!< Data value */
N
N/******************  Bit definition for USART_BRR register  *******************/
N#define  USART_BRR_DIV_Fraction              ((uint16_t)0x000F)            /*!< Fraction of USARTDIV */
N#define  USART_BRR_DIV_Mantissa              ((uint16_t)0xFFF0)            /*!< Mantissa of USARTDIV */
N
N/******************  Bit definition for USART_CR1 register  *******************/
N#define  USART_CR1_SBK                       ((uint16_t)0x0001)            /*!< Send Break */
N#define  USART_CR1_RWU                       ((uint16_t)0x0002)            /*!< Receiver wakeup */
N#define  USART_CR1_RE                        ((uint16_t)0x0004)            /*!< Receiver Enable */
N#define  USART_CR1_TE                        ((uint16_t)0x0008)            /*!< Transmitter Enable */
N#define  USART_CR1_IDLEIE                    ((uint16_t)0x0010)            /*!< IDLE Interrupt Enable */
N#define  USART_CR1_RXNEIE                    ((uint16_t)0x0020)            /*!< RXNE Interrupt Enable */
N#define  USART_CR1_TCIE                      ((uint16_t)0x0040)            /*!< Transmission Complete Interrupt Enable */
N#define  USART_CR1_TXEIE                     ((uint16_t)0x0080)            /*!< PE Interrupt Enable */
N#define  USART_CR1_PEIE                      ((uint16_t)0x0100)            /*!< PE Interrupt Enable */
N#define  USART_CR1_PS                        ((uint16_t)0x0200)            /*!< Parity Selection */
N#define  USART_CR1_PCE                       ((uint16_t)0x0400)            /*!< Parity Control Enable */
N#define  USART_CR1_WAKE                      ((uint16_t)0x0800)            /*!< Wakeup method */
N#define  USART_CR1_M                         ((uint16_t)0x1000)            /*!< Word length */
N#define  USART_CR1_UE                        ((uint16_t)0x2000)            /*!< USART Enable */
N#define  USART_CR1_OVER8                     ((uint16_t)0x8000)            /*!< USART Oversmapling 8-bits */
N
N/******************  Bit definition for USART_CR2 register  *******************/
N#define  USART_CR2_ADD                       ((uint16_t)0x000F)            /*!< Address of the USART node */
N#define  USART_CR2_LBDL                      ((uint16_t)0x0020)            /*!< LIN Break Detection Length */
N#define  USART_CR2_LBDIE                     ((uint16_t)0x0040)            /*!< LIN Break Detection Interrupt Enable */
N#define  USART_CR2_LBCL                      ((uint16_t)0x0100)            /*!< Last Bit Clock pulse */
N#define  USART_CR2_CPHA                      ((uint16_t)0x0200)            /*!< Clock Phase */
N#define  USART_CR2_CPOL                      ((uint16_t)0x0400)            /*!< Clock Polarity */
N#define  USART_CR2_CLKEN                     ((uint16_t)0x0800)            /*!< Clock Enable */
N
N#define  USART_CR2_STOP                      ((uint16_t)0x3000)            /*!< STOP[1:0] bits (STOP bits) */
N#define  USART_CR2_STOP_0                    ((uint16_t)0x1000)            /*!< Bit 0 */
N#define  USART_CR2_STOP_1                    ((uint16_t)0x2000)            /*!< Bit 1 */
N
N#define  USART_CR2_LINEN                     ((uint16_t)0x4000)            /*!< LIN mode enable */
N
N/******************  Bit definition for USART_CR3 register  *******************/
N#define  USART_CR3_EIE                       ((uint16_t)0x0001)            /*!< Error Interrupt Enable */
N#define  USART_CR3_IREN                      ((uint16_t)0x0002)            /*!< IrDA mode Enable */
N#define  USART_CR3_IRLP                      ((uint16_t)0x0004)            /*!< IrDA Low-Power */
N#define  USART_CR3_HDSEL                     ((uint16_t)0x0008)            /*!< Half-Duplex Selection */
N#define  USART_CR3_NACK                      ((uint16_t)0x0010)            /*!< Smartcard NACK enable */
N#define  USART_CR3_SCEN                      ((uint16_t)0x0020)            /*!< Smartcard mode enable */
N#define  USART_CR3_DMAR                      ((uint16_t)0x0040)            /*!< DMA Enable Receiver */
N#define  USART_CR3_DMAT                      ((uint16_t)0x0080)            /*!< DMA Enable Transmitter */
N#define  USART_CR3_RTSE                      ((uint16_t)0x0100)            /*!< RTS Enable */
N#define  USART_CR3_CTSE                      ((uint16_t)0x0200)            /*!< CTS Enable */
N#define  USART_CR3_CTSIE                     ((uint16_t)0x0400)            /*!< CTS Interrupt Enable */
N#define  USART_CR3_ONEBIT                    ((uint16_t)0x0800)            /*!< One Bit method */
N
N/******************  Bit definition for USART_GTPR register  ******************/
N#define  USART_GTPR_PSC                      ((uint16_t)0x00FF)            /*!< PSC[7:0] bits (Prescaler value) */
N#define  USART_GTPR_PSC_0                    ((uint16_t)0x0001)            /*!< Bit 0 */
N#define  USART_GTPR_PSC_1                    ((uint16_t)0x0002)            /*!< Bit 1 */
N#define  USART_GTPR_PSC_2                    ((uint16_t)0x0004)            /*!< Bit 2 */
N#define  USART_GTPR_PSC_3                    ((uint16_t)0x0008)            /*!< Bit 3 */
N#define  USART_GTPR_PSC_4                    ((uint16_t)0x0010)            /*!< Bit 4 */
N#define  USART_GTPR_PSC_5                    ((uint16_t)0x0020)            /*!< Bit 5 */
N#define  USART_GTPR_PSC_6                    ((uint16_t)0x0040)            /*!< Bit 6 */
N#define  USART_GTPR_PSC_7                    ((uint16_t)0x0080)            /*!< Bit 7 */
N
N#define  USART_GTPR_GT                       ((uint16_t)0xFF00)            /*!< Guard time value */
N
N/******************************************************************************/
N/*                                                                            */
N/*                                 Debug MCU                                  */
N/*                                                                            */
N/******************************************************************************/
N
N/****************  Bit definition for DBGMCU_IDCODE register  *****************/
N#define  DBGMCU_IDCODE_DEV_ID                ((uint32_t)0x00000FFF)        /*!< Device Identifier */
N
N#define  DBGMCU_IDCODE_REV_ID                ((uint32_t)0xFFFF0000)        /*!< REV_ID[15:0] bits (Revision Identifier) */
N#define  DBGMCU_IDCODE_REV_ID_0              ((uint32_t)0x00010000)        /*!< Bit 0 */
N#define  DBGMCU_IDCODE_REV_ID_1              ((uint32_t)0x00020000)        /*!< Bit 1 */
N#define  DBGMCU_IDCODE_REV_ID_2              ((uint32_t)0x00040000)        /*!< Bit 2 */
N#define  DBGMCU_IDCODE_REV_ID_3              ((uint32_t)0x00080000)        /*!< Bit 3 */
N#define  DBGMCU_IDCODE_REV_ID_4              ((uint32_t)0x00100000)        /*!< Bit 4 */
N#define  DBGMCU_IDCODE_REV_ID_5              ((uint32_t)0x00200000)        /*!< Bit 5 */
N#define  DBGMCU_IDCODE_REV_ID_6              ((uint32_t)0x00400000)        /*!< Bit 6 */
N#define  DBGMCU_IDCODE_REV_ID_7              ((uint32_t)0x00800000)        /*!< Bit 7 */
N#define  DBGMCU_IDCODE_REV_ID_8              ((uint32_t)0x01000000)        /*!< Bit 8 */
N#define  DBGMCU_IDCODE_REV_ID_9              ((uint32_t)0x02000000)        /*!< Bit 9 */
N#define  DBGMCU_IDCODE_REV_ID_10             ((uint32_t)0x04000000)        /*!< Bit 10 */
N#define  DBGMCU_IDCODE_REV_ID_11             ((uint32_t)0x08000000)        /*!< Bit 11 */
N#define  DBGMCU_IDCODE_REV_ID_12             ((uint32_t)0x10000000)        /*!< Bit 12 */
N#define  DBGMCU_IDCODE_REV_ID_13             ((uint32_t)0x20000000)        /*!< Bit 13 */
N#define  DBGMCU_IDCODE_REV_ID_14             ((uint32_t)0x40000000)        /*!< Bit 14 */
N#define  DBGMCU_IDCODE_REV_ID_15             ((uint32_t)0x80000000)        /*!< Bit 15 */
N
N/******************  Bit definition for DBGMCU_CR register  *******************/
N#define  DBGMCU_CR_DBG_SLEEP                 ((uint32_t)0x00000001)        /*!< Debug Sleep Mode */
N#define  DBGMCU_CR_DBG_STOP                  ((uint32_t)0x00000002)        /*!< Debug Stop Mode */
N#define  DBGMCU_CR_DBG_STANDBY               ((uint32_t)0x00000004)        /*!< Debug Standby mode */
N#define  DBGMCU_CR_TRACE_IOEN                ((uint32_t)0x00000020)        /*!< Trace Pin Assignment Control */
N
N#define  DBGMCU_CR_TRACE_MODE                ((uint32_t)0x000000C0)        /*!< TRACE_MODE[1:0] bits (Trace Pin Assignment Control) */
N#define  DBGMCU_CR_TRACE_MODE_0              ((uint32_t)0x00000040)        /*!< Bit 0 */
N#define  DBGMCU_CR_TRACE_MODE_1              ((uint32_t)0x00000080)        /*!< Bit 1 */
N
N#define  DBGMCU_CR_DBG_IWDG_STOP             ((uint32_t)0x00000100)        /*!< Debug Independent Watchdog stopped when Core is halted */
N#define  DBGMCU_CR_DBG_WWDG_STOP             ((uint32_t)0x00000200)        /*!< Debug Window Watchdog stopped when Core is halted */
N#define  DBGMCU_CR_DBG_TIM1_STOP             ((uint32_t)0x00000400)        /*!< TIM1 counter stopped when core is halted */
N#define  DBGMCU_CR_DBG_TIM2_STOP             ((uint32_t)0x00000800)        /*!< TIM2 counter stopped when core is halted */
N#define  DBGMCU_CR_DBG_TIM3_STOP             ((uint32_t)0x00001000)        /*!< TIM3 counter stopped when core is halted */
N#define  DBGMCU_CR_DBG_TIM4_STOP             ((uint32_t)0x00002000)        /*!< TIM4 counter stopped when core is halted */
N#define  DBGMCU_CR_DBG_CAN1_STOP             ((uint32_t)0x00004000)        /*!< Debug CAN1 stopped when Core is halted */
N#define  DBGMCU_CR_DBG_I2C1_SMBUS_TIMEOUT    ((uint32_t)0x00008000)        /*!< SMBUS timeout mode stopped when Core is halted */
N#define  DBGMCU_CR_DBG_I2C2_SMBUS_TIMEOUT    ((uint32_t)0x00010000)        /*!< SMBUS timeout mode stopped when Core is halted */
N#define  DBGMCU_CR_DBG_TIM8_STOP             ((uint32_t)0x00020000)        /*!< TIM8 counter stopped when core is halted */
N#define  DBGMCU_CR_DBG_TIM5_STOP             ((uint32_t)0x00040000)        /*!< TIM5 counter stopped when core is halted */
N#define  DBGMCU_CR_DBG_TIM6_STOP             ((uint32_t)0x00080000)        /*!< TIM6 counter stopped when core is halted */
N#define  DBGMCU_CR_DBG_TIM7_STOP             ((uint32_t)0x00100000)        /*!< TIM7 counter stopped when core is halted */
N#define  DBGMCU_CR_DBG_CAN2_STOP             ((uint32_t)0x00200000)        /*!< Debug CAN2 stopped when Core is halted */
N#define  DBGMCU_CR_DBG_TIM15_STOP            ((uint32_t)0x00400000)        /*!< Debug TIM15 stopped when Core is halted */
N#define  DBGMCU_CR_DBG_TIM16_STOP            ((uint32_t)0x00800000)        /*!< Debug TIM16 stopped when Core is halted */
N#define  DBGMCU_CR_DBG_TIM17_STOP            ((uint32_t)0x01000000)        /*!< Debug TIM17 stopped when Core is halted */
N#define  DBGMCU_CR_DBG_TIM12_STOP            ((uint32_t)0x02000000)        /*!< Debug TIM12 stopped when Core is halted */
N#define  DBGMCU_CR_DBG_TIM13_STOP            ((uint32_t)0x04000000)        /*!< Debug TIM13 stopped when Core is halted */
N#define  DBGMCU_CR_DBG_TIM14_STOP            ((uint32_t)0x08000000)        /*!< Debug TIM14 stopped when Core is halted */
N#define  DBGMCU_CR_DBG_TIM9_STOP             ((uint32_t)0x10000000)        /*!< Debug TIM9 stopped when Core is halted */
N#define  DBGMCU_CR_DBG_TIM10_STOP            ((uint32_t)0x20000000)        /*!< Debug TIM10 stopped when Core is halted */
N#define  DBGMCU_CR_DBG_TIM11_STOP            ((uint32_t)0x40000000)        /*!< Debug TIM11 stopped when Core is halted */
N
N/******************************************************************************/
N/*                                                                            */
N/*                      FLASH and Option Bytes Registers                      */
N/*                                                                            */
N/******************************************************************************/
N
N/*******************  Bit definition for FLASH_ACR register  ******************/
N#define  FLASH_ACR_LATENCY                   ((uint8_t)0x03)               /*!< LATENCY[2:0] bits (Latency) */
N#define  FLASH_ACR_LATENCY_0                 ((uint8_t)0x00)               /*!< Bit 0 */
N#define  FLASH_ACR_LATENCY_1                 ((uint8_t)0x01)               /*!< Bit 0 */
N#define  FLASH_ACR_LATENCY_2                 ((uint8_t)0x02)               /*!< Bit 1 */
N
N#define  FLASH_ACR_HLFCYA                    ((uint8_t)0x08)               /*!< Flash Half Cycle Access Enable */
N#define  FLASH_ACR_PRFTBE                    ((uint8_t)0x10)               /*!< Prefetch Buffer Enable */
N#define  FLASH_ACR_PRFTBS                    ((uint8_t)0x20)               /*!< Prefetch Buffer Status */
N
N/******************  Bit definition for FLASH_KEYR register  ******************/
N#define  FLASH_KEYR_FKEYR                    ((uint32_t)0xFFFFFFFF)        /*!< FPEC Key */
N
N/*****************  Bit definition for FLASH_OPTKEYR register  ****************/
N#define  FLASH_OPTKEYR_OPTKEYR               ((uint32_t)0xFFFFFFFF)        /*!< Option Byte Key */
N
N/******************  Bit definition for FLASH_SR register  *******************/
N#define  FLASH_SR_BSY                        ((uint8_t)0x01)               /*!< Busy */
N#define  FLASH_SR_PGERR                      ((uint8_t)0x04)               /*!< Programming Error */
N#define  FLASH_SR_WRPRTERR                   ((uint8_t)0x10)               /*!< Write Protection Error */
N#define  FLASH_SR_EOP                        ((uint8_t)0x20)               /*!< End of operation */
N
N/*******************  Bit definition for FLASH_CR register  *******************/
N#define  FLASH_CR_PG                         ((uint16_t)0x0001)            /*!< Programming */
N#define  FLASH_CR_PER                        ((uint16_t)0x0002)            /*!< Page Erase */
N#define  FLASH_CR_MER                        ((uint16_t)0x0004)            /*!< Mass Erase */
N#define  FLASH_CR_OPTPG                      ((uint16_t)0x0010)            /*!< Option Byte Programming */
N#define  FLASH_CR_OPTER                      ((uint16_t)0x0020)            /*!< Option Byte Erase */
N#define  FLASH_CR_STRT                       ((uint16_t)0x0040)            /*!< Start */
N#define  FLASH_CR_LOCK                       ((uint16_t)0x0080)            /*!< Lock */
N#define  FLASH_CR_OPTWRE                     ((uint16_t)0x0200)            /*!< Option Bytes Write Enable */
N#define  FLASH_CR_ERRIE                      ((uint16_t)0x0400)            /*!< Error Interrupt Enable */
N#define  FLASH_CR_EOPIE                      ((uint16_t)0x1000)            /*!< End of operation interrupt enable */
N
N/*******************  Bit definition for FLASH_AR register  *******************/
N#define  FLASH_AR_FAR                        ((uint32_t)0xFFFFFFFF)        /*!< Flash Address */
N
N/******************  Bit definition for FLASH_OBR register  *******************/
N#define  FLASH_OBR_OPTERR                    ((uint16_t)0x0001)            /*!< Option Byte Error */
N#define  FLASH_OBR_RDPRT                     ((uint16_t)0x0002)            /*!< Read protection */
N
N#define  FLASH_OBR_USER                      ((uint16_t)0x03FC)            /*!< User Option Bytes */
N#define  FLASH_OBR_WDG_SW                    ((uint16_t)0x0004)            /*!< WDG_SW */
N#define  FLASH_OBR_nRST_STOP                 ((uint16_t)0x0008)            /*!< nRST_STOP */
N#define  FLASH_OBR_nRST_STDBY                ((uint16_t)0x0010)            /*!< nRST_STDBY */
N#define  FLASH_OBR_BFB2                      ((uint16_t)0x0020)            /*!< BFB2 */
N
N/******************  Bit definition for FLASH_WRPR register  ******************/
N#define  FLASH_WRPR_WRP                        ((uint32_t)0xFFFFFFFF)        /*!< Write Protect */
N
N/*----------------------------------------------------------------------------*/
N
N/******************  Bit definition for FLASH_RDP register  *******************/
N#define  FLASH_RDP_RDP                       ((uint32_t)0x000000FF)        /*!< Read protection option byte */
N#define  FLASH_RDP_nRDP                      ((uint32_t)0x0000FF00)        /*!< Read protection complemented option byte */
N
N/******************  Bit definition for FLASH_USER register  ******************/
N#define  FLASH_USER_USER                     ((uint32_t)0x00FF0000)        /*!< User option byte */
N#define  FLASH_USER_nUSER                    ((uint32_t)0xFF000000)        /*!< User complemented option byte */
N
N/******************  Bit definition for FLASH_Data0 register  *****************/
N#define  FLASH_Data0_Data0                   ((uint32_t)0x000000FF)        /*!< User data storage option byte */
N#define  FLASH_Data0_nData0                  ((uint32_t)0x0000FF00)        /*!< User data storage complemented option byte */
N
N/******************  Bit definition for FLASH_Data1 register  *****************/
N#define  FLASH_Data1_Data1                   ((uint32_t)0x00FF0000)        /*!< User data storage option byte */
N#define  FLASH_Data1_nData1                  ((uint32_t)0xFF000000)        /*!< User data storage complemented option byte */
N
N/******************  Bit definition for FLASH_WRP0 register  ******************/
N#define  FLASH_WRP0_WRP0                     ((uint32_t)0x000000FF)        /*!< Flash memory write protection option bytes */
N#define  FLASH_WRP0_nWRP0                    ((uint32_t)0x0000FF00)        /*!< Flash memory write protection complemented option bytes */
N
N/******************  Bit definition for FLASH_WRP1 register  ******************/
N#define  FLASH_WRP1_WRP1                     ((uint32_t)0x00FF0000)        /*!< Flash memory write protection option bytes */
N#define  FLASH_WRP1_nWRP1                    ((uint32_t)0xFF000000)        /*!< Flash memory write protection complemented option bytes */
N
N/******************  Bit definition for FLASH_WRP2 register  ******************/
N#define  FLASH_WRP2_WRP2                     ((uint32_t)0x000000FF)        /*!< Flash memory write protection option bytes */
N#define  FLASH_WRP2_nWRP2                    ((uint32_t)0x0000FF00)        /*!< Flash memory write protection complemented option bytes */
N
N/******************  Bit definition for FLASH_WRP3 register  ******************/
N#define  FLASH_WRP3_WRP3                     ((uint32_t)0x00FF0000)        /*!< Flash memory write protection option bytes */
N#define  FLASH_WRP3_nWRP3                    ((uint32_t)0xFF000000)        /*!< Flash memory write protection complemented option bytes */
N
N#ifdef STM32F10X_CL
S/******************************************************************************/
S/*                Ethernet MAC Registers bits definitions                     */
S/******************************************************************************/
S/* Bit definition for Ethernet MAC Control Register register */
S#define ETH_MACCR_WD      ((uint32_t)0x00800000)  /* Watchdog disable */
S#define ETH_MACCR_JD      ((uint32_t)0x00400000)  /* Jabber disable */
S#define ETH_MACCR_IFG     ((uint32_t)0x000E0000)  /* Inter-frame gap */
S  #define ETH_MACCR_IFG_96Bit     ((uint32_t)0x00000000)  /* Minimum IFG between frames during transmission is 96Bit */
S  #define ETH_MACCR_IFG_88Bit     ((uint32_t)0x00020000)  /* Minimum IFG between frames during transmission is 88Bit */
S  #define ETH_MACCR_IFG_80Bit     ((uint32_t)0x00040000)  /* Minimum IFG between frames during transmission is 80Bit */
S  #define ETH_MACCR_IFG_72Bit     ((uint32_t)0x00060000)  /* Minimum IFG between frames during transmission is 72Bit */
S  #define ETH_MACCR_IFG_64Bit     ((uint32_t)0x00080000)  /* Minimum IFG between frames during transmission is 64Bit */        
S  #define ETH_MACCR_IFG_56Bit     ((uint32_t)0x000A0000)  /* Minimum IFG between frames during transmission is 56Bit */
S  #define ETH_MACCR_IFG_48Bit     ((uint32_t)0x000C0000)  /* Minimum IFG between frames during transmission is 48Bit */
S  #define ETH_MACCR_IFG_40Bit     ((uint32_t)0x000E0000)  /* Minimum IFG between frames during transmission is 40Bit */              
S#define ETH_MACCR_CSD     ((uint32_t)0x00010000)  /* Carrier sense disable (during transmission) */
S#define ETH_MACCR_FES     ((uint32_t)0x00004000)  /* Fast ethernet speed */
S#define ETH_MACCR_ROD     ((uint32_t)0x00002000)  /* Receive own disable */
S#define ETH_MACCR_LM      ((uint32_t)0x00001000)  /* loopback mode */
S#define ETH_MACCR_DM      ((uint32_t)0x00000800)  /* Duplex mode */
S#define ETH_MACCR_IPCO    ((uint32_t)0x00000400)  /* IP Checksum offload */
S#define ETH_MACCR_RD      ((uint32_t)0x00000200)  /* Retry disable */
S#define ETH_MACCR_APCS    ((uint32_t)0x00000080)  /* Automatic Pad/CRC stripping */
S#define ETH_MACCR_BL      ((uint32_t)0x00000060)  /* Back-off limit: random integer number (r) of slot time delays before rescheduling
S                                                       a transmission attempt during retries after a collision: 0 =< r <2^k */
S  #define ETH_MACCR_BL_10    ((uint32_t)0x00000000)  /* k = min (n, 10) */
S  #define ETH_MACCR_BL_8     ((uint32_t)0x00000020)  /* k = min (n, 8) */
S  #define ETH_MACCR_BL_4     ((uint32_t)0x00000040)  /* k = min (n, 4) */
S  #define ETH_MACCR_BL_1     ((uint32_t)0x00000060)  /* k = min (n, 1) */ 
S#define ETH_MACCR_DC      ((uint32_t)0x00000010)  /* Defferal check */
S#define ETH_MACCR_TE      ((uint32_t)0x00000008)  /* Transmitter enable */
S#define ETH_MACCR_RE      ((uint32_t)0x00000004)  /* Receiver enable */
S
S/* Bit definition for Ethernet MAC Frame Filter Register */
S#define ETH_MACFFR_RA     ((uint32_t)0x80000000)  /* Receive all */ 
S#define ETH_MACFFR_HPF    ((uint32_t)0x00000400)  /* Hash or perfect filter */ 
S#define ETH_MACFFR_SAF    ((uint32_t)0x00000200)  /* Source address filter enable */ 
S#define ETH_MACFFR_SAIF   ((uint32_t)0x00000100)  /* SA inverse filtering */ 
S#define ETH_MACFFR_PCF    ((uint32_t)0x000000C0)  /* Pass control frames: 3 cases */
S  #define ETH_MACFFR_PCF_BlockAll                ((uint32_t)0x00000040)  /* MAC filters all control frames from reaching the application */
S  #define ETH_MACFFR_PCF_ForwardAll              ((uint32_t)0x00000080)  /* MAC forwards all control frames to application even if they fail the Address Filter */
S  #define ETH_MACFFR_PCF_ForwardPassedAddrFilter ((uint32_t)0x000000C0)  /* MAC forwards control frames that pass the Address Filter. */ 
S#define ETH_MACFFR_BFD    ((uint32_t)0x00000020)  /* Broadcast frame disable */ 
S#define ETH_MACFFR_PAM 	  ((uint32_t)0x00000010)  /* Pass all mutlicast */ 
S#define ETH_MACFFR_DAIF   ((uint32_t)0x00000008)  /* DA Inverse filtering */ 
S#define ETH_MACFFR_HM     ((uint32_t)0x00000004)  /* Hash multicast */ 
S#define ETH_MACFFR_HU     ((uint32_t)0x00000002)  /* Hash unicast */
S#define ETH_MACFFR_PM     ((uint32_t)0x00000001)  /* Promiscuous mode */
S
S/* Bit definition for Ethernet MAC Hash Table High Register */
S#define ETH_MACHTHR_HTH   ((uint32_t)0xFFFFFFFF)  /* Hash table high */
S
S/* Bit definition for Ethernet MAC Hash Table Low Register */
S#define ETH_MACHTLR_HTL   ((uint32_t)0xFFFFFFFF)  /* Hash table low */
S
S/* Bit definition for Ethernet MAC MII Address Register */
S#define ETH_MACMIIAR_PA   ((uint32_t)0x0000F800)  /* Physical layer address */ 
S#define ETH_MACMIIAR_MR   ((uint32_t)0x000007C0)  /* MII register in the selected PHY */ 
S#define ETH_MACMIIAR_CR   ((uint32_t)0x0000001C)  /* CR clock range: 6 cases */ 
S  #define ETH_MACMIIAR_CR_Div42   ((uint32_t)0x00000000)  /* HCLK:60-72 MHz; MDC clock= HCLK/42 */
S  #define ETH_MACMIIAR_CR_Div16   ((uint32_t)0x00000008)  /* HCLK:20-35 MHz; MDC clock= HCLK/16 */
S  #define ETH_MACMIIAR_CR_Div26   ((uint32_t)0x0000000C)  /* HCLK:35-60 MHz; MDC clock= HCLK/26 */
S#define ETH_MACMIIAR_MW   ((uint32_t)0x00000002)  /* MII write */ 
S#define ETH_MACMIIAR_MB   ((uint32_t)0x00000001)  /* MII busy */ 
S  
S/* Bit definition for Ethernet MAC MII Data Register */
S#define ETH_MACMIIDR_MD   ((uint32_t)0x0000FFFF)  /* MII data: read/write data from/to PHY */
S
S/* Bit definition for Ethernet MAC Flow Control Register */
S#define ETH_MACFCR_PT     ((uint32_t)0xFFFF0000)  /* Pause time */
S#define ETH_MACFCR_ZQPD   ((uint32_t)0x00000080)  /* Zero-quanta pause disable */
S#define ETH_MACFCR_PLT    ((uint32_t)0x00000030)  /* Pause low threshold: 4 cases */
S  #define ETH_MACFCR_PLT_Minus4   ((uint32_t)0x00000000)  /* Pause time minus 4 slot times */
S  #define ETH_MACFCR_PLT_Minus28  ((uint32_t)0x00000010)  /* Pause time minus 28 slot times */
S  #define ETH_MACFCR_PLT_Minus144 ((uint32_t)0x00000020)  /* Pause time minus 144 slot times */
S  #define ETH_MACFCR_PLT_Minus256 ((uint32_t)0x00000030)  /* Pause time minus 256 slot times */      
S#define ETH_MACFCR_UPFD   ((uint32_t)0x00000008)  /* Unicast pause frame detect */
S#define ETH_MACFCR_RFCE   ((uint32_t)0x00000004)  /* Receive flow control enable */
S#define ETH_MACFCR_TFCE   ((uint32_t)0x00000002)  /* Transmit flow control enable */
S#define ETH_MACFCR_FCBBPA ((uint32_t)0x00000001)  /* Flow control busy/backpressure activate */
S
S/* Bit definition for Ethernet MAC VLAN Tag Register */
S#define ETH_MACVLANTR_VLANTC ((uint32_t)0x00010000)  /* 12-bit VLAN tag comparison */
S#define ETH_MACVLANTR_VLANTI ((uint32_t)0x0000FFFF)  /* VLAN tag identifier (for receive frames) */
S
S/* Bit definition for Ethernet MAC Remote Wake-UpFrame Filter Register */ 
S#define ETH_MACRWUFFR_D   ((uint32_t)0xFFFFFFFF)  /* Wake-up frame filter register data */
S/* Eight sequential Writes to this address (offset 0x28) will write all Wake-UpFrame Filter Registers.
S   Eight sequential Reads from this address (offset 0x28) will read all Wake-UpFrame Filter Registers. */
S/* Wake-UpFrame Filter Reg0 : Filter 0 Byte Mask
S   Wake-UpFrame Filter Reg1 : Filter 1 Byte Mask
S   Wake-UpFrame Filter Reg2 : Filter 2 Byte Mask
S   Wake-UpFrame Filter Reg3 : Filter 3 Byte Mask
S   Wake-UpFrame Filter Reg4 : RSVD - Filter3 Command - RSVD - Filter2 Command - 
S                              RSVD - Filter1 Command - RSVD - Filter0 Command
S   Wake-UpFrame Filter Re5 : Filter3 Offset - Filter2 Offset - Filter1 Offset - Filter0 Offset
S   Wake-UpFrame Filter Re6 : Filter1 CRC16 - Filter0 CRC16
S   Wake-UpFrame Filter Re7 : Filter3 CRC16 - Filter2 CRC16 */
S
S/* Bit definition for Ethernet MAC PMT Control and Status Register */ 
S#define ETH_MACPMTCSR_WFFRPR ((uint32_t)0x80000000)  /* Wake-Up Frame Filter Register Pointer Reset */
S#define ETH_MACPMTCSR_GU     ((uint32_t)0x00000200)  /* Global Unicast */
S#define ETH_MACPMTCSR_WFR    ((uint32_t)0x00000040)  /* Wake-Up Frame Received */
S#define ETH_MACPMTCSR_MPR    ((uint32_t)0x00000020)  /* Magic Packet Received */
S#define ETH_MACPMTCSR_WFE    ((uint32_t)0x00000004)  /* Wake-Up Frame Enable */
S#define ETH_MACPMTCSR_MPE    ((uint32_t)0x00000002)  /* Magic Packet Enable */
S#define ETH_MACPMTCSR_PD     ((uint32_t)0x00000001)  /* Power Down */
S
S/* Bit definition for Ethernet MAC Status Register */
S#define ETH_MACSR_TSTS      ((uint32_t)0x00000200)  /* Time stamp trigger status */
S#define ETH_MACSR_MMCTS     ((uint32_t)0x00000040)  /* MMC transmit status */
S#define ETH_MACSR_MMMCRS    ((uint32_t)0x00000020)  /* MMC receive status */
S#define ETH_MACSR_MMCS      ((uint32_t)0x00000010)  /* MMC status */
S#define ETH_MACSR_PMTS      ((uint32_t)0x00000008)  /* PMT status */
S
S/* Bit definition for Ethernet MAC Interrupt Mask Register */
S#define ETH_MACIMR_TSTIM     ((uint32_t)0x00000200)  /* Time stamp trigger interrupt mask */
S#define ETH_MACIMR_PMTIM     ((uint32_t)0x00000008)  /* PMT interrupt mask */
S
S/* Bit definition for Ethernet MAC Address0 High Register */
S#define ETH_MACA0HR_MACA0H   ((uint32_t)0x0000FFFF)  /* MAC address0 high */
S
S/* Bit definition for Ethernet MAC Address0 Low Register */
S#define ETH_MACA0LR_MACA0L   ((uint32_t)0xFFFFFFFF)  /* MAC address0 low */
S
S/* Bit definition for Ethernet MAC Address1 High Register */
S#define ETH_MACA1HR_AE       ((uint32_t)0x80000000)  /* Address enable */
S#define ETH_MACA1HR_SA       ((uint32_t)0x40000000)  /* Source address */
S#define ETH_MACA1HR_MBC      ((uint32_t)0x3F000000)  /* Mask byte control: bits to mask for comparison of the MAC Address bytes */
S  #define ETH_MACA1HR_MBC_HBits15_8    ((uint32_t)0x20000000)  /* Mask MAC Address high reg bits [15:8] */
S  #define ETH_MACA1HR_MBC_HBits7_0     ((uint32_t)0x10000000)  /* Mask MAC Address high reg bits [7:0] */
S  #define ETH_MACA1HR_MBC_LBits31_24   ((uint32_t)0x08000000)  /* Mask MAC Address low reg bits [31:24] */
S  #define ETH_MACA1HR_MBC_LBits23_16   ((uint32_t)0x04000000)  /* Mask MAC Address low reg bits [23:16] */
S  #define ETH_MACA1HR_MBC_LBits15_8    ((uint32_t)0x02000000)  /* Mask MAC Address low reg bits [15:8] */
S  #define ETH_MACA1HR_MBC_LBits7_0     ((uint32_t)0x01000000)  /* Mask MAC Address low reg bits [7:0] */ 
S#define ETH_MACA1HR_MACA1H   ((uint32_t)0x0000FFFF)  /* MAC address1 high */
S
S/* Bit definition for Ethernet MAC Address1 Low Register */
S#define ETH_MACA1LR_MACA1L   ((uint32_t)0xFFFFFFFF)  /* MAC address1 low */
S
S/* Bit definition for Ethernet MAC Address2 High Register */
S#define ETH_MACA2HR_AE       ((uint32_t)0x80000000)  /* Address enable */
S#define ETH_MACA2HR_SA       ((uint32_t)0x40000000)  /* Source address */
S#define ETH_MACA2HR_MBC      ((uint32_t)0x3F000000)  /* Mask byte control */
S  #define ETH_MACA2HR_MBC_HBits15_8    ((uint32_t)0x20000000)  /* Mask MAC Address high reg bits [15:8] */
S  #define ETH_MACA2HR_MBC_HBits7_0     ((uint32_t)0x10000000)  /* Mask MAC Address high reg bits [7:0] */
S  #define ETH_MACA2HR_MBC_LBits31_24   ((uint32_t)0x08000000)  /* Mask MAC Address low reg bits [31:24] */
S  #define ETH_MACA2HR_MBC_LBits23_16   ((uint32_t)0x04000000)  /* Mask MAC Address low reg bits [23:16] */
S  #define ETH_MACA2HR_MBC_LBits15_8    ((uint32_t)0x02000000)  /* Mask MAC Address low reg bits [15:8] */
S  #define ETH_MACA2HR_MBC_LBits7_0     ((uint32_t)0x01000000)  /* Mask MAC Address low reg bits [70] */
S#define ETH_MACA2HR_MACA2H   ((uint32_t)0x0000FFFF)  /* MAC address1 high */
S
S/* Bit definition for Ethernet MAC Address2 Low Register */
S#define ETH_MACA2LR_MACA2L   ((uint32_t)0xFFFFFFFF)  /* MAC address2 low */
S
S/* Bit definition for Ethernet MAC Address3 High Register */
S#define ETH_MACA3HR_AE       ((uint32_t)0x80000000)  /* Address enable */
S#define ETH_MACA3HR_SA       ((uint32_t)0x40000000)  /* Source address */
S#define ETH_MACA3HR_MBC      ((uint32_t)0x3F000000)  /* Mask byte control */
S  #define ETH_MACA3HR_MBC_HBits15_8    ((uint32_t)0x20000000)  /* Mask MAC Address high reg bits [15:8] */
S  #define ETH_MACA3HR_MBC_HBits7_0     ((uint32_t)0x10000000)  /* Mask MAC Address high reg bits [7:0] */
S  #define ETH_MACA3HR_MBC_LBits31_24   ((uint32_t)0x08000000)  /* Mask MAC Address low reg bits [31:24] */
S  #define ETH_MACA3HR_MBC_LBits23_16   ((uint32_t)0x04000000)  /* Mask MAC Address low reg bits [23:16] */
S  #define ETH_MACA3HR_MBC_LBits15_8    ((uint32_t)0x02000000)  /* Mask MAC Address low reg bits [15:8] */
S  #define ETH_MACA3HR_MBC_LBits7_0     ((uint32_t)0x01000000)  /* Mask MAC Address low reg bits [70] */
S#define ETH_MACA3HR_MACA3H   ((uint32_t)0x0000FFFF)  /* MAC address3 high */
S
S/* Bit definition for Ethernet MAC Address3 Low Register */
S#define ETH_MACA3LR_MACA3L   ((uint32_t)0xFFFFFFFF)  /* MAC address3 low */
S
S/******************************************************************************/
S/*                Ethernet MMC Registers bits definition                      */
S/******************************************************************************/
S
S/* Bit definition for Ethernet MMC Contol Register */
S#define ETH_MMCCR_MCF        ((uint32_t)0x00000008)  /* MMC Counter Freeze */
S#define ETH_MMCCR_ROR        ((uint32_t)0x00000004)  /* Reset on Read */
S#define ETH_MMCCR_CSR        ((uint32_t)0x00000002)  /* Counter Stop Rollover */
S#define ETH_MMCCR_CR         ((uint32_t)0x00000001)  /* Counters Reset */
S
S/* Bit definition for Ethernet MMC Receive Interrupt Register */
S#define ETH_MMCRIR_RGUFS     ((uint32_t)0x00020000)  /* Set when Rx good unicast frames counter reaches half the maximum value */
S#define ETH_MMCRIR_RFAES     ((uint32_t)0x00000040)  /* Set when Rx alignment error counter reaches half the maximum value */
S#define ETH_MMCRIR_RFCES     ((uint32_t)0x00000020)  /* Set when Rx crc error counter reaches half the maximum value */
S
S/* Bit definition for Ethernet MMC Transmit Interrupt Register */
S#define ETH_MMCTIR_TGFS      ((uint32_t)0x00200000)  /* Set when Tx good frame count counter reaches half the maximum value */
S#define ETH_MMCTIR_TGFMSCS   ((uint32_t)0x00008000)  /* Set when Tx good multi col counter reaches half the maximum value */
S#define ETH_MMCTIR_TGFSCS    ((uint32_t)0x00004000)  /* Set when Tx good single col counter reaches half the maximum value */
S
S/* Bit definition for Ethernet MMC Receive Interrupt Mask Register */
S#define ETH_MMCRIMR_RGUFM    ((uint32_t)0x00020000)  /* Mask the interrupt when Rx good unicast frames counter reaches half the maximum value */
S#define ETH_MMCRIMR_RFAEM    ((uint32_t)0x00000040)  /* Mask the interrupt when when Rx alignment error counter reaches half the maximum value */
S#define ETH_MMCRIMR_RFCEM    ((uint32_t)0x00000020)  /* Mask the interrupt when Rx crc error counter reaches half the maximum value */
S
S/* Bit definition for Ethernet MMC Transmit Interrupt Mask Register */
S#define ETH_MMCTIMR_TGFM     ((uint32_t)0x00200000)  /* Mask the interrupt when Tx good frame count counter reaches half the maximum value */
S#define ETH_MMCTIMR_TGFMSCM  ((uint32_t)0x00008000)  /* Mask the interrupt when Tx good multi col counter reaches half the maximum value */
S#define ETH_MMCTIMR_TGFSCM   ((uint32_t)0x00004000)  /* Mask the interrupt when Tx good single col counter reaches half the maximum value */
S
S/* Bit definition for Ethernet MMC Transmitted Good Frames after Single Collision Counter Register */
S#define ETH_MMCTGFSCCR_TGFSCC     ((uint32_t)0xFFFFFFFF)  /* Number of successfully transmitted frames after a single collision in Half-duplex mode. */
S
S/* Bit definition for Ethernet MMC Transmitted Good Frames after More than a Single Collision Counter Register */
S#define ETH_MMCTGFMSCCR_TGFMSCC   ((uint32_t)0xFFFFFFFF)  /* Number of successfully transmitted frames after more than a single collision in Half-duplex mode. */
S
S/* Bit definition for Ethernet MMC Transmitted Good Frames Counter Register */
S#define ETH_MMCTGFCR_TGFC    ((uint32_t)0xFFFFFFFF)  /* Number of good frames transmitted. */
S
S/* Bit definition for Ethernet MMC Received Frames with CRC Error Counter Register */
S#define ETH_MMCRFCECR_RFCEC  ((uint32_t)0xFFFFFFFF)  /* Number of frames received with CRC error. */
S
S/* Bit definition for Ethernet MMC Received Frames with Alignement Error Counter Register */
S#define ETH_MMCRFAECR_RFAEC  ((uint32_t)0xFFFFFFFF)  /* Number of frames received with alignment (dribble) error */
S
S/* Bit definition for Ethernet MMC Received Good Unicast Frames Counter Register */
S#define ETH_MMCRGUFCR_RGUFC  ((uint32_t)0xFFFFFFFF)  /* Number of good unicast frames received. */
S
S/******************************************************************************/
S/*               Ethernet PTP Registers bits definition                       */
S/******************************************************************************/
S
S/* Bit definition for Ethernet PTP Time Stamp Contol Register */
S#define ETH_PTPTSCR_TSARU    ((uint32_t)0x00000020)  /* Addend register update */
S#define ETH_PTPTSCR_TSITE    ((uint32_t)0x00000010)  /* Time stamp interrupt trigger enable */
S#define ETH_PTPTSCR_TSSTU    ((uint32_t)0x00000008)  /* Time stamp update */
S#define ETH_PTPTSCR_TSSTI    ((uint32_t)0x00000004)  /* Time stamp initialize */
S#define ETH_PTPTSCR_TSFCU    ((uint32_t)0x00000002)  /* Time stamp fine or coarse update */
S#define ETH_PTPTSCR_TSE      ((uint32_t)0x00000001)  /* Time stamp enable */
S
S/* Bit definition for Ethernet PTP Sub-Second Increment Register */
S#define ETH_PTPSSIR_STSSI    ((uint32_t)0x000000FF)  /* System time Sub-second increment value */
S
S/* Bit definition for Ethernet PTP Time Stamp High Register */
S#define ETH_PTPTSHR_STS      ((uint32_t)0xFFFFFFFF)  /* System Time second */
S
S/* Bit definition for Ethernet PTP Time Stamp Low Register */
S#define ETH_PTPTSLR_STPNS    ((uint32_t)0x80000000)  /* System Time Positive or negative time */
S#define ETH_PTPTSLR_STSS     ((uint32_t)0x7FFFFFFF)  /* System Time sub-seconds */
S
S/* Bit definition for Ethernet PTP Time Stamp High Update Register */
S#define ETH_PTPTSHUR_TSUS    ((uint32_t)0xFFFFFFFF)  /* Time stamp update seconds */
S
S/* Bit definition for Ethernet PTP Time Stamp Low Update Register */
S#define ETH_PTPTSLUR_TSUPNS  ((uint32_t)0x80000000)  /* Time stamp update Positive or negative time */
S#define ETH_PTPTSLUR_TSUSS   ((uint32_t)0x7FFFFFFF)  /* Time stamp update sub-seconds */
S
S/* Bit definition for Ethernet PTP Time Stamp Addend Register */
S#define ETH_PTPTSAR_TSA      ((uint32_t)0xFFFFFFFF)  /* Time stamp addend */
S
S/* Bit definition for Ethernet PTP Target Time High Register */
S#define ETH_PTPTTHR_TTSH     ((uint32_t)0xFFFFFFFF)  /* Target time stamp high */
S
S/* Bit definition for Ethernet PTP Target Time Low Register */
S#define ETH_PTPTTLR_TTSL     ((uint32_t)0xFFFFFFFF)  /* Target time stamp low */
S
S/******************************************************************************/
S/*                 Ethernet DMA Registers bits definition                     */
S/******************************************************************************/
S
S/* Bit definition for Ethernet DMA Bus Mode Register */
S#define ETH_DMABMR_AAB       ((uint32_t)0x02000000)  /* Address-Aligned beats */
S#define ETH_DMABMR_FPM        ((uint32_t)0x01000000)  /* 4xPBL mode */
S#define ETH_DMABMR_USP       ((uint32_t)0x00800000)  /* Use separate PBL */
S#define ETH_DMABMR_RDP       ((uint32_t)0x007E0000)  /* RxDMA PBL */
S  #define ETH_DMABMR_RDP_1Beat    ((uint32_t)0x00020000)  /* maximum number of beats to be transferred in one RxDMA transaction is 1 */
S  #define ETH_DMABMR_RDP_2Beat    ((uint32_t)0x00040000)  /* maximum number of beats to be transferred in one RxDMA transaction is 2 */
S  #define ETH_DMABMR_RDP_4Beat    ((uint32_t)0x00080000)  /* maximum number of beats to be transferred in one RxDMA transaction is 4 */
S  #define ETH_DMABMR_RDP_8Beat    ((uint32_t)0x00100000)  /* maximum number of beats to be transferred in one RxDMA transaction is 8 */
S  #define ETH_DMABMR_RDP_16Beat   ((uint32_t)0x00200000)  /* maximum number of beats to be transferred in one RxDMA transaction is 16 */
S  #define ETH_DMABMR_RDP_32Beat   ((uint32_t)0x00400000)  /* maximum number of beats to be transferred in one RxDMA transaction is 32 */                
S  #define ETH_DMABMR_RDP_4xPBL_4Beat   ((uint32_t)0x01020000)  /* maximum number of beats to be transferred in one RxDMA transaction is 4 */
S  #define ETH_DMABMR_RDP_4xPBL_8Beat   ((uint32_t)0x01040000)  /* maximum number of beats to be transferred in one RxDMA transaction is 8 */
S  #define ETH_DMABMR_RDP_4xPBL_16Beat  ((uint32_t)0x01080000)  /* maximum number of beats to be transferred in one RxDMA transaction is 16 */
S  #define ETH_DMABMR_RDP_4xPBL_32Beat  ((uint32_t)0x01100000)  /* maximum number of beats to be transferred in one RxDMA transaction is 32 */
S  #define ETH_DMABMR_RDP_4xPBL_64Beat  ((uint32_t)0x01200000)  /* maximum number of beats to be transferred in one RxDMA transaction is 64 */
S  #define ETH_DMABMR_RDP_4xPBL_128Beat ((uint32_t)0x01400000)  /* maximum number of beats to be transferred in one RxDMA transaction is 128 */  
S#define ETH_DMABMR_FB        ((uint32_t)0x00010000)  /* Fixed Burst */
S#define ETH_DMABMR_RTPR      ((uint32_t)0x0000C000)  /* Rx Tx priority ratio */
S  #define ETH_DMABMR_RTPR_1_1     ((uint32_t)0x00000000)  /* Rx Tx priority ratio */
S  #define ETH_DMABMR_RTPR_2_1     ((uint32_t)0x00004000)  /* Rx Tx priority ratio */
S  #define ETH_DMABMR_RTPR_3_1     ((uint32_t)0x00008000)  /* Rx Tx priority ratio */
S  #define ETH_DMABMR_RTPR_4_1     ((uint32_t)0x0000C000)  /* Rx Tx priority ratio */  
S#define ETH_DMABMR_PBL    ((uint32_t)0x00003F00)  /* Programmable burst length */
S  #define ETH_DMABMR_PBL_1Beat    ((uint32_t)0x00000100)  /* maximum number of beats to be transferred in one TxDMA (or both) transaction is 1 */
S  #define ETH_DMABMR_PBL_2Beat    ((uint32_t)0x00000200)  /* maximum number of beats to be transferred in one TxDMA (or both) transaction is 2 */
S  #define ETH_DMABMR_PBL_4Beat    ((uint32_t)0x00000400)  /* maximum number of beats to be transferred in one TxDMA (or both) transaction is 4 */
S  #define ETH_DMABMR_PBL_8Beat    ((uint32_t)0x00000800)  /* maximum number of beats to be transferred in one TxDMA (or both) transaction is 8 */
S  #define ETH_DMABMR_PBL_16Beat   ((uint32_t)0x00001000)  /* maximum number of beats to be transferred in one TxDMA (or both) transaction is 16 */
S  #define ETH_DMABMR_PBL_32Beat   ((uint32_t)0x00002000)  /* maximum number of beats to be transferred in one TxDMA (or both) transaction is 32 */                
S  #define ETH_DMABMR_PBL_4xPBL_4Beat   ((uint32_t)0x01000100)  /* maximum number of beats to be transferred in one TxDMA (or both) transaction is 4 */
S  #define ETH_DMABMR_PBL_4xPBL_8Beat   ((uint32_t)0x01000200)  /* maximum number of beats to be transferred in one TxDMA (or both) transaction is 8 */
S  #define ETH_DMABMR_PBL_4xPBL_16Beat  ((uint32_t)0x01000400)  /* maximum number of beats to be transferred in one TxDMA (or both) transaction is 16 */
S  #define ETH_DMABMR_PBL_4xPBL_32Beat  ((uint32_t)0x01000800)  /* maximum number of beats to be transferred in one TxDMA (or both) transaction is 32 */
S  #define ETH_DMABMR_PBL_4xPBL_64Beat  ((uint32_t)0x01001000)  /* maximum number of beats to be transferred in one TxDMA (or both) transaction is 64 */
S  #define ETH_DMABMR_PBL_4xPBL_128Beat ((uint32_t)0x01002000)  /* maximum number of beats to be transferred in one TxDMA (or both) transaction is 128 */
S#define ETH_DMABMR_DSL       ((uint32_t)0x0000007C)  /* Descriptor Skip Length */
S#define ETH_DMABMR_DA        ((uint32_t)0x00000002)  /* DMA arbitration scheme */
S#define ETH_DMABMR_SR        ((uint32_t)0x00000001)  /* Software reset */
S
S/* Bit definition for Ethernet DMA Transmit Poll Demand Register */
S#define ETH_DMATPDR_TPD      ((uint32_t)0xFFFFFFFF)  /* Transmit poll demand */
S
S/* Bit definition for Ethernet DMA Receive Poll Demand Register */
S#define ETH_DMARPDR_RPD      ((uint32_t)0xFFFFFFFF)  /* Receive poll demand  */
S
S/* Bit definition for Ethernet DMA Receive Descriptor List Address Register */
S#define ETH_DMARDLAR_SRL     ((uint32_t)0xFFFFFFFF)  /* Start of receive list */
S
S/* Bit definition for Ethernet DMA Transmit Descriptor List Address Register */
S#define ETH_DMATDLAR_STL     ((uint32_t)0xFFFFFFFF)  /* Start of transmit list */
S
S/* Bit definition for Ethernet DMA Status Register */
S#define ETH_DMASR_TSTS       ((uint32_t)0x20000000)  /* Time-stamp trigger status */
S#define ETH_DMASR_PMTS       ((uint32_t)0x10000000)  /* PMT status */
S#define ETH_DMASR_MMCS       ((uint32_t)0x08000000)  /* MMC status */
S#define ETH_DMASR_EBS        ((uint32_t)0x03800000)  /* Error bits status */
S  /* combination with EBS[2:0] for GetFlagStatus function */
S  #define ETH_DMASR_EBS_DescAccess      ((uint32_t)0x02000000)  /* Error bits 0-data buffer, 1-desc. access */
S  #define ETH_DMASR_EBS_ReadTransf      ((uint32_t)0x01000000)  /* Error bits 0-write trnsf, 1-read transfr */
S  #define ETH_DMASR_EBS_DataTransfTx    ((uint32_t)0x00800000)  /* Error bits 0-Rx DMA, 1-Tx DMA */
S#define ETH_DMASR_TPS         ((uint32_t)0x00700000)  /* Transmit process state */
S  #define ETH_DMASR_TPS_Stopped         ((uint32_t)0x00000000)  /* Stopped - Reset or Stop Tx Command issued  */
S  #define ETH_DMASR_TPS_Fetching        ((uint32_t)0x00100000)  /* Running - fetching the Tx descriptor */
S  #define ETH_DMASR_TPS_Waiting         ((uint32_t)0x00200000)  /* Running - waiting for status */
S  #define ETH_DMASR_TPS_Reading         ((uint32_t)0x00300000)  /* Running - reading the data from host memory */
S  #define ETH_DMASR_TPS_Suspended       ((uint32_t)0x00600000)  /* Suspended - Tx Descriptor unavailabe */
S  #define ETH_DMASR_TPS_Closing         ((uint32_t)0x00700000)  /* Running - closing Rx descriptor */
S#define ETH_DMASR_RPS         ((uint32_t)0x000E0000)  /* Receive process state */
S  #define ETH_DMASR_RPS_Stopped         ((uint32_t)0x00000000)  /* Stopped - Reset or Stop Rx Command issued */
S  #define ETH_DMASR_RPS_Fetching        ((uint32_t)0x00020000)  /* Running - fetching the Rx descriptor */
S  #define ETH_DMASR_RPS_Waiting         ((uint32_t)0x00060000)  /* Running - waiting for packet */
S  #define ETH_DMASR_RPS_Suspended       ((uint32_t)0x00080000)  /* Suspended - Rx Descriptor unavailable */
S  #define ETH_DMASR_RPS_Closing         ((uint32_t)0x000A0000)  /* Running - closing descriptor */
S  #define ETH_DMASR_RPS_Queuing         ((uint32_t)0x000E0000)  /* Running - queuing the recieve frame into host memory */
S#define ETH_DMASR_NIS        ((uint32_t)0x00010000)  /* Normal interrupt summary */
S#define ETH_DMASR_AIS        ((uint32_t)0x00008000)  /* Abnormal interrupt summary */
S#define ETH_DMASR_ERS        ((uint32_t)0x00004000)  /* Early receive status */
S#define ETH_DMASR_FBES       ((uint32_t)0x00002000)  /* Fatal bus error status */
S#define ETH_DMASR_ETS        ((uint32_t)0x00000400)  /* Early transmit status */
S#define ETH_DMASR_RWTS       ((uint32_t)0x00000200)  /* Receive watchdog timeout status */
S#define ETH_DMASR_RPSS       ((uint32_t)0x00000100)  /* Receive process stopped status */
S#define ETH_DMASR_RBUS       ((uint32_t)0x00000080)  /* Receive buffer unavailable status */
S#define ETH_DMASR_RS         ((uint32_t)0x00000040)  /* Receive status */
S#define ETH_DMASR_TUS        ((uint32_t)0x00000020)  /* Transmit underflow status */
S#define ETH_DMASR_ROS        ((uint32_t)0x00000010)  /* Receive overflow status */
S#define ETH_DMASR_TJTS       ((uint32_t)0x00000008)  /* Transmit jabber timeout status */
S#define ETH_DMASR_TBUS       ((uint32_t)0x00000004)  /* Transmit buffer unavailable status */
S#define ETH_DMASR_TPSS       ((uint32_t)0x00000002)  /* Transmit process stopped status */
S#define ETH_DMASR_TS         ((uint32_t)0x00000001)  /* Transmit status */
S
S/* Bit definition for Ethernet DMA Operation Mode Register */
S#define ETH_DMAOMR_DTCEFD    ((uint32_t)0x04000000)  /* Disable Dropping of TCP/IP checksum error frames */
S#define ETH_DMAOMR_RSF       ((uint32_t)0x02000000)  /* Receive store and forward */
S#define ETH_DMAOMR_DFRF      ((uint32_t)0x01000000)  /* Disable flushing of received frames */
S#define ETH_DMAOMR_TSF       ((uint32_t)0x00200000)  /* Transmit store and forward */
S#define ETH_DMAOMR_FTF       ((uint32_t)0x00100000)  /* Flush transmit FIFO */
S#define ETH_DMAOMR_TTC       ((uint32_t)0x0001C000)  /* Transmit threshold control */
S  #define ETH_DMAOMR_TTC_64Bytes       ((uint32_t)0x00000000)  /* threshold level of the MTL Transmit FIFO is 64 Bytes */
S  #define ETH_DMAOMR_TTC_128Bytes      ((uint32_t)0x00004000)  /* threshold level of the MTL Transmit FIFO is 128 Bytes */
S  #define ETH_DMAOMR_TTC_192Bytes      ((uint32_t)0x00008000)  /* threshold level of the MTL Transmit FIFO is 192 Bytes */
S  #define ETH_DMAOMR_TTC_256Bytes      ((uint32_t)0x0000C000)  /* threshold level of the MTL Transmit FIFO is 256 Bytes */
S  #define ETH_DMAOMR_TTC_40Bytes       ((uint32_t)0x00010000)  /* threshold level of the MTL Transmit FIFO is 40 Bytes */
S  #define ETH_DMAOMR_TTC_32Bytes       ((uint32_t)0x00014000)  /* threshold level of the MTL Transmit FIFO is 32 Bytes */
S  #define ETH_DMAOMR_TTC_24Bytes       ((uint32_t)0x00018000)  /* threshold level of the MTL Transmit FIFO is 24 Bytes */
S  #define ETH_DMAOMR_TTC_16Bytes       ((uint32_t)0x0001C000)  /* threshold level of the MTL Transmit FIFO is 16 Bytes */
S#define ETH_DMAOMR_ST        ((uint32_t)0x00002000)  /* Start/stop transmission command */
S#define ETH_DMAOMR_FEF       ((uint32_t)0x00000080)  /* Forward error frames */
S#define ETH_DMAOMR_FUGF      ((uint32_t)0x00000040)  /* Forward undersized good frames */
S#define ETH_DMAOMR_RTC       ((uint32_t)0x00000018)  /* receive threshold control */
S  #define ETH_DMAOMR_RTC_64Bytes       ((uint32_t)0x00000000)  /* threshold level of the MTL Receive FIFO is 64 Bytes */
S  #define ETH_DMAOMR_RTC_32Bytes       ((uint32_t)0x00000008)  /* threshold level of the MTL Receive FIFO is 32 Bytes */
S  #define ETH_DMAOMR_RTC_96Bytes       ((uint32_t)0x00000010)  /* threshold level of the MTL Receive FIFO is 96 Bytes */
S  #define ETH_DMAOMR_RTC_128Bytes      ((uint32_t)0x00000018)  /* threshold level of the MTL Receive FIFO is 128 Bytes */
S#define ETH_DMAOMR_OSF       ((uint32_t)0x00000004)  /* operate on second frame */
S#define ETH_DMAOMR_SR        ((uint32_t)0x00000002)  /* Start/stop receive */
S
S/* Bit definition for Ethernet DMA Interrupt Enable Register */
S#define ETH_DMAIER_NISE      ((uint32_t)0x00010000)  /* Normal interrupt summary enable */
S#define ETH_DMAIER_AISE      ((uint32_t)0x00008000)  /* Abnormal interrupt summary enable */
S#define ETH_DMAIER_ERIE      ((uint32_t)0x00004000)  /* Early receive interrupt enable */
S#define ETH_DMAIER_FBEIE     ((uint32_t)0x00002000)  /* Fatal bus error interrupt enable */
S#define ETH_DMAIER_ETIE      ((uint32_t)0x00000400)  /* Early transmit interrupt enable */
S#define ETH_DMAIER_RWTIE     ((uint32_t)0x00000200)  /* Receive watchdog timeout interrupt enable */
S#define ETH_DMAIER_RPSIE     ((uint32_t)0x00000100)  /* Receive process stopped interrupt enable */
S#define ETH_DMAIER_RBUIE     ((uint32_t)0x00000080)  /* Receive buffer unavailable interrupt enable */
S#define ETH_DMAIER_RIE       ((uint32_t)0x00000040)  /* Receive interrupt enable */
S#define ETH_DMAIER_TUIE      ((uint32_t)0x00000020)  /* Transmit Underflow interrupt enable */
S#define ETH_DMAIER_ROIE      ((uint32_t)0x00000010)  /* Receive Overflow interrupt enable */
S#define ETH_DMAIER_TJTIE     ((uint32_t)0x00000008)  /* Transmit jabber timeout interrupt enable */
S#define ETH_DMAIER_TBUIE     ((uint32_t)0x00000004)  /* Transmit buffer unavailable interrupt enable */
S#define ETH_DMAIER_TPSIE     ((uint32_t)0x00000002)  /* Transmit process stopped interrupt enable */
S#define ETH_DMAIER_TIE       ((uint32_t)0x00000001)  /* Transmit interrupt enable */
S
S/* Bit definition for Ethernet DMA Missed Frame and Buffer Overflow Counter Register */
S#define ETH_DMAMFBOCR_OFOC   ((uint32_t)0x10000000)  /* Overflow bit for FIFO overflow counter */
S#define ETH_DMAMFBOCR_MFA    ((uint32_t)0x0FFE0000)  /* Number of frames missed by the application */
S#define ETH_DMAMFBOCR_OMFC   ((uint32_t)0x00010000)  /* Overflow bit for missed frame counter */
S#define ETH_DMAMFBOCR_MFC    ((uint32_t)0x0000FFFF)  /* Number of frames missed by the controller */
S
S/* Bit definition for Ethernet DMA Current Host Transmit Descriptor Register */
S#define ETH_DMACHTDR_HTDAP   ((uint32_t)0xFFFFFFFF)  /* Host transmit descriptor address pointer */
S
S/* Bit definition for Ethernet DMA Current Host Receive Descriptor Register */
S#define ETH_DMACHRDR_HRDAP   ((uint32_t)0xFFFFFFFF)  /* Host receive descriptor address pointer */
S
S/* Bit definition for Ethernet DMA Current Host Transmit Buffer Address Register */
S#define ETH_DMACHTBAR_HTBAP  ((uint32_t)0xFFFFFFFF)  /* Host transmit buffer address pointer */
S
S/* Bit definition for Ethernet DMA Current Host Receive Buffer Address Register */
S#define ETH_DMACHRBAR_HRBAP  ((uint32_t)0xFFFFFFFF)  /* Host receive buffer address pointer */
N#endif /* STM32F10X_CL */
N
N/**
N  * @}
N  */
N
N /**
N  * @}
N  */ 
N
N#ifdef USE_STDPERIPH_DRIVER
N  #include "stm32f10x_conf.h"
L 1 "..\..\User\stm32f10x_conf.h" 1
N/**
N  ******************************************************************************
N  * @file    Project/STM32F10x_StdPeriph_Template/stm32f10x_conf.h 
N  * @author  MCD Application Team
N  * @version V3.5.0
N  * @date    08-April-2011
N  * @brief   Library configuration file.
N  ******************************************************************************
N  * @attention
N  *
N  * THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
N  * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE
N  * TIME. AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY
N  * DIRECT, INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING
N  * FROM THE CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE
N  * CODING INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
N  *
N  * <h2><center>&copy; COPYRIGHT 2011 STMicroelectronics</center></h2>
N  ******************************************************************************
N  */
N
N/* Define to prevent recursive inclusion -------------------------------------*/
N#ifndef __STM32F10x_CONF_H
N#define __STM32F10x_CONF_H
N
N/* Includes ------------------------------------------------------------------*/
N/* Uncomment/Comment the line below to enable/disable peripheral header file inclusion */
N//#include "stm32f10x_adc.h" 
N#include "stm32f10x_bkp.h" 
L 1 "..\..\Libraries\FWlib\inc\stm32f10x_bkp.h" 1
N/**
N  ******************************************************************************
N  * @file    stm32f10x_bkp.h
N  * @author  MCD Application Team
N  * @version V3.5.0
N  * @date    11-March-2011
N  * @brief   This file contains all the functions prototypes for the BKP firmware 
N  *          library.
N  ******************************************************************************
N  * @attention
N  *
N  * THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
N  * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE
N  * TIME. AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY
N  * DIRECT, INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING
N  * FROM THE CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE
N  * CODING INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
N  *
N  * <h2><center>&copy; COPYRIGHT 2011 STMicroelectronics</center></h2>
N  ******************************************************************************
N  */
N
N/* Define to prevent recursive inclusion -------------------------------------*/
N#ifndef __STM32F10x_BKP_H
N#define __STM32F10x_BKP_H
N
N#ifdef __cplusplus
S extern "C" {
N#endif
N
N/* Includes ------------------------------------------------------------------*/
N#include "stm32f10x.h"
L 1 "..\..\Libraries\CMSIS\stm32f10x.h" 1
N/**
N  ******************************************************************************
N  * @file    stm32f10x.h
N  * @author  MCD Application Team
N  * @version V3.5.0
N  * @date    11-March-2011
N  * @brief   CMSIS Cortex-M3 Device Peripheral Access Layer Header File. 
N  *          This file contains all the peripheral register's definitions, bits 
N  *          definitions and memory mapping for STM32F10x Connectivity line, 
N  *          High density, High density value line, Medium density, 
N  *          Medium density Value line, Low density, Low density Value line 
N  *          and XL-density devices.
N  *
N  *          The file is the unique include file that the application programmer
N  *          is using in the C source code, usually in main.c. This file contains:
N  *           - Configuration section that allows to select:
N  *              - The device used in the target application
N  *              - To use or not the peripheral’s drivers in application code(i.e. 
N  *                code will be based on direct access to peripheral’s registers 
N  *                rather than drivers API), this option is controlled by 
N  *                "#define USE_STDPERIPH_DRIVER"
N  *              - To change few application-specific parameters such as the HSE 
N  *                crystal frequency
N  *           - Data structures and the address mapping for all peripherals
N  *           - Peripheral's registers declarations and bits definition
N  *           - Macros to access peripheral’s registers hardware
N  *
N  ******************************************************************************
N  * @attention
N  *
N  * THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
N  * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE
N  * TIME. AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY
N  * DIRECT, INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING
N  * FROM THE CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE
N  * CODING INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
N  *
N  * <h2><center>&copy; COPYRIGHT 2011 STMicroelectronics</center></h2>
N  ******************************************************************************
N  */
N
N/** @addtogroup CMSIS
N  * @{
N  */
N
N/** @addtogroup stm32f10x
N  * @{
N  */
N    
N#ifndef __STM32F10x_H
S#define __STM32F10x_H
S
S#ifdef __cplusplus
S extern "C" {
S#endif 
S  
S/** @addtogroup Library_configuration_section
S  * @{
S  */
S  
S/* Uncomment the line below according to the target STM32 device used in your
S   application 
S  */
S
S#if !defined (STM32F10X_LD) && !defined (STM32F10X_LD_VL) && !defined (STM32F10X_MD) && !defined (STM32F10X_MD_VL) && !defined (STM32F10X_HD) && !defined (STM32F10X_HD_VL) && !defined (STM32F10X_XL) && !defined (STM32F10X_CL) 
S  /* #define STM32F10X_LD */     /*!< STM32F10X_LD: STM32 Low density devices */
S  /* #define STM32F10X_LD_VL */  /*!< STM32F10X_LD_VL: STM32 Low density Value Line devices */  
S  /* #define STM32F10X_MD */     /*!< STM32F10X_MD: STM32 Medium density devices */
S  /* #define STM32F10X_MD_VL */  /*!< STM32F10X_MD_VL: STM32 Medium density Value Line devices */  
S  /* #define STM32F10X_HD */     /*!< STM32F10X_HD: STM32 High density devices */
S  /* #define STM32F10X_HD_VL */  /*!< STM32F10X_HD_VL: STM32 High density value line devices */  
S  /* #define STM32F10X_XL */     /*!< STM32F10X_XL: STM32 XL-density devices */
S  /* #define STM32F10X_CL */     /*!< STM32F10X_CL: STM32 Connectivity line devices */
S#endif
S/*  Tip: To avoid modifying this file each time you need to switch between these
S        devices, you can define the device in your toolchain compiler preprocessor.
S
S - Low-density devices are STM32F101xx, STM32F102xx and STM32F103xx microcontrollers
S   where the Flash memory density ranges between 16 and 32 Kbytes.
S - Low-density value line devices are STM32F100xx microcontrollers where the Flash
S   memory density ranges between 16 and 32 Kbytes.
S - Medium-density devices are STM32F101xx, STM32F102xx and STM32F103xx microcontrollers
S   where the Flash memory density ranges between 64 and 128 Kbytes.
S - Medium-density value line devices are STM32F100xx microcontrollers where the 
S   Flash memory density ranges between 64 and 128 Kbytes.   
S - High-density devices are STM32F101xx and STM32F103xx microcontrollers where
S   the Flash memory density ranges between 256 and 512 Kbytes.
S - High-density value line devices are STM32F100xx microcontrollers where the 
S   Flash memory density ranges between 256 and 512 Kbytes.   
S - XL-density devices are STM32F101xx and STM32F103xx microcontrollers where
S   the Flash memory density ranges between 512 and 1024 Kbytes.
S - Connectivity line devices are STM32F105xx and STM32F107xx microcontrollers.
S  */
S
S#if !defined (STM32F10X_LD) && !defined (STM32F10X_LD_VL) && !defined (STM32F10X_MD) && !defined (STM32F10X_MD_VL) && !defined (STM32F10X_HD) && !defined (STM32F10X_HD_VL) && !defined (STM32F10X_XL) && !defined (STM32F10X_CL)
S #error "Please select first the target STM32F10x device used in your application (in stm32f10x.h file)"
S#endif
S
S#if !defined  USE_STDPERIPH_DRIVER
S/**
S * @brief Comment the line below if you will not use the peripherals drivers.
S   In this case, these drivers will not be included and the application code will 
S   be based on direct access to peripherals registers 
S   */
S  /*#define USE_STDPERIPH_DRIVER*/
S#endif
S
S/**
S * @brief In the following line adjust the value of External High Speed oscillator (HSE)
S   used in your application 
S   
S   Tip: To avoid modifying this file each time you need to use different HSE, you
S        can define the HSE value in your toolchain compiler preprocessor.
S  */           
S#if !defined  HSE_VALUE
S #ifdef STM32F10X_CL   
S  #define HSE_VALUE    ((uint32_t)25000000) /*!< Value of the External oscillator in Hz */
S #else 
S  #define HSE_VALUE    ((uint32_t)8000000) /*!< Value of the External oscillator in Hz */
S #endif /* STM32F10X_CL */
S#endif /* HSE_VALUE */
S
S
S/**
S * @brief In the following line adjust the External High Speed oscillator (HSE) Startup 
S   Timeout value 
S   */
S#define HSE_STARTUP_TIMEOUT   ((uint16_t)0x0500) /*!< Time out for HSE start up */
S
S#define HSI_VALUE    ((uint32_t)8000000) /*!< Value of the Internal oscillator in Hz*/
S
S/**
S * @brief STM32F10x Standard Peripheral Library version number
S   */
S#define __STM32F10X_STDPERIPH_VERSION_MAIN   (0x03) /*!< [31:24] main version */                                  
S#define __STM32F10X_STDPERIPH_VERSION_SUB1   (0x05) /*!< [23:16] sub1 version */
S#define __STM32F10X_STDPERIPH_VERSION_SUB2   (0x00) /*!< [15:8]  sub2 version */
S#define __STM32F10X_STDPERIPH_VERSION_RC     (0x00) /*!< [7:0]  release candidate */ 
S#define __STM32F10X_STDPERIPH_VERSION       ( (__STM32F10X_STDPERIPH_VERSION_MAIN << 24)\
S                                             |(__STM32F10X_STDPERIPH_VERSION_SUB1 << 16)\
S                                             |(__STM32F10X_STDPERIPH_VERSION_SUB2 << 8)\
S                                             |(__STM32F10X_STDPERIPH_VERSION_RC))
X#define __STM32F10X_STDPERIPH_VERSION       ( (__STM32F10X_STDPERIPH_VERSION_MAIN << 24)                                             |(__STM32F10X_STDPERIPH_VERSION_SUB1 << 16)                                             |(__STM32F10X_STDPERIPH_VERSION_SUB2 << 8)                                             |(__STM32F10X_STDPERIPH_VERSION_RC))
S
S/**
S  * @}
S  */
S
S/** @addtogroup Configuration_section_for_CMSIS
S  * @{
S  */
S
S/**
S * @brief Configuration of the Cortex-M3 Processor and Core Peripherals 
S */
S#ifdef STM32F10X_XL
S #define __MPU_PRESENT             1 /*!< STM32 XL-density devices provide an MPU */
S#else
S #define __MPU_PRESENT             0 /*!< Other STM32 devices does not provide an MPU */
S#endif /* STM32F10X_XL */
S#define __NVIC_PRIO_BITS          4 /*!< STM32 uses 4 Bits for the Priority Levels    */
S#define __Vendor_SysTickConfig    0 /*!< Set to 1 if different SysTick Config is used */
S
S/**
S * @brief STM32F10x Interrupt Number Definition, according to the selected device 
S *        in @ref Library_configuration_section 
S */
Stypedef enum IRQn
S{
S/******  Cortex-M3 Processor Exceptions Numbers ***************************************************/
S  NonMaskableInt_IRQn         = -14,    /*!< 2 Non Maskable Interrupt                             */
S  MemoryManagement_IRQn       = -12,    /*!< 4 Cortex-M3 Memory Management Interrupt              */
S  BusFault_IRQn               = -11,    /*!< 5 Cortex-M3 Bus Fault Interrupt                      */
S  UsageFault_IRQn             = -10,    /*!< 6 Cortex-M3 Usage Fault Interrupt                    */
S  SVCall_IRQn                 = -5,     /*!< 11 Cortex-M3 SV Call Interrupt                       */
S  DebugMonitor_IRQn           = -4,     /*!< 12 Cortex-M3 Debug Monitor Interrupt                 */
S  PendSV_IRQn                 = -2,     /*!< 14 Cortex-M3 Pend SV Interrupt                       */
S  SysTick_IRQn                = -1,     /*!< 15 Cortex-M3 System Tick Interrupt                   */
S
S/******  STM32 specific Interrupt Numbers *********************************************************/
S  WWDG_IRQn                   = 0,      /*!< Window WatchDog Interrupt                            */
S  PVD_IRQn                    = 1,      /*!< PVD through EXTI Line detection Interrupt            */
S  TAMPER_IRQn                 = 2,      /*!< Tamper Interrupt                                     */
S  RTC_IRQn                    = 3,      /*!< RTC global Interrupt                                 */
S  FLASH_IRQn                  = 4,      /*!< FLASH global Interrupt                               */
S  RCC_IRQn                    = 5,      /*!< RCC global Interrupt                                 */
S  EXTI0_IRQn                  = 6,      /*!< EXTI Line0 Interrupt                                 */
S  EXTI1_IRQn                  = 7,      /*!< EXTI Line1 Interrupt                                 */
S  EXTI2_IRQn                  = 8,      /*!< EXTI Line2 Interrupt                                 */
S  EXTI3_IRQn                  = 9,      /*!< EXTI Line3 Interrupt                                 */
S  EXTI4_IRQn                  = 10,     /*!< EXTI Line4 Interrupt                                 */
S  DMA1_Channel1_IRQn          = 11,     /*!< DMA1 Channel 1 global Interrupt                      */
S  DMA1_Channel2_IRQn          = 12,     /*!< DMA1 Channel 2 global Interrupt                      */
S  DMA1_Channel3_IRQn          = 13,     /*!< DMA1 Channel 3 global Interrupt                      */
S  DMA1_Channel4_IRQn          = 14,     /*!< DMA1 Channel 4 global Interrupt                      */
S  DMA1_Channel5_IRQn          = 15,     /*!< DMA1 Channel 5 global Interrupt                      */
S  DMA1_Channel6_IRQn          = 16,     /*!< DMA1 Channel 6 global Interrupt                      */
S  DMA1_Channel7_IRQn          = 17,     /*!< DMA1 Channel 7 global Interrupt                      */
S
S#ifdef STM32F10X_LD
S  ADC1_2_IRQn                 = 18,     /*!< ADC1 and ADC2 global Interrupt                       */
S  USB_HP_CAN1_TX_IRQn         = 19,     /*!< USB Device High Priority or CAN1 TX Interrupts       */
S  USB_LP_CAN1_RX0_IRQn        = 20,     /*!< USB Device Low Priority or CAN1 RX0 Interrupts       */
S  CAN1_RX1_IRQn               = 21,     /*!< CAN1 RX1 Interrupt                                   */
S  CAN1_SCE_IRQn               = 22,     /*!< CAN1 SCE Interrupt                                   */
S  EXTI9_5_IRQn                = 23,     /*!< External Line[9:5] Interrupts                        */
S  TIM1_BRK_IRQn               = 24,     /*!< TIM1 Break Interrupt                                 */
S  TIM1_UP_IRQn                = 25,     /*!< TIM1 Update Interrupt                                */
S  TIM1_TRG_COM_IRQn           = 26,     /*!< TIM1 Trigger and Commutation Interrupt               */
S  TIM1_CC_IRQn                = 27,     /*!< TIM1 Capture Compare Interrupt                       */
S  TIM2_IRQn                   = 28,     /*!< TIM2 global Interrupt                                */
S  TIM3_IRQn                   = 29,     /*!< TIM3 global Interrupt                                */
S  I2C1_EV_IRQn                = 31,     /*!< I2C1 Event Interrupt                                 */
S  I2C1_ER_IRQn                = 32,     /*!< I2C1 Error Interrupt                                 */
S  SPI1_IRQn                   = 35,     /*!< SPI1 global Interrupt                                */
S  USART1_IRQn                 = 37,     /*!< USART1 global Interrupt                              */
S  USART2_IRQn                 = 38,     /*!< USART2 global Interrupt                              */
S  EXTI15_10_IRQn              = 40,     /*!< External Line[15:10] Interrupts                      */
S  RTCAlarm_IRQn               = 41,     /*!< RTC Alarm through EXTI Line Interrupt                */
S  USBWakeUp_IRQn              = 42      /*!< USB Device WakeUp from suspend through EXTI Line Interrupt */    
S#endif /* STM32F10X_LD */  
S
S#ifdef STM32F10X_LD_VL
S  ADC1_IRQn                   = 18,     /*!< ADC1 global Interrupt                                */
S  EXTI9_5_IRQn                = 23,     /*!< External Line[9:5] Interrupts                        */
S  TIM1_BRK_TIM15_IRQn         = 24,     /*!< TIM1 Break and TIM15 Interrupts                      */
S  TIM1_UP_TIM16_IRQn          = 25,     /*!< TIM1 Update and TIM16 Interrupts                     */
S  TIM1_TRG_COM_TIM17_IRQn     = 26,     /*!< TIM1 Trigger and Commutation and TIM17 Interrupt     */
S  TIM1_CC_IRQn                = 27,     /*!< TIM1 Capture Compare Interrupt                       */
S  TIM2_IRQn                   = 28,     /*!< TIM2 global Interrupt                                */
S  TIM3_IRQn                   = 29,     /*!< TIM3 global Interrupt                                */
S  I2C1_EV_IRQn                = 31,     /*!< I2C1 Event Interrupt                                 */
S  I2C1_ER_IRQn                = 32,     /*!< I2C1 Error Interrupt                                 */
S  SPI1_IRQn                   = 35,     /*!< SPI1 global Interrupt                                */
S  USART1_IRQn                 = 37,     /*!< USART1 global Interrupt                              */
S  USART2_IRQn                 = 38,     /*!< USART2 global Interrupt                              */
S  EXTI15_10_IRQn              = 40,     /*!< External Line[15:10] Interrupts                      */
S  RTCAlarm_IRQn               = 41,     /*!< RTC Alarm through EXTI Line Interrupt                */
S  CEC_IRQn                    = 42,     /*!< HDMI-CEC Interrupt                                   */
S  TIM6_DAC_IRQn               = 54,     /*!< TIM6 and DAC underrun Interrupt                      */
S  TIM7_IRQn                   = 55      /*!< TIM7 Interrupt                                       */       
S#endif /* STM32F10X_LD_VL */
S
S#ifdef STM32F10X_MD
S  ADC1_2_IRQn                 = 18,     /*!< ADC1 and ADC2 global Interrupt                       */
S  USB_HP_CAN1_TX_IRQn         = 19,     /*!< USB Device High Priority or CAN1 TX Interrupts       */
S  USB_LP_CAN1_RX0_IRQn        = 20,     /*!< USB Device Low Priority or CAN1 RX0 Interrupts       */
S  CAN1_RX1_IRQn               = 21,     /*!< CAN1 RX1 Interrupt                                   */
S  CAN1_SCE_IRQn               = 22,     /*!< CAN1 SCE Interrupt                                   */
S  EXTI9_5_IRQn                = 23,     /*!< External Line[9:5] Interrupts                        */
S  TIM1_BRK_IRQn               = 24,     /*!< TIM1 Break Interrupt                                 */
S  TIM1_UP_IRQn                = 25,     /*!< TIM1 Update Interrupt                                */
S  TIM1_TRG_COM_IRQn           = 26,     /*!< TIM1 Trigger and Commutation Interrupt               */
S  TIM1_CC_IRQn                = 27,     /*!< TIM1 Capture Compare Interrupt                       */
S  TIM2_IRQn                   = 28,     /*!< TIM2 global Interrupt                                */
S  TIM3_IRQn                   = 29,     /*!< TIM3 global Interrupt                                */
S  TIM4_IRQn                   = 30,     /*!< TIM4 global Interrupt                                */
S  I2C1_EV_IRQn                = 31,     /*!< I2C1 Event Interrupt                                 */
S  I2C1_ER_IRQn                = 32,     /*!< I2C1 Error Interrupt                                 */
S  I2C2_EV_IRQn                = 33,     /*!< I2C2 Event Interrupt                                 */
S  I2C2_ER_IRQn                = 34,     /*!< I2C2 Error Interrupt                                 */
S  SPI1_IRQn                   = 35,     /*!< SPI1 global Interrupt                                */
S  SPI2_IRQn                   = 36,     /*!< SPI2 global Interrupt                                */
S  USART1_IRQn                 = 37,     /*!< USART1 global Interrupt                              */
S  USART2_IRQn                 = 38,     /*!< USART2 global Interrupt                              */
S  USART3_IRQn                 = 39,     /*!< USART3 global Interrupt                              */
S  EXTI15_10_IRQn              = 40,     /*!< External Line[15:10] Interrupts                      */
S  RTCAlarm_IRQn               = 41,     /*!< RTC Alarm through EXTI Line Interrupt                */
S  USBWakeUp_IRQn              = 42      /*!< USB Device WakeUp from suspend through EXTI Line Interrupt */  
S#endif /* STM32F10X_MD */  
S
S#ifdef STM32F10X_MD_VL
S  ADC1_IRQn                   = 18,     /*!< ADC1 global Interrupt                                */
S  EXTI9_5_IRQn                = 23,     /*!< External Line[9:5] Interrupts                        */
S  TIM1_BRK_TIM15_IRQn         = 24,     /*!< TIM1 Break and TIM15 Interrupts                      */
S  TIM1_UP_TIM16_IRQn          = 25,     /*!< TIM1 Update and TIM16 Interrupts                     */
S  TIM1_TRG_COM_TIM17_IRQn     = 26,     /*!< TIM1 Trigger and Commutation and TIM17 Interrupt     */
S  TIM1_CC_IRQn                = 27,     /*!< TIM1 Capture Compare Interrupt                       */
S  TIM2_IRQn                   = 28,     /*!< TIM2 global Interrupt                                */
S  TIM3_IRQn                   = 29,     /*!< TIM3 global Interrupt                                */
S  TIM4_IRQn                   = 30,     /*!< TIM4 global Interrupt                                */
S  I2C1_EV_IRQn                = 31,     /*!< I2C1 Event Interrupt                                 */
S  I2C1_ER_IRQn                = 32,     /*!< I2C1 Error Interrupt                                 */
S  I2C2_EV_IRQn                = 33,     /*!< I2C2 Event Interrupt                                 */
S  I2C2_ER_IRQn                = 34,     /*!< I2C2 Error Interrupt                                 */
S  SPI1_IRQn                   = 35,     /*!< SPI1 global Interrupt                                */
S  SPI2_IRQn                   = 36,     /*!< SPI2 global Interrupt                                */
S  USART1_IRQn                 = 37,     /*!< USART1 global Interrupt                              */
S  USART2_IRQn                 = 38,     /*!< USART2 global Interrupt                              */
S  USART3_IRQn                 = 39,     /*!< USART3 global Interrupt                              */
S  EXTI15_10_IRQn              = 40,     /*!< External Line[15:10] Interrupts                      */
S  RTCAlarm_IRQn               = 41,     /*!< RTC Alarm through EXTI Line Interrupt                */
S  CEC_IRQn                    = 42,     /*!< HDMI-CEC Interrupt                                   */
S  TIM6_DAC_IRQn               = 54,     /*!< TIM6 and DAC underrun Interrupt                      */
S  TIM7_IRQn                   = 55      /*!< TIM7 Interrupt                                       */       
S#endif /* STM32F10X_MD_VL */
S
S#ifdef STM32F10X_HD
S  ADC1_2_IRQn                 = 18,     /*!< ADC1 and ADC2 global Interrupt                       */
S  USB_HP_CAN1_TX_IRQn         = 19,     /*!< USB Device High Priority or CAN1 TX Interrupts       */
S  USB_LP_CAN1_RX0_IRQn        = 20,     /*!< USB Device Low Priority or CAN1 RX0 Interrupts       */
S  CAN1_RX1_IRQn               = 21,     /*!< CAN1 RX1 Interrupt                                   */
S  CAN1_SCE_IRQn               = 22,     /*!< CAN1 SCE Interrupt                                   */
S  EXTI9_5_IRQn                = 23,     /*!< External Line[9:5] Interrupts                        */
S  TIM1_BRK_IRQn               = 24,     /*!< TIM1 Break Interrupt                                 */
S  TIM1_UP_IRQn                = 25,     /*!< TIM1 Update Interrupt                                */
S  TIM1_TRG_COM_IRQn           = 26,     /*!< TIM1 Trigger and Commutation Interrupt               */
S  TIM1_CC_IRQn                = 27,     /*!< TIM1 Capture Compare Interrupt                       */
S  TIM2_IRQn                   = 28,     /*!< TIM2 global Interrupt                                */
S  TIM3_IRQn                   = 29,     /*!< TIM3 global Interrupt                                */
S  TIM4_IRQn                   = 30,     /*!< TIM4 global Interrupt                                */
S  I2C1_EV_IRQn                = 31,     /*!< I2C1 Event Interrupt                                 */
S  I2C1_ER_IRQn                = 32,     /*!< I2C1 Error Interrupt                                 */
S  I2C2_EV_IRQn                = 33,     /*!< I2C2 Event Interrupt                                 */
S  I2C2_ER_IRQn                = 34,     /*!< I2C2 Error Interrupt                                 */
S  SPI1_IRQn                   = 35,     /*!< SPI1 global Interrupt                                */
S  SPI2_IRQn                   = 36,     /*!< SPI2 global Interrupt                                */
S  USART1_IRQn                 = 37,     /*!< USART1 global Interrupt                              */
S  USART2_IRQn                 = 38,     /*!< USART2 global Interrupt                              */
S  USART3_IRQn                 = 39,     /*!< USART3 global Interrupt                              */
S  EXTI15_10_IRQn              = 40,     /*!< External Line[15:10] Interrupts                      */
S  RTCAlarm_IRQn               = 41,     /*!< RTC Alarm through EXTI Line Interrupt                */
S  USBWakeUp_IRQn              = 42,     /*!< USB Device WakeUp from suspend through EXTI Line Interrupt */
S  TIM8_BRK_IRQn               = 43,     /*!< TIM8 Break Interrupt                                 */
S  TIM8_UP_IRQn                = 44,     /*!< TIM8 Update Interrupt                                */
S  TIM8_TRG_COM_IRQn           = 45,     /*!< TIM8 Trigger and Commutation Interrupt               */
S  TIM8_CC_IRQn                = 46,     /*!< TIM8 Capture Compare Interrupt                       */
S  ADC3_IRQn                   = 47,     /*!< ADC3 global Interrupt                                */
S  FSMC_IRQn                   = 48,     /*!< FSMC global Interrupt                                */
S  SDIO_IRQn                   = 49,     /*!< SDIO global Interrupt                                */
S  TIM5_IRQn                   = 50,     /*!< TIM5 global Interrupt                                */
S  SPI3_IRQn                   = 51,     /*!< SPI3 global Interrupt                                */
S  UART4_IRQn                  = 52,     /*!< UART4 global Interrupt                               */
S  UART5_IRQn                  = 53,     /*!< UART5 global Interrupt                               */
S  TIM6_IRQn                   = 54,     /*!< TIM6 global Interrupt                                */
S  TIM7_IRQn                   = 55,     /*!< TIM7 global Interrupt                                */
S  DMA2_Channel1_IRQn          = 56,     /*!< DMA2 Channel 1 global Interrupt                      */
S  DMA2_Channel2_IRQn          = 57,     /*!< DMA2 Channel 2 global Interrupt                      */
S  DMA2_Channel3_IRQn          = 58,     /*!< DMA2 Channel 3 global Interrupt                      */
S  DMA2_Channel4_5_IRQn        = 59      /*!< DMA2 Channel 4 and Channel 5 global Interrupt        */
S#endif /* STM32F10X_HD */  
S
S#ifdef STM32F10X_HD_VL
S  ADC1_IRQn                   = 18,     /*!< ADC1 global Interrupt                                */
S  EXTI9_5_IRQn                = 23,     /*!< External Line[9:5] Interrupts                        */
S  TIM1_BRK_TIM15_IRQn         = 24,     /*!< TIM1 Break and TIM15 Interrupts                      */
S  TIM1_UP_TIM16_IRQn          = 25,     /*!< TIM1 Update and TIM16 Interrupts                     */
S  TIM1_TRG_COM_TIM17_IRQn     = 26,     /*!< TIM1 Trigger and Commutation and TIM17 Interrupt     */
S  TIM1_CC_IRQn                = 27,     /*!< TIM1 Capture Compare Interrupt                       */
S  TIM2_IRQn                   = 28,     /*!< TIM2 global Interrupt                                */
S  TIM3_IRQn                   = 29,     /*!< TIM3 global Interrupt                                */
S  TIM4_IRQn                   = 30,     /*!< TIM4 global Interrupt                                */
S  I2C1_EV_IRQn                = 31,     /*!< I2C1 Event Interrupt                                 */
S  I2C1_ER_IRQn                = 32,     /*!< I2C1 Error Interrupt                                 */
S  I2C2_EV_IRQn                = 33,     /*!< I2C2 Event Interrupt                                 */
S  I2C2_ER_IRQn                = 34,     /*!< I2C2 Error Interrupt                                 */
S  SPI1_IRQn                   = 35,     /*!< SPI1 global Interrupt                                */
S  SPI2_IRQn                   = 36,     /*!< SPI2 global Interrupt                                */
S  USART1_IRQn                 = 37,     /*!< USART1 global Interrupt                              */
S  USART2_IRQn                 = 38,     /*!< USART2 global Interrupt                              */
S  USART3_IRQn                 = 39,     /*!< USART3 global Interrupt                              */
S  EXTI15_10_IRQn              = 40,     /*!< External Line[15:10] Interrupts                      */
S  RTCAlarm_IRQn               = 41,     /*!< RTC Alarm through EXTI Line Interrupt                */
S  CEC_IRQn                    = 42,     /*!< HDMI-CEC Interrupt                                   */
S  TIM12_IRQn                  = 43,     /*!< TIM12 global Interrupt                               */
S  TIM13_IRQn                  = 44,     /*!< TIM13 global Interrupt                               */
S  TIM14_IRQn                  = 45,     /*!< TIM14 global Interrupt                               */
S  TIM5_IRQn                   = 50,     /*!< TIM5 global Interrupt                                */
S  SPI3_IRQn                   = 51,     /*!< SPI3 global Interrupt                                */
S  UART4_IRQn                  = 52,     /*!< UART4 global Interrupt                               */
S  UART5_IRQn                  = 53,     /*!< UART5 global Interrupt                               */  
S  TIM6_DAC_IRQn               = 54,     /*!< TIM6 and DAC underrun Interrupt                      */
S  TIM7_IRQn                   = 55,     /*!< TIM7 Interrupt                                       */  
S  DMA2_Channel1_IRQn          = 56,     /*!< DMA2 Channel 1 global Interrupt                      */
S  DMA2_Channel2_IRQn          = 57,     /*!< DMA2 Channel 2 global Interrupt                      */
S  DMA2_Channel3_IRQn          = 58,     /*!< DMA2 Channel 3 global Interrupt                      */
S  DMA2_Channel4_5_IRQn        = 59,     /*!< DMA2 Channel 4 and Channel 5 global Interrupt        */
S  DMA2_Channel5_IRQn          = 60      /*!< DMA2 Channel 5 global Interrupt (DMA2 Channel 5 is 
S                                             mapped at position 60 only if the MISC_REMAP bit in 
S                                             the AFIO_MAPR2 register is set)                      */       
S#endif /* STM32F10X_HD_VL */
S
S#ifdef STM32F10X_XL
S  ADC1_2_IRQn                 = 18,     /*!< ADC1 and ADC2 global Interrupt                       */
S  USB_HP_CAN1_TX_IRQn         = 19,     /*!< USB Device High Priority or CAN1 TX Interrupts       */
S  USB_LP_CAN1_RX0_IRQn        = 20,     /*!< USB Device Low Priority or CAN1 RX0 Interrupts       */
S  CAN1_RX1_IRQn               = 21,     /*!< CAN1 RX1 Interrupt                                   */
S  CAN1_SCE_IRQn               = 22,     /*!< CAN1 SCE Interrupt                                   */
S  EXTI9_5_IRQn                = 23,     /*!< External Line[9:5] Interrupts                        */
S  TIM1_BRK_TIM9_IRQn          = 24,     /*!< TIM1 Break Interrupt and TIM9 global Interrupt       */
S  TIM1_UP_TIM10_IRQn          = 25,     /*!< TIM1 Update Interrupt and TIM10 global Interrupt     */
S  TIM1_TRG_COM_TIM11_IRQn     = 26,     /*!< TIM1 Trigger and Commutation Interrupt and TIM11 global interrupt */
S  TIM1_CC_IRQn                = 27,     /*!< TIM1 Capture Compare Interrupt                       */
S  TIM2_IRQn                   = 28,     /*!< TIM2 global Interrupt                                */
S  TIM3_IRQn                   = 29,     /*!< TIM3 global Interrupt                                */
S  TIM4_IRQn                   = 30,     /*!< TIM4 global Interrupt                                */
S  I2C1_EV_IRQn                = 31,     /*!< I2C1 Event Interrupt                                 */
S  I2C1_ER_IRQn                = 32,     /*!< I2C1 Error Interrupt                                 */
S  I2C2_EV_IRQn                = 33,     /*!< I2C2 Event Interrupt                                 */
S  I2C2_ER_IRQn                = 34,     /*!< I2C2 Error Interrupt                                 */
S  SPI1_IRQn                   = 35,     /*!< SPI1 global Interrupt                                */
S  SPI2_IRQn                   = 36,     /*!< SPI2 global Interrupt                                */
S  USART1_IRQn                 = 37,     /*!< USART1 global Interrupt                              */
S  USART2_IRQn                 = 38,     /*!< USART2 global Interrupt                              */
S  USART3_IRQn                 = 39,     /*!< USART3 global Interrupt                              */
S  EXTI15_10_IRQn              = 40,     /*!< External Line[15:10] Interrupts                      */
S  RTCAlarm_IRQn               = 41,     /*!< RTC Alarm through EXTI Line Interrupt                */
S  USBWakeUp_IRQn              = 42,     /*!< USB Device WakeUp from suspend through EXTI Line Interrupt */
S  TIM8_BRK_TIM12_IRQn         = 43,     /*!< TIM8 Break Interrupt and TIM12 global Interrupt      */
S  TIM8_UP_TIM13_IRQn          = 44,     /*!< TIM8 Update Interrupt and TIM13 global Interrupt     */
S  TIM8_TRG_COM_TIM14_IRQn     = 45,     /*!< TIM8 Trigger and Commutation Interrupt and TIM14 global interrupt */
S  TIM8_CC_IRQn                = 46,     /*!< TIM8 Capture Compare Interrupt                       */
S  ADC3_IRQn                   = 47,     /*!< ADC3 global Interrupt                                */
S  FSMC_IRQn                   = 48,     /*!< FSMC global Interrupt                                */
S  SDIO_IRQn                   = 49,     /*!< SDIO global Interrupt                                */
S  TIM5_IRQn                   = 50,     /*!< TIM5 global Interrupt                                */
S  SPI3_IRQn                   = 51,     /*!< SPI3 global Interrupt                                */
S  UART4_IRQn                  = 52,     /*!< UART4 global Interrupt                               */
S  UART5_IRQn                  = 53,     /*!< UART5 global Interrupt                               */
S  TIM6_IRQn                   = 54,     /*!< TIM6 global Interrupt                                */
S  TIM7_IRQn                   = 55,     /*!< TIM7 global Interrupt                                */
S  DMA2_Channel1_IRQn          = 56,     /*!< DMA2 Channel 1 global Interrupt                      */
S  DMA2_Channel2_IRQn          = 57,     /*!< DMA2 Channel 2 global Interrupt                      */
S  DMA2_Channel3_IRQn          = 58,     /*!< DMA2 Channel 3 global Interrupt                      */
S  DMA2_Channel4_5_IRQn        = 59      /*!< DMA2 Channel 4 and Channel 5 global Interrupt        */
S#endif /* STM32F10X_XL */  
S
S#ifdef STM32F10X_CL
S  ADC1_2_IRQn                 = 18,     /*!< ADC1 and ADC2 global Interrupt                       */
S  CAN1_TX_IRQn                = 19,     /*!< USB Device High Priority or CAN1 TX Interrupts       */
S  CAN1_RX0_IRQn               = 20,     /*!< USB Device Low Priority or CAN1 RX0 Interrupts       */
S  CAN1_RX1_IRQn               = 21,     /*!< CAN1 RX1 Interrupt                                   */
S  CAN1_SCE_IRQn               = 22,     /*!< CAN1 SCE Interrupt                                   */
S  EXTI9_5_IRQn                = 23,     /*!< External Line[9:5] Interrupts                        */
S  TIM1_BRK_IRQn               = 24,     /*!< TIM1 Break Interrupt                                 */
S  TIM1_UP_IRQn                = 25,     /*!< TIM1 Update Interrupt                                */
S  TIM1_TRG_COM_IRQn           = 26,     /*!< TIM1 Trigger and Commutation Interrupt               */
S  TIM1_CC_IRQn                = 27,     /*!< TIM1 Capture Compare Interrupt                       */
S  TIM2_IRQn                   = 28,     /*!< TIM2 global Interrupt                                */
S  TIM3_IRQn                   = 29,     /*!< TIM3 global Interrupt                                */
S  TIM4_IRQn                   = 30,     /*!< TIM4 global Interrupt                                */
S  I2C1_EV_IRQn                = 31,     /*!< I2C1 Event Interrupt                                 */
S  I2C1_ER_IRQn                = 32,     /*!< I2C1 Error Interrupt                                 */
S  I2C2_EV_IRQn                = 33,     /*!< I2C2 Event Interrupt                                 */
S  I2C2_ER_IRQn                = 34,     /*!< I2C2 Error Interrupt                                 */
S  SPI1_IRQn                   = 35,     /*!< SPI1 global Interrupt                                */
S  SPI2_IRQn                   = 36,     /*!< SPI2 global Interrupt                                */
S  USART1_IRQn                 = 37,     /*!< USART1 global Interrupt                              */
S  USART2_IRQn                 = 38,     /*!< USART2 global Interrupt                              */
S  USART3_IRQn                 = 39,     /*!< USART3 global Interrupt                              */
S  EXTI15_10_IRQn              = 40,     /*!< External Line[15:10] Interrupts                      */
S  RTCAlarm_IRQn               = 41,     /*!< RTC Alarm through EXTI Line Interrupt                */
S  OTG_FS_WKUP_IRQn            = 42,     /*!< USB OTG FS WakeUp from suspend through EXTI Line Interrupt */
S  TIM5_IRQn                   = 50,     /*!< TIM5 global Interrupt                                */
S  SPI3_IRQn                   = 51,     /*!< SPI3 global Interrupt                                */
S  UART4_IRQn                  = 52,     /*!< UART4 global Interrupt                               */
S  UART5_IRQn                  = 53,     /*!< UART5 global Interrupt                               */
S  TIM6_IRQn                   = 54,     /*!< TIM6 global Interrupt                                */
S  TIM7_IRQn                   = 55,     /*!< TIM7 global Interrupt                                */
S  DMA2_Channel1_IRQn          = 56,     /*!< DMA2 Channel 1 global Interrupt                      */
S  DMA2_Channel2_IRQn          = 57,     /*!< DMA2 Channel 2 global Interrupt                      */
S  DMA2_Channel3_IRQn          = 58,     /*!< DMA2 Channel 3 global Interrupt                      */
S  DMA2_Channel4_IRQn          = 59,     /*!< DMA2 Channel 4 global Interrupt                      */
S  DMA2_Channel5_IRQn          = 60,     /*!< DMA2 Channel 5 global Interrupt                      */
S  ETH_IRQn                    = 61,     /*!< Ethernet global Interrupt                            */
S  ETH_WKUP_IRQn               = 62,     /*!< Ethernet Wakeup through EXTI line Interrupt          */
S  CAN2_TX_IRQn                = 63,     /*!< CAN2 TX Interrupt                                    */
S  CAN2_RX0_IRQn               = 64,     /*!< CAN2 RX0 Interrupt                                   */
S  CAN2_RX1_IRQn               = 65,     /*!< CAN2 RX1 Interrupt                                   */
S  CAN2_SCE_IRQn               = 66,     /*!< CAN2 SCE Interrupt                                   */
S  OTG_FS_IRQn                 = 67      /*!< USB OTG FS global Interrupt                          */
S#endif /* STM32F10X_CL */     
S} IRQn_Type;
S
S/**
S  * @}
S  */
S
S#include "core_cm3.h"
S#include "system_stm32f10x.h"
S#include <stdint.h>
S
S/** @addtogroup Exported_types
S  * @{
S  */  
S
S/*!< STM32F10x Standard Peripheral Library old types (maintained for legacy purpose) */
Stypedef int32_t  s32;
Stypedef int16_t s16;
Stypedef int8_t  s8;
S
Stypedef const int32_t sc32;  /*!< Read Only */
Stypedef const int16_t sc16;  /*!< Read Only */
Stypedef const int8_t sc8;   /*!< Read Only */
S
Stypedef __IO int32_t  vs32;
Stypedef __IO int16_t  vs16;
Stypedef __IO int8_t   vs8;
S
Stypedef __I int32_t vsc32;  /*!< Read Only */
Stypedef __I int16_t vsc16;  /*!< Read Only */
Stypedef __I int8_t vsc8;   /*!< Read Only */
S
Stypedef uint32_t  u32;
Stypedef uint16_t u16;
Stypedef uint8_t  u8;
S
Stypedef const uint32_t uc32;  /*!< Read Only */
Stypedef const uint16_t uc16;  /*!< Read Only */
Stypedef const uint8_t uc8;   /*!< Read Only */
S
Stypedef __IO uint32_t  vu32;
Stypedef __IO uint16_t vu16;
Stypedef __IO uint8_t  vu8;
S
Stypedef __I uint32_t vuc32;  /*!< Read Only */
Stypedef __I uint16_t vuc16;  /*!< Read Only */
Stypedef __I uint8_t vuc8;   /*!< Read Only */
S
Stypedef enum {RESET = 0, SET = !RESET} FlagStatus, ITStatus;
S
Stypedef enum {DISABLE = 0, ENABLE = !DISABLE} FunctionalState;
S#define IS_FUNCTIONAL_STATE(STATE) (((STATE) == DISABLE) || ((STATE) == ENABLE))
S
Stypedef enum {ERROR = 0, SUCCESS = !ERROR} ErrorStatus;
S
S/*!< STM32F10x Standard Peripheral Library old definitions (maintained for legacy purpose) */
S#define HSEStartUp_TimeOut   HSE_STARTUP_TIMEOUT
S#define HSE_Value            HSE_VALUE
S#define HSI_Value            HSI_VALUE
S/**
S  * @}
S  */
S
S/** @addtogroup Peripheral_registers_structures
S  * @{
S  */   
S
S/** 
S  * @brief Analog to Digital Converter  
S  */
S
Stypedef struct
S{
S  __IO uint32_t SR;
S  __IO uint32_t CR1;
S  __IO uint32_t CR2;
S  __IO uint32_t SMPR1;
S  __IO uint32_t SMPR2;
S  __IO uint32_t JOFR1;
S  __IO uint32_t JOFR2;
S  __IO uint32_t JOFR3;
S  __IO uint32_t JOFR4;
S  __IO uint32_t HTR;
S  __IO uint32_t LTR;
S  __IO uint32_t SQR1;
S  __IO uint32_t SQR2;
S  __IO uint32_t SQR3;
S  __IO uint32_t JSQR;
S  __IO uint32_t JDR1;
S  __IO uint32_t JDR2;
S  __IO uint32_t JDR3;
S  __IO uint32_t JDR4;
S  __IO uint32_t DR;
S} ADC_TypeDef;
S
S/** 
S  * @brief Backup Registers  
S  */
S
Stypedef struct
S{
S  uint32_t  RESERVED0;
S  __IO uint16_t DR1;
S  uint16_t  RESERVED1;
S  __IO uint16_t DR2;
S  uint16_t  RESERVED2;
S  __IO uint16_t DR3;
S  uint16_t  RESERVED3;
S  __IO uint16_t DR4;
S  uint16_t  RESERVED4;
S  __IO uint16_t DR5;
S  uint16_t  RESERVED5;
S  __IO uint16_t DR6;
S  uint16_t  RESERVED6;
S  __IO uint16_t DR7;
S  uint16_t  RESERVED7;
S  __IO uint16_t DR8;
S  uint16_t  RESERVED8;
S  __IO uint16_t DR9;
S  uint16_t  RESERVED9;
S  __IO uint16_t DR10;
S  uint16_t  RESERVED10; 
S  __IO uint16_t RTCCR;
S  uint16_t  RESERVED11;
S  __IO uint16_t CR;
S  uint16_t  RESERVED12;
S  __IO uint16_t CSR;
S  uint16_t  RESERVED13[5];
S  __IO uint16_t DR11;
S  uint16_t  RESERVED14;
S  __IO uint16_t DR12;
S  uint16_t  RESERVED15;
S  __IO uint16_t DR13;
S  uint16_t  RESERVED16;
S  __IO uint16_t DR14;
S  uint16_t  RESERVED17;
S  __IO uint16_t DR15;
S  uint16_t  RESERVED18;
S  __IO uint16_t DR16;
S  uint16_t  RESERVED19;
S  __IO uint16_t DR17;
S  uint16_t  RESERVED20;
S  __IO uint16_t DR18;
S  uint16_t  RESERVED21;
S  __IO uint16_t DR19;
S  uint16_t  RESERVED22;
S  __IO uint16_t DR20;
S  uint16_t  RESERVED23;
S  __IO uint16_t DR21;
S  uint16_t  RESERVED24;
S  __IO uint16_t DR22;
S  uint16_t  RESERVED25;
S  __IO uint16_t DR23;
S  uint16_t  RESERVED26;
S  __IO uint16_t DR24;
S  uint16_t  RESERVED27;
S  __IO uint16_t DR25;
S  uint16_t  RESERVED28;
S  __IO uint16_t DR26;
S  uint16_t  RESERVED29;
S  __IO uint16_t DR27;
S  uint16_t  RESERVED30;
S  __IO uint16_t DR28;
S  uint16_t  RESERVED31;
S  __IO uint16_t DR29;
S  uint16_t  RESERVED32;
S  __IO uint16_t DR30;
S  uint16_t  RESERVED33; 
S  __IO uint16_t DR31;
S  uint16_t  RESERVED34;
S  __IO uint16_t DR32;
S  uint16_t  RESERVED35;
S  __IO uint16_t DR33;
S  uint16_t  RESERVED36;
S  __IO uint16_t DR34;
S  uint16_t  RESERVED37;
S  __IO uint16_t DR35;
S  uint16_t  RESERVED38;
S  __IO uint16_t DR36;
S  uint16_t  RESERVED39;
S  __IO uint16_t DR37;
S  uint16_t  RESERVED40;
S  __IO uint16_t DR38;
S  uint16_t  RESERVED41;
S  __IO uint16_t DR39;
S  uint16_t  RESERVED42;
S  __IO uint16_t DR40;
S  uint16_t  RESERVED43;
S  __IO uint16_t DR41;
S  uint16_t  RESERVED44;
S  __IO uint16_t DR42;
S  uint16_t  RESERVED45;    
S} BKP_TypeDef;
S  
S/** 
S  * @brief Controller Area Network TxMailBox 
S  */
S
Stypedef struct
S{
S  __IO uint32_t TIR;
S  __IO uint32_t TDTR;
S  __IO uint32_t TDLR;
S  __IO uint32_t TDHR;
S} CAN_TxMailBox_TypeDef;
S
S/** 
S  * @brief Controller Area Network FIFOMailBox 
S  */
S  
Stypedef struct
S{
S  __IO uint32_t RIR;
S  __IO uint32_t RDTR;
S  __IO uint32_t RDLR;
S  __IO uint32_t RDHR;
S} CAN_FIFOMailBox_TypeDef;
S
S/** 
S  * @brief Controller Area Network FilterRegister 
S  */
S  
Stypedef struct
S{
S  __IO uint32_t FR1;
S  __IO uint32_t FR2;
S} CAN_FilterRegister_TypeDef;
S
S/** 
S  * @brief Controller Area Network 
S  */
S  
Stypedef struct
S{
S  __IO uint32_t MCR;
S  __IO uint32_t MSR;
S  __IO uint32_t TSR;
S  __IO uint32_t RF0R;
S  __IO uint32_t RF1R;
S  __IO uint32_t IER;
S  __IO uint32_t ESR;
S  __IO uint32_t BTR;
S  uint32_t  RESERVED0[88];
S  CAN_TxMailBox_TypeDef sTxMailBox[3];
S  CAN_FIFOMailBox_TypeDef sFIFOMailBox[2];
S  uint32_t  RESERVED1[12];
S  __IO uint32_t FMR;
S  __IO uint32_t FM1R;
S  uint32_t  RESERVED2;
S  __IO uint32_t FS1R;
S  uint32_t  RESERVED3;
S  __IO uint32_t FFA1R;
S  uint32_t  RESERVED4;
S  __IO uint32_t FA1R;
S  uint32_t  RESERVED5[8];
S#ifndef STM32F10X_CL
S  CAN_FilterRegister_TypeDef sFilterRegister[14];
S#else
S  CAN_FilterRegister_TypeDef sFilterRegister[28];
S#endif /* STM32F10X_CL */  
S} CAN_TypeDef;
S
S/** 
S  * @brief Consumer Electronics Control (CEC)
S  */
Stypedef struct
S{
S  __IO uint32_t CFGR;
S  __IO uint32_t OAR;
S  __IO uint32_t PRES;
S  __IO uint32_t ESR;
S  __IO uint32_t CSR;
S  __IO uint32_t TXD;
S  __IO uint32_t RXD;  
S} CEC_TypeDef;
S
S/** 
S  * @brief CRC calculation unit 
S  */
S
Stypedef struct
S{
S  __IO uint32_t DR;
S  __IO uint8_t  IDR;
S  uint8_t   RESERVED0;
S  uint16_t  RESERVED1;
S  __IO uint32_t CR;
S} CRC_TypeDef;
S
S/** 
S  * @brief Digital to Analog Converter
S  */
S
Stypedef struct
S{
S  __IO uint32_t CR;
S  __IO uint32_t SWTRIGR;
S  __IO uint32_t DHR12R1;
S  __IO uint32_t DHR12L1;
S  __IO uint32_t DHR8R1;
S  __IO uint32_t DHR12R2;
S  __IO uint32_t DHR12L2;
S  __IO uint32_t DHR8R2;
S  __IO uint32_t DHR12RD;
S  __IO uint32_t DHR12LD;
S  __IO uint32_t DHR8RD;
S  __IO uint32_t DOR1;
S  __IO uint32_t DOR2;
S#if defined (STM32F10X_LD_VL) || defined (STM32F10X_MD_VL) || defined (STM32F10X_HD_VL)
S  __IO uint32_t SR;
S#endif
S} DAC_TypeDef;
S
S/** 
S  * @brief Debug MCU
S  */
S
Stypedef struct
S{
S  __IO uint32_t IDCODE;
S  __IO uint32_t CR;	
S}DBGMCU_TypeDef;
S
S/** 
S  * @brief DMA Controller
S  */
S
Stypedef struct
S{
S  __IO uint32_t CCR;
S  __IO uint32_t CNDTR;
S  __IO uint32_t CPAR;
S  __IO uint32_t CMAR;
S} DMA_Channel_TypeDef;
S
Stypedef struct
S{
S  __IO uint32_t ISR;
S  __IO uint32_t IFCR;
S} DMA_TypeDef;
S
S/** 
S  * @brief Ethernet MAC
S  */
S
Stypedef struct
S{
S  __IO uint32_t MACCR;
S  __IO uint32_t MACFFR;
S  __IO uint32_t MACHTHR;
S  __IO uint32_t MACHTLR;
S  __IO uint32_t MACMIIAR;
S  __IO uint32_t MACMIIDR;
S  __IO uint32_t MACFCR;
S  __IO uint32_t MACVLANTR;             /*    8 */
S       uint32_t RESERVED0[2];
S  __IO uint32_t MACRWUFFR;             /*   11 */
S  __IO uint32_t MACPMTCSR;
S       uint32_t RESERVED1[2];
S  __IO uint32_t MACSR;                 /*   15 */
S  __IO uint32_t MACIMR;
S  __IO uint32_t MACA0HR;
S  __IO uint32_t MACA0LR;
S  __IO uint32_t MACA1HR;
S  __IO uint32_t MACA1LR;
S  __IO uint32_t MACA2HR;
S  __IO uint32_t MACA2LR;
S  __IO uint32_t MACA3HR;
S  __IO uint32_t MACA3LR;               /*   24 */
S       uint32_t RESERVED2[40];
S  __IO uint32_t MMCCR;                 /*   65 */
S  __IO uint32_t MMCRIR;
S  __IO uint32_t MMCTIR;
S  __IO uint32_t MMCRIMR;
S  __IO uint32_t MMCTIMR;               /*   69 */
S       uint32_t RESERVED3[14];
S  __IO uint32_t MMCTGFSCCR;            /*   84 */
S  __IO uint32_t MMCTGFMSCCR;
S       uint32_t RESERVED4[5];
S  __IO uint32_t MMCTGFCR;
S       uint32_t RESERVED5[10];
S  __IO uint32_t MMCRFCECR;
S  __IO uint32_t MMCRFAECR;
S       uint32_t RESERVED6[10];
S  __IO uint32_t MMCRGUFCR;
S       uint32_t RESERVED7[334];
S  __IO uint32_t PTPTSCR;
S  __IO uint32_t PTPSSIR;
S  __IO uint32_t PTPTSHR;
S  __IO uint32_t PTPTSLR;
S  __IO uint32_t PTPTSHUR;
S  __IO uint32_t PTPTSLUR;
S  __IO uint32_t PTPTSAR;
S  __IO uint32_t PTPTTHR;
S  __IO uint32_t PTPTTLR;
S       uint32_t RESERVED8[567];
S  __IO uint32_t DMABMR;
S  __IO uint32_t DMATPDR;
S  __IO uint32_t DMARPDR;
S  __IO uint32_t DMARDLAR;
S  __IO uint32_t DMATDLAR;
S  __IO uint32_t DMASR;
S  __IO uint32_t DMAOMR;
S  __IO uint32_t DMAIER;
S  __IO uint32_t DMAMFBOCR;
S       uint32_t RESERVED9[9];
S  __IO uint32_t DMACHTDR;
S  __IO uint32_t DMACHRDR;
S  __IO uint32_t DMACHTBAR;
S  __IO uint32_t DMACHRBAR;
S} ETH_TypeDef;
S
S/** 
S  * @brief External Interrupt/Event Controller
S  */
S
Stypedef struct
S{
S  __IO uint32_t IMR;
S  __IO uint32_t EMR;
S  __IO uint32_t RTSR;
S  __IO uint32_t FTSR;
S  __IO uint32_t SWIER;
S  __IO uint32_t PR;
S} EXTI_TypeDef;
S
S/** 
S  * @brief FLASH Registers
S  */
S
Stypedef struct
S{
S  __IO uint32_t ACR;
S  __IO uint32_t KEYR;
S  __IO uint32_t OPTKEYR;
S  __IO uint32_t SR;
S  __IO uint32_t CR;
S  __IO uint32_t AR;
S  __IO uint32_t RESERVED;
S  __IO uint32_t OBR;
S  __IO uint32_t WRPR;
S#ifdef STM32F10X_XL
S  uint32_t RESERVED1[8]; 
S  __IO uint32_t KEYR2;
S  uint32_t RESERVED2;   
S  __IO uint32_t SR2;
S  __IO uint32_t CR2;
S  __IO uint32_t AR2; 
S#endif /* STM32F10X_XL */  
S} FLASH_TypeDef;
S
S/** 
S  * @brief Option Bytes Registers
S  */
S  
Stypedef struct
S{
S  __IO uint16_t RDP;
S  __IO uint16_t USER;
S  __IO uint16_t Data0;
S  __IO uint16_t Data1;
S  __IO uint16_t WRP0;
S  __IO uint16_t WRP1;
S  __IO uint16_t WRP2;
S  __IO uint16_t WRP3;
S} OB_TypeDef;
S
S/** 
S  * @brief Flexible Static Memory Controller
S  */
S
Stypedef struct
S{
S  __IO uint32_t BTCR[8];   
S} FSMC_Bank1_TypeDef; 
S
S/** 
S  * @brief Flexible Static Memory Controller Bank1E
S  */
S  
Stypedef struct
S{
S  __IO uint32_t BWTR[7];
S} FSMC_Bank1E_TypeDef;
S
S/** 
S  * @brief Flexible Static Memory Controller Bank2
S  */
S  
Stypedef struct
S{
S  __IO uint32_t PCR2;
S  __IO uint32_t SR2;
S  __IO uint32_t PMEM2;
S  __IO uint32_t PATT2;
S  uint32_t  RESERVED0;   
S  __IO uint32_t ECCR2; 
S} FSMC_Bank2_TypeDef;  
S
S/** 
S  * @brief Flexible Static Memory Controller Bank3
S  */
S  
Stypedef struct
S{
S  __IO uint32_t PCR3;
S  __IO uint32_t SR3;
S  __IO uint32_t PMEM3;
S  __IO uint32_t PATT3;
S  uint32_t  RESERVED0;   
S  __IO uint32_t ECCR3; 
S} FSMC_Bank3_TypeDef; 
S
S/** 
S  * @brief Flexible Static Memory Controller Bank4
S  */
S  
Stypedef struct
S{
S  __IO uint32_t PCR4;
S  __IO uint32_t SR4;
S  __IO uint32_t PMEM4;
S  __IO uint32_t PATT4;
S  __IO uint32_t PIO4; 
S} FSMC_Bank4_TypeDef; 
S
S/** 
S  * @brief General Purpose I/O
S  */
S
Stypedef struct
S{
S  __IO uint32_t CRL;
S  __IO uint32_t CRH;
S  __IO uint32_t IDR;
S  __IO uint32_t ODR;
S  __IO uint32_t BSRR;
S  __IO uint32_t BRR;
S  __IO uint32_t LCKR;
S} GPIO_TypeDef;
S
S/** 
S  * @brief Alternate Function I/O
S  */
S
Stypedef struct
S{
S  __IO uint32_t EVCR;
S  __IO uint32_t MAPR;
S  __IO uint32_t EXTICR[4];
S  uint32_t RESERVED0;
S  __IO uint32_t MAPR2;  
S} AFIO_TypeDef;
S/** 
S  * @brief Inter Integrated Circuit Interface
S  */
S
Stypedef struct
S{
S  __IO uint16_t CR1;
S  uint16_t  RESERVED0;
S  __IO uint16_t CR2;
S  uint16_t  RESERVED1;
S  __IO uint16_t OAR1;
S  uint16_t  RESERVED2;
S  __IO uint16_t OAR2;
S  uint16_t  RESERVED3;
S  __IO uint16_t DR;
S  uint16_t  RESERVED4;
S  __IO uint16_t SR1;
S  uint16_t  RESERVED5;
S  __IO uint16_t SR2;
S  uint16_t  RESERVED6;
S  __IO uint16_t CCR;
S  uint16_t  RESERVED7;
S  __IO uint16_t TRISE;
S  uint16_t  RESERVED8;
S} I2C_TypeDef;
S
S/** 
S  * @brief Independent WATCHDOG
S  */
S
Stypedef struct
S{
S  __IO uint32_t KR;
S  __IO uint32_t PR;
S  __IO uint32_t RLR;
S  __IO uint32_t SR;
S} IWDG_TypeDef;
S
S/** 
S  * @brief Power Control
S  */
S
Stypedef struct
S{
S  __IO uint32_t CR;
S  __IO uint32_t CSR;
S} PWR_TypeDef;
S
S/** 
S  * @brief Reset and Clock Control
S  */
S
Stypedef struct
S{
S  __IO uint32_t CR;
S  __IO uint32_t CFGR;
S  __IO uint32_t CIR;
S  __IO uint32_t APB2RSTR;
S  __IO uint32_t APB1RSTR;
S  __IO uint32_t AHBENR;
S  __IO uint32_t APB2ENR;
S  __IO uint32_t APB1ENR;
S  __IO uint32_t BDCR;
S  __IO uint32_t CSR;
S
S#ifdef STM32F10X_CL  
S  __IO uint32_t AHBRSTR;
S  __IO uint32_t CFGR2;
S#endif /* STM32F10X_CL */ 
S
S#if defined (STM32F10X_LD_VL) || defined (STM32F10X_MD_VL) || defined (STM32F10X_HD_VL)   
S  uint32_t RESERVED0;
S  __IO uint32_t CFGR2;
S#endif /* STM32F10X_LD_VL || STM32F10X_MD_VL || STM32F10X_HD_VL */ 
S} RCC_TypeDef;
S
S/** 
S  * @brief Real-Time Clock
S  */
S
Stypedef struct
S{
S  __IO uint16_t CRH;
S  uint16_t  RESERVED0;
S  __IO uint16_t CRL;
S  uint16_t  RESERVED1;
S  __IO uint16_t PRLH;
S  uint16_t  RESERVED2;
S  __IO uint16_t PRLL;
S  uint16_t  RESERVED3;
S  __IO uint16_t DIVH;
S  uint16_t  RESERVED4;
S  __IO uint16_t DIVL;
S  uint16_t  RESERVED5;
S  __IO uint16_t CNTH;
S  uint16_t  RESERVED6;
S  __IO uint16_t CNTL;
S  uint16_t  RESERVED7;
S  __IO uint16_t ALRH;
S  uint16_t  RESERVED8;
S  __IO uint16_t ALRL;
S  uint16_t  RESERVED9;
S} RTC_TypeDef;
S
S/** 
S  * @brief SD host Interface
S  */
S
Stypedef struct
S{
S  __IO uint32_t POWER;
S  __IO uint32_t CLKCR;
S  __IO uint32_t ARG;
S  __IO uint32_t CMD;
S  __I uint32_t RESPCMD;
S  __I uint32_t RESP1;
S  __I uint32_t RESP2;
S  __I uint32_t RESP3;
S  __I uint32_t RESP4;
S  __IO uint32_t DTIMER;
S  __IO uint32_t DLEN;
S  __IO uint32_t DCTRL;
S  __I uint32_t DCOUNT;
S  __I uint32_t STA;
S  __IO uint32_t ICR;
S  __IO uint32_t MASK;
S  uint32_t  RESERVED0[2];
S  __I uint32_t FIFOCNT;
S  uint32_t  RESERVED1[13];
S  __IO uint32_t FIFO;
S} SDIO_TypeDef;
S
S/** 
S  * @brief Serial Peripheral Interface
S  */
S
Stypedef struct
S{
S  __IO uint16_t CR1;
S  uint16_t  RESERVED0;
S  __IO uint16_t CR2;
S  uint16_t  RESERVED1;
S  __IO uint16_t SR;
S  uint16_t  RESERVED2;
S  __IO uint16_t DR;
S  uint16_t  RESERVED3;
S  __IO uint16_t CRCPR;
S  uint16_t  RESERVED4;
S  __IO uint16_t RXCRCR;
S  uint16_t  RESERVED5;
S  __IO uint16_t TXCRCR;
S  uint16_t  RESERVED6;
S  __IO uint16_t I2SCFGR;
S  uint16_t  RESERVED7;
S  __IO uint16_t I2SPR;
S  uint16_t  RESERVED8;  
S} SPI_TypeDef;
S
S/** 
S  * @brief TIM
S  */
S
Stypedef struct
S{
S  __IO uint16_t CR1;
S  uint16_t  RESERVED0;
S  __IO uint16_t CR2;
S  uint16_t  RESERVED1;
S  __IO uint16_t SMCR;
S  uint16_t  RESERVED2;
S  __IO uint16_t DIER;
S  uint16_t  RESERVED3;
S  __IO uint16_t SR;
S  uint16_t  RESERVED4;
S  __IO uint16_t EGR;
S  uint16_t  RESERVED5;
S  __IO uint16_t CCMR1;
S  uint16_t  RESERVED6;
S  __IO uint16_t CCMR2;
S  uint16_t  RESERVED7;
S  __IO uint16_t CCER;
S  uint16_t  RESERVED8;
S  __IO uint16_t CNT;
S  uint16_t  RESERVED9;
S  __IO uint16_t PSC;
S  uint16_t  RESERVED10;
S  __IO uint16_t ARR;
S  uint16_t  RESERVED11;
S  __IO uint16_t RCR;
S  uint16_t  RESERVED12;
S  __IO uint16_t CCR1;
S  uint16_t  RESERVED13;
S  __IO uint16_t CCR2;
S  uint16_t  RESERVED14;
S  __IO uint16_t CCR3;
S  uint16_t  RESERVED15;
S  __IO uint16_t CCR4;
S  uint16_t  RESERVED16;
S  __IO uint16_t BDTR;
S  uint16_t  RESERVED17;
S  __IO uint16_t DCR;
S  uint16_t  RESERVED18;
S  __IO uint16_t DMAR;
S  uint16_t  RESERVED19;
S} TIM_TypeDef;
S
S/** 
S  * @brief Universal Synchronous Asynchronous Receiver Transmitter
S  */
S 
Stypedef struct
S{
S  __IO uint16_t SR;
S  uint16_t  RESERVED0;
S  __IO uint16_t DR;
S  uint16_t  RESERVED1;
S  __IO uint16_t BRR;
S  uint16_t  RESERVED2;
S  __IO uint16_t CR1;
S  uint16_t  RESERVED3;
S  __IO uint16_t CR2;
S  uint16_t  RESERVED4;
S  __IO uint16_t CR3;
S  uint16_t  RESERVED5;
S  __IO uint16_t GTPR;
S  uint16_t  RESERVED6;
S} USART_TypeDef;
S
S/** 
S  * @brief Window WATCHDOG
S  */
S
Stypedef struct
S{
S  __IO uint32_t CR;
S  __IO uint32_t CFR;
S  __IO uint32_t SR;
S} WWDG_TypeDef;
S
S/**
S  * @}
S  */
S  
S/** @addtogroup Peripheral_memory_map
S  * @{
S  */
S
S
S#define FLASH_BASE            ((uint32_t)0x08000000) /*!< FLASH base address in the alias region */
S#define SRAM_BASE             ((uint32_t)0x20000000) /*!< SRAM base address in the alias region */
S#define PERIPH_BASE           ((uint32_t)0x40000000) /*!< Peripheral base address in the alias region */
S
S#define SRAM_BB_BASE          ((uint32_t)0x22000000) /*!< SRAM base address in the bit-band region */
S#define PERIPH_BB_BASE        ((uint32_t)0x42000000) /*!< Peripheral base address in the bit-band region */
S
S#define FSMC_R_BASE           ((uint32_t)0xA0000000) /*!< FSMC registers base address */
S
S/*!< Peripheral memory map */
S#define APB1PERIPH_BASE       PERIPH_BASE
S#define APB2PERIPH_BASE       (PERIPH_BASE + 0x10000)
S#define AHBPERIPH_BASE        (PERIPH_BASE + 0x20000)
S
S#define TIM2_BASE             (APB1PERIPH_BASE + 0x0000)
S#define TIM3_BASE             (APB1PERIPH_BASE + 0x0400)
S#define TIM4_BASE             (APB1PERIPH_BASE + 0x0800)
S#define TIM5_BASE             (APB1PERIPH_BASE + 0x0C00)
S#define TIM6_BASE             (APB1PERIPH_BASE + 0x1000)
S#define TIM7_BASE             (APB1PERIPH_BASE + 0x1400)
S#define TIM12_BASE            (APB1PERIPH_BASE + 0x1800)
S#define TIM13_BASE            (APB1PERIPH_BASE + 0x1C00)
S#define TIM14_BASE            (APB1PERIPH_BASE + 0x2000)
S#define RTC_BASE              (APB1PERIPH_BASE + 0x2800)
S#define WWDG_BASE             (APB1PERIPH_BASE + 0x2C00)
S#define IWDG_BASE             (APB1PERIPH_BASE + 0x3000)
S#define SPI2_BASE             (APB1PERIPH_BASE + 0x3800)
S#define SPI3_BASE             (APB1PERIPH_BASE + 0x3C00)
S#define USART2_BASE           (APB1PERIPH_BASE + 0x4400)
S#define USART3_BASE           (APB1PERIPH_BASE + 0x4800)
S#define UART4_BASE            (APB1PERIPH_BASE + 0x4C00)
S#define UART5_BASE            (APB1PERIPH_BASE + 0x5000)
S#define I2C1_BASE             (APB1PERIPH_BASE + 0x5400)
S#define I2C2_BASE             (APB1PERIPH_BASE + 0x5800)
S#define CAN1_BASE             (APB1PERIPH_BASE + 0x6400)
S#define CAN2_BASE             (APB1PERIPH_BASE + 0x6800)
S#define BKP_BASE              (APB1PERIPH_BASE + 0x6C00)
S#define PWR_BASE              (APB1PERIPH_BASE + 0x7000)
S#define DAC_BASE              (APB1PERIPH_BASE + 0x7400)
S#define CEC_BASE              (APB1PERIPH_BASE + 0x7800)
S
S#define AFIO_BASE             (APB2PERIPH_BASE + 0x0000)
S#define EXTI_BASE             (APB2PERIPH_BASE + 0x0400)
S#define GPIOA_BASE            (APB2PERIPH_BASE + 0x0800)
S#define GPIOB_BASE            (APB2PERIPH_BASE + 0x0C00)
S#define GPIOC_BASE            (APB2PERIPH_BASE + 0x1000)
S#define GPIOD_BASE            (APB2PERIPH_BASE + 0x1400)
S#define GPIOE_BASE            (APB2PERIPH_BASE + 0x1800)
S#define GPIOF_BASE            (APB2PERIPH_BASE + 0x1C00)
S#define GPIOG_BASE            (APB2PERIPH_BASE + 0x2000)
S#define ADC1_BASE             (APB2PERIPH_BASE + 0x2400)
S#define ADC2_BASE             (APB2PERIPH_BASE + 0x2800)
S#define TIM1_BASE             (APB2PERIPH_BASE + 0x2C00)
S#define SPI1_BASE             (APB2PERIPH_BASE + 0x3000)
S#define TIM8_BASE             (APB2PERIPH_BASE + 0x3400)
S#define USART1_BASE           (APB2PERIPH_BASE + 0x3800)
S#define ADC3_BASE             (APB2PERIPH_BASE + 0x3C00)
S#define TIM15_BASE            (APB2PERIPH_BASE + 0x4000)
S#define TIM16_BASE            (APB2PERIPH_BASE + 0x4400)
S#define TIM17_BASE            (APB2PERIPH_BASE + 0x4800)
S#define TIM9_BASE             (APB2PERIPH_BASE + 0x4C00)
S#define TIM10_BASE            (APB2PERIPH_BASE + 0x5000)
S#define TIM11_BASE            (APB2PERIPH_BASE + 0x5400)
S
S#define SDIO_BASE             (PERIPH_BASE + 0x18000)
S
S#define DMA1_BASE             (AHBPERIPH_BASE + 0x0000)
S#define DMA1_Channel1_BASE    (AHBPERIPH_BASE + 0x0008)
S#define DMA1_Channel2_BASE    (AHBPERIPH_BASE + 0x001C)
S#define DMA1_Channel3_BASE    (AHBPERIPH_BASE + 0x0030)
S#define DMA1_Channel4_BASE    (AHBPERIPH_BASE + 0x0044)
S#define DMA1_Channel5_BASE    (AHBPERIPH_BASE + 0x0058)
S#define DMA1_Channel6_BASE    (AHBPERIPH_BASE + 0x006C)
S#define DMA1_Channel7_BASE    (AHBPERIPH_BASE + 0x0080)
S#define DMA2_BASE             (AHBPERIPH_BASE + 0x0400)
S#define DMA2_Channel1_BASE    (AHBPERIPH_BASE + 0x0408)
S#define DMA2_Channel2_BASE    (AHBPERIPH_BASE + 0x041C)
S#define DMA2_Channel3_BASE    (AHBPERIPH_BASE + 0x0430)
S#define DMA2_Channel4_BASE    (AHBPERIPH_BASE + 0x0444)
S#define DMA2_Channel5_BASE    (AHBPERIPH_BASE + 0x0458)
S#define RCC_BASE              (AHBPERIPH_BASE + 0x1000)
S#define CRC_BASE              (AHBPERIPH_BASE + 0x3000)
S
S#define FLASH_R_BASE          (AHBPERIPH_BASE + 0x2000) /*!< Flash registers base address */
S#define OB_BASE               ((uint32_t)0x1FFFF800)    /*!< Flash Option Bytes base address */
S
S#define ETH_BASE              (AHBPERIPH_BASE + 0x8000)
S#define ETH_MAC_BASE          (ETH_BASE)
S#define ETH_MMC_BASE          (ETH_BASE + 0x0100)
S#define ETH_PTP_BASE          (ETH_BASE + 0x0700)
S#define ETH_DMA_BASE          (ETH_BASE + 0x1000)
S
S#define FSMC_Bank1_R_BASE     (FSMC_R_BASE + 0x0000) /*!< FSMC Bank1 registers base address */
S#define FSMC_Bank1E_R_BASE    (FSMC_R_BASE + 0x0104) /*!< FSMC Bank1E registers base address */
S#define FSMC_Bank2_R_BASE     (FSMC_R_BASE + 0x0060) /*!< FSMC Bank2 registers base address */
S#define FSMC_Bank3_R_BASE     (FSMC_R_BASE + 0x0080) /*!< FSMC Bank3 registers base address */
S#define FSMC_Bank4_R_BASE     (FSMC_R_BASE + 0x00A0) /*!< FSMC Bank4 registers base address */
S
S#define DBGMCU_BASE          ((uint32_t)0xE0042000) /*!< Debug MCU registers base address */
S
S/**
S  * @}
S  */
S  
S/** @addtogroup Peripheral_declaration
S  * @{
S  */  
S
S#define TIM2                ((TIM_TypeDef *) TIM2_BASE)
S#define TIM3                ((TIM_TypeDef *) TIM3_BASE)
S#define TIM4                ((TIM_TypeDef *) TIM4_BASE)
S#define TIM5                ((TIM_TypeDef *) TIM5_BASE)
S#define TIM6                ((TIM_TypeDef *) TIM6_BASE)
S#define TIM7                ((TIM_TypeDef *) TIM7_BASE)
S#define TIM12               ((TIM_TypeDef *) TIM12_BASE)
S#define TIM13               ((TIM_TypeDef *) TIM13_BASE)
S#define TIM14               ((TIM_TypeDef *) TIM14_BASE)
S#define RTC                 ((RTC_TypeDef *) RTC_BASE)
S#define WWDG                ((WWDG_TypeDef *) WWDG_BASE)
S#define IWDG                ((IWDG_TypeDef *) IWDG_BASE)
S#define SPI2                ((SPI_TypeDef *) SPI2_BASE)
S#define SPI3                ((SPI_TypeDef *) SPI3_BASE)
S#define USART2              ((USART_TypeDef *) USART2_BASE)
S#define USART3              ((USART_TypeDef *) USART3_BASE)
S#define UART4               ((USART_TypeDef *) UART4_BASE)
S#define UART5               ((USART_TypeDef *) UART5_BASE)
S#define I2C1                ((I2C_TypeDef *) I2C1_BASE)
S#define I2C2                ((I2C_TypeDef *) I2C2_BASE)
S#define CAN1                ((CAN_TypeDef *) CAN1_BASE)
S#define CAN2                ((CAN_TypeDef *) CAN2_BASE)
S#define BKP                 ((BKP_TypeDef *) BKP_BASE)
S#define PWR                 ((PWR_TypeDef *) PWR_BASE)
S#define DAC                 ((DAC_TypeDef *) DAC_BASE)
S#define CEC                 ((CEC_TypeDef *) CEC_BASE)
S#define AFIO                ((AFIO_TypeDef *) AFIO_BASE)
S#define EXTI                ((EXTI_TypeDef *) EXTI_BASE)
S#define GPIOA               ((GPIO_TypeDef *) GPIOA_BASE)
S#define GPIOB               ((GPIO_TypeDef *) GPIOB_BASE)
S#define GPIOC               ((GPIO_TypeDef *) GPIOC_BASE)
S#define GPIOD               ((GPIO_TypeDef *) GPIOD_BASE)
S#define GPIOE               ((GPIO_TypeDef *) GPIOE_BASE)
S#define GPIOF               ((GPIO_TypeDef *) GPIOF_BASE)
S#define GPIOG               ((GPIO_TypeDef *) GPIOG_BASE)
S#define ADC1                ((ADC_TypeDef *) ADC1_BASE)
S#define ADC2                ((ADC_TypeDef *) ADC2_BASE)
S#define TIM1                ((TIM_TypeDef *) TIM1_BASE)
S#define SPI1                ((SPI_TypeDef *) SPI1_BASE)
S#define TIM8                ((TIM_TypeDef *) TIM8_BASE)
S#define USART1              ((USART_TypeDef *) USART1_BASE)
S#define ADC3                ((ADC_TypeDef *) ADC3_BASE)
S#define TIM15               ((TIM_TypeDef *) TIM15_BASE)
S#define TIM16               ((TIM_TypeDef *) TIM16_BASE)
S#define TIM17               ((TIM_TypeDef *) TIM17_BASE)
S#define TIM9                ((TIM_TypeDef *) TIM9_BASE)
S#define TIM10               ((TIM_TypeDef *) TIM10_BASE)
S#define TIM11               ((TIM_TypeDef *) TIM11_BASE)
S#define SDIO                ((SDIO_TypeDef *) SDIO_BASE)
S#define DMA1                ((DMA_TypeDef *) DMA1_BASE)
S#define DMA2                ((DMA_TypeDef *) DMA2_BASE)
S#define DMA1_Channel1       ((DMA_Channel_TypeDef *) DMA1_Channel1_BASE)
S#define DMA1_Channel2       ((DMA_Channel_TypeDef *) DMA1_Channel2_BASE)
S#define DMA1_Channel3       ((DMA_Channel_TypeDef *) DMA1_Channel3_BASE)
S#define DMA1_Channel4       ((DMA_Channel_TypeDef *) DMA1_Channel4_BASE)
S#define DMA1_Channel5       ((DMA_Channel_TypeDef *) DMA1_Channel5_BASE)
S#define DMA1_Channel6       ((DMA_Channel_TypeDef *) DMA1_Channel6_BASE)
S#define DMA1_Channel7       ((DMA_Channel_TypeDef *) DMA1_Channel7_BASE)
S#define DMA2_Channel1       ((DMA_Channel_TypeDef *) DMA2_Channel1_BASE)
S#define DMA2_Channel2       ((DMA_Channel_TypeDef *) DMA2_Channel2_BASE)
S#define DMA2_Channel3       ((DMA_Channel_TypeDef *) DMA2_Channel3_BASE)
S#define DMA2_Channel4       ((DMA_Channel_TypeDef *) DMA2_Channel4_BASE)
S#define DMA2_Channel5       ((DMA_Channel_TypeDef *) DMA2_Channel5_BASE)
S#define RCC                 ((RCC_TypeDef *) RCC_BASE)
S#define CRC                 ((CRC_TypeDef *) CRC_BASE)
S#define FLASH               ((FLASH_TypeDef *) FLASH_R_BASE)
S#define OB                  ((OB_TypeDef *) OB_BASE) 
S#define ETH                 ((ETH_TypeDef *) ETH_BASE)
S#define FSMC_Bank1          ((FSMC_Bank1_TypeDef *) FSMC_Bank1_R_BASE)
S#define FSMC_Bank1E         ((FSMC_Bank1E_TypeDef *) FSMC_Bank1E_R_BASE)
S#define FSMC_Bank2          ((FSMC_Bank2_TypeDef *) FSMC_Bank2_R_BASE)
S#define FSMC_Bank3          ((FSMC_Bank3_TypeDef *) FSMC_Bank3_R_BASE)
S#define FSMC_Bank4          ((FSMC_Bank4_TypeDef *) FSMC_Bank4_R_BASE)
S#define DBGMCU              ((DBGMCU_TypeDef *) DBGMCU_BASE)
S
S/**
S  * @}
S  */
S
S/** @addtogroup Exported_constants
S  * @{
S  */
S  
S  /** @addtogroup Peripheral_Registers_Bits_Definition
S  * @{
S  */
S    
S/******************************************************************************/
S/*                         Peripheral Registers_Bits_Definition               */
S/******************************************************************************/
S
S/******************************************************************************/
S/*                                                                            */
S/*                          CRC calculation unit                              */
S/*                                                                            */
S/******************************************************************************/
S
S/*******************  Bit definition for CRC_DR register  *********************/
S#define  CRC_DR_DR                           ((uint32_t)0xFFFFFFFF) /*!< Data register bits */
S
S
S/*******************  Bit definition for CRC_IDR register  ********************/
S#define  CRC_IDR_IDR                         ((uint8_t)0xFF)        /*!< General-purpose 8-bit data register bits */
S
S
S/********************  Bit definition for CRC_CR register  ********************/
S#define  CRC_CR_RESET                        ((uint8_t)0x01)        /*!< RESET bit */
S
S/******************************************************************************/
S/*                                                                            */
S/*                             Power Control                                  */
S/*                                                                            */
S/******************************************************************************/
S
S/********************  Bit definition for PWR_CR register  ********************/
S#define  PWR_CR_LPDS                         ((uint16_t)0x0001)     /*!< Low-Power Deepsleep */
S#define  PWR_CR_PDDS                         ((uint16_t)0x0002)     /*!< Power Down Deepsleep */
S#define  PWR_CR_CWUF                         ((uint16_t)0x0004)     /*!< Clear Wakeup Flag */
S#define  PWR_CR_CSBF                         ((uint16_t)0x0008)     /*!< Clear Standby Flag */
S#define  PWR_CR_PVDE                         ((uint16_t)0x0010)     /*!< Power Voltage Detector Enable */
S
S#define  PWR_CR_PLS                          ((uint16_t)0x00E0)     /*!< PLS[2:0] bits (PVD Level Selection) */
S#define  PWR_CR_PLS_0                        ((uint16_t)0x0020)     /*!< Bit 0 */
S#define  PWR_CR_PLS_1                        ((uint16_t)0x0040)     /*!< Bit 1 */
S#define  PWR_CR_PLS_2                        ((uint16_t)0x0080)     /*!< Bit 2 */
S
S/*!< PVD level configuration */
S#define  PWR_CR_PLS_2V2                      ((uint16_t)0x0000)     /*!< PVD level 2.2V */
S#define  PWR_CR_PLS_2V3                      ((uint16_t)0x0020)     /*!< PVD level 2.3V */
S#define  PWR_CR_PLS_2V4                      ((uint16_t)0x0040)     /*!< PVD level 2.4V */
S#define  PWR_CR_PLS_2V5                      ((uint16_t)0x0060)     /*!< PVD level 2.5V */
S#define  PWR_CR_PLS_2V6                      ((uint16_t)0x0080)     /*!< PVD level 2.6V */
S#define  PWR_CR_PLS_2V7                      ((uint16_t)0x00A0)     /*!< PVD level 2.7V */
S#define  PWR_CR_PLS_2V8                      ((uint16_t)0x00C0)     /*!< PVD level 2.8V */
S#define  PWR_CR_PLS_2V9                      ((uint16_t)0x00E0)     /*!< PVD level 2.9V */
S
S#define  PWR_CR_DBP                          ((uint16_t)0x0100)     /*!< Disable Backup Domain write protection */
S
S
S/*******************  Bit definition for PWR_CSR register  ********************/
S#define  PWR_CSR_WUF                         ((uint16_t)0x0001)     /*!< Wakeup Flag */
S#define  PWR_CSR_SBF                         ((uint16_t)0x0002)     /*!< Standby Flag */
S#define  PWR_CSR_PVDO                        ((uint16_t)0x0004)     /*!< PVD Output */
S#define  PWR_CSR_EWUP                        ((uint16_t)0x0100)     /*!< Enable WKUP pin */
S
S/******************************************************************************/
S/*                                                                            */
S/*                            Backup registers                                */
S/*                                                                            */
S/******************************************************************************/
S
S/*******************  Bit definition for BKP_DR1 register  ********************/
S#define  BKP_DR1_D                           ((uint16_t)0xFFFF)     /*!< Backup data */
S
S/*******************  Bit definition for BKP_DR2 register  ********************/
S#define  BKP_DR2_D                           ((uint16_t)0xFFFF)     /*!< Backup data */
S
S/*******************  Bit definition for BKP_DR3 register  ********************/
S#define  BKP_DR3_D                           ((uint16_t)0xFFFF)     /*!< Backup data */
S
S/*******************  Bit definition for BKP_DR4 register  ********************/
S#define  BKP_DR4_D                           ((uint16_t)0xFFFF)     /*!< Backup data */
S
S/*******************  Bit definition for BKP_DR5 register  ********************/
S#define  BKP_DR5_D                           ((uint16_t)0xFFFF)     /*!< Backup data */
S
S/*******************  Bit definition for BKP_DR6 register  ********************/
S#define  BKP_DR6_D                           ((uint16_t)0xFFFF)     /*!< Backup data */
S
S/*******************  Bit definition for BKP_DR7 register  ********************/
S#define  BKP_DR7_D                           ((uint16_t)0xFFFF)     /*!< Backup data */
S
S/*******************  Bit definition for BKP_DR8 register  ********************/
S#define  BKP_DR8_D                           ((uint16_t)0xFFFF)     /*!< Backup data */
S
S/*******************  Bit definition for BKP_DR9 register  ********************/
S#define  BKP_DR9_D                           ((uint16_t)0xFFFF)     /*!< Backup data */
S
S/*******************  Bit definition for BKP_DR10 register  *******************/
S#define  BKP_DR10_D                          ((uint16_t)0xFFFF)     /*!< Backup data */
S
S/*******************  Bit definition for BKP_DR11 register  *******************/
S#define  BKP_DR11_D                          ((uint16_t)0xFFFF)     /*!< Backup data */
S
S/*******************  Bit definition for BKP_DR12 register  *******************/
S#define  BKP_DR12_D                          ((uint16_t)0xFFFF)     /*!< Backup data */
S
S/*******************  Bit definition for BKP_DR13 register  *******************/
S#define  BKP_DR13_D                          ((uint16_t)0xFFFF)     /*!< Backup data */
S
S/*******************  Bit definition for BKP_DR14 register  *******************/
S#define  BKP_DR14_D                          ((uint16_t)0xFFFF)     /*!< Backup data */
S
S/*******************  Bit definition for BKP_DR15 register  *******************/
S#define  BKP_DR15_D                          ((uint16_t)0xFFFF)     /*!< Backup data */
S
S/*******************  Bit definition for BKP_DR16 register  *******************/
S#define  BKP_DR16_D                          ((uint16_t)0xFFFF)     /*!< Backup data */
S
S/*******************  Bit definition for BKP_DR17 register  *******************/
S#define  BKP_DR17_D                          ((uint16_t)0xFFFF)     /*!< Backup data */
S
S/******************  Bit definition for BKP_DR18 register  ********************/
S#define  BKP_DR18_D                          ((uint16_t)0xFFFF)     /*!< Backup data */
S
S/*******************  Bit definition for BKP_DR19 register  *******************/
S#define  BKP_DR19_D                          ((uint16_t)0xFFFF)     /*!< Backup data */
S
S/*******************  Bit definition for BKP_DR20 register  *******************/
S#define  BKP_DR20_D                          ((uint16_t)0xFFFF)     /*!< Backup data */
S
S/*******************  Bit definition for BKP_DR21 register  *******************/
S#define  BKP_DR21_D                          ((uint16_t)0xFFFF)     /*!< Backup data */
S
S/*******************  Bit definition for BKP_DR22 register  *******************/
S#define  BKP_DR22_D                          ((uint16_t)0xFFFF)     /*!< Backup data */
S
S/*******************  Bit definition for BKP_DR23 register  *******************/
S#define  BKP_DR23_D                          ((uint16_t)0xFFFF)     /*!< Backup data */
S
S/*******************  Bit definition for BKP_DR24 register  *******************/
S#define  BKP_DR24_D                          ((uint16_t)0xFFFF)     /*!< Backup data */
S
S/*******************  Bit definition for BKP_DR25 register  *******************/
S#define  BKP_DR25_D                          ((uint16_t)0xFFFF)     /*!< Backup data */
S
S/*******************  Bit definition for BKP_DR26 register  *******************/
S#define  BKP_DR26_D                          ((uint16_t)0xFFFF)     /*!< Backup data */
S
S/*******************  Bit definition for BKP_DR27 register  *******************/
S#define  BKP_DR27_D                          ((uint16_t)0xFFFF)     /*!< Backup data */
S
S/*******************  Bit definition for BKP_DR28 register  *******************/
S#define  BKP_DR28_D                          ((uint16_t)0xFFFF)     /*!< Backup data */
S
S/*******************  Bit definition for BKP_DR29 register  *******************/
S#define  BKP_DR29_D                          ((uint16_t)0xFFFF)     /*!< Backup data */
S
S/*******************  Bit definition for BKP_DR30 register  *******************/
S#define  BKP_DR30_D                          ((uint16_t)0xFFFF)     /*!< Backup data */
S
S/*******************  Bit definition for BKP_DR31 register  *******************/
S#define  BKP_DR31_D                          ((uint16_t)0xFFFF)     /*!< Backup data */
S
S/*******************  Bit definition for BKP_DR32 register  *******************/
S#define  BKP_DR32_D                          ((uint16_t)0xFFFF)     /*!< Backup data */
S
S/*******************  Bit definition for BKP_DR33 register  *******************/
S#define  BKP_DR33_D                          ((uint16_t)0xFFFF)     /*!< Backup data */
S
S/*******************  Bit definition for BKP_DR34 register  *******************/
S#define  BKP_DR34_D                          ((uint16_t)0xFFFF)     /*!< Backup data */
S
S/*******************  Bit definition for BKP_DR35 register  *******************/
S#define  BKP_DR35_D                          ((uint16_t)0xFFFF)     /*!< Backup data */
S
S/*******************  Bit definition for BKP_DR36 register  *******************/
S#define  BKP_DR36_D                          ((uint16_t)0xFFFF)     /*!< Backup data */
S
S/*******************  Bit definition for BKP_DR37 register  *******************/
S#define  BKP_DR37_D                          ((uint16_t)0xFFFF)     /*!< Backup data */
S
S/*******************  Bit definition for BKP_DR38 register  *******************/
S#define  BKP_DR38_D                          ((uint16_t)0xFFFF)     /*!< Backup data */
S
S/*******************  Bit definition for BKP_DR39 register  *******************/
S#define  BKP_DR39_D                          ((uint16_t)0xFFFF)     /*!< Backup data */
S
S/*******************  Bit definition for BKP_DR40 register  *******************/
S#define  BKP_DR40_D                          ((uint16_t)0xFFFF)     /*!< Backup data */
S
S/*******************  Bit definition for BKP_DR41 register  *******************/
S#define  BKP_DR41_D                          ((uint16_t)0xFFFF)     /*!< Backup data */
S
S/*******************  Bit definition for BKP_DR42 register  *******************/
S#define  BKP_DR42_D                          ((uint16_t)0xFFFF)     /*!< Backup data */
S
S/******************  Bit definition for BKP_RTCCR register  *******************/
S#define  BKP_RTCCR_CAL                       ((uint16_t)0x007F)     /*!< Calibration value */
S#define  BKP_RTCCR_CCO                       ((uint16_t)0x0080)     /*!< Calibration Clock Output */
S#define  BKP_RTCCR_ASOE                      ((uint16_t)0x0100)     /*!< Alarm or Second Output Enable */
S#define  BKP_RTCCR_ASOS                      ((uint16_t)0x0200)     /*!< Alarm or Second Output Selection */
S
S/********************  Bit definition for BKP_CR register  ********************/
S#define  BKP_CR_TPE                          ((uint8_t)0x01)        /*!< TAMPER pin enable */
S#define  BKP_CR_TPAL                         ((uint8_t)0x02)        /*!< TAMPER pin active level */
S
S/*******************  Bit definition for BKP_CSR register  ********************/
S#define  BKP_CSR_CTE                         ((uint16_t)0x0001)     /*!< Clear Tamper event */
S#define  BKP_CSR_CTI                         ((uint16_t)0x0002)     /*!< Clear Tamper Interrupt */
S#define  BKP_CSR_TPIE                        ((uint16_t)0x0004)     /*!< TAMPER Pin interrupt enable */
S#define  BKP_CSR_TEF                         ((uint16_t)0x0100)     /*!< Tamper Event Flag */
S#define  BKP_CSR_TIF                         ((uint16_t)0x0200)     /*!< Tamper Interrupt Flag */
S
S/******************************************************************************/
S/*                                                                            */
S/*                         Reset and Clock Control                            */
S/*                                                                            */
S/******************************************************************************/
S
S/********************  Bit definition for RCC_CR register  ********************/
S#define  RCC_CR_HSION                        ((uint32_t)0x00000001)        /*!< Internal High Speed clock enable */
S#define  RCC_CR_HSIRDY                       ((uint32_t)0x00000002)        /*!< Internal High Speed clock ready flag */
S#define  RCC_CR_HSITRIM                      ((uint32_t)0x000000F8)        /*!< Internal High Speed clock trimming */
S#define  RCC_CR_HSICAL                       ((uint32_t)0x0000FF00)        /*!< Internal High Speed clock Calibration */
S#define  RCC_CR_HSEON                        ((uint32_t)0x00010000)        /*!< External High Speed clock enable */
S#define  RCC_CR_HSERDY                       ((uint32_t)0x00020000)        /*!< External High Speed clock ready flag */
S#define  RCC_CR_HSEBYP                       ((uint32_t)0x00040000)        /*!< External High Speed clock Bypass */
S#define  RCC_CR_CSSON                        ((uint32_t)0x00080000)        /*!< Clock Security System enable */
S#define  RCC_CR_PLLON                        ((uint32_t)0x01000000)        /*!< PLL enable */
S#define  RCC_CR_PLLRDY                       ((uint32_t)0x02000000)        /*!< PLL clock ready flag */
S
S#ifdef STM32F10X_CL
S #define  RCC_CR_PLL2ON                       ((uint32_t)0x04000000)        /*!< PLL2 enable */
S #define  RCC_CR_PLL2RDY                      ((uint32_t)0x08000000)        /*!< PLL2 clock ready flag */
S #define  RCC_CR_PLL3ON                       ((uint32_t)0x10000000)        /*!< PLL3 enable */
S #define  RCC_CR_PLL3RDY                      ((uint32_t)0x20000000)        /*!< PLL3 clock ready flag */
S#endif /* STM32F10X_CL */
S
S/*******************  Bit definition for RCC_CFGR register  *******************/
S/*!< SW configuration */
S#define  RCC_CFGR_SW                         ((uint32_t)0x00000003)        /*!< SW[1:0] bits (System clock Switch) */
S#define  RCC_CFGR_SW_0                       ((uint32_t)0x00000001)        /*!< Bit 0 */
S#define  RCC_CFGR_SW_1                       ((uint32_t)0x00000002)        /*!< Bit 1 */
S
S#define  RCC_CFGR_SW_HSI                     ((uint32_t)0x00000000)        /*!< HSI selected as system clock */
S#define  RCC_CFGR_SW_HSE                     ((uint32_t)0x00000001)        /*!< HSE selected as system clock */
S#define  RCC_CFGR_SW_PLL                     ((uint32_t)0x00000002)        /*!< PLL selected as system clock */
S
S/*!< SWS configuration */
S#define  RCC_CFGR_SWS                        ((uint32_t)0x0000000C)        /*!< SWS[1:0] bits (System Clock Switch Status) */
S#define  RCC_CFGR_SWS_0                      ((uint32_t)0x00000004)        /*!< Bit 0 */
S#define  RCC_CFGR_SWS_1                      ((uint32_t)0x00000008)        /*!< Bit 1 */
S
S#define  RCC_CFGR_SWS_HSI                    ((uint32_t)0x00000000)        /*!< HSI oscillator used as system clock */
S#define  RCC_CFGR_SWS_HSE                    ((uint32_t)0x00000004)        /*!< HSE oscillator used as system clock */
S#define  RCC_CFGR_SWS_PLL                    ((uint32_t)0x00000008)        /*!< PLL used as system clock */
S
S/*!< HPRE configuration */
S#define  RCC_CFGR_HPRE                       ((uint32_t)0x000000F0)        /*!< HPRE[3:0] bits (AHB prescaler) */
S#define  RCC_CFGR_HPRE_0                     ((uint32_t)0x00000010)        /*!< Bit 0 */
S#define  RCC_CFGR_HPRE_1                     ((uint32_t)0x00000020)        /*!< Bit 1 */
S#define  RCC_CFGR_HPRE_2                     ((uint32_t)0x00000040)        /*!< Bit 2 */
S#define  RCC_CFGR_HPRE_3                     ((uint32_t)0x00000080)        /*!< Bit 3 */
S
S#define  RCC_CFGR_HPRE_DIV1                  ((uint32_t)0x00000000)        /*!< SYSCLK not divided */
S#define  RCC_CFGR_HPRE_DIV2                  ((uint32_t)0x00000080)        /*!< SYSCLK divided by 2 */
S#define  RCC_CFGR_HPRE_DIV4                  ((uint32_t)0x00000090)        /*!< SYSCLK divided by 4 */
S#define  RCC_CFGR_HPRE_DIV8                  ((uint32_t)0x000000A0)        /*!< SYSCLK divided by 8 */
S#define  RCC_CFGR_HPRE_DIV16                 ((uint32_t)0x000000B0)        /*!< SYSCLK divided by 16 */
S#define  RCC_CFGR_HPRE_DIV64                 ((uint32_t)0x000000C0)        /*!< SYSCLK divided by 64 */
S#define  RCC_CFGR_HPRE_DIV128                ((uint32_t)0x000000D0)        /*!< SYSCLK divided by 128 */
S#define  RCC_CFGR_HPRE_DIV256                ((uint32_t)0x000000E0)        /*!< SYSCLK divided by 256 */
S#define  RCC_CFGR_HPRE_DIV512                ((uint32_t)0x000000F0)        /*!< SYSCLK divided by 512 */
S
S/*!< PPRE1 configuration */
S#define  RCC_CFGR_PPRE1                      ((uint32_t)0x00000700)        /*!< PRE1[2:0] bits (APB1 prescaler) */
S#define  RCC_CFGR_PPRE1_0                    ((uint32_t)0x00000100)        /*!< Bit 0 */
S#define  RCC_CFGR_PPRE1_1                    ((uint32_t)0x00000200)        /*!< Bit 1 */
S#define  RCC_CFGR_PPRE1_2                    ((uint32_t)0x00000400)        /*!< Bit 2 */
S
S#define  RCC_CFGR_PPRE1_DIV1                 ((uint32_t)0x00000000)        /*!< HCLK not divided */
S#define  RCC_CFGR_PPRE1_DIV2                 ((uint32_t)0x00000400)        /*!< HCLK divided by 2 */
S#define  RCC_CFGR_PPRE1_DIV4                 ((uint32_t)0x00000500)        /*!< HCLK divided by 4 */
S#define  RCC_CFGR_PPRE1_DIV8                 ((uint32_t)0x00000600)        /*!< HCLK divided by 8 */
S#define  RCC_CFGR_PPRE1_DIV16                ((uint32_t)0x00000700)        /*!< HCLK divided by 16 */
S
S/*!< PPRE2 configuration */
S#define  RCC_CFGR_PPRE2                      ((uint32_t)0x00003800)        /*!< PRE2[2:0] bits (APB2 prescaler) */
S#define  RCC_CFGR_PPRE2_0                    ((uint32_t)0x00000800)        /*!< Bit 0 */
S#define  RCC_CFGR_PPRE2_1                    ((uint32_t)0x00001000)        /*!< Bit 1 */
S#define  RCC_CFGR_PPRE2_2                    ((uint32_t)0x00002000)        /*!< Bit 2 */
S
S#define  RCC_CFGR_PPRE2_DIV1                 ((uint32_t)0x00000000)        /*!< HCLK not divided */
S#define  RCC_CFGR_PPRE2_DIV2                 ((uint32_t)0x00002000)        /*!< HCLK divided by 2 */
S#define  RCC_CFGR_PPRE2_DIV4                 ((uint32_t)0x00002800)        /*!< HCLK divided by 4 */
S#define  RCC_CFGR_PPRE2_DIV8                 ((uint32_t)0x00003000)        /*!< HCLK divided by 8 */
S#define  RCC_CFGR_PPRE2_DIV16                ((uint32_t)0x00003800)        /*!< HCLK divided by 16 */
S
S/*!< ADCPPRE configuration */
S#define  RCC_CFGR_ADCPRE                     ((uint32_t)0x0000C000)        /*!< ADCPRE[1:0] bits (ADC prescaler) */
S#define  RCC_CFGR_ADCPRE_0                   ((uint32_t)0x00004000)        /*!< Bit 0 */
S#define  RCC_CFGR_ADCPRE_1                   ((uint32_t)0x00008000)        /*!< Bit 1 */
S
S#define  RCC_CFGR_ADCPRE_DIV2                ((uint32_t)0x00000000)        /*!< PCLK2 divided by 2 */
S#define  RCC_CFGR_ADCPRE_DIV4                ((uint32_t)0x00004000)        /*!< PCLK2 divided by 4 */
S#define  RCC_CFGR_ADCPRE_DIV6                ((uint32_t)0x00008000)        /*!< PCLK2 divided by 6 */
S#define  RCC_CFGR_ADCPRE_DIV8                ((uint32_t)0x0000C000)        /*!< PCLK2 divided by 8 */
S
S#define  RCC_CFGR_PLLSRC                     ((uint32_t)0x00010000)        /*!< PLL entry clock source */
S
S#define  RCC_CFGR_PLLXTPRE                   ((uint32_t)0x00020000)        /*!< HSE divider for PLL entry */
S
S/*!< PLLMUL configuration */
S#define  RCC_CFGR_PLLMULL                    ((uint32_t)0x003C0000)        /*!< PLLMUL[3:0] bits (PLL multiplication factor) */
S#define  RCC_CFGR_PLLMULL_0                  ((uint32_t)0x00040000)        /*!< Bit 0 */
S#define  RCC_CFGR_PLLMULL_1                  ((uint32_t)0x00080000)        /*!< Bit 1 */
S#define  RCC_CFGR_PLLMULL_2                  ((uint32_t)0x00100000)        /*!< Bit 2 */
S#define  RCC_CFGR_PLLMULL_3                  ((uint32_t)0x00200000)        /*!< Bit 3 */
S
S#ifdef STM32F10X_CL
S #define  RCC_CFGR_PLLSRC_HSI_Div2           ((uint32_t)0x00000000)        /*!< HSI clock divided by 2 selected as PLL entry clock source */
S #define  RCC_CFGR_PLLSRC_PREDIV1            ((uint32_t)0x00010000)        /*!< PREDIV1 clock selected as PLL entry clock source */
S
S #define  RCC_CFGR_PLLXTPRE_PREDIV1          ((uint32_t)0x00000000)        /*!< PREDIV1 clock not divided for PLL entry */
S #define  RCC_CFGR_PLLXTPRE_PREDIV1_Div2     ((uint32_t)0x00020000)        /*!< PREDIV1 clock divided by 2 for PLL entry */
S
S #define  RCC_CFGR_PLLMULL4                  ((uint32_t)0x00080000)        /*!< PLL input clock * 4 */
S #define  RCC_CFGR_PLLMULL5                  ((uint32_t)0x000C0000)        /*!< PLL input clock * 5 */
S #define  RCC_CFGR_PLLMULL6                  ((uint32_t)0x00100000)        /*!< PLL input clock * 6 */
S #define  RCC_CFGR_PLLMULL7                  ((uint32_t)0x00140000)        /*!< PLL input clock * 7 */
S #define  RCC_CFGR_PLLMULL8                  ((uint32_t)0x00180000)        /*!< PLL input clock * 8 */
S #define  RCC_CFGR_PLLMULL9                  ((uint32_t)0x001C0000)        /*!< PLL input clock * 9 */
S #define  RCC_CFGR_PLLMULL6_5                ((uint32_t)0x00340000)        /*!< PLL input clock * 6.5 */
S 
S #define  RCC_CFGR_OTGFSPRE                  ((uint32_t)0x00400000)        /*!< USB OTG FS prescaler */
S 
S/*!< MCO configuration */
S #define  RCC_CFGR_MCO                       ((uint32_t)0x0F000000)        /*!< MCO[3:0] bits (Microcontroller Clock Output) */
S #define  RCC_CFGR_MCO_0                     ((uint32_t)0x01000000)        /*!< Bit 0 */
S #define  RCC_CFGR_MCO_1                     ((uint32_t)0x02000000)        /*!< Bit 1 */
S #define  RCC_CFGR_MCO_2                     ((uint32_t)0x04000000)        /*!< Bit 2 */
S #define  RCC_CFGR_MCO_3                     ((uint32_t)0x08000000)        /*!< Bit 3 */
S
S #define  RCC_CFGR_MCO_NOCLOCK               ((uint32_t)0x00000000)        /*!< No clock */
S #define  RCC_CFGR_MCO_SYSCLK                ((uint32_t)0x04000000)        /*!< System clock selected as MCO source */
S #define  RCC_CFGR_MCO_HSI                   ((uint32_t)0x05000000)        /*!< HSI clock selected as MCO source */
S #define  RCC_CFGR_MCO_HSE                   ((uint32_t)0x06000000)        /*!< HSE clock selected as MCO source */
S #define  RCC_CFGR_MCO_PLLCLK_Div2           ((uint32_t)0x07000000)        /*!< PLL clock divided by 2 selected as MCO source */
S #define  RCC_CFGR_MCO_PLL2CLK               ((uint32_t)0x08000000)        /*!< PLL2 clock selected as MCO source*/
S #define  RCC_CFGR_MCO_PLL3CLK_Div2          ((uint32_t)0x09000000)        /*!< PLL3 clock divided by 2 selected as MCO source*/
S #define  RCC_CFGR_MCO_Ext_HSE               ((uint32_t)0x0A000000)        /*!< XT1 external 3-25 MHz oscillator clock selected as MCO source */
S #define  RCC_CFGR_MCO_PLL3CLK               ((uint32_t)0x0B000000)        /*!< PLL3 clock selected as MCO source */
S#elif defined (STM32F10X_LD_VL) || defined (STM32F10X_MD_VL) || defined (STM32F10X_HD_VL)
S #define  RCC_CFGR_PLLSRC_HSI_Div2           ((uint32_t)0x00000000)        /*!< HSI clock divided by 2 selected as PLL entry clock source */
S #define  RCC_CFGR_PLLSRC_PREDIV1            ((uint32_t)0x00010000)        /*!< PREDIV1 clock selected as PLL entry clock source */
S
S #define  RCC_CFGR_PLLXTPRE_PREDIV1          ((uint32_t)0x00000000)        /*!< PREDIV1 clock not divided for PLL entry */
S #define  RCC_CFGR_PLLXTPRE_PREDIV1_Div2     ((uint32_t)0x00020000)        /*!< PREDIV1 clock divided by 2 for PLL entry */
S
S #define  RCC_CFGR_PLLMULL2                  ((uint32_t)0x00000000)        /*!< PLL input clock*2 */
S #define  RCC_CFGR_PLLMULL3                  ((uint32_t)0x00040000)        /*!< PLL input clock*3 */
S #define  RCC_CFGR_PLLMULL4                  ((uint32_t)0x00080000)        /*!< PLL input clock*4 */
S #define  RCC_CFGR_PLLMULL5                  ((uint32_t)0x000C0000)        /*!< PLL input clock*5 */
S #define  RCC_CFGR_PLLMULL6                  ((uint32_t)0x00100000)        /*!< PLL input clock*6 */
S #define  RCC_CFGR_PLLMULL7                  ((uint32_t)0x00140000)        /*!< PLL input clock*7 */
S #define  RCC_CFGR_PLLMULL8                  ((uint32_t)0x00180000)        /*!< PLL input clock*8 */
S #define  RCC_CFGR_PLLMULL9                  ((uint32_t)0x001C0000)        /*!< PLL input clock*9 */
S #define  RCC_CFGR_PLLMULL10                 ((uint32_t)0x00200000)        /*!< PLL input clock10 */
S #define  RCC_CFGR_PLLMULL11                 ((uint32_t)0x00240000)        /*!< PLL input clock*11 */
S #define  RCC_CFGR_PLLMULL12                 ((uint32_t)0x00280000)        /*!< PLL input clock*12 */
S #define  RCC_CFGR_PLLMULL13                 ((uint32_t)0x002C0000)        /*!< PLL input clock*13 */
S #define  RCC_CFGR_PLLMULL14                 ((uint32_t)0x00300000)        /*!< PLL input clock*14 */
S #define  RCC_CFGR_PLLMULL15                 ((uint32_t)0x00340000)        /*!< PLL input clock*15 */
S #define  RCC_CFGR_PLLMULL16                 ((uint32_t)0x00380000)        /*!< PLL input clock*16 */
S
S/*!< MCO configuration */
S #define  RCC_CFGR_MCO                       ((uint32_t)0x07000000)        /*!< MCO[2:0] bits (Microcontroller Clock Output) */
S #define  RCC_CFGR_MCO_0                     ((uint32_t)0x01000000)        /*!< Bit 0 */
S #define  RCC_CFGR_MCO_1                     ((uint32_t)0x02000000)        /*!< Bit 1 */
S #define  RCC_CFGR_MCO_2                     ((uint32_t)0x04000000)        /*!< Bit 2 */
S
S #define  RCC_CFGR_MCO_NOCLOCK               ((uint32_t)0x00000000)        /*!< No clock */
S #define  RCC_CFGR_MCO_SYSCLK                ((uint32_t)0x04000000)        /*!< System clock selected as MCO source */
S #define  RCC_CFGR_MCO_HSI                   ((uint32_t)0x05000000)        /*!< HSI clock selected as MCO source */
S #define  RCC_CFGR_MCO_HSE                   ((uint32_t)0x06000000)        /*!< HSE clock selected as MCO source  */
S #define  RCC_CFGR_MCO_PLL                   ((uint32_t)0x07000000)        /*!< PLL clock divided by 2 selected as MCO source */
S#else
S #define  RCC_CFGR_PLLSRC_HSI_Div2           ((uint32_t)0x00000000)        /*!< HSI clock divided by 2 selected as PLL entry clock source */
S #define  RCC_CFGR_PLLSRC_HSE                ((uint32_t)0x00010000)        /*!< HSE clock selected as PLL entry clock source */
S
S #define  RCC_CFGR_PLLXTPRE_HSE              ((uint32_t)0x00000000)        /*!< HSE clock not divided for PLL entry */
S #define  RCC_CFGR_PLLXTPRE_HSE_Div2         ((uint32_t)0x00020000)        /*!< HSE clock divided by 2 for PLL entry */
S
S #define  RCC_CFGR_PLLMULL2                  ((uint32_t)0x00000000)        /*!< PLL input clock*2 */
S #define  RCC_CFGR_PLLMULL3                  ((uint32_t)0x00040000)        /*!< PLL input clock*3 */
S #define  RCC_CFGR_PLLMULL4                  ((uint32_t)0x00080000)        /*!< PLL input clock*4 */
S #define  RCC_CFGR_PLLMULL5                  ((uint32_t)0x000C0000)        /*!< PLL input clock*5 */
S #define  RCC_CFGR_PLLMULL6                  ((uint32_t)0x00100000)        /*!< PLL input clock*6 */
S #define  RCC_CFGR_PLLMULL7                  ((uint32_t)0x00140000)        /*!< PLL input clock*7 */
S #define  RCC_CFGR_PLLMULL8                  ((uint32_t)0x00180000)        /*!< PLL input clock*8 */
S #define  RCC_CFGR_PLLMULL9                  ((uint32_t)0x001C0000)        /*!< PLL input clock*9 */
S #define  RCC_CFGR_PLLMULL10                 ((uint32_t)0x00200000)        /*!< PLL input clock10 */
S #define  RCC_CFGR_PLLMULL11                 ((uint32_t)0x00240000)        /*!< PLL input clock*11 */
S #define  RCC_CFGR_PLLMULL12                 ((uint32_t)0x00280000)        /*!< PLL input clock*12 */
S #define  RCC_CFGR_PLLMULL13                 ((uint32_t)0x002C0000)        /*!< PLL input clock*13 */
S #define  RCC_CFGR_PLLMULL14                 ((uint32_t)0x00300000)        /*!< PLL input clock*14 */
S #define  RCC_CFGR_PLLMULL15                 ((uint32_t)0x00340000)        /*!< PLL input clock*15 */
S #define  RCC_CFGR_PLLMULL16                 ((uint32_t)0x00380000)        /*!< PLL input clock*16 */
S #define  RCC_CFGR_USBPRE                    ((uint32_t)0x00400000)        /*!< USB Device prescaler */
S
S/*!< MCO configuration */
S #define  RCC_CFGR_MCO                       ((uint32_t)0x07000000)        /*!< MCO[2:0] bits (Microcontroller Clock Output) */
S #define  RCC_CFGR_MCO_0                     ((uint32_t)0x01000000)        /*!< Bit 0 */
S #define  RCC_CFGR_MCO_1                     ((uint32_t)0x02000000)        /*!< Bit 1 */
S #define  RCC_CFGR_MCO_2                     ((uint32_t)0x04000000)        /*!< Bit 2 */
S
S #define  RCC_CFGR_MCO_NOCLOCK               ((uint32_t)0x00000000)        /*!< No clock */
S #define  RCC_CFGR_MCO_SYSCLK                ((uint32_t)0x04000000)        /*!< System clock selected as MCO source */
S #define  RCC_CFGR_MCO_HSI                   ((uint32_t)0x05000000)        /*!< HSI clock selected as MCO source */
S #define  RCC_CFGR_MCO_HSE                   ((uint32_t)0x06000000)        /*!< HSE clock selected as MCO source  */
S #define  RCC_CFGR_MCO_PLL                   ((uint32_t)0x07000000)        /*!< PLL clock divided by 2 selected as MCO source */
S#endif /* STM32F10X_CL */
S
S/*!<******************  Bit definition for RCC_CIR register  ********************/
S#define  RCC_CIR_LSIRDYF                     ((uint32_t)0x00000001)        /*!< LSI Ready Interrupt flag */
S#define  RCC_CIR_LSERDYF                     ((uint32_t)0x00000002)        /*!< LSE Ready Interrupt flag */
S#define  RCC_CIR_HSIRDYF                     ((uint32_t)0x00000004)        /*!< HSI Ready Interrupt flag */
S#define  RCC_CIR_HSERDYF                     ((uint32_t)0x00000008)        /*!< HSE Ready Interrupt flag */
S#define  RCC_CIR_PLLRDYF                     ((uint32_t)0x00000010)        /*!< PLL Ready Interrupt flag */
S#define  RCC_CIR_CSSF                        ((uint32_t)0x00000080)        /*!< Clock Security System Interrupt flag */
S#define  RCC_CIR_LSIRDYIE                    ((uint32_t)0x00000100)        /*!< LSI Ready Interrupt Enable */
S#define  RCC_CIR_LSERDYIE                    ((uint32_t)0x00000200)        /*!< LSE Ready Interrupt Enable */
S#define  RCC_CIR_HSIRDYIE                    ((uint32_t)0x00000400)        /*!< HSI Ready Interrupt Enable */
S#define  RCC_CIR_HSERDYIE                    ((uint32_t)0x00000800)        /*!< HSE Ready Interrupt Enable */
S#define  RCC_CIR_PLLRDYIE                    ((uint32_t)0x00001000)        /*!< PLL Ready Interrupt Enable */
S#define  RCC_CIR_LSIRDYC                     ((uint32_t)0x00010000)        /*!< LSI Ready Interrupt Clear */
S#define  RCC_CIR_LSERDYC                     ((uint32_t)0x00020000)        /*!< LSE Ready Interrupt Clear */
S#define  RCC_CIR_HSIRDYC                     ((uint32_t)0x00040000)        /*!< HSI Ready Interrupt Clear */
S#define  RCC_CIR_HSERDYC                     ((uint32_t)0x00080000)        /*!< HSE Ready Interrupt Clear */
S#define  RCC_CIR_PLLRDYC                     ((uint32_t)0x00100000)        /*!< PLL Ready Interrupt Clear */
S#define  RCC_CIR_CSSC                        ((uint32_t)0x00800000)        /*!< Clock Security System Interrupt Clear */
S
S#ifdef STM32F10X_CL
S #define  RCC_CIR_PLL2RDYF                    ((uint32_t)0x00000020)        /*!< PLL2 Ready Interrupt flag */
S #define  RCC_CIR_PLL3RDYF                    ((uint32_t)0x00000040)        /*!< PLL3 Ready Interrupt flag */
S #define  RCC_CIR_PLL2RDYIE                   ((uint32_t)0x00002000)        /*!< PLL2 Ready Interrupt Enable */
S #define  RCC_CIR_PLL3RDYIE                   ((uint32_t)0x00004000)        /*!< PLL3 Ready Interrupt Enable */
S #define  RCC_CIR_PLL2RDYC                    ((uint32_t)0x00200000)        /*!< PLL2 Ready Interrupt Clear */
S #define  RCC_CIR_PLL3RDYC                    ((uint32_t)0x00400000)        /*!< PLL3 Ready Interrupt Clear */
S#endif /* STM32F10X_CL */
S
S/*****************  Bit definition for RCC_APB2RSTR register  *****************/
S#define  RCC_APB2RSTR_AFIORST                ((uint32_t)0x00000001)        /*!< Alternate Function I/O reset */
S#define  RCC_APB2RSTR_IOPARST                ((uint32_t)0x00000004)        /*!< I/O port A reset */
S#define  RCC_APB2RSTR_IOPBRST                ((uint32_t)0x00000008)        /*!< I/O port B reset */
S#define  RCC_APB2RSTR_IOPCRST                ((uint32_t)0x00000010)        /*!< I/O port C reset */
S#define  RCC_APB2RSTR_IOPDRST                ((uint32_t)0x00000020)        /*!< I/O port D reset */
S#define  RCC_APB2RSTR_ADC1RST                ((uint32_t)0x00000200)        /*!< ADC 1 interface reset */
S
S#if !defined (STM32F10X_LD_VL) && !defined (STM32F10X_MD_VL) && !defined (STM32F10X_HD_VL)
S#define  RCC_APB2RSTR_ADC2RST                ((uint32_t)0x00000400)        /*!< ADC 2 interface reset */
S#endif
S
S#define  RCC_APB2RSTR_TIM1RST                ((uint32_t)0x00000800)        /*!< TIM1 Timer reset */
S#define  RCC_APB2RSTR_SPI1RST                ((uint32_t)0x00001000)        /*!< SPI 1 reset */
S#define  RCC_APB2RSTR_USART1RST              ((uint32_t)0x00004000)        /*!< USART1 reset */
S
S#if defined (STM32F10X_LD_VL) || defined (STM32F10X_MD_VL) || defined (STM32F10X_HD_VL)
S#define  RCC_APB2RSTR_TIM15RST               ((uint32_t)0x00010000)        /*!< TIM15 Timer reset */
S#define  RCC_APB2RSTR_TIM16RST               ((uint32_t)0x00020000)        /*!< TIM16 Timer reset */
S#define  RCC_APB2RSTR_TIM17RST               ((uint32_t)0x00040000)        /*!< TIM17 Timer reset */
S#endif
S
S#if !defined (STM32F10X_LD) && !defined (STM32F10X_LD_VL)
S #define  RCC_APB2RSTR_IOPERST               ((uint32_t)0x00000040)        /*!< I/O port E reset */
S#endif /* STM32F10X_LD && STM32F10X_LD_VL */
S
S#if defined (STM32F10X_HD) || defined (STM32F10X_XL)
S #define  RCC_APB2RSTR_IOPFRST               ((uint32_t)0x00000080)        /*!< I/O port F reset */
S #define  RCC_APB2RSTR_IOPGRST               ((uint32_t)0x00000100)        /*!< I/O port G reset */
S #define  RCC_APB2RSTR_TIM8RST               ((uint32_t)0x00002000)        /*!< TIM8 Timer reset */
S #define  RCC_APB2RSTR_ADC3RST               ((uint32_t)0x00008000)        /*!< ADC3 interface reset */
S#endif
S
S#if defined (STM32F10X_HD_VL)
S #define  RCC_APB2RSTR_IOPFRST               ((uint32_t)0x00000080)        /*!< I/O port F reset */
S #define  RCC_APB2RSTR_IOPGRST               ((uint32_t)0x00000100)        /*!< I/O port G reset */
S#endif
S
S#ifdef STM32F10X_XL
S #define  RCC_APB2RSTR_TIM9RST               ((uint32_t)0x00080000)         /*!< TIM9 Timer reset */
S #define  RCC_APB2RSTR_TIM10RST              ((uint32_t)0x00100000)         /*!< TIM10 Timer reset */
S #define  RCC_APB2RSTR_TIM11RST              ((uint32_t)0x00200000)         /*!< TIM11 Timer reset */
S#endif /* STM32F10X_XL */
S
S/*****************  Bit definition for RCC_APB1RSTR register  *****************/
S#define  RCC_APB1RSTR_TIM2RST                ((uint32_t)0x00000001)        /*!< Timer 2 reset */
S#define  RCC_APB1RSTR_TIM3RST                ((uint32_t)0x00000002)        /*!< Timer 3 reset */
S#define  RCC_APB1RSTR_WWDGRST                ((uint32_t)0x00000800)        /*!< Window Watchdog reset */
S#define  RCC_APB1RSTR_USART2RST              ((uint32_t)0x00020000)        /*!< USART 2 reset */
S#define  RCC_APB1RSTR_I2C1RST                ((uint32_t)0x00200000)        /*!< I2C 1 reset */
S
S#if !defined (STM32F10X_LD_VL) && !defined (STM32F10X_MD_VL) && !defined (STM32F10X_HD_VL)
S#define  RCC_APB1RSTR_CAN1RST                ((uint32_t)0x02000000)        /*!< CAN1 reset */
S#endif
S
S#define  RCC_APB1RSTR_BKPRST                 ((uint32_t)0x08000000)        /*!< Backup interface reset */
S#define  RCC_APB1RSTR_PWRRST                 ((uint32_t)0x10000000)        /*!< Power interface reset */
S
S#if !defined (STM32F10X_LD) && !defined (STM32F10X_LD_VL)
S #define  RCC_APB1RSTR_TIM4RST               ((uint32_t)0x00000004)        /*!< Timer 4 reset */
S #define  RCC_APB1RSTR_SPI2RST               ((uint32_t)0x00004000)        /*!< SPI 2 reset */
S #define  RCC_APB1RSTR_USART3RST             ((uint32_t)0x00040000)        /*!< USART 3 reset */
S #define  RCC_APB1RSTR_I2C2RST               ((uint32_t)0x00400000)        /*!< I2C 2 reset */
S#endif /* STM32F10X_LD && STM32F10X_LD_VL */
S
S#if defined (STM32F10X_HD) || defined (STM32F10X_MD) || defined (STM32F10X_LD) || defined  (STM32F10X_XL)
S #define  RCC_APB1RSTR_USBRST                ((uint32_t)0x00800000)        /*!< USB Device reset */
S#endif
S
S#if defined (STM32F10X_HD) || defined  (STM32F10X_CL) || defined  (STM32F10X_XL)
S #define  RCC_APB1RSTR_TIM5RST                ((uint32_t)0x00000008)        /*!< Timer 5 reset */
S #define  RCC_APB1RSTR_TIM6RST                ((uint32_t)0x00000010)        /*!< Timer 6 reset */
S #define  RCC_APB1RSTR_TIM7RST                ((uint32_t)0x00000020)        /*!< Timer 7 reset */
S #define  RCC_APB1RSTR_SPI3RST                ((uint32_t)0x00008000)        /*!< SPI 3 reset */
S #define  RCC_APB1RSTR_UART4RST               ((uint32_t)0x00080000)        /*!< UART 4 reset */
S #define  RCC_APB1RSTR_UART5RST               ((uint32_t)0x00100000)        /*!< UART 5 reset */
S #define  RCC_APB1RSTR_DACRST                 ((uint32_t)0x20000000)        /*!< DAC interface reset */
S#endif
S
S#if defined (STM32F10X_LD_VL) || defined  (STM32F10X_MD_VL) || defined  (STM32F10X_HD_VL)
S #define  RCC_APB1RSTR_TIM6RST                ((uint32_t)0x00000010)        /*!< Timer 6 reset */
S #define  RCC_APB1RSTR_TIM7RST                ((uint32_t)0x00000020)        /*!< Timer 7 reset */
S #define  RCC_APB1RSTR_DACRST                 ((uint32_t)0x20000000)        /*!< DAC interface reset */
S #define  RCC_APB1RSTR_CECRST                 ((uint32_t)0x40000000)        /*!< CEC interface reset */ 
S#endif
S
S#if defined  (STM32F10X_HD_VL)
S #define  RCC_APB1RSTR_TIM5RST                ((uint32_t)0x00000008)        /*!< Timer 5 reset */
S #define  RCC_APB1RSTR_TIM12RST               ((uint32_t)0x00000040)        /*!< TIM12 Timer reset */
S #define  RCC_APB1RSTR_TIM13RST               ((uint32_t)0x00000080)        /*!< TIM13 Timer reset */
S #define  RCC_APB1RSTR_TIM14RST               ((uint32_t)0x00000100)        /*!< TIM14 Timer reset */
S #define  RCC_APB1RSTR_SPI3RST                ((uint32_t)0x00008000)        /*!< SPI 3 reset */ 
S #define  RCC_APB1RSTR_UART4RST               ((uint32_t)0x00080000)        /*!< UART 4 reset */
S #define  RCC_APB1RSTR_UART5RST               ((uint32_t)0x00100000)        /*!< UART 5 reset */ 
S#endif
S
S#ifdef STM32F10X_CL
S #define  RCC_APB1RSTR_CAN2RST                ((uint32_t)0x04000000)        /*!< CAN2 reset */
S#endif /* STM32F10X_CL */
S
S#ifdef STM32F10X_XL
S #define  RCC_APB1RSTR_TIM12RST               ((uint32_t)0x00000040)         /*!< TIM12 Timer reset */
S #define  RCC_APB1RSTR_TIM13RST               ((uint32_t)0x00000080)         /*!< TIM13 Timer reset */
S #define  RCC_APB1RSTR_TIM14RST               ((uint32_t)0x00000100)         /*!< TIM14 Timer reset */
S#endif /* STM32F10X_XL */
S
S/******************  Bit definition for RCC_AHBENR register  ******************/
S#define  RCC_AHBENR_DMA1EN                   ((uint16_t)0x0001)            /*!< DMA1 clock enable */
S#define  RCC_AHBENR_SRAMEN                   ((uint16_t)0x0004)            /*!< SRAM interface clock enable */
S#define  RCC_AHBENR_FLITFEN                  ((uint16_t)0x0010)            /*!< FLITF clock enable */
S#define  RCC_AHBENR_CRCEN                    ((uint16_t)0x0040)            /*!< CRC clock enable */
S
S#if defined (STM32F10X_HD) || defined  (STM32F10X_CL) || defined  (STM32F10X_HD_VL)
S #define  RCC_AHBENR_DMA2EN                  ((uint16_t)0x0002)            /*!< DMA2 clock enable */
S#endif
S
S#if defined (STM32F10X_HD) || defined (STM32F10X_XL)
S #define  RCC_AHBENR_FSMCEN                  ((uint16_t)0x0100)            /*!< FSMC clock enable */
S #define  RCC_AHBENR_SDIOEN                  ((uint16_t)0x0400)            /*!< SDIO clock enable */
S#endif
S
S#if defined (STM32F10X_HD_VL)
S #define  RCC_AHBENR_FSMCEN                  ((uint16_t)0x0100)            /*!< FSMC clock enable */
S#endif
S
S#ifdef STM32F10X_CL
S #define  RCC_AHBENR_OTGFSEN                 ((uint32_t)0x00001000)         /*!< USB OTG FS clock enable */
S #define  RCC_AHBENR_ETHMACEN                ((uint32_t)0x00004000)         /*!< ETHERNET MAC clock enable */
S #define  RCC_AHBENR_ETHMACTXEN              ((uint32_t)0x00008000)         /*!< ETHERNET MAC Tx clock enable */
S #define  RCC_AHBENR_ETHMACRXEN              ((uint32_t)0x00010000)         /*!< ETHERNET MAC Rx clock enable */
S#endif /* STM32F10X_CL */
S
S/******************  Bit definition for RCC_APB2ENR register  *****************/
S#define  RCC_APB2ENR_AFIOEN                  ((uint32_t)0x00000001)         /*!< Alternate Function I/O clock enable */
S#define  RCC_APB2ENR_IOPAEN                  ((uint32_t)0x00000004)         /*!< I/O port A clock enable */
S#define  RCC_APB2ENR_IOPBEN                  ((uint32_t)0x00000008)         /*!< I/O port B clock enable */
S#define  RCC_APB2ENR_IOPCEN                  ((uint32_t)0x00000010)         /*!< I/O port C clock enable */
S#define  RCC_APB2ENR_IOPDEN                  ((uint32_t)0x00000020)         /*!< I/O port D clock enable */
S#define  RCC_APB2ENR_ADC1EN                  ((uint32_t)0x00000200)         /*!< ADC 1 interface clock enable */
S
S#if !defined (STM32F10X_LD_VL) && !defined (STM32F10X_MD_VL) && !defined (STM32F10X_HD_VL)
S#define  RCC_APB2ENR_ADC2EN                  ((uint32_t)0x00000400)         /*!< ADC 2 interface clock enable */
S#endif
S
S#define  RCC_APB2ENR_TIM1EN                  ((uint32_t)0x00000800)         /*!< TIM1 Timer clock enable */
S#define  RCC_APB2ENR_SPI1EN                  ((uint32_t)0x00001000)         /*!< SPI 1 clock enable */
S#define  RCC_APB2ENR_USART1EN                ((uint32_t)0x00004000)         /*!< USART1 clock enable */
S
S#if defined (STM32F10X_LD_VL) || defined (STM32F10X_MD_VL) || defined (STM32F10X_HD_VL)
S#define  RCC_APB2ENR_TIM15EN                 ((uint32_t)0x00010000)         /*!< TIM15 Timer clock enable */
S#define  RCC_APB2ENR_TIM16EN                 ((uint32_t)0x00020000)         /*!< TIM16 Timer clock enable */
S#define  RCC_APB2ENR_TIM17EN                 ((uint32_t)0x00040000)         /*!< TIM17 Timer clock enable */
S#endif
S
S#if !defined (STM32F10X_LD) && !defined (STM32F10X_LD_VL)
S #define  RCC_APB2ENR_IOPEEN                 ((uint32_t)0x00000040)         /*!< I/O port E clock enable */
S#endif /* STM32F10X_LD && STM32F10X_LD_VL */
S
S#if defined (STM32F10X_HD) || defined (STM32F10X_XL)
S #define  RCC_APB2ENR_IOPFEN                 ((uint32_t)0x00000080)         /*!< I/O port F clock enable */
S #define  RCC_APB2ENR_IOPGEN                 ((uint32_t)0x00000100)         /*!< I/O port G clock enable */
S #define  RCC_APB2ENR_TIM8EN                 ((uint32_t)0x00002000)         /*!< TIM8 Timer clock enable */
S #define  RCC_APB2ENR_ADC3EN                 ((uint32_t)0x00008000)         /*!< DMA1 clock enable */
S#endif
S
S#if defined (STM32F10X_HD_VL)
S #define  RCC_APB2ENR_IOPFEN                 ((uint32_t)0x00000080)         /*!< I/O port F clock enable */
S #define  RCC_APB2ENR_IOPGEN                 ((uint32_t)0x00000100)         /*!< I/O port G clock enable */
S#endif
S
S#ifdef STM32F10X_XL
S #define  RCC_APB2ENR_TIM9EN                 ((uint32_t)0x00080000)         /*!< TIM9 Timer clock enable  */
S #define  RCC_APB2ENR_TIM10EN                ((uint32_t)0x00100000)         /*!< TIM10 Timer clock enable  */
S #define  RCC_APB2ENR_TIM11EN                ((uint32_t)0x00200000)         /*!< TIM11 Timer clock enable */
S#endif
S
S/*****************  Bit definition for RCC_APB1ENR register  ******************/
S#define  RCC_APB1ENR_TIM2EN                  ((uint32_t)0x00000001)        /*!< Timer 2 clock enabled*/
S#define  RCC_APB1ENR_TIM3EN                  ((uint32_t)0x00000002)        /*!< Timer 3 clock enable */
S#define  RCC_APB1ENR_WWDGEN                  ((uint32_t)0x00000800)        /*!< Window Watchdog clock enable */
S#define  RCC_APB1ENR_USART2EN                ((uint32_t)0x00020000)        /*!< USART 2 clock enable */
S#define  RCC_APB1ENR_I2C1EN                  ((uint32_t)0x00200000)        /*!< I2C 1 clock enable */
S
S#if !defined (STM32F10X_LD_VL) && !defined (STM32F10X_MD_VL) && !defined (STM32F10X_HD_VL)
S#define  RCC_APB1ENR_CAN1EN                  ((uint32_t)0x02000000)        /*!< CAN1 clock enable */
S#endif
S
S#define  RCC_APB1ENR_BKPEN                   ((uint32_t)0x08000000)        /*!< Backup interface clock enable */
S#define  RCC_APB1ENR_PWREN                   ((uint32_t)0x10000000)        /*!< Power interface clock enable */
S
S#if !defined (STM32F10X_LD) && !defined (STM32F10X_LD_VL)
S #define  RCC_APB1ENR_TIM4EN                 ((uint32_t)0x00000004)        /*!< Timer 4 clock enable */
S #define  RCC_APB1ENR_SPI2EN                 ((uint32_t)0x00004000)        /*!< SPI 2 clock enable */
S #define  RCC_APB1ENR_USART3EN               ((uint32_t)0x00040000)        /*!< USART 3 clock enable */
S #define  RCC_APB1ENR_I2C2EN                 ((uint32_t)0x00400000)        /*!< I2C 2 clock enable */
S#endif /* STM32F10X_LD && STM32F10X_LD_VL */
S
S#if defined (STM32F10X_HD) || defined (STM32F10X_MD) || defined  (STM32F10X_LD)
S #define  RCC_APB1ENR_USBEN                  ((uint32_t)0x00800000)        /*!< USB Device clock enable */
S#endif
S
S#if defined (STM32F10X_HD) || defined  (STM32F10X_CL)
S #define  RCC_APB1ENR_TIM5EN                 ((uint32_t)0x00000008)        /*!< Timer 5 clock enable */
S #define  RCC_APB1ENR_TIM6EN                 ((uint32_t)0x00000010)        /*!< Timer 6 clock enable */
S #define  RCC_APB1ENR_TIM7EN                 ((uint32_t)0x00000020)        /*!< Timer 7 clock enable */
S #define  RCC_APB1ENR_SPI3EN                 ((uint32_t)0x00008000)        /*!< SPI 3 clock enable */
S #define  RCC_APB1ENR_UART4EN                ((uint32_t)0x00080000)        /*!< UART 4 clock enable */
S #define  RCC_APB1ENR_UART5EN                ((uint32_t)0x00100000)        /*!< UART 5 clock enable */
S #define  RCC_APB1ENR_DACEN                  ((uint32_t)0x20000000)        /*!< DAC interface clock enable */
S#endif
S
S#if defined (STM32F10X_LD_VL) || defined  (STM32F10X_MD_VL) || defined  (STM32F10X_HD_VL)
S #define  RCC_APB1ENR_TIM6EN                 ((uint32_t)0x00000010)        /*!< Timer 6 clock enable */
S #define  RCC_APB1ENR_TIM7EN                 ((uint32_t)0x00000020)        /*!< Timer 7 clock enable */
S #define  RCC_APB1ENR_DACEN                  ((uint32_t)0x20000000)        /*!< DAC interface clock enable */
S #define  RCC_APB1ENR_CECEN                  ((uint32_t)0x40000000)        /*!< CEC interface clock enable */ 
S#endif
S
S#ifdef STM32F10X_HD_VL
S #define  RCC_APB1ENR_TIM5EN                 ((uint32_t)0x00000008)        /*!< Timer 5 clock enable */
S #define  RCC_APB1ENR_TIM12EN                ((uint32_t)0x00000040)         /*!< TIM12 Timer clock enable  */
S #define  RCC_APB1ENR_TIM13EN                ((uint32_t)0x00000080)         /*!< TIM13 Timer clock enable  */
S #define  RCC_APB1ENR_TIM14EN                ((uint32_t)0x00000100)         /*!< TIM14 Timer clock enable */
S #define  RCC_APB1ENR_SPI3EN                 ((uint32_t)0x00008000)        /*!< SPI 3 clock enable */
S #define  RCC_APB1ENR_UART4EN                ((uint32_t)0x00080000)        /*!< UART 4 clock enable */
S #define  RCC_APB1ENR_UART5EN                ((uint32_t)0x00100000)        /*!< UART 5 clock enable */ 
S#endif /* STM32F10X_HD_VL */
S
S#ifdef STM32F10X_CL
S #define  RCC_APB1ENR_CAN2EN                  ((uint32_t)0x04000000)        /*!< CAN2 clock enable */
S#endif /* STM32F10X_CL */
S
S#ifdef STM32F10X_XL
S #define  RCC_APB1ENR_TIM12EN                ((uint32_t)0x00000040)         /*!< TIM12 Timer clock enable  */
S #define  RCC_APB1ENR_TIM13EN                ((uint32_t)0x00000080)         /*!< TIM13 Timer clock enable  */
S #define  RCC_APB1ENR_TIM14EN                ((uint32_t)0x00000100)         /*!< TIM14 Timer clock enable */
S#endif /* STM32F10X_XL */
S
S/*******************  Bit definition for RCC_BDCR register  *******************/
S#define  RCC_BDCR_LSEON                      ((uint32_t)0x00000001)        /*!< External Low Speed oscillator enable */
S#define  RCC_BDCR_LSERDY                     ((uint32_t)0x00000002)        /*!< External Low Speed oscillator Ready */
S#define  RCC_BDCR_LSEBYP                     ((uint32_t)0x00000004)        /*!< External Low Speed oscillator Bypass */
S
S#define  RCC_BDCR_RTCSEL                     ((uint32_t)0x00000300)        /*!< RTCSEL[1:0] bits (RTC clock source selection) */
S#define  RCC_BDCR_RTCSEL_0                   ((uint32_t)0x00000100)        /*!< Bit 0 */
S#define  RCC_BDCR_RTCSEL_1                   ((uint32_t)0x00000200)        /*!< Bit 1 */
S
S/*!< RTC congiguration */
S#define  RCC_BDCR_RTCSEL_NOCLOCK             ((uint32_t)0x00000000)        /*!< No clock */
S#define  RCC_BDCR_RTCSEL_LSE                 ((uint32_t)0x00000100)        /*!< LSE oscillator clock used as RTC clock */
S#define  RCC_BDCR_RTCSEL_LSI                 ((uint32_t)0x00000200)        /*!< LSI oscillator clock used as RTC clock */
S#define  RCC_BDCR_RTCSEL_HSE                 ((uint32_t)0x00000300)        /*!< HSE oscillator clock divided by 128 used as RTC clock */
S
S#define  RCC_BDCR_RTCEN                      ((uint32_t)0x00008000)        /*!< RTC clock enable */
S#define  RCC_BDCR_BDRST                      ((uint32_t)0x00010000)        /*!< Backup domain software reset  */
S
S/*******************  Bit definition for RCC_CSR register  ********************/  
S#define  RCC_CSR_LSION                       ((uint32_t)0x00000001)        /*!< Internal Low Speed oscillator enable */
S#define  RCC_CSR_LSIRDY                      ((uint32_t)0x00000002)        /*!< Internal Low Speed oscillator Ready */
S#define  RCC_CSR_RMVF                        ((uint32_t)0x01000000)        /*!< Remove reset flag */
S#define  RCC_CSR_PINRSTF                     ((uint32_t)0x04000000)        /*!< PIN reset flag */
S#define  RCC_CSR_PORRSTF                     ((uint32_t)0x08000000)        /*!< POR/PDR reset flag */
S#define  RCC_CSR_SFTRSTF                     ((uint32_t)0x10000000)        /*!< Software Reset flag */
S#define  RCC_CSR_IWDGRSTF                    ((uint32_t)0x20000000)        /*!< Independent Watchdog reset flag */
S#define  RCC_CSR_WWDGRSTF                    ((uint32_t)0x40000000)        /*!< Window watchdog reset flag */
S#define  RCC_CSR_LPWRRSTF                    ((uint32_t)0x80000000)        /*!< Low-Power reset flag */
S
S#ifdef STM32F10X_CL
S/*******************  Bit definition for RCC_AHBRSTR register  ****************/
S #define  RCC_AHBRSTR_OTGFSRST               ((uint32_t)0x00001000)         /*!< USB OTG FS reset */
S #define  RCC_AHBRSTR_ETHMACRST              ((uint32_t)0x00004000)         /*!< ETHERNET MAC reset */
S
S/*******************  Bit definition for RCC_CFGR2 register  ******************/
S/*!< PREDIV1 configuration */
S #define  RCC_CFGR2_PREDIV1                  ((uint32_t)0x0000000F)        /*!< PREDIV1[3:0] bits */
S #define  RCC_CFGR2_PREDIV1_0                ((uint32_t)0x00000001)        /*!< Bit 0 */
S #define  RCC_CFGR2_PREDIV1_1                ((uint32_t)0x00000002)        /*!< Bit 1 */
S #define  RCC_CFGR2_PREDIV1_2                ((uint32_t)0x00000004)        /*!< Bit 2 */
S #define  RCC_CFGR2_PREDIV1_3                ((uint32_t)0x00000008)        /*!< Bit 3 */
S
S #define  RCC_CFGR2_PREDIV1_DIV1             ((uint32_t)0x00000000)        /*!< PREDIV1 input clock not divided */
S #define  RCC_CFGR2_PREDIV1_DIV2             ((uint32_t)0x00000001)        /*!< PREDIV1 input clock divided by 2 */
S #define  RCC_CFGR2_PREDIV1_DIV3             ((uint32_t)0x00000002)        /*!< PREDIV1 input clock divided by 3 */
S #define  RCC_CFGR2_PREDIV1_DIV4             ((uint32_t)0x00000003)        /*!< PREDIV1 input clock divided by 4 */
S #define  RCC_CFGR2_PREDIV1_DIV5             ((uint32_t)0x00000004)        /*!< PREDIV1 input clock divided by 5 */
S #define  RCC_CFGR2_PREDIV1_DIV6             ((uint32_t)0x00000005)        /*!< PREDIV1 input clock divided by 6 */
S #define  RCC_CFGR2_PREDIV1_DIV7             ((uint32_t)0x00000006)        /*!< PREDIV1 input clock divided by 7 */
S #define  RCC_CFGR2_PREDIV1_DIV8             ((uint32_t)0x00000007)        /*!< PREDIV1 input clock divided by 8 */
S #define  RCC_CFGR2_PREDIV1_DIV9             ((uint32_t)0x00000008)        /*!< PREDIV1 input clock divided by 9 */
S #define  RCC_CFGR2_PREDIV1_DIV10            ((uint32_t)0x00000009)        /*!< PREDIV1 input clock divided by 10 */
S #define  RCC_CFGR2_PREDIV1_DIV11            ((uint32_t)0x0000000A)        /*!< PREDIV1 input clock divided by 11 */
S #define  RCC_CFGR2_PREDIV1_DIV12            ((uint32_t)0x0000000B)        /*!< PREDIV1 input clock divided by 12 */
S #define  RCC_CFGR2_PREDIV1_DIV13            ((uint32_t)0x0000000C)        /*!< PREDIV1 input clock divided by 13 */
S #define  RCC_CFGR2_PREDIV1_DIV14            ((uint32_t)0x0000000D)        /*!< PREDIV1 input clock divided by 14 */
S #define  RCC_CFGR2_PREDIV1_DIV15            ((uint32_t)0x0000000E)        /*!< PREDIV1 input clock divided by 15 */
S #define  RCC_CFGR2_PREDIV1_DIV16            ((uint32_t)0x0000000F)        /*!< PREDIV1 input clock divided by 16 */
S
S/*!< PREDIV2 configuration */
S #define  RCC_CFGR2_PREDIV2                  ((uint32_t)0x000000F0)        /*!< PREDIV2[3:0] bits */
S #define  RCC_CFGR2_PREDIV2_0                ((uint32_t)0x00000010)        /*!< Bit 0 */
S #define  RCC_CFGR2_PREDIV2_1                ((uint32_t)0x00000020)        /*!< Bit 1 */
S #define  RCC_CFGR2_PREDIV2_2                ((uint32_t)0x00000040)        /*!< Bit 2 */
S #define  RCC_CFGR2_PREDIV2_3                ((uint32_t)0x00000080)        /*!< Bit 3 */
S
S #define  RCC_CFGR2_PREDIV2_DIV1             ((uint32_t)0x00000000)        /*!< PREDIV2 input clock not divided */
S #define  RCC_CFGR2_PREDIV2_DIV2             ((uint32_t)0x00000010)        /*!< PREDIV2 input clock divided by 2 */
S #define  RCC_CFGR2_PREDIV2_DIV3             ((uint32_t)0x00000020)        /*!< PREDIV2 input clock divided by 3 */
S #define  RCC_CFGR2_PREDIV2_DIV4             ((uint32_t)0x00000030)        /*!< PREDIV2 input clock divided by 4 */
S #define  RCC_CFGR2_PREDIV2_DIV5             ((uint32_t)0x00000040)        /*!< PREDIV2 input clock divided by 5 */
S #define  RCC_CFGR2_PREDIV2_DIV6             ((uint32_t)0x00000050)        /*!< PREDIV2 input clock divided by 6 */
S #define  RCC_CFGR2_PREDIV2_DIV7             ((uint32_t)0x00000060)        /*!< PREDIV2 input clock divided by 7 */
S #define  RCC_CFGR2_PREDIV2_DIV8             ((uint32_t)0x00000070)        /*!< PREDIV2 input clock divided by 8 */
S #define  RCC_CFGR2_PREDIV2_DIV9             ((uint32_t)0x00000080)        /*!< PREDIV2 input clock divided by 9 */
S #define  RCC_CFGR2_PREDIV2_DIV10            ((uint32_t)0x00000090)        /*!< PREDIV2 input clock divided by 10 */
S #define  RCC_CFGR2_PREDIV2_DIV11            ((uint32_t)0x000000A0)        /*!< PREDIV2 input clock divided by 11 */
S #define  RCC_CFGR2_PREDIV2_DIV12            ((uint32_t)0x000000B0)        /*!< PREDIV2 input clock divided by 12 */
S #define  RCC_CFGR2_PREDIV2_DIV13            ((uint32_t)0x000000C0)        /*!< PREDIV2 input clock divided by 13 */
S #define  RCC_CFGR2_PREDIV2_DIV14            ((uint32_t)0x000000D0)        /*!< PREDIV2 input clock divided by 14 */
S #define  RCC_CFGR2_PREDIV2_DIV15            ((uint32_t)0x000000E0)        /*!< PREDIV2 input clock divided by 15 */
S #define  RCC_CFGR2_PREDIV2_DIV16            ((uint32_t)0x000000F0)        /*!< PREDIV2 input clock divided by 16 */
S
S/*!< PLL2MUL configuration */
S #define  RCC_CFGR2_PLL2MUL                  ((uint32_t)0x00000F00)        /*!< PLL2MUL[3:0] bits */
S #define  RCC_CFGR2_PLL2MUL_0                ((uint32_t)0x00000100)        /*!< Bit 0 */
S #define  RCC_CFGR2_PLL2MUL_1                ((uint32_t)0x00000200)        /*!< Bit 1 */
S #define  RCC_CFGR2_PLL2MUL_2                ((uint32_t)0x00000400)        /*!< Bit 2 */
S #define  RCC_CFGR2_PLL2MUL_3                ((uint32_t)0x00000800)        /*!< Bit 3 */
S
S #define  RCC_CFGR2_PLL2MUL8                 ((uint32_t)0x00000600)        /*!< PLL2 input clock * 8 */
S #define  RCC_CFGR2_PLL2MUL9                 ((uint32_t)0x00000700)        /*!< PLL2 input clock * 9 */
S #define  RCC_CFGR2_PLL2MUL10                ((uint32_t)0x00000800)        /*!< PLL2 input clock * 10 */
S #define  RCC_CFGR2_PLL2MUL11                ((uint32_t)0x00000900)        /*!< PLL2 input clock * 11 */
S #define  RCC_CFGR2_PLL2MUL12                ((uint32_t)0x00000A00)        /*!< PLL2 input clock * 12 */
S #define  RCC_CFGR2_PLL2MUL13                ((uint32_t)0x00000B00)        /*!< PLL2 input clock * 13 */
S #define  RCC_CFGR2_PLL2MUL14                ((uint32_t)0x00000C00)        /*!< PLL2 input clock * 14 */
S #define  RCC_CFGR2_PLL2MUL16                ((uint32_t)0x00000E00)        /*!< PLL2 input clock * 16 */
S #define  RCC_CFGR2_PLL2MUL20                ((uint32_t)0x00000F00)        /*!< PLL2 input clock * 20 */
S
S/*!< PLL3MUL configuration */
S #define  RCC_CFGR2_PLL3MUL                  ((uint32_t)0x0000F000)        /*!< PLL3MUL[3:0] bits */
S #define  RCC_CFGR2_PLL3MUL_0                ((uint32_t)0x00001000)        /*!< Bit 0 */
S #define  RCC_CFGR2_PLL3MUL_1                ((uint32_t)0x00002000)        /*!< Bit 1 */
S #define  RCC_CFGR2_PLL3MUL_2                ((uint32_t)0x00004000)        /*!< Bit 2 */
S #define  RCC_CFGR2_PLL3MUL_3                ((uint32_t)0x00008000)        /*!< Bit 3 */
S
S #define  RCC_CFGR2_PLL3MUL8                 ((uint32_t)0x00006000)        /*!< PLL3 input clock * 8 */
S #define  RCC_CFGR2_PLL3MUL9                 ((uint32_t)0x00007000)        /*!< PLL3 input clock * 9 */
S #define  RCC_CFGR2_PLL3MUL10                ((uint32_t)0x00008000)        /*!< PLL3 input clock * 10 */
S #define  RCC_CFGR2_PLL3MUL11                ((uint32_t)0x00009000)        /*!< PLL3 input clock * 11 */
S #define  RCC_CFGR2_PLL3MUL12                ((uint32_t)0x0000A000)        /*!< PLL3 input clock * 12 */
S #define  RCC_CFGR2_PLL3MUL13                ((uint32_t)0x0000B000)        /*!< PLL3 input clock * 13 */
S #define  RCC_CFGR2_PLL3MUL14                ((uint32_t)0x0000C000)        /*!< PLL3 input clock * 14 */
S #define  RCC_CFGR2_PLL3MUL16                ((uint32_t)0x0000E000)        /*!< PLL3 input clock * 16 */
S #define  RCC_CFGR2_PLL3MUL20                ((uint32_t)0x0000F000)        /*!< PLL3 input clock * 20 */
S
S #define  RCC_CFGR2_PREDIV1SRC               ((uint32_t)0x00010000)        /*!< PREDIV1 entry clock source */
S #define  RCC_CFGR2_PREDIV1SRC_PLL2          ((uint32_t)0x00010000)        /*!< PLL2 selected as PREDIV1 entry clock source */
S #define  RCC_CFGR2_PREDIV1SRC_HSE           ((uint32_t)0x00000000)        /*!< HSE selected as PREDIV1 entry clock source */
S #define  RCC_CFGR2_I2S2SRC                  ((uint32_t)0x00020000)        /*!< I2S2 entry clock source */
S #define  RCC_CFGR2_I2S3SRC                  ((uint32_t)0x00040000)        /*!< I2S3 clock source */
S#endif /* STM32F10X_CL */
S
S#if defined (STM32F10X_LD_VL) || defined (STM32F10X_MD_VL) || defined (STM32F10X_HD_VL)
S/*******************  Bit definition for RCC_CFGR2 register  ******************/
S/*!< PREDIV1 configuration */
S #define  RCC_CFGR2_PREDIV1                  ((uint32_t)0x0000000F)        /*!< PREDIV1[3:0] bits */
S #define  RCC_CFGR2_PREDIV1_0                ((uint32_t)0x00000001)        /*!< Bit 0 */
S #define  RCC_CFGR2_PREDIV1_1                ((uint32_t)0x00000002)        /*!< Bit 1 */
S #define  RCC_CFGR2_PREDIV1_2                ((uint32_t)0x00000004)        /*!< Bit 2 */
S #define  RCC_CFGR2_PREDIV1_3                ((uint32_t)0x00000008)        /*!< Bit 3 */
S
S #define  RCC_CFGR2_PREDIV1_DIV1             ((uint32_t)0x00000000)        /*!< PREDIV1 input clock not divided */
S #define  RCC_CFGR2_PREDIV1_DIV2             ((uint32_t)0x00000001)        /*!< PREDIV1 input clock divided by 2 */
S #define  RCC_CFGR2_PREDIV1_DIV3             ((uint32_t)0x00000002)        /*!< PREDIV1 input clock divided by 3 */
S #define  RCC_CFGR2_PREDIV1_DIV4             ((uint32_t)0x00000003)        /*!< PREDIV1 input clock divided by 4 */
S #define  RCC_CFGR2_PREDIV1_DIV5             ((uint32_t)0x00000004)        /*!< PREDIV1 input clock divided by 5 */
S #define  RCC_CFGR2_PREDIV1_DIV6             ((uint32_t)0x00000005)        /*!< PREDIV1 input clock divided by 6 */
S #define  RCC_CFGR2_PREDIV1_DIV7             ((uint32_t)0x00000006)        /*!< PREDIV1 input clock divided by 7 */
S #define  RCC_CFGR2_PREDIV1_DIV8             ((uint32_t)0x00000007)        /*!< PREDIV1 input clock divided by 8 */
S #define  RCC_CFGR2_PREDIV1_DIV9             ((uint32_t)0x00000008)        /*!< PREDIV1 input clock divided by 9 */
S #define  RCC_CFGR2_PREDIV1_DIV10            ((uint32_t)0x00000009)        /*!< PREDIV1 input clock divided by 10 */
S #define  RCC_CFGR2_PREDIV1_DIV11            ((uint32_t)0x0000000A)        /*!< PREDIV1 input clock divided by 11 */
S #define  RCC_CFGR2_PREDIV1_DIV12            ((uint32_t)0x0000000B)        /*!< PREDIV1 input clock divided by 12 */
S #define  RCC_CFGR2_PREDIV1_DIV13            ((uint32_t)0x0000000C)        /*!< PREDIV1 input clock divided by 13 */
S #define  RCC_CFGR2_PREDIV1_DIV14            ((uint32_t)0x0000000D)        /*!< PREDIV1 input clock divided by 14 */
S #define  RCC_CFGR2_PREDIV1_DIV15            ((uint32_t)0x0000000E)        /*!< PREDIV1 input clock divided by 15 */
S #define  RCC_CFGR2_PREDIV1_DIV16            ((uint32_t)0x0000000F)        /*!< PREDIV1 input clock divided by 16 */
S#endif
S 
S/******************************************************************************/
S/*                                                                            */
S/*                General Purpose and Alternate Function I/O                  */
S/*                                                                            */
S/******************************************************************************/
S
S/*******************  Bit definition for GPIO_CRL register  *******************/
S#define  GPIO_CRL_MODE                       ((uint32_t)0x33333333)        /*!< Port x mode bits */
S
S#define  GPIO_CRL_MODE0                      ((uint32_t)0x00000003)        /*!< MODE0[1:0] bits (Port x mode bits, pin 0) */
S#define  GPIO_CRL_MODE0_0                    ((uint32_t)0x00000001)        /*!< Bit 0 */
S#define  GPIO_CRL_MODE0_1                    ((uint32_t)0x00000002)        /*!< Bit 1 */
S
S#define  GPIO_CRL_MODE1                      ((uint32_t)0x00000030)        /*!< MODE1[1:0] bits (Port x mode bits, pin 1) */
S#define  GPIO_CRL_MODE1_0                    ((uint32_t)0x00000010)        /*!< Bit 0 */
S#define  GPIO_CRL_MODE1_1                    ((uint32_t)0x00000020)        /*!< Bit 1 */
S
S#define  GPIO_CRL_MODE2                      ((uint32_t)0x00000300)        /*!< MODE2[1:0] bits (Port x mode bits, pin 2) */
S#define  GPIO_CRL_MODE2_0                    ((uint32_t)0x00000100)        /*!< Bit 0 */
S#define  GPIO_CRL_MODE2_1                    ((uint32_t)0x00000200)        /*!< Bit 1 */
S
S#define  GPIO_CRL_MODE3                      ((uint32_t)0x00003000)        /*!< MODE3[1:0] bits (Port x mode bits, pin 3) */
S#define  GPIO_CRL_MODE3_0                    ((uint32_t)0x00001000)        /*!< Bit 0 */
S#define  GPIO_CRL_MODE3_1                    ((uint32_t)0x00002000)        /*!< Bit 1 */
S
S#define  GPIO_CRL_MODE4                      ((uint32_t)0x00030000)        /*!< MODE4[1:0] bits (Port x mode bits, pin 4) */
S#define  GPIO_CRL_MODE4_0                    ((uint32_t)0x00010000)        /*!< Bit 0 */
S#define  GPIO_CRL_MODE4_1                    ((uint32_t)0x00020000)        /*!< Bit 1 */
S
S#define  GPIO_CRL_MODE5                      ((uint32_t)0x00300000)        /*!< MODE5[1:0] bits (Port x mode bits, pin 5) */
S#define  GPIO_CRL_MODE5_0                    ((uint32_t)0x00100000)        /*!< Bit 0 */
S#define  GPIO_CRL_MODE5_1                    ((uint32_t)0x00200000)        /*!< Bit 1 */
S
S#define  GPIO_CRL_MODE6                      ((uint32_t)0x03000000)        /*!< MODE6[1:0] bits (Port x mode bits, pin 6) */
S#define  GPIO_CRL_MODE6_0                    ((uint32_t)0x01000000)        /*!< Bit 0 */
S#define  GPIO_CRL_MODE6_1                    ((uint32_t)0x02000000)        /*!< Bit 1 */
S
S#define  GPIO_CRL_MODE7                      ((uint32_t)0x30000000)        /*!< MODE7[1:0] bits (Port x mode bits, pin 7) */
S#define  GPIO_CRL_MODE7_0                    ((uint32_t)0x10000000)        /*!< Bit 0 */
S#define  GPIO_CRL_MODE7_1                    ((uint32_t)0x20000000)        /*!< Bit 1 */
S
S#define  GPIO_CRL_CNF                        ((uint32_t)0xCCCCCCCC)        /*!< Port x configuration bits */
S
S#define  GPIO_CRL_CNF0                       ((uint32_t)0x0000000C)        /*!< CNF0[1:0] bits (Port x configuration bits, pin 0) */
S#define  GPIO_CRL_CNF0_0                     ((uint32_t)0x00000004)        /*!< Bit 0 */
S#define  GPIO_CRL_CNF0_1                     ((uint32_t)0x00000008)        /*!< Bit 1 */
S
S#define  GPIO_CRL_CNF1                       ((uint32_t)0x000000C0)        /*!< CNF1[1:0] bits (Port x configuration bits, pin 1) */
S#define  GPIO_CRL_CNF1_0                     ((uint32_t)0x00000040)        /*!< Bit 0 */
S#define  GPIO_CRL_CNF1_1                     ((uint32_t)0x00000080)        /*!< Bit 1 */
S
S#define  GPIO_CRL_CNF2                       ((uint32_t)0x00000C00)        /*!< CNF2[1:0] bits (Port x configuration bits, pin 2) */
S#define  GPIO_CRL_CNF2_0                     ((uint32_t)0x00000400)        /*!< Bit 0 */
S#define  GPIO_CRL_CNF2_1                     ((uint32_t)0x00000800)        /*!< Bit 1 */
S
S#define  GPIO_CRL_CNF3                       ((uint32_t)0x0000C000)        /*!< CNF3[1:0] bits (Port x configuration bits, pin 3) */
S#define  GPIO_CRL_CNF3_0                     ((uint32_t)0x00004000)        /*!< Bit 0 */
S#define  GPIO_CRL_CNF3_1                     ((uint32_t)0x00008000)        /*!< Bit 1 */
S
S#define  GPIO_CRL_CNF4                       ((uint32_t)0x000C0000)        /*!< CNF4[1:0] bits (Port x configuration bits, pin 4) */
S#define  GPIO_CRL_CNF4_0                     ((uint32_t)0x00040000)        /*!< Bit 0 */
S#define  GPIO_CRL_CNF4_1                     ((uint32_t)0x00080000)        /*!< Bit 1 */
S
S#define  GPIO_CRL_CNF5                       ((uint32_t)0x00C00000)        /*!< CNF5[1:0] bits (Port x configuration bits, pin 5) */
S#define  GPIO_CRL_CNF5_0                     ((uint32_t)0x00400000)        /*!< Bit 0 */
S#define  GPIO_CRL_CNF5_1                     ((uint32_t)0x00800000)        /*!< Bit 1 */
S
S#define  GPIO_CRL_CNF6                       ((uint32_t)0x0C000000)        /*!< CNF6[1:0] bits (Port x configuration bits, pin 6) */
S#define  GPIO_CRL_CNF6_0                     ((uint32_t)0x04000000)        /*!< Bit 0 */
S#define  GPIO_CRL_CNF6_1                     ((uint32_t)0x08000000)        /*!< Bit 1 */
S
S#define  GPIO_CRL_CNF7                       ((uint32_t)0xC0000000)        /*!< CNF7[1:0] bits (Port x configuration bits, pin 7) */
S#define  GPIO_CRL_CNF7_0                     ((uint32_t)0x40000000)        /*!< Bit 0 */
S#define  GPIO_CRL_CNF7_1                     ((uint32_t)0x80000000)        /*!< Bit 1 */
S
S/*******************  Bit definition for GPIO_CRH register  *******************/
S#define  GPIO_CRH_MODE                       ((uint32_t)0x33333333)        /*!< Port x mode bits */
S
S#define  GPIO_CRH_MODE8                      ((uint32_t)0x00000003)        /*!< MODE8[1:0] bits (Port x mode bits, pin 8) */
S#define  GPIO_CRH_MODE8_0                    ((uint32_t)0x00000001)        /*!< Bit 0 */
S#define  GPIO_CRH_MODE8_1                    ((uint32_t)0x00000002)        /*!< Bit 1 */
S
S#define  GPIO_CRH_MODE9                      ((uint32_t)0x00000030)        /*!< MODE9[1:0] bits (Port x mode bits, pin 9) */
S#define  GPIO_CRH_MODE9_0                    ((uint32_t)0x00000010)        /*!< Bit 0 */
S#define  GPIO_CRH_MODE9_1                    ((uint32_t)0x00000020)        /*!< Bit 1 */
S
S#define  GPIO_CRH_MODE10                     ((uint32_t)0x00000300)        /*!< MODE10[1:0] bits (Port x mode bits, pin 10) */
S#define  GPIO_CRH_MODE10_0                   ((uint32_t)0x00000100)        /*!< Bit 0 */
S#define  GPIO_CRH_MODE10_1                   ((uint32_t)0x00000200)        /*!< Bit 1 */
S
S#define  GPIO_CRH_MODE11                     ((uint32_t)0x00003000)        /*!< MODE11[1:0] bits (Port x mode bits, pin 11) */
S#define  GPIO_CRH_MODE11_0                   ((uint32_t)0x00001000)        /*!< Bit 0 */
S#define  GPIO_CRH_MODE11_1                   ((uint32_t)0x00002000)        /*!< Bit 1 */
S
S#define  GPIO_CRH_MODE12                     ((uint32_t)0x00030000)        /*!< MODE12[1:0] bits (Port x mode bits, pin 12) */
S#define  GPIO_CRH_MODE12_0                   ((uint32_t)0x00010000)        /*!< Bit 0 */
S#define  GPIO_CRH_MODE12_1                   ((uint32_t)0x00020000)        /*!< Bit 1 */
S
S#define  GPIO_CRH_MODE13                     ((uint32_t)0x00300000)        /*!< MODE13[1:0] bits (Port x mode bits, pin 13) */
S#define  GPIO_CRH_MODE13_0                   ((uint32_t)0x00100000)        /*!< Bit 0 */
S#define  GPIO_CRH_MODE13_1                   ((uint32_t)0x00200000)        /*!< Bit 1 */
S
S#define  GPIO_CRH_MODE14                     ((uint32_t)0x03000000)        /*!< MODE14[1:0] bits (Port x mode bits, pin 14) */
S#define  GPIO_CRH_MODE14_0                   ((uint32_t)0x01000000)        /*!< Bit 0 */
S#define  GPIO_CRH_MODE14_1                   ((uint32_t)0x02000000)        /*!< Bit 1 */
S
S#define  GPIO_CRH_MODE15                     ((uint32_t)0x30000000)        /*!< MODE15[1:0] bits (Port x mode bits, pin 15) */
S#define  GPIO_CRH_MODE15_0                   ((uint32_t)0x10000000)        /*!< Bit 0 */
S#define  GPIO_CRH_MODE15_1                   ((uint32_t)0x20000000)        /*!< Bit 1 */
S
S#define  GPIO_CRH_CNF                        ((uint32_t)0xCCCCCCCC)        /*!< Port x configuration bits */
S
S#define  GPIO_CRH_CNF8                       ((uint32_t)0x0000000C)        /*!< CNF8[1:0] bits (Port x configuration bits, pin 8) */
S#define  GPIO_CRH_CNF8_0                     ((uint32_t)0x00000004)        /*!< Bit 0 */
S#define  GPIO_CRH_CNF8_1                     ((uint32_t)0x00000008)        /*!< Bit 1 */
S
S#define  GPIO_CRH_CNF9                       ((uint32_t)0x000000C0)        /*!< CNF9[1:0] bits (Port x configuration bits, pin 9) */
S#define  GPIO_CRH_CNF9_0                     ((uint32_t)0x00000040)        /*!< Bit 0 */
S#define  GPIO_CRH_CNF9_1                     ((uint32_t)0x00000080)        /*!< Bit 1 */
S
S#define  GPIO_CRH_CNF10                      ((uint32_t)0x00000C00)        /*!< CNF10[1:0] bits (Port x configuration bits, pin 10) */
S#define  GPIO_CRH_CNF10_0                    ((uint32_t)0x00000400)        /*!< Bit 0 */
S#define  GPIO_CRH_CNF10_1                    ((uint32_t)0x00000800)        /*!< Bit 1 */
S
S#define  GPIO_CRH_CNF11                      ((uint32_t)0x0000C000)        /*!< CNF11[1:0] bits (Port x configuration bits, pin 11) */
S#define  GPIO_CRH_CNF11_0                    ((uint32_t)0x00004000)        /*!< Bit 0 */
S#define  GPIO_CRH_CNF11_1                    ((uint32_t)0x00008000)        /*!< Bit 1 */
S
S#define  GPIO_CRH_CNF12                      ((uint32_t)0x000C0000)        /*!< CNF12[1:0] bits (Port x configuration bits, pin 12) */
S#define  GPIO_CRH_CNF12_0                    ((uint32_t)0x00040000)        /*!< Bit 0 */
S#define  GPIO_CRH_CNF12_1                    ((uint32_t)0x00080000)        /*!< Bit 1 */
S
S#define  GPIO_CRH_CNF13                      ((uint32_t)0x00C00000)        /*!< CNF13[1:0] bits (Port x configuration bits, pin 13) */
S#define  GPIO_CRH_CNF13_0                    ((uint32_t)0x00400000)        /*!< Bit 0 */
S#define  GPIO_CRH_CNF13_1                    ((uint32_t)0x00800000)        /*!< Bit 1 */
S
S#define  GPIO_CRH_CNF14                      ((uint32_t)0x0C000000)        /*!< CNF14[1:0] bits (Port x configuration bits, pin 14) */
S#define  GPIO_CRH_CNF14_0                    ((uint32_t)0x04000000)        /*!< Bit 0 */
S#define  GPIO_CRH_CNF14_1                    ((uint32_t)0x08000000)        /*!< Bit 1 */
S
S#define  GPIO_CRH_CNF15                      ((uint32_t)0xC0000000)        /*!< CNF15[1:0] bits (Port x configuration bits, pin 15) */
S#define  GPIO_CRH_CNF15_0                    ((uint32_t)0x40000000)        /*!< Bit 0 */
S#define  GPIO_CRH_CNF15_1                    ((uint32_t)0x80000000)        /*!< Bit 1 */
S
S/*!<******************  Bit definition for GPIO_IDR register  *******************/
S#define GPIO_IDR_IDR0                        ((uint16_t)0x0001)            /*!< Port input data, bit 0 */
S#define GPIO_IDR_IDR1                        ((uint16_t)0x0002)            /*!< Port input data, bit 1 */
S#define GPIO_IDR_IDR2                        ((uint16_t)0x0004)            /*!< Port input data, bit 2 */
S#define GPIO_IDR_IDR3                        ((uint16_t)0x0008)            /*!< Port input data, bit 3 */
S#define GPIO_IDR_IDR4                        ((uint16_t)0x0010)            /*!< Port input data, bit 4 */
S#define GPIO_IDR_IDR5                        ((uint16_t)0x0020)            /*!< Port input data, bit 5 */
S#define GPIO_IDR_IDR6                        ((uint16_t)0x0040)            /*!< Port input data, bit 6 */
S#define GPIO_IDR_IDR7                        ((uint16_t)0x0080)            /*!< Port input data, bit 7 */
S#define GPIO_IDR_IDR8                        ((uint16_t)0x0100)            /*!< Port input data, bit 8 */
S#define GPIO_IDR_IDR9                        ((uint16_t)0x0200)            /*!< Port input data, bit 9 */
S#define GPIO_IDR_IDR10                       ((uint16_t)0x0400)            /*!< Port input data, bit 10 */
S#define GPIO_IDR_IDR11                       ((uint16_t)0x0800)            /*!< Port input data, bit 11 */
S#define GPIO_IDR_IDR12                       ((uint16_t)0x1000)            /*!< Port input data, bit 12 */
S#define GPIO_IDR_IDR13                       ((uint16_t)0x2000)            /*!< Port input data, bit 13 */
S#define GPIO_IDR_IDR14                       ((uint16_t)0x4000)            /*!< Port input data, bit 14 */
S#define GPIO_IDR_IDR15                       ((uint16_t)0x8000)            /*!< Port input data, bit 15 */
S
S/*******************  Bit definition for GPIO_ODR register  *******************/
S#define GPIO_ODR_ODR0                        ((uint16_t)0x0001)            /*!< Port output data, bit 0 */
S#define GPIO_ODR_ODR1                        ((uint16_t)0x0002)            /*!< Port output data, bit 1 */
S#define GPIO_ODR_ODR2                        ((uint16_t)0x0004)            /*!< Port output data, bit 2 */
S#define GPIO_ODR_ODR3                        ((uint16_t)0x0008)            /*!< Port output data, bit 3 */
S#define GPIO_ODR_ODR4                        ((uint16_t)0x0010)            /*!< Port output data, bit 4 */
S#define GPIO_ODR_ODR5                        ((uint16_t)0x0020)            /*!< Port output data, bit 5 */
S#define GPIO_ODR_ODR6                        ((uint16_t)0x0040)            /*!< Port output data, bit 6 */
S#define GPIO_ODR_ODR7                        ((uint16_t)0x0080)            /*!< Port output data, bit 7 */
S#define GPIO_ODR_ODR8                        ((uint16_t)0x0100)            /*!< Port output data, bit 8 */
S#define GPIO_ODR_ODR9                        ((uint16_t)0x0200)            /*!< Port output data, bit 9 */
S#define GPIO_ODR_ODR10                       ((uint16_t)0x0400)            /*!< Port output data, bit 10 */
S#define GPIO_ODR_ODR11                       ((uint16_t)0x0800)            /*!< Port output data, bit 11 */
S#define GPIO_ODR_ODR12                       ((uint16_t)0x1000)            /*!< Port output data, bit 12 */
S#define GPIO_ODR_ODR13                       ((uint16_t)0x2000)            /*!< Port output data, bit 13 */
S#define GPIO_ODR_ODR14                       ((uint16_t)0x4000)            /*!< Port output data, bit 14 */
S#define GPIO_ODR_ODR15                       ((uint16_t)0x8000)            /*!< Port output data, bit 15 */
S
S/******************  Bit definition for GPIO_BSRR register  *******************/
S#define GPIO_BSRR_BS0                        ((uint32_t)0x00000001)        /*!< Port x Set bit 0 */
S#define GPIO_BSRR_BS1                        ((uint32_t)0x00000002)        /*!< Port x Set bit 1 */
S#define GPIO_BSRR_BS2                        ((uint32_t)0x00000004)        /*!< Port x Set bit 2 */
S#define GPIO_BSRR_BS3                        ((uint32_t)0x00000008)        /*!< Port x Set bit 3 */
S#define GPIO_BSRR_BS4                        ((uint32_t)0x00000010)        /*!< Port x Set bit 4 */
S#define GPIO_BSRR_BS5                        ((uint32_t)0x00000020)        /*!< Port x Set bit 5 */
S#define GPIO_BSRR_BS6                        ((uint32_t)0x00000040)        /*!< Port x Set bit 6 */
S#define GPIO_BSRR_BS7                        ((uint32_t)0x00000080)        /*!< Port x Set bit 7 */
S#define GPIO_BSRR_BS8                        ((uint32_t)0x00000100)        /*!< Port x Set bit 8 */
S#define GPIO_BSRR_BS9                        ((uint32_t)0x00000200)        /*!< Port x Set bit 9 */
S#define GPIO_BSRR_BS10                       ((uint32_t)0x00000400)        /*!< Port x Set bit 10 */
S#define GPIO_BSRR_BS11                       ((uint32_t)0x00000800)        /*!< Port x Set bit 11 */
S#define GPIO_BSRR_BS12                       ((uint32_t)0x00001000)        /*!< Port x Set bit 12 */
S#define GPIO_BSRR_BS13                       ((uint32_t)0x00002000)        /*!< Port x Set bit 13 */
S#define GPIO_BSRR_BS14                       ((uint32_t)0x00004000)        /*!< Port x Set bit 14 */
S#define GPIO_BSRR_BS15                       ((uint32_t)0x00008000)        /*!< Port x Set bit 15 */
S
S#define GPIO_BSRR_BR0                        ((uint32_t)0x00010000)        /*!< Port x Reset bit 0 */
S#define GPIO_BSRR_BR1                        ((uint32_t)0x00020000)        /*!< Port x Reset bit 1 */
S#define GPIO_BSRR_BR2                        ((uint32_t)0x00040000)        /*!< Port x Reset bit 2 */
S#define GPIO_BSRR_BR3                        ((uint32_t)0x00080000)        /*!< Port x Reset bit 3 */
S#define GPIO_BSRR_BR4                        ((uint32_t)0x00100000)        /*!< Port x Reset bit 4 */
S#define GPIO_BSRR_BR5                        ((uint32_t)0x00200000)        /*!< Port x Reset bit 5 */
S#define GPIO_BSRR_BR6                        ((uint32_t)0x00400000)        /*!< Port x Reset bit 6 */
S#define GPIO_BSRR_BR7                        ((uint32_t)0x00800000)        /*!< Port x Reset bit 7 */
S#define GPIO_BSRR_BR8                        ((uint32_t)0x01000000)        /*!< Port x Reset bit 8 */
S#define GPIO_BSRR_BR9                        ((uint32_t)0x02000000)        /*!< Port x Reset bit 9 */
S#define GPIO_BSRR_BR10                       ((uint32_t)0x04000000)        /*!< Port x Reset bit 10 */
S#define GPIO_BSRR_BR11                       ((uint32_t)0x08000000)        /*!< Port x Reset bit 11 */
S#define GPIO_BSRR_BR12                       ((uint32_t)0x10000000)        /*!< Port x Reset bit 12 */
S#define GPIO_BSRR_BR13                       ((uint32_t)0x20000000)        /*!< Port x Reset bit 13 */
S#define GPIO_BSRR_BR14                       ((uint32_t)0x40000000)        /*!< Port x Reset bit 14 */
S#define GPIO_BSRR_BR15                       ((uint32_t)0x80000000)        /*!< Port x Reset bit 15 */
S
S/*******************  Bit definition for GPIO_BRR register  *******************/
S#define GPIO_BRR_BR0                         ((uint16_t)0x0001)            /*!< Port x Reset bit 0 */
S#define GPIO_BRR_BR1                         ((uint16_t)0x0002)            /*!< Port x Reset bit 1 */
S#define GPIO_BRR_BR2                         ((uint16_t)0x0004)            /*!< Port x Reset bit 2 */
S#define GPIO_BRR_BR3                         ((uint16_t)0x0008)            /*!< Port x Reset bit 3 */
S#define GPIO_BRR_BR4                         ((uint16_t)0x0010)            /*!< Port x Reset bit 4 */
S#define GPIO_BRR_BR5                         ((uint16_t)0x0020)            /*!< Port x Reset bit 5 */
S#define GPIO_BRR_BR6                         ((uint16_t)0x0040)            /*!< Port x Reset bit 6 */
S#define GPIO_BRR_BR7                         ((uint16_t)0x0080)            /*!< Port x Reset bit 7 */
S#define GPIO_BRR_BR8                         ((uint16_t)0x0100)            /*!< Port x Reset bit 8 */
S#define GPIO_BRR_BR9                         ((uint16_t)0x0200)            /*!< Port x Reset bit 9 */
S#define GPIO_BRR_BR10                        ((uint16_t)0x0400)            /*!< Port x Reset bit 10 */
S#define GPIO_BRR_BR11                        ((uint16_t)0x0800)            /*!< Port x Reset bit 11 */
S#define GPIO_BRR_BR12                        ((uint16_t)0x1000)            /*!< Port x Reset bit 12 */
S#define GPIO_BRR_BR13                        ((uint16_t)0x2000)            /*!< Port x Reset bit 13 */
S#define GPIO_BRR_BR14                        ((uint16_t)0x4000)            /*!< Port x Reset bit 14 */
S#define GPIO_BRR_BR15                        ((uint16_t)0x8000)            /*!< Port x Reset bit 15 */
S
S/******************  Bit definition for GPIO_LCKR register  *******************/
S#define GPIO_LCKR_LCK0                       ((uint32_t)0x00000001)        /*!< Port x Lock bit 0 */
S#define GPIO_LCKR_LCK1                       ((uint32_t)0x00000002)        /*!< Port x Lock bit 1 */
S#define GPIO_LCKR_LCK2                       ((uint32_t)0x00000004)        /*!< Port x Lock bit 2 */
S#define GPIO_LCKR_LCK3                       ((uint32_t)0x00000008)        /*!< Port x Lock bit 3 */
S#define GPIO_LCKR_LCK4                       ((uint32_t)0x00000010)        /*!< Port x Lock bit 4 */
S#define GPIO_LCKR_LCK5                       ((uint32_t)0x00000020)        /*!< Port x Lock bit 5 */
S#define GPIO_LCKR_LCK6                       ((uint32_t)0x00000040)        /*!< Port x Lock bit 6 */
S#define GPIO_LCKR_LCK7                       ((uint32_t)0x00000080)        /*!< Port x Lock bit 7 */
S#define GPIO_LCKR_LCK8                       ((uint32_t)0x00000100)        /*!< Port x Lock bit 8 */
S#define GPIO_LCKR_LCK9                       ((uint32_t)0x00000200)        /*!< Port x Lock bit 9 */
S#define GPIO_LCKR_LCK10                      ((uint32_t)0x00000400)        /*!< Port x Lock bit 10 */
S#define GPIO_LCKR_LCK11                      ((uint32_t)0x00000800)        /*!< Port x Lock bit 11 */
S#define GPIO_LCKR_LCK12                      ((uint32_t)0x00001000)        /*!< Port x Lock bit 12 */
S#define GPIO_LCKR_LCK13                      ((uint32_t)0x00002000)        /*!< Port x Lock bit 13 */
S#define GPIO_LCKR_LCK14                      ((uint32_t)0x00004000)        /*!< Port x Lock bit 14 */
S#define GPIO_LCKR_LCK15                      ((uint32_t)0x00008000)        /*!< Port x Lock bit 15 */
S#define GPIO_LCKR_LCKK                       ((uint32_t)0x00010000)        /*!< Lock key */
S
S/*----------------------------------------------------------------------------*/
S
S/******************  Bit definition for AFIO_EVCR register  *******************/
S#define AFIO_EVCR_PIN                        ((uint8_t)0x0F)               /*!< PIN[3:0] bits (Pin selection) */
S#define AFIO_EVCR_PIN_0                      ((uint8_t)0x01)               /*!< Bit 0 */
S#define AFIO_EVCR_PIN_1                      ((uint8_t)0x02)               /*!< Bit 1 */
S#define AFIO_EVCR_PIN_2                      ((uint8_t)0x04)               /*!< Bit 2 */
S#define AFIO_EVCR_PIN_3                      ((uint8_t)0x08)               /*!< Bit 3 */
S
S/*!< PIN configuration */
S#define AFIO_EVCR_PIN_PX0                    ((uint8_t)0x00)               /*!< Pin 0 selected */
S#define AFIO_EVCR_PIN_PX1                    ((uint8_t)0x01)               /*!< Pin 1 selected */
S#define AFIO_EVCR_PIN_PX2                    ((uint8_t)0x02)               /*!< Pin 2 selected */
S#define AFIO_EVCR_PIN_PX3                    ((uint8_t)0x03)               /*!< Pin 3 selected */
S#define AFIO_EVCR_PIN_PX4                    ((uint8_t)0x04)               /*!< Pin 4 selected */
S#define AFIO_EVCR_PIN_PX5                    ((uint8_t)0x05)               /*!< Pin 5 selected */
S#define AFIO_EVCR_PIN_PX6                    ((uint8_t)0x06)               /*!< Pin 6 selected */
S#define AFIO_EVCR_PIN_PX7                    ((uint8_t)0x07)               /*!< Pin 7 selected */
S#define AFIO_EVCR_PIN_PX8                    ((uint8_t)0x08)               /*!< Pin 8 selected */
S#define AFIO_EVCR_PIN_PX9                    ((uint8_t)0x09)               /*!< Pin 9 selected */
S#define AFIO_EVCR_PIN_PX10                   ((uint8_t)0x0A)               /*!< Pin 10 selected */
S#define AFIO_EVCR_PIN_PX11                   ((uint8_t)0x0B)               /*!< Pin 11 selected */
S#define AFIO_EVCR_PIN_PX12                   ((uint8_t)0x0C)               /*!< Pin 12 selected */
S#define AFIO_EVCR_PIN_PX13                   ((uint8_t)0x0D)               /*!< Pin 13 selected */
S#define AFIO_EVCR_PIN_PX14                   ((uint8_t)0x0E)               /*!< Pin 14 selected */
S#define AFIO_EVCR_PIN_PX15                   ((uint8_t)0x0F)               /*!< Pin 15 selected */
S
S#define AFIO_EVCR_PORT                       ((uint8_t)0x70)               /*!< PORT[2:0] bits (Port selection) */
S#define AFIO_EVCR_PORT_0                     ((uint8_t)0x10)               /*!< Bit 0 */
S#define AFIO_EVCR_PORT_1                     ((uint8_t)0x20)               /*!< Bit 1 */
S#define AFIO_EVCR_PORT_2                     ((uint8_t)0x40)               /*!< Bit 2 */
S
S/*!< PORT configuration */
S#define AFIO_EVCR_PORT_PA                    ((uint8_t)0x00)               /*!< Port A selected */
S#define AFIO_EVCR_PORT_PB                    ((uint8_t)0x10)               /*!< Port B selected */
S#define AFIO_EVCR_PORT_PC                    ((uint8_t)0x20)               /*!< Port C selected */
S#define AFIO_EVCR_PORT_PD                    ((uint8_t)0x30)               /*!< Port D selected */
S#define AFIO_EVCR_PORT_PE                    ((uint8_t)0x40)               /*!< Port E selected */
S
S#define AFIO_EVCR_EVOE                       ((uint8_t)0x80)               /*!< Event Output Enable */
S
S/******************  Bit definition for AFIO_MAPR register  *******************/
S#define AFIO_MAPR_SPI1_REMAP                 ((uint32_t)0x00000001)        /*!< SPI1 remapping */
S#define AFIO_MAPR_I2C1_REMAP                 ((uint32_t)0x00000002)        /*!< I2C1 remapping */
S#define AFIO_MAPR_USART1_REMAP               ((uint32_t)0x00000004)        /*!< USART1 remapping */
S#define AFIO_MAPR_USART2_REMAP               ((uint32_t)0x00000008)        /*!< USART2 remapping */
S
S#define AFIO_MAPR_USART3_REMAP               ((uint32_t)0x00000030)        /*!< USART3_REMAP[1:0] bits (USART3 remapping) */
S#define AFIO_MAPR_USART3_REMAP_0             ((uint32_t)0x00000010)        /*!< Bit 0 */
S#define AFIO_MAPR_USART3_REMAP_1             ((uint32_t)0x00000020)        /*!< Bit 1 */
S
S/* USART3_REMAP configuration */
S#define AFIO_MAPR_USART3_REMAP_NOREMAP       ((uint32_t)0x00000000)        /*!< No remap (TX/PB10, RX/PB11, CK/PB12, CTS/PB13, RTS/PB14) */
S#define AFIO_MAPR_USART3_REMAP_PARTIALREMAP  ((uint32_t)0x00000010)        /*!< Partial remap (TX/PC10, RX/PC11, CK/PC12, CTS/PB13, RTS/PB14) */
S#define AFIO_MAPR_USART3_REMAP_FULLREMAP     ((uint32_t)0x00000030)        /*!< Full remap (TX/PD8, RX/PD9, CK/PD10, CTS/PD11, RTS/PD12) */
S
S#define AFIO_MAPR_TIM1_REMAP                 ((uint32_t)0x000000C0)        /*!< TIM1_REMAP[1:0] bits (TIM1 remapping) */
S#define AFIO_MAPR_TIM1_REMAP_0               ((uint32_t)0x00000040)        /*!< Bit 0 */
S#define AFIO_MAPR_TIM1_REMAP_1               ((uint32_t)0x00000080)        /*!< Bit 1 */
S
S/*!< TIM1_REMAP configuration */
S#define AFIO_MAPR_TIM1_REMAP_NOREMAP         ((uint32_t)0x00000000)        /*!< No remap (ETR/PA12, CH1/PA8, CH2/PA9, CH3/PA10, CH4/PA11, BKIN/PB12, CH1N/PB13, CH2N/PB14, CH3N/PB15) */
S#define AFIO_MAPR_TIM1_REMAP_PARTIALREMAP    ((uint32_t)0x00000040)        /*!< Partial remap (ETR/PA12, CH1/PA8, CH2/PA9, CH3/PA10, CH4/PA11, BKIN/PA6, CH1N/PA7, CH2N/PB0, CH3N/PB1) */
S#define AFIO_MAPR_TIM1_REMAP_FULLREMAP       ((uint32_t)0x000000C0)        /*!< Full remap (ETR/PE7, CH1/PE9, CH2/PE11, CH3/PE13, CH4/PE14, BKIN/PE15, CH1N/PE8, CH2N/PE10, CH3N/PE12) */
S
S#define AFIO_MAPR_TIM2_REMAP                 ((uint32_t)0x00000300)        /*!< TIM2_REMAP[1:0] bits (TIM2 remapping) */
S#define AFIO_MAPR_TIM2_REMAP_0               ((uint32_t)0x00000100)        /*!< Bit 0 */
S#define AFIO_MAPR_TIM2_REMAP_1               ((uint32_t)0x00000200)        /*!< Bit 1 */
S
S/*!< TIM2_REMAP configuration */
S#define AFIO_MAPR_TIM2_REMAP_NOREMAP         ((uint32_t)0x00000000)        /*!< No remap (CH1/ETR/PA0, CH2/PA1, CH3/PA2, CH4/PA3) */
S#define AFIO_MAPR_TIM2_REMAP_PARTIALREMAP1   ((uint32_t)0x00000100)        /*!< Partial remap (CH1/ETR/PA15, CH2/PB3, CH3/PA2, CH4/PA3) */
S#define AFIO_MAPR_TIM2_REMAP_PARTIALREMAP2   ((uint32_t)0x00000200)        /*!< Partial remap (CH1/ETR/PA0, CH2/PA1, CH3/PB10, CH4/PB11) */
S#define AFIO_MAPR_TIM2_REMAP_FULLREMAP       ((uint32_t)0x00000300)        /*!< Full remap (CH1/ETR/PA15, CH2/PB3, CH3/PB10, CH4/PB11) */
S
S#define AFIO_MAPR_TIM3_REMAP                 ((uint32_t)0x00000C00)        /*!< TIM3_REMAP[1:0] bits (TIM3 remapping) */
S#define AFIO_MAPR_TIM3_REMAP_0               ((uint32_t)0x00000400)        /*!< Bit 0 */
S#define AFIO_MAPR_TIM3_REMAP_1               ((uint32_t)0x00000800)        /*!< Bit 1 */
S
S/*!< TIM3_REMAP configuration */
S#define AFIO_MAPR_TIM3_REMAP_NOREMAP         ((uint32_t)0x00000000)        /*!< No remap (CH1/PA6, CH2/PA7, CH3/PB0, CH4/PB1) */
S#define AFIO_MAPR_TIM3_REMAP_PARTIALREMAP    ((uint32_t)0x00000800)        /*!< Partial remap (CH1/PB4, CH2/PB5, CH3/PB0, CH4/PB1) */
S#define AFIO_MAPR_TIM3_REMAP_FULLREMAP       ((uint32_t)0x00000C00)        /*!< Full remap (CH1/PC6, CH2/PC7, CH3/PC8, CH4/PC9) */
S
S#define AFIO_MAPR_TIM4_REMAP                 ((uint32_t)0x00001000)        /*!< TIM4_REMAP bit (TIM4 remapping) */
S
S#define AFIO_MAPR_CAN_REMAP                  ((uint32_t)0x00006000)        /*!< CAN_REMAP[1:0] bits (CAN Alternate function remapping) */
S#define AFIO_MAPR_CAN_REMAP_0                ((uint32_t)0x00002000)        /*!< Bit 0 */
S#define AFIO_MAPR_CAN_REMAP_1                ((uint32_t)0x00004000)        /*!< Bit 1 */
S
S/*!< CAN_REMAP configuration */
S#define AFIO_MAPR_CAN_REMAP_REMAP1           ((uint32_t)0x00000000)        /*!< CANRX mapped to PA11, CANTX mapped to PA12 */
S#define AFIO_MAPR_CAN_REMAP_REMAP2           ((uint32_t)0x00004000)        /*!< CANRX mapped to PB8, CANTX mapped to PB9 */
S#define AFIO_MAPR_CAN_REMAP_REMAP3           ((uint32_t)0x00006000)        /*!< CANRX mapped to PD0, CANTX mapped to PD1 */
S
S#define AFIO_MAPR_PD01_REMAP                 ((uint32_t)0x00008000)        /*!< Port D0/Port D1 mapping on OSC_IN/OSC_OUT */
S#define AFIO_MAPR_TIM5CH4_IREMAP             ((uint32_t)0x00010000)        /*!< TIM5 Channel4 Internal Remap */
S#define AFIO_MAPR_ADC1_ETRGINJ_REMAP         ((uint32_t)0x00020000)        /*!< ADC 1 External Trigger Injected Conversion remapping */
S#define AFIO_MAPR_ADC1_ETRGREG_REMAP         ((uint32_t)0x00040000)        /*!< ADC 1 External Trigger Regular Conversion remapping */
S#define AFIO_MAPR_ADC2_ETRGINJ_REMAP         ((uint32_t)0x00080000)        /*!< ADC 2 External Trigger Injected Conversion remapping */
S#define AFIO_MAPR_ADC2_ETRGREG_REMAP         ((uint32_t)0x00100000)        /*!< ADC 2 External Trigger Regular Conversion remapping */
S
S/*!< SWJ_CFG configuration */
S#define AFIO_MAPR_SWJ_CFG                    ((uint32_t)0x07000000)        /*!< SWJ_CFG[2:0] bits (Serial Wire JTAG configuration) */
S#define AFIO_MAPR_SWJ_CFG_0                  ((uint32_t)0x01000000)        /*!< Bit 0 */
S#define AFIO_MAPR_SWJ_CFG_1                  ((uint32_t)0x02000000)        /*!< Bit 1 */
S#define AFIO_MAPR_SWJ_CFG_2                  ((uint32_t)0x04000000)        /*!< Bit 2 */
S
S#define AFIO_MAPR_SWJ_CFG_RESET              ((uint32_t)0x00000000)        /*!< Full SWJ (JTAG-DP + SW-DP) : Reset State */
S#define AFIO_MAPR_SWJ_CFG_NOJNTRST           ((uint32_t)0x01000000)        /*!< Full SWJ (JTAG-DP + SW-DP) but without JNTRST */
S#define AFIO_MAPR_SWJ_CFG_JTAGDISABLE        ((uint32_t)0x02000000)        /*!< JTAG-DP Disabled and SW-DP Enabled */
S#define AFIO_MAPR_SWJ_CFG_DISABLE            ((uint32_t)0x04000000)        /*!< JTAG-DP Disabled and SW-DP Disabled */
S
S#ifdef STM32F10X_CL
S/*!< ETH_REMAP configuration */
S #define AFIO_MAPR_ETH_REMAP                  ((uint32_t)0x00200000)        /*!< SPI3_REMAP bit (Ethernet MAC I/O remapping) */
S
S/*!< CAN2_REMAP configuration */
S #define AFIO_MAPR_CAN2_REMAP                 ((uint32_t)0x00400000)        /*!< CAN2_REMAP bit (CAN2 I/O remapping) */
S
S/*!< MII_RMII_SEL configuration */
S #define AFIO_MAPR_MII_RMII_SEL               ((uint32_t)0x00800000)        /*!< MII_RMII_SEL bit (Ethernet MII or RMII selection) */
S
S/*!< SPI3_REMAP configuration */
S #define AFIO_MAPR_SPI3_REMAP                 ((uint32_t)0x10000000)        /*!< SPI3_REMAP bit (SPI3 remapping) */
S
S/*!< TIM2ITR1_IREMAP configuration */
S #define AFIO_MAPR_TIM2ITR1_IREMAP            ((uint32_t)0x20000000)        /*!< TIM2ITR1_IREMAP bit (TIM2 internal trigger 1 remapping) */
S
S/*!< PTP_PPS_REMAP configuration */
S #define AFIO_MAPR_PTP_PPS_REMAP              ((uint32_t)0x40000000)        /*!< PTP_PPS_REMAP bit (Ethernet PTP PPS remapping) */
S#endif
S
S/*****************  Bit definition for AFIO_EXTICR1 register  *****************/
S#define AFIO_EXTICR1_EXTI0                   ((uint16_t)0x000F)            /*!< EXTI 0 configuration */
S#define AFIO_EXTICR1_EXTI1                   ((uint16_t)0x00F0)            /*!< EXTI 1 configuration */
S#define AFIO_EXTICR1_EXTI2                   ((uint16_t)0x0F00)            /*!< EXTI 2 configuration */
S#define AFIO_EXTICR1_EXTI3                   ((uint16_t)0xF000)            /*!< EXTI 3 configuration */
S
S/*!< EXTI0 configuration */
S#define AFIO_EXTICR1_EXTI0_PA                ((uint16_t)0x0000)            /*!< PA[0] pin */
S#define AFIO_EXTICR1_EXTI0_PB                ((uint16_t)0x0001)            /*!< PB[0] pin */
S#define AFIO_EXTICR1_EXTI0_PC                ((uint16_t)0x0002)            /*!< PC[0] pin */
S#define AFIO_EXTICR1_EXTI0_PD                ((uint16_t)0x0003)            /*!< PD[0] pin */
S#define AFIO_EXTICR1_EXTI0_PE                ((uint16_t)0x0004)            /*!< PE[0] pin */
S#define AFIO_EXTICR1_EXTI0_PF                ((uint16_t)0x0005)            /*!< PF[0] pin */
S#define AFIO_EXTICR1_EXTI0_PG                ((uint16_t)0x0006)            /*!< PG[0] pin */
S
S/*!< EXTI1 configuration */
S#define AFIO_EXTICR1_EXTI1_PA                ((uint16_t)0x0000)            /*!< PA[1] pin */
S#define AFIO_EXTICR1_EXTI1_PB                ((uint16_t)0x0010)            /*!< PB[1] pin */
S#define AFIO_EXTICR1_EXTI1_PC                ((uint16_t)0x0020)            /*!< PC[1] pin */
S#define AFIO_EXTICR1_EXTI1_PD                ((uint16_t)0x0030)            /*!< PD[1] pin */
S#define AFIO_EXTICR1_EXTI1_PE                ((uint16_t)0x0040)            /*!< PE[1] pin */
S#define AFIO_EXTICR1_EXTI1_PF                ((uint16_t)0x0050)            /*!< PF[1] pin */
S#define AFIO_EXTICR1_EXTI1_PG                ((uint16_t)0x0060)            /*!< PG[1] pin */
S
S/*!< EXTI2 configuration */  
S#define AFIO_EXTICR1_EXTI2_PA                ((uint16_t)0x0000)            /*!< PA[2] pin */
S#define AFIO_EXTICR1_EXTI2_PB                ((uint16_t)0x0100)            /*!< PB[2] pin */
S#define AFIO_EXTICR1_EXTI2_PC                ((uint16_t)0x0200)            /*!< PC[2] pin */
S#define AFIO_EXTICR1_EXTI2_PD                ((uint16_t)0x0300)            /*!< PD[2] pin */
S#define AFIO_EXTICR1_EXTI2_PE                ((uint16_t)0x0400)            /*!< PE[2] pin */
S#define AFIO_EXTICR1_EXTI2_PF                ((uint16_t)0x0500)            /*!< PF[2] pin */
S#define AFIO_EXTICR1_EXTI2_PG                ((uint16_t)0x0600)            /*!< PG[2] pin */
S
S/*!< EXTI3 configuration */
S#define AFIO_EXTICR1_EXTI3_PA                ((uint16_t)0x0000)            /*!< PA[3] pin */
S#define AFIO_EXTICR1_EXTI3_PB                ((uint16_t)0x1000)            /*!< PB[3] pin */
S#define AFIO_EXTICR1_EXTI3_PC                ((uint16_t)0x2000)            /*!< PC[3] pin */
S#define AFIO_EXTICR1_EXTI3_PD                ((uint16_t)0x3000)            /*!< PD[3] pin */
S#define AFIO_EXTICR1_EXTI3_PE                ((uint16_t)0x4000)            /*!< PE[3] pin */
S#define AFIO_EXTICR1_EXTI3_PF                ((uint16_t)0x5000)            /*!< PF[3] pin */
S#define AFIO_EXTICR1_EXTI3_PG                ((uint16_t)0x6000)            /*!< PG[3] pin */
S
S/*****************  Bit definition for AFIO_EXTICR2 register  *****************/
S#define AFIO_EXTICR2_EXTI4                   ((uint16_t)0x000F)            /*!< EXTI 4 configuration */
S#define AFIO_EXTICR2_EXTI5                   ((uint16_t)0x00F0)            /*!< EXTI 5 configuration */
S#define AFIO_EXTICR2_EXTI6                   ((uint16_t)0x0F00)            /*!< EXTI 6 configuration */
S#define AFIO_EXTICR2_EXTI7                   ((uint16_t)0xF000)            /*!< EXTI 7 configuration */
S
S/*!< EXTI4 configuration */
S#define AFIO_EXTICR2_EXTI4_PA                ((uint16_t)0x0000)            /*!< PA[4] pin */
S#define AFIO_EXTICR2_EXTI4_PB                ((uint16_t)0x0001)            /*!< PB[4] pin */
S#define AFIO_EXTICR2_EXTI4_PC                ((uint16_t)0x0002)            /*!< PC[4] pin */
S#define AFIO_EXTICR2_EXTI4_PD                ((uint16_t)0x0003)            /*!< PD[4] pin */
S#define AFIO_EXTICR2_EXTI4_PE                ((uint16_t)0x0004)            /*!< PE[4] pin */
S#define AFIO_EXTICR2_EXTI4_PF                ((uint16_t)0x0005)            /*!< PF[4] pin */
S#define AFIO_EXTICR2_EXTI4_PG                ((uint16_t)0x0006)            /*!< PG[4] pin */
S
S/* EXTI5 configuration */
S#define AFIO_EXTICR2_EXTI5_PA                ((uint16_t)0x0000)            /*!< PA[5] pin */
S#define AFIO_EXTICR2_EXTI5_PB                ((uint16_t)0x0010)            /*!< PB[5] pin */
S#define AFIO_EXTICR2_EXTI5_PC                ((uint16_t)0x0020)            /*!< PC[5] pin */
S#define AFIO_EXTICR2_EXTI5_PD                ((uint16_t)0x0030)            /*!< PD[5] pin */
S#define AFIO_EXTICR2_EXTI5_PE                ((uint16_t)0x0040)            /*!< PE[5] pin */
S#define AFIO_EXTICR2_EXTI5_PF                ((uint16_t)0x0050)            /*!< PF[5] pin */
S#define AFIO_EXTICR2_EXTI5_PG                ((uint16_t)0x0060)            /*!< PG[5] pin */
S
S/*!< EXTI6 configuration */  
S#define AFIO_EXTICR2_EXTI6_PA                ((uint16_t)0x0000)            /*!< PA[6] pin */
S#define AFIO_EXTICR2_EXTI6_PB                ((uint16_t)0x0100)            /*!< PB[6] pin */
S#define AFIO_EXTICR2_EXTI6_PC                ((uint16_t)0x0200)            /*!< PC[6] pin */
S#define AFIO_EXTICR2_EXTI6_PD                ((uint16_t)0x0300)            /*!< PD[6] pin */
S#define AFIO_EXTICR2_EXTI6_PE                ((uint16_t)0x0400)            /*!< PE[6] pin */
S#define AFIO_EXTICR2_EXTI6_PF                ((uint16_t)0x0500)            /*!< PF[6] pin */
S#define AFIO_EXTICR2_EXTI6_PG                ((uint16_t)0x0600)            /*!< PG[6] pin */
S
S/*!< EXTI7 configuration */
S#define AFIO_EXTICR2_EXTI7_PA                ((uint16_t)0x0000)            /*!< PA[7] pin */
S#define AFIO_EXTICR2_EXTI7_PB                ((uint16_t)0x1000)            /*!< PB[7] pin */
S#define AFIO_EXTICR2_EXTI7_PC                ((uint16_t)0x2000)            /*!< PC[7] pin */
S#define AFIO_EXTICR2_EXTI7_PD                ((uint16_t)0x3000)            /*!< PD[7] pin */
S#define AFIO_EXTICR2_EXTI7_PE                ((uint16_t)0x4000)            /*!< PE[7] pin */
S#define AFIO_EXTICR2_EXTI7_PF                ((uint16_t)0x5000)            /*!< PF[7] pin */
S#define AFIO_EXTICR2_EXTI7_PG                ((uint16_t)0x6000)            /*!< PG[7] pin */
S
S/*****************  Bit definition for AFIO_EXTICR3 register  *****************/
S#define AFIO_EXTICR3_EXTI8                   ((uint16_t)0x000F)            /*!< EXTI 8 configuration */
S#define AFIO_EXTICR3_EXTI9                   ((uint16_t)0x00F0)            /*!< EXTI 9 configuration */
S#define AFIO_EXTICR3_EXTI10                  ((uint16_t)0x0F00)            /*!< EXTI 10 configuration */
S#define AFIO_EXTICR3_EXTI11                  ((uint16_t)0xF000)            /*!< EXTI 11 configuration */
S
S/*!< EXTI8 configuration */
S#define AFIO_EXTICR3_EXTI8_PA                ((uint16_t)0x0000)            /*!< PA[8] pin */
S#define AFIO_EXTICR3_EXTI8_PB                ((uint16_t)0x0001)            /*!< PB[8] pin */
S#define AFIO_EXTICR3_EXTI8_PC                ((uint16_t)0x0002)            /*!< PC[8] pin */
S#define AFIO_EXTICR3_EXTI8_PD                ((uint16_t)0x0003)            /*!< PD[8] pin */
S#define AFIO_EXTICR3_EXTI8_PE                ((uint16_t)0x0004)            /*!< PE[8] pin */
S#define AFIO_EXTICR3_EXTI8_PF                ((uint16_t)0x0005)            /*!< PF[8] pin */
S#define AFIO_EXTICR3_EXTI8_PG                ((uint16_t)0x0006)            /*!< PG[8] pin */
S
S/*!< EXTI9 configuration */
S#define AFIO_EXTICR3_EXTI9_PA                ((uint16_t)0x0000)            /*!< PA[9] pin */
S#define AFIO_EXTICR3_EXTI9_PB                ((uint16_t)0x0010)            /*!< PB[9] pin */
S#define AFIO_EXTICR3_EXTI9_PC                ((uint16_t)0x0020)            /*!< PC[9] pin */
S#define AFIO_EXTICR3_EXTI9_PD                ((uint16_t)0x0030)            /*!< PD[9] pin */
S#define AFIO_EXTICR3_EXTI9_PE                ((uint16_t)0x0040)            /*!< PE[9] pin */
S#define AFIO_EXTICR3_EXTI9_PF                ((uint16_t)0x0050)            /*!< PF[9] pin */
S#define AFIO_EXTICR3_EXTI9_PG                ((uint16_t)0x0060)            /*!< PG[9] pin */
S
S/*!< EXTI10 configuration */  
S#define AFIO_EXTICR3_EXTI10_PA               ((uint16_t)0x0000)            /*!< PA[10] pin */
S#define AFIO_EXTICR3_EXTI10_PB               ((uint16_t)0x0100)            /*!< PB[10] pin */
S#define AFIO_EXTICR3_EXTI10_PC               ((uint16_t)0x0200)            /*!< PC[10] pin */
S#define AFIO_EXTICR3_EXTI10_PD               ((uint16_t)0x0300)            /*!< PD[10] pin */
S#define AFIO_EXTICR3_EXTI10_PE               ((uint16_t)0x0400)            /*!< PE[10] pin */
S#define AFIO_EXTICR3_EXTI10_PF               ((uint16_t)0x0500)            /*!< PF[10] pin */
S#define AFIO_EXTICR3_EXTI10_PG               ((uint16_t)0x0600)            /*!< PG[10] pin */
S
S/*!< EXTI11 configuration */
S#define AFIO_EXTICR3_EXTI11_PA               ((uint16_t)0x0000)            /*!< PA[11] pin */
S#define AFIO_EXTICR3_EXTI11_PB               ((uint16_t)0x1000)            /*!< PB[11] pin */
S#define AFIO_EXTICR3_EXTI11_PC               ((uint16_t)0x2000)            /*!< PC[11] pin */
S#define AFIO_EXTICR3_EXTI11_PD               ((uint16_t)0x3000)            /*!< PD[11] pin */
S#define AFIO_EXTICR3_EXTI11_PE               ((uint16_t)0x4000)            /*!< PE[11] pin */
S#define AFIO_EXTICR3_EXTI11_PF               ((uint16_t)0x5000)            /*!< PF[11] pin */
S#define AFIO_EXTICR3_EXTI11_PG               ((uint16_t)0x6000)            /*!< PG[11] pin */
S
S/*****************  Bit definition for AFIO_EXTICR4 register  *****************/
S#define AFIO_EXTICR4_EXTI12                  ((uint16_t)0x000F)            /*!< EXTI 12 configuration */
S#define AFIO_EXTICR4_EXTI13                  ((uint16_t)0x00F0)            /*!< EXTI 13 configuration */
S#define AFIO_EXTICR4_EXTI14                  ((uint16_t)0x0F00)            /*!< EXTI 14 configuration */
S#define AFIO_EXTICR4_EXTI15                  ((uint16_t)0xF000)            /*!< EXTI 15 configuration */
S
S/* EXTI12 configuration */
S#define AFIO_EXTICR4_EXTI12_PA               ((uint16_t)0x0000)            /*!< PA[12] pin */
S#define AFIO_EXTICR4_EXTI12_PB               ((uint16_t)0x0001)            /*!< PB[12] pin */
S#define AFIO_EXTICR4_EXTI12_PC               ((uint16_t)0x0002)            /*!< PC[12] pin */
S#define AFIO_EXTICR4_EXTI12_PD               ((uint16_t)0x0003)            /*!< PD[12] pin */
S#define AFIO_EXTICR4_EXTI12_PE               ((uint16_t)0x0004)            /*!< PE[12] pin */
S#define AFIO_EXTICR4_EXTI12_PF               ((uint16_t)0x0005)            /*!< PF[12] pin */
S#define AFIO_EXTICR4_EXTI12_PG               ((uint16_t)0x0006)            /*!< PG[12] pin */
S
S/* EXTI13 configuration */
S#define AFIO_EXTICR4_EXTI13_PA               ((uint16_t)0x0000)            /*!< PA[13] pin */
S#define AFIO_EXTICR4_EXTI13_PB               ((uint16_t)0x0010)            /*!< PB[13] pin */
S#define AFIO_EXTICR4_EXTI13_PC               ((uint16_t)0x0020)            /*!< PC[13] pin */
S#define AFIO_EXTICR4_EXTI13_PD               ((uint16_t)0x0030)            /*!< PD[13] pin */
S#define AFIO_EXTICR4_EXTI13_PE               ((uint16_t)0x0040)            /*!< PE[13] pin */
S#define AFIO_EXTICR4_EXTI13_PF               ((uint16_t)0x0050)            /*!< PF[13] pin */
S#define AFIO_EXTICR4_EXTI13_PG               ((uint16_t)0x0060)            /*!< PG[13] pin */
S
S/*!< EXTI14 configuration */  
S#define AFIO_EXTICR4_EXTI14_PA               ((uint16_t)0x0000)            /*!< PA[14] pin */
S#define AFIO_EXTICR4_EXTI14_PB               ((uint16_t)0x0100)            /*!< PB[14] pin */
S#define AFIO_EXTICR4_EXTI14_PC               ((uint16_t)0x0200)            /*!< PC[14] pin */
S#define AFIO_EXTICR4_EXTI14_PD               ((uint16_t)0x0300)            /*!< PD[14] pin */
S#define AFIO_EXTICR4_EXTI14_PE               ((uint16_t)0x0400)            /*!< PE[14] pin */
S#define AFIO_EXTICR4_EXTI14_PF               ((uint16_t)0x0500)            /*!< PF[14] pin */
S#define AFIO_EXTICR4_EXTI14_PG               ((uint16_t)0x0600)            /*!< PG[14] pin */
S
S/*!< EXTI15 configuration */
S#define AFIO_EXTICR4_EXTI15_PA               ((uint16_t)0x0000)            /*!< PA[15] pin */
S#define AFIO_EXTICR4_EXTI15_PB               ((uint16_t)0x1000)            /*!< PB[15] pin */
S#define AFIO_EXTICR4_EXTI15_PC               ((uint16_t)0x2000)            /*!< PC[15] pin */
S#define AFIO_EXTICR4_EXTI15_PD               ((uint16_t)0x3000)            /*!< PD[15] pin */
S#define AFIO_EXTICR4_EXTI15_PE               ((uint16_t)0x4000)            /*!< PE[15] pin */
S#define AFIO_EXTICR4_EXTI15_PF               ((uint16_t)0x5000)            /*!< PF[15] pin */
S#define AFIO_EXTICR4_EXTI15_PG               ((uint16_t)0x6000)            /*!< PG[15] pin */
S
S#if defined (STM32F10X_LD_VL) || defined (STM32F10X_MD_VL) || defined (STM32F10X_HD_VL)
S/******************  Bit definition for AFIO_MAPR2 register  ******************/
S#define AFIO_MAPR2_TIM15_REMAP               ((uint32_t)0x00000001)        /*!< TIM15 remapping */
S#define AFIO_MAPR2_TIM16_REMAP               ((uint32_t)0x00000002)        /*!< TIM16 remapping */
S#define AFIO_MAPR2_TIM17_REMAP               ((uint32_t)0x00000004)        /*!< TIM17 remapping */
S#define AFIO_MAPR2_CEC_REMAP                 ((uint32_t)0x00000008)        /*!< CEC remapping */
S#define AFIO_MAPR2_TIM1_DMA_REMAP            ((uint32_t)0x00000010)        /*!< TIM1_DMA remapping */
S#endif
S
S#ifdef STM32F10X_HD_VL
S#define AFIO_MAPR2_TIM13_REMAP               ((uint32_t)0x00000100)        /*!< TIM13 remapping */
S#define AFIO_MAPR2_TIM14_REMAP               ((uint32_t)0x00000200)        /*!< TIM14 remapping */
S#define AFIO_MAPR2_FSMC_NADV_REMAP           ((uint32_t)0x00000400)        /*!< FSMC NADV remapping */
S#define AFIO_MAPR2_TIM67_DAC_DMA_REMAP       ((uint32_t)0x00000800)        /*!< TIM6/TIM7 and DAC DMA remapping */
S#define AFIO_MAPR2_TIM12_REMAP               ((uint32_t)0x00001000)        /*!< TIM12 remapping */
S#define AFIO_MAPR2_MISC_REMAP                ((uint32_t)0x00002000)        /*!< Miscellaneous remapping */
S#endif
S
S#ifdef STM32F10X_XL 
S/******************  Bit definition for AFIO_MAPR2 register  ******************/
S#define AFIO_MAPR2_TIM9_REMAP                ((uint32_t)0x00000020)        /*!< TIM9 remapping */
S#define AFIO_MAPR2_TIM10_REMAP               ((uint32_t)0x00000040)        /*!< TIM10 remapping */
S#define AFIO_MAPR2_TIM11_REMAP               ((uint32_t)0x00000080)        /*!< TIM11 remapping */
S#define AFIO_MAPR2_TIM13_REMAP               ((uint32_t)0x00000100)        /*!< TIM13 remapping */
S#define AFIO_MAPR2_TIM14_REMAP               ((uint32_t)0x00000200)        /*!< TIM14 remapping */
S#define AFIO_MAPR2_FSMC_NADV_REMAP           ((uint32_t)0x00000400)        /*!< FSMC NADV remapping */
S#endif
S
S/******************************************************************************/
S/*                                                                            */
S/*                               SystemTick                                   */
S/*                                                                            */
S/******************************************************************************/
S
S/*****************  Bit definition for SysTick_CTRL register  *****************/
S#define  SysTick_CTRL_ENABLE                 ((uint32_t)0x00000001)        /*!< Counter enable */
S#define  SysTick_CTRL_TICKINT                ((uint32_t)0x00000002)        /*!< Counting down to 0 pends the SysTick handler */
S#define  SysTick_CTRL_CLKSOURCE              ((uint32_t)0x00000004)        /*!< Clock source */
S#define  SysTick_CTRL_COUNTFLAG              ((uint32_t)0x00010000)        /*!< Count Flag */
S
S/*****************  Bit definition for SysTick_LOAD register  *****************/
S#define  SysTick_LOAD_RELOAD                 ((uint32_t)0x00FFFFFF)        /*!< Value to load into the SysTick Current Value Register when the counter reaches 0 */
S
S/*****************  Bit definition for SysTick_VAL register  ******************/
S#define  SysTick_VAL_CURRENT                 ((uint32_t)0x00FFFFFF)        /*!< Current value at the time the register is accessed */
S
S/*****************  Bit definition for SysTick_CALIB register  ****************/
S#define  SysTick_CALIB_TENMS                 ((uint32_t)0x00FFFFFF)        /*!< Reload value to use for 10ms timing */
S#define  SysTick_CALIB_SKEW                  ((uint32_t)0x40000000)        /*!< Calibration value is not exactly 10 ms */
S#define  SysTick_CALIB_NOREF                 ((uint32_t)0x80000000)        /*!< The reference clock is not provided */
S
S/******************************************************************************/
S/*                                                                            */
S/*                  Nested Vectored Interrupt Controller                      */
S/*                                                                            */
S/******************************************************************************/
S
S/******************  Bit definition for NVIC_ISER register  *******************/
S#define  NVIC_ISER_SETENA                    ((uint32_t)0xFFFFFFFF)        /*!< Interrupt set enable bits */
S#define  NVIC_ISER_SETENA_0                  ((uint32_t)0x00000001)        /*!< bit 0 */
S#define  NVIC_ISER_SETENA_1                  ((uint32_t)0x00000002)        /*!< bit 1 */
S#define  NVIC_ISER_SETENA_2                  ((uint32_t)0x00000004)        /*!< bit 2 */
S#define  NVIC_ISER_SETENA_3                  ((uint32_t)0x00000008)        /*!< bit 3 */
S#define  NVIC_ISER_SETENA_4                  ((uint32_t)0x00000010)        /*!< bit 4 */
S#define  NVIC_ISER_SETENA_5                  ((uint32_t)0x00000020)        /*!< bit 5 */
S#define  NVIC_ISER_SETENA_6                  ((uint32_t)0x00000040)        /*!< bit 6 */
S#define  NVIC_ISER_SETENA_7                  ((uint32_t)0x00000080)        /*!< bit 7 */
S#define  NVIC_ISER_SETENA_8                  ((uint32_t)0x00000100)        /*!< bit 8 */
S#define  NVIC_ISER_SETENA_9                  ((uint32_t)0x00000200)        /*!< bit 9 */
S#define  NVIC_ISER_SETENA_10                 ((uint32_t)0x00000400)        /*!< bit 10 */
S#define  NVIC_ISER_SETENA_11                 ((uint32_t)0x00000800)        /*!< bit 11 */
S#define  NVIC_ISER_SETENA_12                 ((uint32_t)0x00001000)        /*!< bit 12 */
S#define  NVIC_ISER_SETENA_13                 ((uint32_t)0x00002000)        /*!< bit 13 */
S#define  NVIC_ISER_SETENA_14                 ((uint32_t)0x00004000)        /*!< bit 14 */
S#define  NVIC_ISER_SETENA_15                 ((uint32_t)0x00008000)        /*!< bit 15 */
S#define  NVIC_ISER_SETENA_16                 ((uint32_t)0x00010000)        /*!< bit 16 */
S#define  NVIC_ISER_SETENA_17                 ((uint32_t)0x00020000)        /*!< bit 17 */
S#define  NVIC_ISER_SETENA_18                 ((uint32_t)0x00040000)        /*!< bit 18 */
S#define  NVIC_ISER_SETENA_19                 ((uint32_t)0x00080000)        /*!< bit 19 */
S#define  NVIC_ISER_SETENA_20                 ((uint32_t)0x00100000)        /*!< bit 20 */
S#define  NVIC_ISER_SETENA_21                 ((uint32_t)0x00200000)        /*!< bit 21 */
S#define  NVIC_ISER_SETENA_22                 ((uint32_t)0x00400000)        /*!< bit 22 */
S#define  NVIC_ISER_SETENA_23                 ((uint32_t)0x00800000)        /*!< bit 23 */
S#define  NVIC_ISER_SETENA_24                 ((uint32_t)0x01000000)        /*!< bit 24 */
S#define  NVIC_ISER_SETENA_25                 ((uint32_t)0x02000000)        /*!< bit 25 */
S#define  NVIC_ISER_SETENA_26                 ((uint32_t)0x04000000)        /*!< bit 26 */
S#define  NVIC_ISER_SETENA_27                 ((uint32_t)0x08000000)        /*!< bit 27 */
S#define  NVIC_ISER_SETENA_28                 ((uint32_t)0x10000000)        /*!< bit 28 */
S#define  NVIC_ISER_SETENA_29                 ((uint32_t)0x20000000)        /*!< bit 29 */
S#define  NVIC_ISER_SETENA_30                 ((uint32_t)0x40000000)        /*!< bit 30 */
S#define  NVIC_ISER_SETENA_31                 ((uint32_t)0x80000000)        /*!< bit 31 */
S
S/******************  Bit definition for NVIC_ICER register  *******************/
S#define  NVIC_ICER_CLRENA                   ((uint32_t)0xFFFFFFFF)        /*!< Interrupt clear-enable bits */
S#define  NVIC_ICER_CLRENA_0                  ((uint32_t)0x00000001)        /*!< bit 0 */
S#define  NVIC_ICER_CLRENA_1                  ((uint32_t)0x00000002)        /*!< bit 1 */
S#define  NVIC_ICER_CLRENA_2                  ((uint32_t)0x00000004)        /*!< bit 2 */
S#define  NVIC_ICER_CLRENA_3                  ((uint32_t)0x00000008)        /*!< bit 3 */
S#define  NVIC_ICER_CLRENA_4                  ((uint32_t)0x00000010)        /*!< bit 4 */
S#define  NVIC_ICER_CLRENA_5                  ((uint32_t)0x00000020)        /*!< bit 5 */
S#define  NVIC_ICER_CLRENA_6                  ((uint32_t)0x00000040)        /*!< bit 6 */
S#define  NVIC_ICER_CLRENA_7                  ((uint32_t)0x00000080)        /*!< bit 7 */
S#define  NVIC_ICER_CLRENA_8                  ((uint32_t)0x00000100)        /*!< bit 8 */
S#define  NVIC_ICER_CLRENA_9                  ((uint32_t)0x00000200)        /*!< bit 9 */
S#define  NVIC_ICER_CLRENA_10                 ((uint32_t)0x00000400)        /*!< bit 10 */
S#define  NVIC_ICER_CLRENA_11                 ((uint32_t)0x00000800)        /*!< bit 11 */
S#define  NVIC_ICER_CLRENA_12                 ((uint32_t)0x00001000)        /*!< bit 12 */
S#define  NVIC_ICER_CLRENA_13                 ((uint32_t)0x00002000)        /*!< bit 13 */
S#define  NVIC_ICER_CLRENA_14                 ((uint32_t)0x00004000)        /*!< bit 14 */
S#define  NVIC_ICER_CLRENA_15                 ((uint32_t)0x00008000)        /*!< bit 15 */
S#define  NVIC_ICER_CLRENA_16                 ((uint32_t)0x00010000)        /*!< bit 16 */
S#define  NVIC_ICER_CLRENA_17                 ((uint32_t)0x00020000)        /*!< bit 17 */
S#define  NVIC_ICER_CLRENA_18                 ((uint32_t)0x00040000)        /*!< bit 18 */
S#define  NVIC_ICER_CLRENA_19                 ((uint32_t)0x00080000)        /*!< bit 19 */
S#define  NVIC_ICER_CLRENA_20                 ((uint32_t)0x00100000)        /*!< bit 20 */
S#define  NVIC_ICER_CLRENA_21                 ((uint32_t)0x00200000)        /*!< bit 21 */
S#define  NVIC_ICER_CLRENA_22                 ((uint32_t)0x00400000)        /*!< bit 22 */
S#define  NVIC_ICER_CLRENA_23                 ((uint32_t)0x00800000)        /*!< bit 23 */
S#define  NVIC_ICER_CLRENA_24                 ((uint32_t)0x01000000)        /*!< bit 24 */
S#define  NVIC_ICER_CLRENA_25                 ((uint32_t)0x02000000)        /*!< bit 25 */
S#define  NVIC_ICER_CLRENA_26                 ((uint32_t)0x04000000)        /*!< bit 26 */
S#define  NVIC_ICER_CLRENA_27                 ((uint32_t)0x08000000)        /*!< bit 27 */
S#define  NVIC_ICER_CLRENA_28                 ((uint32_t)0x10000000)        /*!< bit 28 */
S#define  NVIC_ICER_CLRENA_29                 ((uint32_t)0x20000000)        /*!< bit 29 */
S#define  NVIC_ICER_CLRENA_30                 ((uint32_t)0x40000000)        /*!< bit 30 */
S#define  NVIC_ICER_CLRENA_31                 ((uint32_t)0x80000000)        /*!< bit 31 */
S
S/******************  Bit definition for NVIC_ISPR register  *******************/
S#define  NVIC_ISPR_SETPEND                   ((uint32_t)0xFFFFFFFF)        /*!< Interrupt set-pending bits */
S#define  NVIC_ISPR_SETPEND_0                 ((uint32_t)0x00000001)        /*!< bit 0 */
S#define  NVIC_ISPR_SETPEND_1                 ((uint32_t)0x00000002)        /*!< bit 1 */
S#define  NVIC_ISPR_SETPEND_2                 ((uint32_t)0x00000004)        /*!< bit 2 */
S#define  NVIC_ISPR_SETPEND_3                 ((uint32_t)0x00000008)        /*!< bit 3 */
S#define  NVIC_ISPR_SETPEND_4                 ((uint32_t)0x00000010)        /*!< bit 4 */
S#define  NVIC_ISPR_SETPEND_5                 ((uint32_t)0x00000020)        /*!< bit 5 */
S#define  NVIC_ISPR_SETPEND_6                 ((uint32_t)0x00000040)        /*!< bit 6 */
S#define  NVIC_ISPR_SETPEND_7                 ((uint32_t)0x00000080)        /*!< bit 7 */
S#define  NVIC_ISPR_SETPEND_8                 ((uint32_t)0x00000100)        /*!< bit 8 */
S#define  NVIC_ISPR_SETPEND_9                 ((uint32_t)0x00000200)        /*!< bit 9 */
S#define  NVIC_ISPR_SETPEND_10                ((uint32_t)0x00000400)        /*!< bit 10 */
S#define  NVIC_ISPR_SETPEND_11                ((uint32_t)0x00000800)        /*!< bit 11 */
S#define  NVIC_ISPR_SETPEND_12                ((uint32_t)0x00001000)        /*!< bit 12 */
S#define  NVIC_ISPR_SETPEND_13                ((uint32_t)0x00002000)        /*!< bit 13 */
S#define  NVIC_ISPR_SETPEND_14                ((uint32_t)0x00004000)        /*!< bit 14 */
S#define  NVIC_ISPR_SETPEND_15                ((uint32_t)0x00008000)        /*!< bit 15 */
S#define  NVIC_ISPR_SETPEND_16                ((uint32_t)0x00010000)        /*!< bit 16 */
S#define  NVIC_ISPR_SETPEND_17                ((uint32_t)0x00020000)        /*!< bit 17 */
S#define  NVIC_ISPR_SETPEND_18                ((uint32_t)0x00040000)        /*!< bit 18 */
S#define  NVIC_ISPR_SETPEND_19                ((uint32_t)0x00080000)        /*!< bit 19 */
S#define  NVIC_ISPR_SETPEND_20                ((uint32_t)0x00100000)        /*!< bit 20 */
S#define  NVIC_ISPR_SETPEND_21                ((uint32_t)0x00200000)        /*!< bit 21 */
S#define  NVIC_ISPR_SETPEND_22                ((uint32_t)0x00400000)        /*!< bit 22 */
S#define  NVIC_ISPR_SETPEND_23                ((uint32_t)0x00800000)        /*!< bit 23 */
S#define  NVIC_ISPR_SETPEND_24                ((uint32_t)0x01000000)        /*!< bit 24 */
S#define  NVIC_ISPR_SETPEND_25                ((uint32_t)0x02000000)        /*!< bit 25 */
S#define  NVIC_ISPR_SETPEND_26                ((uint32_t)0x04000000)        /*!< bit 26 */
S#define  NVIC_ISPR_SETPEND_27                ((uint32_t)0x08000000)        /*!< bit 27 */
S#define  NVIC_ISPR_SETPEND_28                ((uint32_t)0x10000000)        /*!< bit 28 */
S#define  NVIC_ISPR_SETPEND_29                ((uint32_t)0x20000000)        /*!< bit 29 */
S#define  NVIC_ISPR_SETPEND_30                ((uint32_t)0x40000000)        /*!< bit 30 */
S#define  NVIC_ISPR_SETPEND_31                ((uint32_t)0x80000000)        /*!< bit 31 */
S
S/******************  Bit definition for NVIC_ICPR register  *******************/
S#define  NVIC_ICPR_CLRPEND                   ((uint32_t)0xFFFFFFFF)        /*!< Interrupt clear-pending bits */
S#define  NVIC_ICPR_CLRPEND_0                 ((uint32_t)0x00000001)        /*!< bit 0 */
S#define  NVIC_ICPR_CLRPEND_1                 ((uint32_t)0x00000002)        /*!< bit 1 */
S#define  NVIC_ICPR_CLRPEND_2                 ((uint32_t)0x00000004)        /*!< bit 2 */
S#define  NVIC_ICPR_CLRPEND_3                 ((uint32_t)0x00000008)        /*!< bit 3 */
S#define  NVIC_ICPR_CLRPEND_4                 ((uint32_t)0x00000010)        /*!< bit 4 */
S#define  NVIC_ICPR_CLRPEND_5                 ((uint32_t)0x00000020)        /*!< bit 5 */
S#define  NVIC_ICPR_CLRPEND_6                 ((uint32_t)0x00000040)        /*!< bit 6 */
S#define  NVIC_ICPR_CLRPEND_7                 ((uint32_t)0x00000080)        /*!< bit 7 */
S#define  NVIC_ICPR_CLRPEND_8                 ((uint32_t)0x00000100)        /*!< bit 8 */
S#define  NVIC_ICPR_CLRPEND_9                 ((uint32_t)0x00000200)        /*!< bit 9 */
S#define  NVIC_ICPR_CLRPEND_10                ((uint32_t)0x00000400)        /*!< bit 10 */
S#define  NVIC_ICPR_CLRPEND_11                ((uint32_t)0x00000800)        /*!< bit 11 */
S#define  NVIC_ICPR_CLRPEND_12                ((uint32_t)0x00001000)        /*!< bit 12 */
S#define  NVIC_ICPR_CLRPEND_13                ((uint32_t)0x00002000)        /*!< bit 13 */
S#define  NVIC_ICPR_CLRPEND_14                ((uint32_t)0x00004000)        /*!< bit 14 */
S#define  NVIC_ICPR_CLRPEND_15                ((uint32_t)0x00008000)        /*!< bit 15 */
S#define  NVIC_ICPR_CLRPEND_16                ((uint32_t)0x00010000)        /*!< bit 16 */
S#define  NVIC_ICPR_CLRPEND_17                ((uint32_t)0x00020000)        /*!< bit 17 */
S#define  NVIC_ICPR_CLRPEND_18                ((uint32_t)0x00040000)        /*!< bit 18 */
S#define  NVIC_ICPR_CLRPEND_19                ((uint32_t)0x00080000)        /*!< bit 19 */
S#define  NVIC_ICPR_CLRPEND_20                ((uint32_t)0x00100000)        /*!< bit 20 */
S#define  NVIC_ICPR_CLRPEND_21                ((uint32_t)0x00200000)        /*!< bit 21 */
S#define  NVIC_ICPR_CLRPEND_22                ((uint32_t)0x00400000)        /*!< bit 22 */
S#define  NVIC_ICPR_CLRPEND_23                ((uint32_t)0x00800000)        /*!< bit 23 */
S#define  NVIC_ICPR_CLRPEND_24                ((uint32_t)0x01000000)        /*!< bit 24 */
S#define  NVIC_ICPR_CLRPEND_25                ((uint32_t)0x02000000)        /*!< bit 25 */
S#define  NVIC_ICPR_CLRPEND_26                ((uint32_t)0x04000000)        /*!< bit 26 */
S#define  NVIC_ICPR_CLRPEND_27                ((uint32_t)0x08000000)        /*!< bit 27 */
S#define  NVIC_ICPR_CLRPEND_28                ((uint32_t)0x10000000)        /*!< bit 28 */
S#define  NVIC_ICPR_CLRPEND_29                ((uint32_t)0x20000000)        /*!< bit 29 */
S#define  NVIC_ICPR_CLRPEND_30                ((uint32_t)0x40000000)        /*!< bit 30 */
S#define  NVIC_ICPR_CLRPEND_31                ((uint32_t)0x80000000)        /*!< bit 31 */
S
S/******************  Bit definition for NVIC_IABR register  *******************/
S#define  NVIC_IABR_ACTIVE                    ((uint32_t)0xFFFFFFFF)        /*!< Interrupt active flags */
S#define  NVIC_IABR_ACTIVE_0                  ((uint32_t)0x00000001)        /*!< bit 0 */
S#define  NVIC_IABR_ACTIVE_1                  ((uint32_t)0x00000002)        /*!< bit 1 */
S#define  NVIC_IABR_ACTIVE_2                  ((uint32_t)0x00000004)        /*!< bit 2 */
S#define  NVIC_IABR_ACTIVE_3                  ((uint32_t)0x00000008)        /*!< bit 3 */
S#define  NVIC_IABR_ACTIVE_4                  ((uint32_t)0x00000010)        /*!< bit 4 */
S#define  NVIC_IABR_ACTIVE_5                  ((uint32_t)0x00000020)        /*!< bit 5 */
S#define  NVIC_IABR_ACTIVE_6                  ((uint32_t)0x00000040)        /*!< bit 6 */
S#define  NVIC_IABR_ACTIVE_7                  ((uint32_t)0x00000080)        /*!< bit 7 */
S#define  NVIC_IABR_ACTIVE_8                  ((uint32_t)0x00000100)        /*!< bit 8 */
S#define  NVIC_IABR_ACTIVE_9                  ((uint32_t)0x00000200)        /*!< bit 9 */
S#define  NVIC_IABR_ACTIVE_10                 ((uint32_t)0x00000400)        /*!< bit 10 */
S#define  NVIC_IABR_ACTIVE_11                 ((uint32_t)0x00000800)        /*!< bit 11 */
S#define  NVIC_IABR_ACTIVE_12                 ((uint32_t)0x00001000)        /*!< bit 12 */
S#define  NVIC_IABR_ACTIVE_13                 ((uint32_t)0x00002000)        /*!< bit 13 */
S#define  NVIC_IABR_ACTIVE_14                 ((uint32_t)0x00004000)        /*!< bit 14 */
S#define  NVIC_IABR_ACTIVE_15                 ((uint32_t)0x00008000)        /*!< bit 15 */
S#define  NVIC_IABR_ACTIVE_16                 ((uint32_t)0x00010000)        /*!< bit 16 */
S#define  NVIC_IABR_ACTIVE_17                 ((uint32_t)0x00020000)        /*!< bit 17 */
S#define  NVIC_IABR_ACTIVE_18                 ((uint32_t)0x00040000)        /*!< bit 18 */
S#define  NVIC_IABR_ACTIVE_19                 ((uint32_t)0x00080000)        /*!< bit 19 */
S#define  NVIC_IABR_ACTIVE_20                 ((uint32_t)0x00100000)        /*!< bit 20 */
S#define  NVIC_IABR_ACTIVE_21                 ((uint32_t)0x00200000)        /*!< bit 21 */
S#define  NVIC_IABR_ACTIVE_22                 ((uint32_t)0x00400000)        /*!< bit 22 */
S#define  NVIC_IABR_ACTIVE_23                 ((uint32_t)0x00800000)        /*!< bit 23 */
S#define  NVIC_IABR_ACTIVE_24                 ((uint32_t)0x01000000)        /*!< bit 24 */
S#define  NVIC_IABR_ACTIVE_25                 ((uint32_t)0x02000000)        /*!< bit 25 */
S#define  NVIC_IABR_ACTIVE_26                 ((uint32_t)0x04000000)        /*!< bit 26 */
S#define  NVIC_IABR_ACTIVE_27                 ((uint32_t)0x08000000)        /*!< bit 27 */
S#define  NVIC_IABR_ACTIVE_28                 ((uint32_t)0x10000000)        /*!< bit 28 */
S#define  NVIC_IABR_ACTIVE_29                 ((uint32_t)0x20000000)        /*!< bit 29 */
S#define  NVIC_IABR_ACTIVE_30                 ((uint32_t)0x40000000)        /*!< bit 30 */
S#define  NVIC_IABR_ACTIVE_31                 ((uint32_t)0x80000000)        /*!< bit 31 */
S
S/******************  Bit definition for NVIC_PRI0 register  *******************/
S#define  NVIC_IPR0_PRI_0                     ((uint32_t)0x000000FF)        /*!< Priority of interrupt 0 */
S#define  NVIC_IPR0_PRI_1                     ((uint32_t)0x0000FF00)        /*!< Priority of interrupt 1 */
S#define  NVIC_IPR0_PRI_2                     ((uint32_t)0x00FF0000)        /*!< Priority of interrupt 2 */
S#define  NVIC_IPR0_PRI_3                     ((uint32_t)0xFF000000)        /*!< Priority of interrupt 3 */
S
S/******************  Bit definition for NVIC_PRI1 register  *******************/
S#define  NVIC_IPR1_PRI_4                     ((uint32_t)0x000000FF)        /*!< Priority of interrupt 4 */
S#define  NVIC_IPR1_PRI_5                     ((uint32_t)0x0000FF00)        /*!< Priority of interrupt 5 */
S#define  NVIC_IPR1_PRI_6                     ((uint32_t)0x00FF0000)        /*!< Priority of interrupt 6 */
S#define  NVIC_IPR1_PRI_7                     ((uint32_t)0xFF000000)        /*!< Priority of interrupt 7 */
S
S/******************  Bit definition for NVIC_PRI2 register  *******************/
S#define  NVIC_IPR2_PRI_8                     ((uint32_t)0x000000FF)        /*!< Priority of interrupt 8 */
S#define  NVIC_IPR2_PRI_9                     ((uint32_t)0x0000FF00)        /*!< Priority of interrupt 9 */
S#define  NVIC_IPR2_PRI_10                    ((uint32_t)0x00FF0000)        /*!< Priority of interrupt 10 */
S#define  NVIC_IPR2_PRI_11                    ((uint32_t)0xFF000000)        /*!< Priority of interrupt 11 */
S
S/******************  Bit definition for NVIC_PRI3 register  *******************/
S#define  NVIC_IPR3_PRI_12                    ((uint32_t)0x000000FF)        /*!< Priority of interrupt 12 */
S#define  NVIC_IPR3_PRI_13                    ((uint32_t)0x0000FF00)        /*!< Priority of interrupt 13 */
S#define  NVIC_IPR3_PRI_14                    ((uint32_t)0x00FF0000)        /*!< Priority of interrupt 14 */
S#define  NVIC_IPR3_PRI_15                    ((uint32_t)0xFF000000)        /*!< Priority of interrupt 15 */
S
S/******************  Bit definition for NVIC_PRI4 register  *******************/
S#define  NVIC_IPR4_PRI_16                    ((uint32_t)0x000000FF)        /*!< Priority of interrupt 16 */
S#define  NVIC_IPR4_PRI_17                    ((uint32_t)0x0000FF00)        /*!< Priority of interrupt 17 */
S#define  NVIC_IPR4_PRI_18                    ((uint32_t)0x00FF0000)        /*!< Priority of interrupt 18 */
S#define  NVIC_IPR4_PRI_19                    ((uint32_t)0xFF000000)        /*!< Priority of interrupt 19 */
S
S/******************  Bit definition for NVIC_PRI5 register  *******************/
S#define  NVIC_IPR5_PRI_20                    ((uint32_t)0x000000FF)        /*!< Priority of interrupt 20 */
S#define  NVIC_IPR5_PRI_21                    ((uint32_t)0x0000FF00)        /*!< Priority of interrupt 21 */
S#define  NVIC_IPR5_PRI_22                    ((uint32_t)0x00FF0000)        /*!< Priority of interrupt 22 */
S#define  NVIC_IPR5_PRI_23                    ((uint32_t)0xFF000000)        /*!< Priority of interrupt 23 */
S
S/******************  Bit definition for NVIC_PRI6 register  *******************/
S#define  NVIC_IPR6_PRI_24                    ((uint32_t)0x000000FF)        /*!< Priority of interrupt 24 */
S#define  NVIC_IPR6_PRI_25                    ((uint32_t)0x0000FF00)        /*!< Priority of interrupt 25 */
S#define  NVIC_IPR6_PRI_26                    ((uint32_t)0x00FF0000)        /*!< Priority of interrupt 26 */
S#define  NVIC_IPR6_PRI_27                    ((uint32_t)0xFF000000)        /*!< Priority of interrupt 27 */
S
S/******************  Bit definition for NVIC_PRI7 register  *******************/
S#define  NVIC_IPR7_PRI_28                    ((uint32_t)0x000000FF)        /*!< Priority of interrupt 28 */
S#define  NVIC_IPR7_PRI_29                    ((uint32_t)0x0000FF00)        /*!< Priority of interrupt 29 */
S#define  NVIC_IPR7_PRI_30                    ((uint32_t)0x00FF0000)        /*!< Priority of interrupt 30 */
S#define  NVIC_IPR7_PRI_31                    ((uint32_t)0xFF000000)        /*!< Priority of interrupt 31 */
S
S/******************  Bit definition for SCB_CPUID register  *******************/
S#define  SCB_CPUID_REVISION                  ((uint32_t)0x0000000F)        /*!< Implementation defined revision number */
S#define  SCB_CPUID_PARTNO                    ((uint32_t)0x0000FFF0)        /*!< Number of processor within family */
S#define  SCB_CPUID_Constant                  ((uint32_t)0x000F0000)        /*!< Reads as 0x0F */
S#define  SCB_CPUID_VARIANT                   ((uint32_t)0x00F00000)        /*!< Implementation defined variant number */
S#define  SCB_CPUID_IMPLEMENTER               ((uint32_t)0xFF000000)        /*!< Implementer code. ARM is 0x41 */
S
S/*******************  Bit definition for SCB_ICSR register  *******************/
S#define  SCB_ICSR_VECTACTIVE                 ((uint32_t)0x000001FF)        /*!< Active ISR number field */
S#define  SCB_ICSR_RETTOBASE                  ((uint32_t)0x00000800)        /*!< All active exceptions minus the IPSR_current_exception yields the empty set */
S#define  SCB_ICSR_VECTPENDING                ((uint32_t)0x003FF000)        /*!< Pending ISR number field */
S#define  SCB_ICSR_ISRPENDING                 ((uint32_t)0x00400000)        /*!< Interrupt pending flag */
S#define  SCB_ICSR_ISRPREEMPT                 ((uint32_t)0x00800000)        /*!< It indicates that a pending interrupt becomes active in the next running cycle */
S#define  SCB_ICSR_PENDSTCLR                  ((uint32_t)0x02000000)        /*!< Clear pending SysTick bit */
S#define  SCB_ICSR_PENDSTSET                  ((uint32_t)0x04000000)        /*!< Set pending SysTick bit */
S#define  SCB_ICSR_PENDSVCLR                  ((uint32_t)0x08000000)        /*!< Clear pending pendSV bit */
S#define  SCB_ICSR_PENDSVSET                  ((uint32_t)0x10000000)        /*!< Set pending pendSV bit */
S#define  SCB_ICSR_NMIPENDSET                 ((uint32_t)0x80000000)        /*!< Set pending NMI bit */
S
S/*******************  Bit definition for SCB_VTOR register  *******************/
S#define  SCB_VTOR_TBLOFF                     ((uint32_t)0x1FFFFF80)        /*!< Vector table base offset field */
S#define  SCB_VTOR_TBLBASE                    ((uint32_t)0x20000000)        /*!< Table base in code(0) or RAM(1) */
S
S/*!<*****************  Bit definition for SCB_AIRCR register  *******************/
S#define  SCB_AIRCR_VECTRESET                 ((uint32_t)0x00000001)        /*!< System Reset bit */
S#define  SCB_AIRCR_VECTCLRACTIVE             ((uint32_t)0x00000002)        /*!< Clear active vector bit */
S#define  SCB_AIRCR_SYSRESETREQ               ((uint32_t)0x00000004)        /*!< Requests chip control logic to generate a reset */
S
S#define  SCB_AIRCR_PRIGROUP                  ((uint32_t)0x00000700)        /*!< PRIGROUP[2:0] bits (Priority group) */
S#define  SCB_AIRCR_PRIGROUP_0                ((uint32_t)0x00000100)        /*!< Bit 0 */
S#define  SCB_AIRCR_PRIGROUP_1                ((uint32_t)0x00000200)        /*!< Bit 1 */
S#define  SCB_AIRCR_PRIGROUP_2                ((uint32_t)0x00000400)        /*!< Bit 2  */
S
S/* prority group configuration */
S#define  SCB_AIRCR_PRIGROUP0                 ((uint32_t)0x00000000)        /*!< Priority group=0 (7 bits of pre-emption priority, 1 bit of subpriority) */
S#define  SCB_AIRCR_PRIGROUP1                 ((uint32_t)0x00000100)        /*!< Priority group=1 (6 bits of pre-emption priority, 2 bits of subpriority) */
S#define  SCB_AIRCR_PRIGROUP2                 ((uint32_t)0x00000200)        /*!< Priority group=2 (5 bits of pre-emption priority, 3 bits of subpriority) */
S#define  SCB_AIRCR_PRIGROUP3                 ((uint32_t)0x00000300)        /*!< Priority group=3 (4 bits of pre-emption priority, 4 bits of subpriority) */
S#define  SCB_AIRCR_PRIGROUP4                 ((uint32_t)0x00000400)        /*!< Priority group=4 (3 bits of pre-emption priority, 5 bits of subpriority) */
S#define  SCB_AIRCR_PRIGROUP5                 ((uint32_t)0x00000500)        /*!< Priority group=5 (2 bits of pre-emption priority, 6 bits of subpriority) */
S#define  SCB_AIRCR_PRIGROUP6                 ((uint32_t)0x00000600)        /*!< Priority group=6 (1 bit of pre-emption priority, 7 bits of subpriority) */
S#define  SCB_AIRCR_PRIGROUP7                 ((uint32_t)0x00000700)        /*!< Priority group=7 (no pre-emption priority, 8 bits of subpriority) */
S
S#define  SCB_AIRCR_ENDIANESS                 ((uint32_t)0x00008000)        /*!< Data endianness bit */
S#define  SCB_AIRCR_VECTKEY                   ((uint32_t)0xFFFF0000)        /*!< Register key (VECTKEY) - Reads as 0xFA05 (VECTKEYSTAT) */
S
S/*******************  Bit definition for SCB_SCR register  ********************/
S#define  SCB_SCR_SLEEPONEXIT                 ((uint8_t)0x02)               /*!< Sleep on exit bit */
S#define  SCB_SCR_SLEEPDEEP                   ((uint8_t)0x04)               /*!< Sleep deep bit */
S#define  SCB_SCR_SEVONPEND                   ((uint8_t)0x10)               /*!< Wake up from WFE */
S
S/********************  Bit definition for SCB_CCR register  *******************/
S#define  SCB_CCR_NONBASETHRDENA              ((uint16_t)0x0001)            /*!< Thread mode can be entered from any level in Handler mode by controlled return value */
S#define  SCB_CCR_USERSETMPEND                ((uint16_t)0x0002)            /*!< Enables user code to write the Software Trigger Interrupt register to trigger (pend) a Main exception */
S#define  SCB_CCR_UNALIGN_TRP                 ((uint16_t)0x0008)            /*!< Trap for unaligned access */
S#define  SCB_CCR_DIV_0_TRP                   ((uint16_t)0x0010)            /*!< Trap on Divide by 0 */
S#define  SCB_CCR_BFHFNMIGN                   ((uint16_t)0x0100)            /*!< Handlers running at priority -1 and -2 */
S#define  SCB_CCR_STKALIGN                    ((uint16_t)0x0200)            /*!< On exception entry, the SP used prior to the exception is adjusted to be 8-byte aligned */
S
S/*******************  Bit definition for SCB_SHPR register ********************/
S#define  SCB_SHPR_PRI_N                      ((uint32_t)0x000000FF)        /*!< Priority of system handler 4,8, and 12. Mem Manage, reserved and Debug Monitor */
S#define  SCB_SHPR_PRI_N1                     ((uint32_t)0x0000FF00)        /*!< Priority of system handler 5,9, and 13. Bus Fault, reserved and reserved */
S#define  SCB_SHPR_PRI_N2                     ((uint32_t)0x00FF0000)        /*!< Priority of system handler 6,10, and 14. Usage Fault, reserved and PendSV */
S#define  SCB_SHPR_PRI_N3                     ((uint32_t)0xFF000000)        /*!< Priority of system handler 7,11, and 15. Reserved, SVCall and SysTick */
S
S/******************  Bit definition for SCB_SHCSR register  *******************/
S#define  SCB_SHCSR_MEMFAULTACT               ((uint32_t)0x00000001)        /*!< MemManage is active */
S#define  SCB_SHCSR_BUSFAULTACT               ((uint32_t)0x00000002)        /*!< BusFault is active */
S#define  SCB_SHCSR_USGFAULTACT               ((uint32_t)0x00000008)        /*!< UsageFault is active */
S#define  SCB_SHCSR_SVCALLACT                 ((uint32_t)0x00000080)        /*!< SVCall is active */
S#define  SCB_SHCSR_MONITORACT                ((uint32_t)0x00000100)        /*!< Monitor is active */
S#define  SCB_SHCSR_PENDSVACT                 ((uint32_t)0x00000400)        /*!< PendSV is active */
S#define  SCB_SHCSR_SYSTICKACT                ((uint32_t)0x00000800)        /*!< SysTick is active */
S#define  SCB_SHCSR_USGFAULTPENDED            ((uint32_t)0x00001000)        /*!< Usage Fault is pended */
S#define  SCB_SHCSR_MEMFAULTPENDED            ((uint32_t)0x00002000)        /*!< MemManage is pended */
S#define  SCB_SHCSR_BUSFAULTPENDED            ((uint32_t)0x00004000)        /*!< Bus Fault is pended */
S#define  SCB_SHCSR_SVCALLPENDED              ((uint32_t)0x00008000)        /*!< SVCall is pended */
S#define  SCB_SHCSR_MEMFAULTENA               ((uint32_t)0x00010000)        /*!< MemManage enable */
S#define  SCB_SHCSR_BUSFAULTENA               ((uint32_t)0x00020000)        /*!< Bus Fault enable */
S#define  SCB_SHCSR_USGFAULTENA               ((uint32_t)0x00040000)        /*!< UsageFault enable */
S
S/*******************  Bit definition for SCB_CFSR register  *******************/
S/*!< MFSR */
S#define  SCB_CFSR_IACCVIOL                   ((uint32_t)0x00000001)        /*!< Instruction access violation */
S#define  SCB_CFSR_DACCVIOL                   ((uint32_t)0x00000002)        /*!< Data access violation */
S#define  SCB_CFSR_MUNSTKERR                  ((uint32_t)0x00000008)        /*!< Unstacking error */
S#define  SCB_CFSR_MSTKERR                    ((uint32_t)0x00000010)        /*!< Stacking error */
S#define  SCB_CFSR_MMARVALID                  ((uint32_t)0x00000080)        /*!< Memory Manage Address Register address valid flag */
S/*!< BFSR */
S#define  SCB_CFSR_IBUSERR                    ((uint32_t)0x00000100)        /*!< Instruction bus error flag */
S#define  SCB_CFSR_PRECISERR                  ((uint32_t)0x00000200)        /*!< Precise data bus error */
S#define  SCB_CFSR_IMPRECISERR                ((uint32_t)0x00000400)        /*!< Imprecise data bus error */
S#define  SCB_CFSR_UNSTKERR                   ((uint32_t)0x00000800)        /*!< Unstacking error */
S#define  SCB_CFSR_STKERR                     ((uint32_t)0x00001000)        /*!< Stacking error */
S#define  SCB_CFSR_BFARVALID                  ((uint32_t)0x00008000)        /*!< Bus Fault Address Register address valid flag */
S/*!< UFSR */
S#define  SCB_CFSR_UNDEFINSTR                 ((uint32_t)0x00010000)        /*!< The processor attempt to execute an undefined instruction */
S#define  SCB_CFSR_INVSTATE                   ((uint32_t)0x00020000)        /*!< Invalid combination of EPSR and instruction */
S#define  SCB_CFSR_INVPC                      ((uint32_t)0x00040000)        /*!< Attempt to load EXC_RETURN into pc illegally */
S#define  SCB_CFSR_NOCP                       ((uint32_t)0x00080000)        /*!< Attempt to use a coprocessor instruction */
S#define  SCB_CFSR_UNALIGNED                  ((uint32_t)0x01000000)        /*!< Fault occurs when there is an attempt to make an unaligned memory access */
S#define  SCB_CFSR_DIVBYZERO                  ((uint32_t)0x02000000)        /*!< Fault occurs when SDIV or DIV instruction is used with a divisor of 0 */
S
S/*******************  Bit definition for SCB_HFSR register  *******************/
S#define  SCB_HFSR_VECTTBL                    ((uint32_t)0x00000002)        /*!< Fault occurs because of vector table read on exception processing */
S#define  SCB_HFSR_FORCED                     ((uint32_t)0x40000000)        /*!< Hard Fault activated when a configurable Fault was received and cannot activate */
S#define  SCB_HFSR_DEBUGEVT                   ((uint32_t)0x80000000)        /*!< Fault related to debug */
S
S/*******************  Bit definition for SCB_DFSR register  *******************/
S#define  SCB_DFSR_HALTED                     ((uint8_t)0x01)               /*!< Halt request flag */
S#define  SCB_DFSR_BKPT                       ((uint8_t)0x02)               /*!< BKPT flag */
S#define  SCB_DFSR_DWTTRAP                    ((uint8_t)0x04)               /*!< Data Watchpoint and Trace (DWT) flag */
S#define  SCB_DFSR_VCATCH                     ((uint8_t)0x08)               /*!< Vector catch flag */
S#define  SCB_DFSR_EXTERNAL                   ((uint8_t)0x10)               /*!< External debug request flag */
S
S/*******************  Bit definition for SCB_MMFAR register  ******************/
S#define  SCB_MMFAR_ADDRESS                   ((uint32_t)0xFFFFFFFF)        /*!< Mem Manage fault address field */
S
S/*******************  Bit definition for SCB_BFAR register  *******************/
S#define  SCB_BFAR_ADDRESS                    ((uint32_t)0xFFFFFFFF)        /*!< Bus fault address field */
S
S/*******************  Bit definition for SCB_afsr register  *******************/
S#define  SCB_AFSR_IMPDEF                     ((uint32_t)0xFFFFFFFF)        /*!< Implementation defined */
S
S/******************************************************************************/
S/*                                                                            */
S/*                    External Interrupt/Event Controller                     */
S/*                                                                            */
S/******************************************************************************/
S
S/*******************  Bit definition for EXTI_IMR register  *******************/
S#define  EXTI_IMR_MR0                        ((uint32_t)0x00000001)        /*!< Interrupt Mask on line 0 */
S#define  EXTI_IMR_MR1                        ((uint32_t)0x00000002)        /*!< Interrupt Mask on line 1 */
S#define  EXTI_IMR_MR2                        ((uint32_t)0x00000004)        /*!< Interrupt Mask on line 2 */
S#define  EXTI_IMR_MR3                        ((uint32_t)0x00000008)        /*!< Interrupt Mask on line 3 */
S#define  EXTI_IMR_MR4                        ((uint32_t)0x00000010)        /*!< Interrupt Mask on line 4 */
S#define  EXTI_IMR_MR5                        ((uint32_t)0x00000020)        /*!< Interrupt Mask on line 5 */
S#define  EXTI_IMR_MR6                        ((uint32_t)0x00000040)        /*!< Interrupt Mask on line 6 */
S#define  EXTI_IMR_MR7                        ((uint32_t)0x00000080)        /*!< Interrupt Mask on line 7 */
S#define  EXTI_IMR_MR8                        ((uint32_t)0x00000100)        /*!< Interrupt Mask on line 8 */
S#define  EXTI_IMR_MR9                        ((uint32_t)0x00000200)        /*!< Interrupt Mask on line 9 */
S#define  EXTI_IMR_MR10                       ((uint32_t)0x00000400)        /*!< Interrupt Mask on line 10 */
S#define  EXTI_IMR_MR11                       ((uint32_t)0x00000800)        /*!< Interrupt Mask on line 11 */
S#define  EXTI_IMR_MR12                       ((uint32_t)0x00001000)        /*!< Interrupt Mask on line 12 */
S#define  EXTI_IMR_MR13                       ((uint32_t)0x00002000)        /*!< Interrupt Mask on line 13 */
S#define  EXTI_IMR_MR14                       ((uint32_t)0x00004000)        /*!< Interrupt Mask on line 14 */
S#define  EXTI_IMR_MR15                       ((uint32_t)0x00008000)        /*!< Interrupt Mask on line 15 */
S#define  EXTI_IMR_MR16                       ((uint32_t)0x00010000)        /*!< Interrupt Mask on line 16 */
S#define  EXTI_IMR_MR17                       ((uint32_t)0x00020000)        /*!< Interrupt Mask on line 17 */
S#define  EXTI_IMR_MR18                       ((uint32_t)0x00040000)        /*!< Interrupt Mask on line 18 */
S#define  EXTI_IMR_MR19                       ((uint32_t)0x00080000)        /*!< Interrupt Mask on line 19 */
S
S/*******************  Bit definition for EXTI_EMR register  *******************/
S#define  EXTI_EMR_MR0                        ((uint32_t)0x00000001)        /*!< Event Mask on line 0 */
S#define  EXTI_EMR_MR1                        ((uint32_t)0x00000002)        /*!< Event Mask on line 1 */
S#define  EXTI_EMR_MR2                        ((uint32_t)0x00000004)        /*!< Event Mask on line 2 */
S#define  EXTI_EMR_MR3                        ((uint32_t)0x00000008)        /*!< Event Mask on line 3 */
S#define  EXTI_EMR_MR4                        ((uint32_t)0x00000010)        /*!< Event Mask on line 4 */
S#define  EXTI_EMR_MR5                        ((uint32_t)0x00000020)        /*!< Event Mask on line 5 */
S#define  EXTI_EMR_MR6                        ((uint32_t)0x00000040)        /*!< Event Mask on line 6 */
S#define  EXTI_EMR_MR7                        ((uint32_t)0x00000080)        /*!< Event Mask on line 7 */
S#define  EXTI_EMR_MR8                        ((uint32_t)0x00000100)        /*!< Event Mask on line 8 */
S#define  EXTI_EMR_MR9                        ((uint32_t)0x00000200)        /*!< Event Mask on line 9 */
S#define  EXTI_EMR_MR10                       ((uint32_t)0x00000400)        /*!< Event Mask on line 10 */
S#define  EXTI_EMR_MR11                       ((uint32_t)0x00000800)        /*!< Event Mask on line 11 */
S#define  EXTI_EMR_MR12                       ((uint32_t)0x00001000)        /*!< Event Mask on line 12 */
S#define  EXTI_EMR_MR13                       ((uint32_t)0x00002000)        /*!< Event Mask on line 13 */
S#define  EXTI_EMR_MR14                       ((uint32_t)0x00004000)        /*!< Event Mask on line 14 */
S#define  EXTI_EMR_MR15                       ((uint32_t)0x00008000)        /*!< Event Mask on line 15 */
S#define  EXTI_EMR_MR16                       ((uint32_t)0x00010000)        /*!< Event Mask on line 16 */
S#define  EXTI_EMR_MR17                       ((uint32_t)0x00020000)        /*!< Event Mask on line 17 */
S#define  EXTI_EMR_MR18                       ((uint32_t)0x00040000)        /*!< Event Mask on line 18 */
S#define  EXTI_EMR_MR19                       ((uint32_t)0x00080000)        /*!< Event Mask on line 19 */
S
S/******************  Bit definition for EXTI_RTSR register  *******************/
S#define  EXTI_RTSR_TR0                       ((uint32_t)0x00000001)        /*!< Rising trigger event configuration bit of line 0 */
S#define  EXTI_RTSR_TR1                       ((uint32_t)0x00000002)        /*!< Rising trigger event configuration bit of line 1 */
S#define  EXTI_RTSR_TR2                       ((uint32_t)0x00000004)        /*!< Rising trigger event configuration bit of line 2 */
S#define  EXTI_RTSR_TR3                       ((uint32_t)0x00000008)        /*!< Rising trigger event configuration bit of line 3 */
S#define  EXTI_RTSR_TR4                       ((uint32_t)0x00000010)        /*!< Rising trigger event configuration bit of line 4 */
S#define  EXTI_RTSR_TR5                       ((uint32_t)0x00000020)        /*!< Rising trigger event configuration bit of line 5 */
S#define  EXTI_RTSR_TR6                       ((uint32_t)0x00000040)        /*!< Rising trigger event configuration bit of line 6 */
S#define  EXTI_RTSR_TR7                       ((uint32_t)0x00000080)        /*!< Rising trigger event configuration bit of line 7 */
S#define  EXTI_RTSR_TR8                       ((uint32_t)0x00000100)        /*!< Rising trigger event configuration bit of line 8 */
S#define  EXTI_RTSR_TR9                       ((uint32_t)0x00000200)        /*!< Rising trigger event configuration bit of line 9 */
S#define  EXTI_RTSR_TR10                      ((uint32_t)0x00000400)        /*!< Rising trigger event configuration bit of line 10 */
S#define  EXTI_RTSR_TR11                      ((uint32_t)0x00000800)        /*!< Rising trigger event configuration bit of line 11 */
S#define  EXTI_RTSR_TR12                      ((uint32_t)0x00001000)        /*!< Rising trigger event configuration bit of line 12 */
S#define  EXTI_RTSR_TR13                      ((uint32_t)0x00002000)        /*!< Rising trigger event configuration bit of line 13 */
S#define  EXTI_RTSR_TR14                      ((uint32_t)0x00004000)        /*!< Rising trigger event configuration bit of line 14 */
S#define  EXTI_RTSR_TR15                      ((uint32_t)0x00008000)        /*!< Rising trigger event configuration bit of line 15 */
S#define  EXTI_RTSR_TR16                      ((uint32_t)0x00010000)        /*!< Rising trigger event configuration bit of line 16 */
S#define  EXTI_RTSR_TR17                      ((uint32_t)0x00020000)        /*!< Rising trigger event configuration bit of line 17 */
S#define  EXTI_RTSR_TR18                      ((uint32_t)0x00040000)        /*!< Rising trigger event configuration bit of line 18 */
S#define  EXTI_RTSR_TR19                      ((uint32_t)0x00080000)        /*!< Rising trigger event configuration bit of line 19 */
S
S/******************  Bit definition for EXTI_FTSR register  *******************/
S#define  EXTI_FTSR_TR0                       ((uint32_t)0x00000001)        /*!< Falling trigger event configuration bit of line 0 */
S#define  EXTI_FTSR_TR1                       ((uint32_t)0x00000002)        /*!< Falling trigger event configuration bit of line 1 */
S#define  EXTI_FTSR_TR2                       ((uint32_t)0x00000004)        /*!< Falling trigger event configuration bit of line 2 */
S#define  EXTI_FTSR_TR3                       ((uint32_t)0x00000008)        /*!< Falling trigger event configuration bit of line 3 */
S#define  EXTI_FTSR_TR4                       ((uint32_t)0x00000010)        /*!< Falling trigger event configuration bit of line 4 */
S#define  EXTI_FTSR_TR5                       ((uint32_t)0x00000020)        /*!< Falling trigger event configuration bit of line 5 */
S#define  EXTI_FTSR_TR6                       ((uint32_t)0x00000040)        /*!< Falling trigger event configuration bit of line 6 */
S#define  EXTI_FTSR_TR7                       ((uint32_t)0x00000080)        /*!< Falling trigger event configuration bit of line 7 */
S#define  EXTI_FTSR_TR8                       ((uint32_t)0x00000100)        /*!< Falling trigger event configuration bit of line 8 */
S#define  EXTI_FTSR_TR9                       ((uint32_t)0x00000200)        /*!< Falling trigger event configuration bit of line 9 */
S#define  EXTI_FTSR_TR10                      ((uint32_t)0x00000400)        /*!< Falling trigger event configuration bit of line 10 */
S#define  EXTI_FTSR_TR11                      ((uint32_t)0x00000800)        /*!< Falling trigger event configuration bit of line 11 */
S#define  EXTI_FTSR_TR12                      ((uint32_t)0x00001000)        /*!< Falling trigger event configuration bit of line 12 */
S#define  EXTI_FTSR_TR13                      ((uint32_t)0x00002000)        /*!< Falling trigger event configuration bit of line 13 */
S#define  EXTI_FTSR_TR14                      ((uint32_t)0x00004000)        /*!< Falling trigger event configuration bit of line 14 */
S#define  EXTI_FTSR_TR15                      ((uint32_t)0x00008000)        /*!< Falling trigger event configuration bit of line 15 */
S#define  EXTI_FTSR_TR16                      ((uint32_t)0x00010000)        /*!< Falling trigger event configuration bit of line 16 */
S#define  EXTI_FTSR_TR17                      ((uint32_t)0x00020000)        /*!< Falling trigger event configuration bit of line 17 */
S#define  EXTI_FTSR_TR18                      ((uint32_t)0x00040000)        /*!< Falling trigger event configuration bit of line 18 */
S#define  EXTI_FTSR_TR19                      ((uint32_t)0x00080000)        /*!< Falling trigger event configuration bit of line 19 */
S
S/******************  Bit definition for EXTI_SWIER register  ******************/
S#define  EXTI_SWIER_SWIER0                   ((uint32_t)0x00000001)        /*!< Software Interrupt on line 0 */
S#define  EXTI_SWIER_SWIER1                   ((uint32_t)0x00000002)        /*!< Software Interrupt on line 1 */
S#define  EXTI_SWIER_SWIER2                   ((uint32_t)0x00000004)        /*!< Software Interrupt on line 2 */
S#define  EXTI_SWIER_SWIER3                   ((uint32_t)0x00000008)        /*!< Software Interrupt on line 3 */
S#define  EXTI_SWIER_SWIER4                   ((uint32_t)0x00000010)        /*!< Software Interrupt on line 4 */
S#define  EXTI_SWIER_SWIER5                   ((uint32_t)0x00000020)        /*!< Software Interrupt on line 5 */
S#define  EXTI_SWIER_SWIER6                   ((uint32_t)0x00000040)        /*!< Software Interrupt on line 6 */
S#define  EXTI_SWIER_SWIER7                   ((uint32_t)0x00000080)        /*!< Software Interrupt on line 7 */
S#define  EXTI_SWIER_SWIER8                   ((uint32_t)0x00000100)        /*!< Software Interrupt on line 8 */
S#define  EXTI_SWIER_SWIER9                   ((uint32_t)0x00000200)        /*!< Software Interrupt on line 9 */
S#define  EXTI_SWIER_SWIER10                  ((uint32_t)0x00000400)        /*!< Software Interrupt on line 10 */
S#define  EXTI_SWIER_SWIER11                  ((uint32_t)0x00000800)        /*!< Software Interrupt on line 11 */
S#define  EXTI_SWIER_SWIER12                  ((uint32_t)0x00001000)        /*!< Software Interrupt on line 12 */
S#define  EXTI_SWIER_SWIER13                  ((uint32_t)0x00002000)        /*!< Software Interrupt on line 13 */
S#define  EXTI_SWIER_SWIER14                  ((uint32_t)0x00004000)        /*!< Software Interrupt on line 14 */
S#define  EXTI_SWIER_SWIER15                  ((uint32_t)0x00008000)        /*!< Software Interrupt on line 15 */
S#define  EXTI_SWIER_SWIER16                  ((uint32_t)0x00010000)        /*!< Software Interrupt on line 16 */
S#define  EXTI_SWIER_SWIER17                  ((uint32_t)0x00020000)        /*!< Software Interrupt on line 17 */
S#define  EXTI_SWIER_SWIER18                  ((uint32_t)0x00040000)        /*!< Software Interrupt on line 18 */
S#define  EXTI_SWIER_SWIER19                  ((uint32_t)0x00080000)        /*!< Software Interrupt on line 19 */
S
S/*******************  Bit definition for EXTI_PR register  ********************/
S#define  EXTI_PR_PR0                         ((uint32_t)0x00000001)        /*!< Pending bit for line 0 */
S#define  EXTI_PR_PR1                         ((uint32_t)0x00000002)        /*!< Pending bit for line 1 */
S#define  EXTI_PR_PR2                         ((uint32_t)0x00000004)        /*!< Pending bit for line 2 */
S#define  EXTI_PR_PR3                         ((uint32_t)0x00000008)        /*!< Pending bit for line 3 */
S#define  EXTI_PR_PR4                         ((uint32_t)0x00000010)        /*!< Pending bit for line 4 */
S#define  EXTI_PR_PR5                         ((uint32_t)0x00000020)        /*!< Pending bit for line 5 */
S#define  EXTI_PR_PR6                         ((uint32_t)0x00000040)        /*!< Pending bit for line 6 */
S#define  EXTI_PR_PR7                         ((uint32_t)0x00000080)        /*!< Pending bit for line 7 */
S#define  EXTI_PR_PR8                         ((uint32_t)0x00000100)        /*!< Pending bit for line 8 */
S#define  EXTI_PR_PR9                         ((uint32_t)0x00000200)        /*!< Pending bit for line 9 */
S#define  EXTI_PR_PR10                        ((uint32_t)0x00000400)        /*!< Pending bit for line 10 */
S#define  EXTI_PR_PR11                        ((uint32_t)0x00000800)        /*!< Pending bit for line 11 */
S#define  EXTI_PR_PR12                        ((uint32_t)0x00001000)        /*!< Pending bit for line 12 */
S#define  EXTI_PR_PR13                        ((uint32_t)0x00002000)        /*!< Pending bit for line 13 */
S#define  EXTI_PR_PR14                        ((uint32_t)0x00004000)        /*!< Pending bit for line 14 */
S#define  EXTI_PR_PR15                        ((uint32_t)0x00008000)        /*!< Pending bit for line 15 */
S#define  EXTI_PR_PR16                        ((uint32_t)0x00010000)        /*!< Pending bit for line 16 */
S#define  EXTI_PR_PR17                        ((uint32_t)0x00020000)        /*!< Pending bit for line 17 */
S#define  EXTI_PR_PR18                        ((uint32_t)0x00040000)        /*!< Pending bit for line 18 */
S#define  EXTI_PR_PR19                        ((uint32_t)0x00080000)        /*!< Pending bit for line 19 */
S
S/******************************************************************************/
S/*                                                                            */
S/*                             DMA Controller                                 */
S/*                                                                            */
S/******************************************************************************/
S
S/*******************  Bit definition for DMA_ISR register  ********************/
S#define  DMA_ISR_GIF1                        ((uint32_t)0x00000001)        /*!< Channel 1 Global interrupt flag */
S#define  DMA_ISR_TCIF1                       ((uint32_t)0x00000002)        /*!< Channel 1 Transfer Complete flag */
S#define  DMA_ISR_HTIF1                       ((uint32_t)0x00000004)        /*!< Channel 1 Half Transfer flag */
S#define  DMA_ISR_TEIF1                       ((uint32_t)0x00000008)        /*!< Channel 1 Transfer Error flag */
S#define  DMA_ISR_GIF2                        ((uint32_t)0x00000010)        /*!< Channel 2 Global interrupt flag */
S#define  DMA_ISR_TCIF2                       ((uint32_t)0x00000020)        /*!< Channel 2 Transfer Complete flag */
S#define  DMA_ISR_HTIF2                       ((uint32_t)0x00000040)        /*!< Channel 2 Half Transfer flag */
S#define  DMA_ISR_TEIF2                       ((uint32_t)0x00000080)        /*!< Channel 2 Transfer Error flag */
S#define  DMA_ISR_GIF3                        ((uint32_t)0x00000100)        /*!< Channel 3 Global interrupt flag */
S#define  DMA_ISR_TCIF3                       ((uint32_t)0x00000200)        /*!< Channel 3 Transfer Complete flag */
S#define  DMA_ISR_HTIF3                       ((uint32_t)0x00000400)        /*!< Channel 3 Half Transfer flag */
S#define  DMA_ISR_TEIF3                       ((uint32_t)0x00000800)        /*!< Channel 3 Transfer Error flag */
S#define  DMA_ISR_GIF4                        ((uint32_t)0x00001000)        /*!< Channel 4 Global interrupt flag */
S#define  DMA_ISR_TCIF4                       ((uint32_t)0x00002000)        /*!< Channel 4 Transfer Complete flag */
S#define  DMA_ISR_HTIF4                       ((uint32_t)0x00004000)        /*!< Channel 4 Half Transfer flag */
S#define  DMA_ISR_TEIF4                       ((uint32_t)0x00008000)        /*!< Channel 4 Transfer Error flag */
S#define  DMA_ISR_GIF5                        ((uint32_t)0x00010000)        /*!< Channel 5 Global interrupt flag */
S#define  DMA_ISR_TCIF5                       ((uint32_t)0x00020000)        /*!< Channel 5 Transfer Complete flag */
S#define  DMA_ISR_HTIF5                       ((uint32_t)0x00040000)        /*!< Channel 5 Half Transfer flag */
S#define  DMA_ISR_TEIF5                       ((uint32_t)0x00080000)        /*!< Channel 5 Transfer Error flag */
S#define  DMA_ISR_GIF6                        ((uint32_t)0x00100000)        /*!< Channel 6 Global interrupt flag */
S#define  DMA_ISR_TCIF6                       ((uint32_t)0x00200000)        /*!< Channel 6 Transfer Complete flag */
S#define  DMA_ISR_HTIF6                       ((uint32_t)0x00400000)        /*!< Channel 6 Half Transfer flag */
S#define  DMA_ISR_TEIF6                       ((uint32_t)0x00800000)        /*!< Channel 6 Transfer Error flag */
S#define  DMA_ISR_GIF7                        ((uint32_t)0x01000000)        /*!< Channel 7 Global interrupt flag */
S#define  DMA_ISR_TCIF7                       ((uint32_t)0x02000000)        /*!< Channel 7 Transfer Complete flag */
S#define  DMA_ISR_HTIF7                       ((uint32_t)0x04000000)        /*!< Channel 7 Half Transfer flag */
S#define  DMA_ISR_TEIF7                       ((uint32_t)0x08000000)        /*!< Channel 7 Transfer Error flag */
S
S/*******************  Bit definition for DMA_IFCR register  *******************/
S#define  DMA_IFCR_CGIF1                      ((uint32_t)0x00000001)        /*!< Channel 1 Global interrupt clear */
S#define  DMA_IFCR_CTCIF1                     ((uint32_t)0x00000002)        /*!< Channel 1 Transfer Complete clear */
S#define  DMA_IFCR_CHTIF1                     ((uint32_t)0x00000004)        /*!< Channel 1 Half Transfer clear */
S#define  DMA_IFCR_CTEIF1                     ((uint32_t)0x00000008)        /*!< Channel 1 Transfer Error clear */
S#define  DMA_IFCR_CGIF2                      ((uint32_t)0x00000010)        /*!< Channel 2 Global interrupt clear */
S#define  DMA_IFCR_CTCIF2                     ((uint32_t)0x00000020)        /*!< Channel 2 Transfer Complete clear */
S#define  DMA_IFCR_CHTIF2                     ((uint32_t)0x00000040)        /*!< Channel 2 Half Transfer clear */
S#define  DMA_IFCR_CTEIF2                     ((uint32_t)0x00000080)        /*!< Channel 2 Transfer Error clear */
S#define  DMA_IFCR_CGIF3                      ((uint32_t)0x00000100)        /*!< Channel 3 Global interrupt clear */
S#define  DMA_IFCR_CTCIF3                     ((uint32_t)0x00000200)        /*!< Channel 3 Transfer Complete clear */
S#define  DMA_IFCR_CHTIF3                     ((uint32_t)0x00000400)        /*!< Channel 3 Half Transfer clear */
S#define  DMA_IFCR_CTEIF3                     ((uint32_t)0x00000800)        /*!< Channel 3 Transfer Error clear */
S#define  DMA_IFCR_CGIF4                      ((uint32_t)0x00001000)        /*!< Channel 4 Global interrupt clear */
S#define  DMA_IFCR_CTCIF4                     ((uint32_t)0x00002000)        /*!< Channel 4 Transfer Complete clear */
S#define  DMA_IFCR_CHTIF4                     ((uint32_t)0x00004000)        /*!< Channel 4 Half Transfer clear */
S#define  DMA_IFCR_CTEIF4                     ((uint32_t)0x00008000)        /*!< Channel 4 Transfer Error clear */
S#define  DMA_IFCR_CGIF5                      ((uint32_t)0x00010000)        /*!< Channel 5 Global interrupt clear */
S#define  DMA_IFCR_CTCIF5                     ((uint32_t)0x00020000)        /*!< Channel 5 Transfer Complete clear */
S#define  DMA_IFCR_CHTIF5                     ((uint32_t)0x00040000)        /*!< Channel 5 Half Transfer clear */
S#define  DMA_IFCR_CTEIF5                     ((uint32_t)0x00080000)        /*!< Channel 5 Transfer Error clear */
S#define  DMA_IFCR_CGIF6                      ((uint32_t)0x00100000)        /*!< Channel 6 Global interrupt clear */
S#define  DMA_IFCR_CTCIF6                     ((uint32_t)0x00200000)        /*!< Channel 6 Transfer Complete clear */
S#define  DMA_IFCR_CHTIF6                     ((uint32_t)0x00400000)        /*!< Channel 6 Half Transfer clear */
S#define  DMA_IFCR_CTEIF6                     ((uint32_t)0x00800000)        /*!< Channel 6 Transfer Error clear */
S#define  DMA_IFCR_CGIF7                      ((uint32_t)0x01000000)        /*!< Channel 7 Global interrupt clear */
S#define  DMA_IFCR_CTCIF7                     ((uint32_t)0x02000000)        /*!< Channel 7 Transfer Complete clear */
S#define  DMA_IFCR_CHTIF7                     ((uint32_t)0x04000000)        /*!< Channel 7 Half Transfer clear */
S#define  DMA_IFCR_CTEIF7                     ((uint32_t)0x08000000)        /*!< Channel 7 Transfer Error clear */
S
S/*******************  Bit definition for DMA_CCR1 register  *******************/
S#define  DMA_CCR1_EN                         ((uint16_t)0x0001)            /*!< Channel enable*/
S#define  DMA_CCR1_TCIE                       ((uint16_t)0x0002)            /*!< Transfer complete interrupt enable */
S#define  DMA_CCR1_HTIE                       ((uint16_t)0x0004)            /*!< Half Transfer interrupt enable */
S#define  DMA_CCR1_TEIE                       ((uint16_t)0x0008)            /*!< Transfer error interrupt enable */
S#define  DMA_CCR1_DIR                        ((uint16_t)0x0010)            /*!< Data transfer direction */
S#define  DMA_CCR1_CIRC                       ((uint16_t)0x0020)            /*!< Circular mode */
S#define  DMA_CCR1_PINC                       ((uint16_t)0x0040)            /*!< Peripheral increment mode */
S#define  DMA_CCR1_MINC                       ((uint16_t)0x0080)            /*!< Memory increment mode */
S
S#define  DMA_CCR1_PSIZE                      ((uint16_t)0x0300)            /*!< PSIZE[1:0] bits (Peripheral size) */
S#define  DMA_CCR1_PSIZE_0                    ((uint16_t)0x0100)            /*!< Bit 0 */
S#define  DMA_CCR1_PSIZE_1                    ((uint16_t)0x0200)            /*!< Bit 1 */
S
S#define  DMA_CCR1_MSIZE                      ((uint16_t)0x0C00)            /*!< MSIZE[1:0] bits (Memory size) */
S#define  DMA_CCR1_MSIZE_0                    ((uint16_t)0x0400)            /*!< Bit 0 */
S#define  DMA_CCR1_MSIZE_1                    ((uint16_t)0x0800)            /*!< Bit 1 */
S
S#define  DMA_CCR1_PL                         ((uint16_t)0x3000)            /*!< PL[1:0] bits(Channel Priority level) */
S#define  DMA_CCR1_PL_0                       ((uint16_t)0x1000)            /*!< Bit 0 */
S#define  DMA_CCR1_PL_1                       ((uint16_t)0x2000)            /*!< Bit 1 */
S
S#define  DMA_CCR1_MEM2MEM                    ((uint16_t)0x4000)            /*!< Memory to memory mode */
S
S/*******************  Bit definition for DMA_CCR2 register  *******************/
S#define  DMA_CCR2_EN                         ((uint16_t)0x0001)            /*!< Channel enable */
S#define  DMA_CCR2_TCIE                       ((uint16_t)0x0002)            /*!< Transfer complete interrupt enable */
S#define  DMA_CCR2_HTIE                       ((uint16_t)0x0004)            /*!< Half Transfer interrupt enable */
S#define  DMA_CCR2_TEIE                       ((uint16_t)0x0008)            /*!< Transfer error interrupt enable */
S#define  DMA_CCR2_DIR                        ((uint16_t)0x0010)            /*!< Data transfer direction */
S#define  DMA_CCR2_CIRC                       ((uint16_t)0x0020)            /*!< Circular mode */
S#define  DMA_CCR2_PINC                       ((uint16_t)0x0040)            /*!< Peripheral increment mode */
S#define  DMA_CCR2_MINC                       ((uint16_t)0x0080)            /*!< Memory increment mode */
S
S#define  DMA_CCR2_PSIZE                      ((uint16_t)0x0300)            /*!< PSIZE[1:0] bits (Peripheral size) */
S#define  DMA_CCR2_PSIZE_0                    ((uint16_t)0x0100)            /*!< Bit 0 */
S#define  DMA_CCR2_PSIZE_1                    ((uint16_t)0x0200)            /*!< Bit 1 */
S
S#define  DMA_CCR2_MSIZE                      ((uint16_t)0x0C00)            /*!< MSIZE[1:0] bits (Memory size) */
S#define  DMA_CCR2_MSIZE_0                    ((uint16_t)0x0400)            /*!< Bit 0 */
S#define  DMA_CCR2_MSIZE_1                    ((uint16_t)0x0800)            /*!< Bit 1 */
S
S#define  DMA_CCR2_PL                         ((uint16_t)0x3000)            /*!< PL[1:0] bits (Channel Priority level) */
S#define  DMA_CCR2_PL_0                       ((uint16_t)0x1000)            /*!< Bit 0 */
S#define  DMA_CCR2_PL_1                       ((uint16_t)0x2000)            /*!< Bit 1 */
S
S#define  DMA_CCR2_MEM2MEM                    ((uint16_t)0x4000)            /*!< Memory to memory mode */
S
S/*******************  Bit definition for DMA_CCR3 register  *******************/
S#define  DMA_CCR3_EN                         ((uint16_t)0x0001)            /*!< Channel enable */
S#define  DMA_CCR3_TCIE                       ((uint16_t)0x0002)            /*!< Transfer complete interrupt enable */
S#define  DMA_CCR3_HTIE                       ((uint16_t)0x0004)            /*!< Half Transfer interrupt enable */
S#define  DMA_CCR3_TEIE                       ((uint16_t)0x0008)            /*!< Transfer error interrupt enable */
S#define  DMA_CCR3_DIR                        ((uint16_t)0x0010)            /*!< Data transfer direction */
S#define  DMA_CCR3_CIRC                       ((uint16_t)0x0020)            /*!< Circular mode */
S#define  DMA_CCR3_PINC                       ((uint16_t)0x0040)            /*!< Peripheral increment mode */
S#define  DMA_CCR3_MINC                       ((uint16_t)0x0080)            /*!< Memory increment mode */
S
S#define  DMA_CCR3_PSIZE                      ((uint16_t)0x0300)            /*!< PSIZE[1:0] bits (Peripheral size) */
S#define  DMA_CCR3_PSIZE_0                    ((uint16_t)0x0100)            /*!< Bit 0 */
S#define  DMA_CCR3_PSIZE_1                    ((uint16_t)0x0200)            /*!< Bit 1 */
S
S#define  DMA_CCR3_MSIZE                      ((uint16_t)0x0C00)            /*!< MSIZE[1:0] bits (Memory size) */
S#define  DMA_CCR3_MSIZE_0                    ((uint16_t)0x0400)            /*!< Bit 0 */
S#define  DMA_CCR3_MSIZE_1                    ((uint16_t)0x0800)            /*!< Bit 1 */
S
S#define  DMA_CCR3_PL                         ((uint16_t)0x3000)            /*!< PL[1:0] bits (Channel Priority level) */
S#define  DMA_CCR3_PL_0                       ((uint16_t)0x1000)            /*!< Bit 0 */
S#define  DMA_CCR3_PL_1                       ((uint16_t)0x2000)            /*!< Bit 1 */
S
S#define  DMA_CCR3_MEM2MEM                    ((uint16_t)0x4000)            /*!< Memory to memory mode */
S
S/*!<******************  Bit definition for DMA_CCR4 register  *******************/
S#define  DMA_CCR4_EN                         ((uint16_t)0x0001)            /*!< Channel enable */
S#define  DMA_CCR4_TCIE                       ((uint16_t)0x0002)            /*!< Transfer complete interrupt enable */
S#define  DMA_CCR4_HTIE                       ((uint16_t)0x0004)            /*!< Half Transfer interrupt enable */
S#define  DMA_CCR4_TEIE                       ((uint16_t)0x0008)            /*!< Transfer error interrupt enable */
S#define  DMA_CCR4_DIR                        ((uint16_t)0x0010)            /*!< Data transfer direction */
S#define  DMA_CCR4_CIRC                       ((uint16_t)0x0020)            /*!< Circular mode */
S#define  DMA_CCR4_PINC                       ((uint16_t)0x0040)            /*!< Peripheral increment mode */
S#define  DMA_CCR4_MINC                       ((uint16_t)0x0080)            /*!< Memory increment mode */
S
S#define  DMA_CCR4_PSIZE                      ((uint16_t)0x0300)            /*!< PSIZE[1:0] bits (Peripheral size) */
S#define  DMA_CCR4_PSIZE_0                    ((uint16_t)0x0100)            /*!< Bit 0 */
S#define  DMA_CCR4_PSIZE_1                    ((uint16_t)0x0200)            /*!< Bit 1 */
S
S#define  DMA_CCR4_MSIZE                      ((uint16_t)0x0C00)            /*!< MSIZE[1:0] bits (Memory size) */
S#define  DMA_CCR4_MSIZE_0                    ((uint16_t)0x0400)            /*!< Bit 0 */
S#define  DMA_CCR4_MSIZE_1                    ((uint16_t)0x0800)            /*!< Bit 1 */
S
S#define  DMA_CCR4_PL                         ((uint16_t)0x3000)            /*!< PL[1:0] bits (Channel Priority level) */
S#define  DMA_CCR4_PL_0                       ((uint16_t)0x1000)            /*!< Bit 0 */
S#define  DMA_CCR4_PL_1                       ((uint16_t)0x2000)            /*!< Bit 1 */
S
S#define  DMA_CCR4_MEM2MEM                    ((uint16_t)0x4000)            /*!< Memory to memory mode */
S
S/******************  Bit definition for DMA_CCR5 register  *******************/
S#define  DMA_CCR5_EN                         ((uint16_t)0x0001)            /*!< Channel enable */
S#define  DMA_CCR5_TCIE                       ((uint16_t)0x0002)            /*!< Transfer complete interrupt enable */
S#define  DMA_CCR5_HTIE                       ((uint16_t)0x0004)            /*!< Half Transfer interrupt enable */
S#define  DMA_CCR5_TEIE                       ((uint16_t)0x0008)            /*!< Transfer error interrupt enable */
S#define  DMA_CCR5_DIR                        ((uint16_t)0x0010)            /*!< Data transfer direction */
S#define  DMA_CCR5_CIRC                       ((uint16_t)0x0020)            /*!< Circular mode */
S#define  DMA_CCR5_PINC                       ((uint16_t)0x0040)            /*!< Peripheral increment mode */
S#define  DMA_CCR5_MINC                       ((uint16_t)0x0080)            /*!< Memory increment mode */
S
S#define  DMA_CCR5_PSIZE                      ((uint16_t)0x0300)            /*!< PSIZE[1:0] bits (Peripheral size) */
S#define  DMA_CCR5_PSIZE_0                    ((uint16_t)0x0100)            /*!< Bit 0 */
S#define  DMA_CCR5_PSIZE_1                    ((uint16_t)0x0200)            /*!< Bit 1 */
S
S#define  DMA_CCR5_MSIZE                      ((uint16_t)0x0C00)            /*!< MSIZE[1:0] bits (Memory size) */
S#define  DMA_CCR5_MSIZE_0                    ((uint16_t)0x0400)            /*!< Bit 0 */
S#define  DMA_CCR5_MSIZE_1                    ((uint16_t)0x0800)            /*!< Bit 1 */
S
S#define  DMA_CCR5_PL                         ((uint16_t)0x3000)            /*!< PL[1:0] bits (Channel Priority level) */
S#define  DMA_CCR5_PL_0                       ((uint16_t)0x1000)            /*!< Bit 0 */
S#define  DMA_CCR5_PL_1                       ((uint16_t)0x2000)            /*!< Bit 1 */
S
S#define  DMA_CCR5_MEM2MEM                    ((uint16_t)0x4000)            /*!< Memory to memory mode enable */
S
S/*******************  Bit definition for DMA_CCR6 register  *******************/
S#define  DMA_CCR6_EN                         ((uint16_t)0x0001)            /*!< Channel enable */
S#define  DMA_CCR6_TCIE                       ((uint16_t)0x0002)            /*!< Transfer complete interrupt enable */
S#define  DMA_CCR6_HTIE                       ((uint16_t)0x0004)            /*!< Half Transfer interrupt enable */
S#define  DMA_CCR6_TEIE                       ((uint16_t)0x0008)            /*!< Transfer error interrupt enable */
S#define  DMA_CCR6_DIR                        ((uint16_t)0x0010)            /*!< Data transfer direction */
S#define  DMA_CCR6_CIRC                       ((uint16_t)0x0020)            /*!< Circular mode */
S#define  DMA_CCR6_PINC                       ((uint16_t)0x0040)            /*!< Peripheral increment mode */
S#define  DMA_CCR6_MINC                       ((uint16_t)0x0080)            /*!< Memory increment mode */
S
S#define  DMA_CCR6_PSIZE                      ((uint16_t)0x0300)            /*!< PSIZE[1:0] bits (Peripheral size) */
S#define  DMA_CCR6_PSIZE_0                    ((uint16_t)0x0100)            /*!< Bit 0 */
S#define  DMA_CCR6_PSIZE_1                    ((uint16_t)0x0200)            /*!< Bit 1 */
S
S#define  DMA_CCR6_MSIZE                      ((uint16_t)0x0C00)            /*!< MSIZE[1:0] bits (Memory size) */
S#define  DMA_CCR6_MSIZE_0                    ((uint16_t)0x0400)            /*!< Bit 0 */
S#define  DMA_CCR6_MSIZE_1                    ((uint16_t)0x0800)            /*!< Bit 1 */
S
S#define  DMA_CCR6_PL                         ((uint16_t)0x3000)            /*!< PL[1:0] bits (Channel Priority level) */
S#define  DMA_CCR6_PL_0                       ((uint16_t)0x1000)            /*!< Bit 0 */
S#define  DMA_CCR6_PL_1                       ((uint16_t)0x2000)            /*!< Bit 1 */
S
S#define  DMA_CCR6_MEM2MEM                    ((uint16_t)0x4000)            /*!< Memory to memory mode */
S
S/*******************  Bit definition for DMA_CCR7 register  *******************/
S#define  DMA_CCR7_EN                         ((uint16_t)0x0001)            /*!< Channel enable */
S#define  DMA_CCR7_TCIE                       ((uint16_t)0x0002)            /*!< Transfer complete interrupt enable */
S#define  DMA_CCR7_HTIE                       ((uint16_t)0x0004)            /*!< Half Transfer interrupt enable */
S#define  DMA_CCR7_TEIE                       ((uint16_t)0x0008)            /*!< Transfer error interrupt enable */
S#define  DMA_CCR7_DIR                        ((uint16_t)0x0010)            /*!< Data transfer direction */
S#define  DMA_CCR7_CIRC                       ((uint16_t)0x0020)            /*!< Circular mode */
S#define  DMA_CCR7_PINC                       ((uint16_t)0x0040)            /*!< Peripheral increment mode */
S#define  DMA_CCR7_MINC                       ((uint16_t)0x0080)            /*!< Memory increment mode */
S
S#define  DMA_CCR7_PSIZE            ,         ((uint16_t)0x0300)            /*!< PSIZE[1:0] bits (Peripheral size) */
S#define  DMA_CCR7_PSIZE_0                    ((uint16_t)0x0100)            /*!< Bit 0 */
S#define  DMA_CCR7_PSIZE_1                    ((uint16_t)0x0200)            /*!< Bit 1 */
S
S#define  DMA_CCR7_MSIZE                      ((uint16_t)0x0C00)            /*!< MSIZE[1:0] bits (Memory size) */
S#define  DMA_CCR7_MSIZE_0                    ((uint16_t)0x0400)            /*!< Bit 0 */
S#define  DMA_CCR7_MSIZE_1                    ((uint16_t)0x0800)            /*!< Bit 1 */
S
S#define  DMA_CCR7_PL                         ((uint16_t)0x3000)            /*!< PL[1:0] bits (Channel Priority level) */
S#define  DMA_CCR7_PL_0                       ((uint16_t)0x1000)            /*!< Bit 0 */
S#define  DMA_CCR7_PL_1                       ((uint16_t)0x2000)            /*!< Bit 1 */
S
S#define  DMA_CCR7_MEM2MEM                    ((uint16_t)0x4000)            /*!< Memory to memory mode enable */
S
S/******************  Bit definition for DMA_CNDTR1 register  ******************/
S#define  DMA_CNDTR1_NDT                      ((uint16_t)0xFFFF)            /*!< Number of data to Transfer */
S
S/******************  Bit definition for DMA_CNDTR2 register  ******************/
S#define  DMA_CNDTR2_NDT                      ((uint16_t)0xFFFF)            /*!< Number of data to Transfer */
S
S/******************  Bit definition for DMA_CNDTR3 register  ******************/
S#define  DMA_CNDTR3_NDT                      ((uint16_t)0xFFFF)            /*!< Number of data to Transfer */
S
S/******************  Bit definition for DMA_CNDTR4 register  ******************/
S#define  DMA_CNDTR4_NDT                      ((uint16_t)0xFFFF)            /*!< Number of data to Transfer */
S
S/******************  Bit definition for DMA_CNDTR5 register  ******************/
S#define  DMA_CNDTR5_NDT                      ((uint16_t)0xFFFF)            /*!< Number of data to Transfer */
S
S/******************  Bit definition for DMA_CNDTR6 register  ******************/
S#define  DMA_CNDTR6_NDT                      ((uint16_t)0xFFFF)            /*!< Number of data to Transfer */
S
S/******************  Bit definition for DMA_CNDTR7 register  ******************/
S#define  DMA_CNDTR7_NDT                      ((uint16_t)0xFFFF)            /*!< Number of data to Transfer */
S
S/******************  Bit definition for DMA_CPAR1 register  *******************/
S#define  DMA_CPAR1_PA                        ((uint32_t)0xFFFFFFFF)        /*!< Peripheral Address */
S
S/******************  Bit definition for DMA_CPAR2 register  *******************/
S#define  DMA_CPAR2_PA                        ((uint32_t)0xFFFFFFFF)        /*!< Peripheral Address */
S
S/******************  Bit definition for DMA_CPAR3 register  *******************/
S#define  DMA_CPAR3_PA                        ((uint32_t)0xFFFFFFFF)        /*!< Peripheral Address */
S
S
S/******************  Bit definition for DMA_CPAR4 register  *******************/
S#define  DMA_CPAR4_PA                        ((uint32_t)0xFFFFFFFF)        /*!< Peripheral Address */
S
S/******************  Bit definition for DMA_CPAR5 register  *******************/
S#define  DMA_CPAR5_PA                        ((uint32_t)0xFFFFFFFF)        /*!< Peripheral Address */
S
S/******************  Bit definition for DMA_CPAR6 register  *******************/
S#define  DMA_CPAR6_PA                        ((uint32_t)0xFFFFFFFF)        /*!< Peripheral Address */
S
S
S/******************  Bit definition for DMA_CPAR7 register  *******************/
S#define  DMA_CPAR7_PA                        ((uint32_t)0xFFFFFFFF)        /*!< Peripheral Address */
S
S/******************  Bit definition for DMA_CMAR1 register  *******************/
S#define  DMA_CMAR1_MA                        ((uint32_t)0xFFFFFFFF)        /*!< Memory Address */
S
S/******************  Bit definition for DMA_CMAR2 register  *******************/
S#define  DMA_CMAR2_MA                        ((uint32_t)0xFFFFFFFF)        /*!< Memory Address */
S
S/******************  Bit definition for DMA_CMAR3 register  *******************/
S#define  DMA_CMAR3_MA                        ((uint32_t)0xFFFFFFFF)        /*!< Memory Address */
S
S
S/******************  Bit definition for DMA_CMAR4 register  *******************/
S#define  DMA_CMAR4_MA                        ((uint32_t)0xFFFFFFFF)        /*!< Memory Address */
S
S/******************  Bit definition for DMA_CMAR5 register  *******************/
S#define  DMA_CMAR5_MA                        ((uint32_t)0xFFFFFFFF)        /*!< Memory Address */
S
S/******************  Bit definition for DMA_CMAR6 register  *******************/
S#define  DMA_CMAR6_MA                        ((uint32_t)0xFFFFFFFF)        /*!< Memory Address */
S
S/******************  Bit definition for DMA_CMAR7 register  *******************/
S#define  DMA_CMAR7_MA                        ((uint32_t)0xFFFFFFFF)        /*!< Memory Address */
S
S/******************************************************************************/
S/*                                                                            */
S/*                        Analog to Digital Converter                         */
S/*                                                                            */
S/******************************************************************************/
S
S/********************  Bit definition for ADC_SR register  ********************/
S#define  ADC_SR_AWD                          ((uint8_t)0x01)               /*!< Analog watchdog flag */
S#define  ADC_SR_EOC                          ((uint8_t)0x02)               /*!< End of conversion */
S#define  ADC_SR_JEOC                         ((uint8_t)0x04)               /*!< Injected channel end of conversion */
S#define  ADC_SR_JSTRT                        ((uint8_t)0x08)               /*!< Injected channel Start flag */
S#define  ADC_SR_STRT                         ((uint8_t)0x10)               /*!< Regular channel Start flag */
S
S/*******************  Bit definition for ADC_CR1 register  ********************/
S#define  ADC_CR1_AWDCH                       ((uint32_t)0x0000001F)        /*!< AWDCH[4:0] bits (Analog watchdog channel select bits) */
S#define  ADC_CR1_AWDCH_0                     ((uint32_t)0x00000001)        /*!< Bit 0 */
S#define  ADC_CR1_AWDCH_1                     ((uint32_t)0x00000002)        /*!< Bit 1 */
S#define  ADC_CR1_AWDCH_2                     ((uint32_t)0x00000004)        /*!< Bit 2 */
S#define  ADC_CR1_AWDCH_3                     ((uint32_t)0x00000008)        /*!< Bit 3 */
S#define  ADC_CR1_AWDCH_4                     ((uint32_t)0x00000010)        /*!< Bit 4 */
S
S#define  ADC_CR1_EOCIE                       ((uint32_t)0x00000020)        /*!< Interrupt enable for EOC */
S#define  ADC_CR1_AWDIE                       ((uint32_t)0x00000040)        /*!< Analog Watchdog interrupt enable */
S#define  ADC_CR1_JEOCIE                      ((uint32_t)0x00000080)        /*!< Interrupt enable for injected channels */
S#define  ADC_CR1_SCAN                        ((uint32_t)0x00000100)        /*!< Scan mode */
S#define  ADC_CR1_AWDSGL                      ((uint32_t)0x00000200)        /*!< Enable the watchdog on a single channel in scan mode */
S#define  ADC_CR1_JAUTO                       ((uint32_t)0x00000400)        /*!< Automatic injected group conversion */
S#define  ADC_CR1_DISCEN                      ((uint32_t)0x00000800)        /*!< Discontinuous mode on regular channels */
S#define  ADC_CR1_JDISCEN                     ((uint32_t)0x00001000)        /*!< Discontinuous mode on injected channels */
S
S#define  ADC_CR1_DISCNUM                     ((uint32_t)0x0000E000)        /*!< DISCNUM[2:0] bits (Discontinuous mode channel count) */
S#define  ADC_CR1_DISCNUM_0                   ((uint32_t)0x00002000)        /*!< Bit 0 */
S#define  ADC_CR1_DISCNUM_1                   ((uint32_t)0x00004000)        /*!< Bit 1 */
S#define  ADC_CR1_DISCNUM_2                   ((uint32_t)0x00008000)        /*!< Bit 2 */
S
S#define  ADC_CR1_DUALMOD                     ((uint32_t)0x000F0000)        /*!< DUALMOD[3:0] bits (Dual mode selection) */
S#define  ADC_CR1_DUALMOD_0                   ((uint32_t)0x00010000)        /*!< Bit 0 */
S#define  ADC_CR1_DUALMOD_1                   ((uint32_t)0x00020000)        /*!< Bit 1 */
S#define  ADC_CR1_DUALMOD_2                   ((uint32_t)0x00040000)        /*!< Bit 2 */
S#define  ADC_CR1_DUALMOD_3                   ((uint32_t)0x00080000)        /*!< Bit 3 */
S
S#define  ADC_CR1_JAWDEN                      ((uint32_t)0x00400000)        /*!< Analog watchdog enable on injected channels */
S#define  ADC_CR1_AWDEN                       ((uint32_t)0x00800000)        /*!< Analog watchdog enable on regular channels */
S
S  
S/*******************  Bit definition for ADC_CR2 register  ********************/
S#define  ADC_CR2_ADON                        ((uint32_t)0x00000001)        /*!< A/D Converter ON / OFF */
S#define  ADC_CR2_CONT                        ((uint32_t)0x00000002)        /*!< Continuous Conversion */
S#define  ADC_CR2_CAL                         ((uint32_t)0x00000004)        /*!< A/D Calibration */
S#define  ADC_CR2_RSTCAL                      ((uint32_t)0x00000008)        /*!< Reset Calibration */
S#define  ADC_CR2_DMA                         ((uint32_t)0x00000100)        /*!< Direct Memory access mode */
S#define  ADC_CR2_ALIGN                       ((uint32_t)0x00000800)        /*!< Data Alignment */
S
S#define  ADC_CR2_JEXTSEL                     ((uint32_t)0x00007000)        /*!< JEXTSEL[2:0] bits (External event select for injected group) */
S#define  ADC_CR2_JEXTSEL_0                   ((uint32_t)0x00001000)        /*!< Bit 0 */
S#define  ADC_CR2_JEXTSEL_1                   ((uint32_t)0x00002000)        /*!< Bit 1 */
S#define  ADC_CR2_JEXTSEL_2                   ((uint32_t)0x00004000)        /*!< Bit 2 */
S
S#define  ADC_CR2_JEXTTRIG                    ((uint32_t)0x00008000)        /*!< External Trigger Conversion mode for injected channels */
S
S#define  ADC_CR2_EXTSEL                      ((uint32_t)0x000E0000)        /*!< EXTSEL[2:0] bits (External Event Select for regular group) */
S#define  ADC_CR2_EXTSEL_0                    ((uint32_t)0x00020000)        /*!< Bit 0 */
S#define  ADC_CR2_EXTSEL_1                    ((uint32_t)0x00040000)        /*!< Bit 1 */
S#define  ADC_CR2_EXTSEL_2                    ((uint32_t)0x00080000)        /*!< Bit 2 */
S
S#define  ADC_CR2_EXTTRIG                     ((uint32_t)0x00100000)        /*!< External Trigger Conversion mode for regular channels */
S#define  ADC_CR2_JSWSTART                    ((uint32_t)0x00200000)        /*!< Start Conversion of injected channels */
S#define  ADC_CR2_SWSTART                     ((uint32_t)0x00400000)        /*!< Start Conversion of regular channels */
S#define  ADC_CR2_TSVREFE                     ((uint32_t)0x00800000)        /*!< Temperature Sensor and VREFINT Enable */
S
S/******************  Bit definition for ADC_SMPR1 register  *******************/
S#define  ADC_SMPR1_SMP10                     ((uint32_t)0x00000007)        /*!< SMP10[2:0] bits (Channel 10 Sample time selection) */
S#define  ADC_SMPR1_SMP10_0                   ((uint32_t)0x00000001)        /*!< Bit 0 */
S#define  ADC_SMPR1_SMP10_1                   ((uint32_t)0x00000002)        /*!< Bit 1 */
S#define  ADC_SMPR1_SMP10_2                   ((uint32_t)0x00000004)        /*!< Bit 2 */
S
S#define  ADC_SMPR1_SMP11                     ((uint32_t)0x00000038)        /*!< SMP11[2:0] bits (Channel 11 Sample time selection) */
S#define  ADC_SMPR1_SMP11_0                   ((uint32_t)0x00000008)        /*!< Bit 0 */
S#define  ADC_SMPR1_SMP11_1                   ((uint32_t)0x00000010)        /*!< Bit 1 */
S#define  ADC_SMPR1_SMP11_2                   ((uint32_t)0x00000020)        /*!< Bit 2 */
S
S#define  ADC_SMPR1_SMP12                     ((uint32_t)0x000001C0)        /*!< SMP12[2:0] bits (Channel 12 Sample time selection) */
S#define  ADC_SMPR1_SMP12_0                   ((uint32_t)0x00000040)        /*!< Bit 0 */
S#define  ADC_SMPR1_SMP12_1                   ((uint32_t)0x00000080)        /*!< Bit 1 */
S#define  ADC_SMPR1_SMP12_2                   ((uint32_t)0x00000100)        /*!< Bit 2 */
S
S#define  ADC_SMPR1_SMP13                     ((uint32_t)0x00000E00)        /*!< SMP13[2:0] bits (Channel 13 Sample time selection) */
S#define  ADC_SMPR1_SMP13_0                   ((uint32_t)0x00000200)        /*!< Bit 0 */
S#define  ADC_SMPR1_SMP13_1                   ((uint32_t)0x00000400)        /*!< Bit 1 */
S#define  ADC_SMPR1_SMP13_2                   ((uint32_t)0x00000800)        /*!< Bit 2 */
S
S#define  ADC_SMPR1_SMP14                     ((uint32_t)0x00007000)        /*!< SMP14[2:0] bits (Channel 14 Sample time selection) */
S#define  ADC_SMPR1_SMP14_0                   ((uint32_t)0x00001000)        /*!< Bit 0 */
S#define  ADC_SMPR1_SMP14_1                   ((uint32_t)0x00002000)        /*!< Bit 1 */
S#define  ADC_SMPR1_SMP14_2                   ((uint32_t)0x00004000)        /*!< Bit 2 */
S
S#define  ADC_SMPR1_SMP15                     ((uint32_t)0x00038000)        /*!< SMP15[2:0] bits (Channel 15 Sample time selection) */
S#define  ADC_SMPR1_SMP15_0                   ((uint32_t)0x00008000)        /*!< Bit 0 */
S#define  ADC_SMPR1_SMP15_1                   ((uint32_t)0x00010000)        /*!< Bit 1 */
S#define  ADC_SMPR1_SMP15_2                   ((uint32_t)0x00020000)        /*!< Bit 2 */
S
S#define  ADC_SMPR1_SMP16                     ((uint32_t)0x001C0000)        /*!< SMP16[2:0] bits (Channel 16 Sample time selection) */
S#define  ADC_SMPR1_SMP16_0                   ((uint32_t)0x00040000)        /*!< Bit 0 */
S#define  ADC_SMPR1_SMP16_1                   ((uint32_t)0x00080000)        /*!< Bit 1 */
S#define  ADC_SMPR1_SMP16_2                   ((uint32_t)0x00100000)        /*!< Bit 2 */
S
S#define  ADC_SMPR1_SMP17                     ((uint32_t)0x00E00000)        /*!< SMP17[2:0] bits (Channel 17 Sample time selection) */
S#define  ADC_SMPR1_SMP17_0                   ((uint32_t)0x00200000)        /*!< Bit 0 */
S#define  ADC_SMPR1_SMP17_1                   ((uint32_t)0x00400000)        /*!< Bit 1 */
S#define  ADC_SMPR1_SMP17_2                   ((uint32_t)0x00800000)        /*!< Bit 2 */
S
S/******************  Bit definition for ADC_SMPR2 register  *******************/
S#define  ADC_SMPR2_SMP0                      ((uint32_t)0x00000007)        /*!< SMP0[2:0] bits (Channel 0 Sample time selection) */
S#define  ADC_SMPR2_SMP0_0                    ((uint32_t)0x00000001)        /*!< Bit 0 */
S#define  ADC_SMPR2_SMP0_1                    ((uint32_t)0x00000002)        /*!< Bit 1 */
S#define  ADC_SMPR2_SMP0_2                    ((uint32_t)0x00000004)        /*!< Bit 2 */
S
S#define  ADC_SMPR2_SMP1                      ((uint32_t)0x00000038)        /*!< SMP1[2:0] bits (Channel 1 Sample time selection) */
S#define  ADC_SMPR2_SMP1_0                    ((uint32_t)0x00000008)        /*!< Bit 0 */
S#define  ADC_SMPR2_SMP1_1                    ((uint32_t)0x00000010)        /*!< Bit 1 */
S#define  ADC_SMPR2_SMP1_2                    ((uint32_t)0x00000020)        /*!< Bit 2 */
S
S#define  ADC_SMPR2_SMP2                      ((uint32_t)0x000001C0)        /*!< SMP2[2:0] bits (Channel 2 Sample time selection) */
S#define  ADC_SMPR2_SMP2_0                    ((uint32_t)0x00000040)        /*!< Bit 0 */
S#define  ADC_SMPR2_SMP2_1                    ((uint32_t)0x00000080)        /*!< Bit 1 */
S#define  ADC_SMPR2_SMP2_2                    ((uint32_t)0x00000100)        /*!< Bit 2 */
S
S#define  ADC_SMPR2_SMP3                      ((uint32_t)0x00000E00)        /*!< SMP3[2:0] bits (Channel 3 Sample time selection) */
S#define  ADC_SMPR2_SMP3_0                    ((uint32_t)0x00000200)        /*!< Bit 0 */
S#define  ADC_SMPR2_SMP3_1                    ((uint32_t)0x00000400)        /*!< Bit 1 */
S#define  ADC_SMPR2_SMP3_2                    ((uint32_t)0x00000800)        /*!< Bit 2 */
S
S#define  ADC_SMPR2_SMP4                      ((uint32_t)0x00007000)        /*!< SMP4[2:0] bits (Channel 4 Sample time selection) */
S#define  ADC_SMPR2_SMP4_0                    ((uint32_t)0x00001000)        /*!< Bit 0 */
S#define  ADC_SMPR2_SMP4_1                    ((uint32_t)0x00002000)        /*!< Bit 1 */
S#define  ADC_SMPR2_SMP4_2                    ((uint32_t)0x00004000)        /*!< Bit 2 */
S
S#define  ADC_SMPR2_SMP5                      ((uint32_t)0x00038000)        /*!< SMP5[2:0] bits (Channel 5 Sample time selection) */
S#define  ADC_SMPR2_SMP5_0                    ((uint32_t)0x00008000)        /*!< Bit 0 */
S#define  ADC_SMPR2_SMP5_1                    ((uint32_t)0x00010000)        /*!< Bit 1 */
S#define  ADC_SMPR2_SMP5_2                    ((uint32_t)0x00020000)        /*!< Bit 2 */
S
S#define  ADC_SMPR2_SMP6                      ((uint32_t)0x001C0000)        /*!< SMP6[2:0] bits (Channel 6 Sample time selection) */
S#define  ADC_SMPR2_SMP6_0                    ((uint32_t)0x00040000)        /*!< Bit 0 */
S#define  ADC_SMPR2_SMP6_1                    ((uint32_t)0x00080000)        /*!< Bit 1 */
S#define  ADC_SMPR2_SMP6_2                    ((uint32_t)0x00100000)        /*!< Bit 2 */
S
S#define  ADC_SMPR2_SMP7                      ((uint32_t)0x00E00000)        /*!< SMP7[2:0] bits (Channel 7 Sample time selection) */
S#define  ADC_SMPR2_SMP7_0                    ((uint32_t)0x00200000)        /*!< Bit 0 */
S#define  ADC_SMPR2_SMP7_1                    ((uint32_t)0x00400000)        /*!< Bit 1 */
S#define  ADC_SMPR2_SMP7_2                    ((uint32_t)0x00800000)        /*!< Bit 2 */
S
S#define  ADC_SMPR2_SMP8                      ((uint32_t)0x07000000)        /*!< SMP8[2:0] bits (Channel 8 Sample time selection) */
S#define  ADC_SMPR2_SMP8_0                    ((uint32_t)0x01000000)        /*!< Bit 0 */
S#define  ADC_SMPR2_SMP8_1                    ((uint32_t)0x02000000)        /*!< Bit 1 */
S#define  ADC_SMPR2_SMP8_2                    ((uint32_t)0x04000000)        /*!< Bit 2 */
S
S#define  ADC_SMPR2_SMP9                      ((uint32_t)0x38000000)        /*!< SMP9[2:0] bits (Channel 9 Sample time selection) */
S#define  ADC_SMPR2_SMP9_0                    ((uint32_t)0x08000000)        /*!< Bit 0 */
S#define  ADC_SMPR2_SMP9_1                    ((uint32_t)0x10000000)        /*!< Bit 1 */
S#define  ADC_SMPR2_SMP9_2                    ((uint32_t)0x20000000)        /*!< Bit 2 */
S
S/******************  Bit definition for ADC_JOFR1 register  *******************/
S#define  ADC_JOFR1_JOFFSET1                  ((uint16_t)0x0FFF)            /*!< Data offset for injected channel 1 */
S
S/******************  Bit definition for ADC_JOFR2 register  *******************/
S#define  ADC_JOFR2_JOFFSET2                  ((uint16_t)0x0FFF)            /*!< Data offset for injected channel 2 */
S
S/******************  Bit definition for ADC_JOFR3 register  *******************/
S#define  ADC_JOFR3_JOFFSET3                  ((uint16_t)0x0FFF)            /*!< Data offset for injected channel 3 */
S
S/******************  Bit definition for ADC_JOFR4 register  *******************/
S#define  ADC_JOFR4_JOFFSET4                  ((uint16_t)0x0FFF)            /*!< Data offset for injected channel 4 */
S
S/*******************  Bit definition for ADC_HTR register  ********************/
S#define  ADC_HTR_HT                          ((uint16_t)0x0FFF)            /*!< Analog watchdog high threshold */
S
S/*******************  Bit definition for ADC_LTR register  ********************/
S#define  ADC_LTR_LT                          ((uint16_t)0x0FFF)            /*!< Analog watchdog low threshold */
S
S/*******************  Bit definition for ADC_SQR1 register  *******************/
S#define  ADC_SQR1_SQ13                       ((uint32_t)0x0000001F)        /*!< SQ13[4:0] bits (13th conversion in regular sequence) */
S#define  ADC_SQR1_SQ13_0                     ((uint32_t)0x00000001)        /*!< Bit 0 */
S#define  ADC_SQR1_SQ13_1                     ((uint32_t)0x00000002)        /*!< Bit 1 */
S#define  ADC_SQR1_SQ13_2                     ((uint32_t)0x00000004)        /*!< Bit 2 */
S#define  ADC_SQR1_SQ13_3                     ((uint32_t)0x00000008)        /*!< Bit 3 */
S#define  ADC_SQR1_SQ13_4                     ((uint32_t)0x00000010)        /*!< Bit 4 */
S
S#define  ADC_SQR1_SQ14                       ((uint32_t)0x000003E0)        /*!< SQ14[4:0] bits (14th conversion in regular sequence) */
S#define  ADC_SQR1_SQ14_0                     ((uint32_t)0x00000020)        /*!< Bit 0 */
S#define  ADC_SQR1_SQ14_1                     ((uint32_t)0x00000040)        /*!< Bit 1 */
S#define  ADC_SQR1_SQ14_2                     ((uint32_t)0x00000080)        /*!< Bit 2 */
S#define  ADC_SQR1_SQ14_3                     ((uint32_t)0x00000100)        /*!< Bit 3 */
S#define  ADC_SQR1_SQ14_4                     ((uint32_t)0x00000200)        /*!< Bit 4 */
S
S#define  ADC_SQR1_SQ15                       ((uint32_t)0x00007C00)        /*!< SQ15[4:0] bits (15th conversion in regular sequence) */
S#define  ADC_SQR1_SQ15_0                     ((uint32_t)0x00000400)        /*!< Bit 0 */
S#define  ADC_SQR1_SQ15_1                     ((uint32_t)0x00000800)        /*!< Bit 1 */
S#define  ADC_SQR1_SQ15_2                     ((uint32_t)0x00001000)        /*!< Bit 2 */
S#define  ADC_SQR1_SQ15_3                     ((uint32_t)0x00002000)        /*!< Bit 3 */
S#define  ADC_SQR1_SQ15_4                     ((uint32_t)0x00004000)        /*!< Bit 4 */
S
S#define  ADC_SQR1_SQ16                       ((uint32_t)0x000F8000)        /*!< SQ16[4:0] bits (16th conversion in regular sequence) */
S#define  ADC_SQR1_SQ16_0                     ((uint32_t)0x00008000)        /*!< Bit 0 */
S#define  ADC_SQR1_SQ16_1                     ((uint32_t)0x00010000)        /*!< Bit 1 */
S#define  ADC_SQR1_SQ16_2                     ((uint32_t)0x00020000)        /*!< Bit 2 */
S#define  ADC_SQR1_SQ16_3                     ((uint32_t)0x00040000)        /*!< Bit 3 */
S#define  ADC_SQR1_SQ16_4                     ((uint32_t)0x00080000)        /*!< Bit 4 */
S
S#define  ADC_SQR1_L                          ((uint32_t)0x00F00000)        /*!< L[3:0] bits (Regular channel sequence length) */
S#define  ADC_SQR1_L_0                        ((uint32_t)0x00100000)        /*!< Bit 0 */
S#define  ADC_SQR1_L_1                        ((uint32_t)0x00200000)        /*!< Bit 1 */
S#define  ADC_SQR1_L_2                        ((uint32_t)0x00400000)        /*!< Bit 2 */
S#define  ADC_SQR1_L_3                        ((uint32_t)0x00800000)        /*!< Bit 3 */
S
S/*******************  Bit definition for ADC_SQR2 register  *******************/
S#define  ADC_SQR2_SQ7                        ((uint32_t)0x0000001F)        /*!< SQ7[4:0] bits (7th conversion in regular sequence) */
S#define  ADC_SQR2_SQ7_0                      ((uint32_t)0x00000001)        /*!< Bit 0 */
S#define  ADC_SQR2_SQ7_1                      ((uint32_t)0x00000002)        /*!< Bit 1 */
S#define  ADC_SQR2_SQ7_2                      ((uint32_t)0x00000004)        /*!< Bit 2 */
S#define  ADC_SQR2_SQ7_3                      ((uint32_t)0x00000008)        /*!< Bit 3 */
S#define  ADC_SQR2_SQ7_4                      ((uint32_t)0x00000010)        /*!< Bit 4 */
S
S#define  ADC_SQR2_SQ8                        ((uint32_t)0x000003E0)        /*!< SQ8[4:0] bits (8th conversion in regular sequence) */
S#define  ADC_SQR2_SQ8_0                      ((uint32_t)0x00000020)        /*!< Bit 0 */
S#define  ADC_SQR2_SQ8_1                      ((uint32_t)0x00000040)        /*!< Bit 1 */
S#define  ADC_SQR2_SQ8_2                      ((uint32_t)0x00000080)        /*!< Bit 2 */
S#define  ADC_SQR2_SQ8_3                      ((uint32_t)0x00000100)        /*!< Bit 3 */
S#define  ADC_SQR2_SQ8_4                      ((uint32_t)0x00000200)        /*!< Bit 4 */
S
S#define  ADC_SQR2_SQ9                        ((uint32_t)0x00007C00)        /*!< SQ9[4:0] bits (9th conversion in regular sequence) */
S#define  ADC_SQR2_SQ9_0                      ((uint32_t)0x00000400)        /*!< Bit 0 */
S#define  ADC_SQR2_SQ9_1                      ((uint32_t)0x00000800)        /*!< Bit 1 */
S#define  ADC_SQR2_SQ9_2                      ((uint32_t)0x00001000)        /*!< Bit 2 */
S#define  ADC_SQR2_SQ9_3                      ((uint32_t)0x00002000)        /*!< Bit 3 */
S#define  ADC_SQR2_SQ9_4                      ((uint32_t)0x00004000)        /*!< Bit 4 */
S
S#define  ADC_SQR2_SQ10                       ((uint32_t)0x000F8000)        /*!< SQ10[4:0] bits (10th conversion in regular sequence) */
S#define  ADC_SQR2_SQ10_0                     ((uint32_t)0x00008000)        /*!< Bit 0 */
S#define  ADC_SQR2_SQ10_1                     ((uint32_t)0x00010000)        /*!< Bit 1 */
S#define  ADC_SQR2_SQ10_2                     ((uint32_t)0x00020000)        /*!< Bit 2 */
S#define  ADC_SQR2_SQ10_3                     ((uint32_t)0x00040000)        /*!< Bit 3 */
S#define  ADC_SQR2_SQ10_4                     ((uint32_t)0x00080000)        /*!< Bit 4 */
S
S#define  ADC_SQR2_SQ11                       ((uint32_t)0x01F00000)        /*!< SQ11[4:0] bits (11th conversion in regular sequence) */
S#define  ADC_SQR2_SQ11_0                     ((uint32_t)0x00100000)        /*!< Bit 0 */
S#define  ADC_SQR2_SQ11_1                     ((uint32_t)0x00200000)        /*!< Bit 1 */
S#define  ADC_SQR2_SQ11_2                     ((uint32_t)0x00400000)        /*!< Bit 2 */
S#define  ADC_SQR2_SQ11_3                     ((uint32_t)0x00800000)        /*!< Bit 3 */
S#define  ADC_SQR2_SQ11_4                     ((uint32_t)0x01000000)        /*!< Bit 4 */
S
S#define  ADC_SQR2_SQ12                       ((uint32_t)0x3E000000)        /*!< SQ12[4:0] bits (12th conversion in regular sequence) */
S#define  ADC_SQR2_SQ12_0                     ((uint32_t)0x02000000)        /*!< Bit 0 */
S#define  ADC_SQR2_SQ12_1                     ((uint32_t)0x04000000)        /*!< Bit 1 */
S#define  ADC_SQR2_SQ12_2                     ((uint32_t)0x08000000)        /*!< Bit 2 */
S#define  ADC_SQR2_SQ12_3                     ((uint32_t)0x10000000)        /*!< Bit 3 */
S#define  ADC_SQR2_SQ12_4                     ((uint32_t)0x20000000)        /*!< Bit 4 */
S
S/*******************  Bit definition for ADC_SQR3 register  *******************/
S#define  ADC_SQR3_SQ1                        ((uint32_t)0x0000001F)        /*!< SQ1[4:0] bits (1st conversion in regular sequence) */
S#define  ADC_SQR3_SQ1_0                      ((uint32_t)0x00000001)        /*!< Bit 0 */
S#define  ADC_SQR3_SQ1_1                      ((uint32_t)0x00000002)        /*!< Bit 1 */
S#define  ADC_SQR3_SQ1_2                      ((uint32_t)0x00000004)        /*!< Bit 2 */
S#define  ADC_SQR3_SQ1_3                      ((uint32_t)0x00000008)        /*!< Bit 3 */
S#define  ADC_SQR3_SQ1_4                      ((uint32_t)0x00000010)        /*!< Bit 4 */
S
S#define  ADC_SQR3_SQ2                        ((uint32_t)0x000003E0)        /*!< SQ2[4:0] bits (2nd conversion in regular sequence) */
S#define  ADC_SQR3_SQ2_0                      ((uint32_t)0x00000020)        /*!< Bit 0 */
S#define  ADC_SQR3_SQ2_1                      ((uint32_t)0x00000040)        /*!< Bit 1 */
S#define  ADC_SQR3_SQ2_2                      ((uint32_t)0x00000080)        /*!< Bit 2 */
S#define  ADC_SQR3_SQ2_3                      ((uint32_t)0x00000100)        /*!< Bit 3 */
S#define  ADC_SQR3_SQ2_4                      ((uint32_t)0x00000200)        /*!< Bit 4 */
S
S#define  ADC_SQR3_SQ3                        ((uint32_t)0x00007C00)        /*!< SQ3[4:0] bits (3rd conversion in regular sequence) */
S#define  ADC_SQR3_SQ3_0                      ((uint32_t)0x00000400)        /*!< Bit 0 */
S#define  ADC_SQR3_SQ3_1                      ((uint32_t)0x00000800)        /*!< Bit 1 */
S#define  ADC_SQR3_SQ3_2                      ((uint32_t)0x00001000)        /*!< Bit 2 */
S#define  ADC_SQR3_SQ3_3                      ((uint32_t)0x00002000)        /*!< Bit 3 */
S#define  ADC_SQR3_SQ3_4                      ((uint32_t)0x00004000)        /*!< Bit 4 */
S
S#define  ADC_SQR3_SQ4                        ((uint32_t)0x000F8000)        /*!< SQ4[4:0] bits (4th conversion in regular sequence) */
S#define  ADC_SQR3_SQ4_0                      ((uint32_t)0x00008000)        /*!< Bit 0 */
S#define  ADC_SQR3_SQ4_1                      ((uint32_t)0x00010000)        /*!< Bit 1 */
S#define  ADC_SQR3_SQ4_2                      ((uint32_t)0x00020000)        /*!< Bit 2 */
S#define  ADC_SQR3_SQ4_3                      ((uint32_t)0x00040000)        /*!< Bit 3 */
S#define  ADC_SQR3_SQ4_4                      ((uint32_t)0x00080000)        /*!< Bit 4 */
S
S#define  ADC_SQR3_SQ5                        ((uint32_t)0x01F00000)        /*!< SQ5[4:0] bits (5th conversion in regular sequence) */
S#define  ADC_SQR3_SQ5_0                      ((uint32_t)0x00100000)        /*!< Bit 0 */
S#define  ADC_SQR3_SQ5_1                      ((uint32_t)0x00200000)        /*!< Bit 1 */
S#define  ADC_SQR3_SQ5_2                      ((uint32_t)0x00400000)        /*!< Bit 2 */
S#define  ADC_SQR3_SQ5_3                      ((uint32_t)0x00800000)        /*!< Bit 3 */
S#define  ADC_SQR3_SQ5_4                      ((uint32_t)0x01000000)        /*!< Bit 4 */
S
S#define  ADC_SQR3_SQ6                        ((uint32_t)0x3E000000)        /*!< SQ6[4:0] bits (6th conversion in regular sequence) */
S#define  ADC_SQR3_SQ6_0                      ((uint32_t)0x02000000)        /*!< Bit 0 */
S#define  ADC_SQR3_SQ6_1                      ((uint32_t)0x04000000)        /*!< Bit 1 */
S#define  ADC_SQR3_SQ6_2                      ((uint32_t)0x08000000)        /*!< Bit 2 */
S#define  ADC_SQR3_SQ6_3                      ((uint32_t)0x10000000)        /*!< Bit 3 */
S#define  ADC_SQR3_SQ6_4                      ((uint32_t)0x20000000)        /*!< Bit 4 */
S
S/*******************  Bit definition for ADC_JSQR register  *******************/
S#define  ADC_JSQR_JSQ1                       ((uint32_t)0x0000001F)        /*!< JSQ1[4:0] bits (1st conversion in injected sequence) */  
S#define  ADC_JSQR_JSQ1_0                     ((uint32_t)0x00000001)        /*!< Bit 0 */
S#define  ADC_JSQR_JSQ1_1                     ((uint32_t)0x00000002)        /*!< Bit 1 */
S#define  ADC_JSQR_JSQ1_2                     ((uint32_t)0x00000004)        /*!< Bit 2 */
S#define  ADC_JSQR_JSQ1_3                     ((uint32_t)0x00000008)        /*!< Bit 3 */
S#define  ADC_JSQR_JSQ1_4                     ((uint32_t)0x00000010)        /*!< Bit 4 */
S
S#define  ADC_JSQR_JSQ2                       ((uint32_t)0x000003E0)        /*!< JSQ2[4:0] bits (2nd conversion in injected sequence) */
S#define  ADC_JSQR_JSQ2_0                     ((uint32_t)0x00000020)        /*!< Bit 0 */
S#define  ADC_JSQR_JSQ2_1                     ((uint32_t)0x00000040)        /*!< Bit 1 */
S#define  ADC_JSQR_JSQ2_2                     ((uint32_t)0x00000080)        /*!< Bit 2 */
S#define  ADC_JSQR_JSQ2_3                     ((uint32_t)0x00000100)        /*!< Bit 3 */
S#define  ADC_JSQR_JSQ2_4                     ((uint32_t)0x00000200)        /*!< Bit 4 */
S
S#define  ADC_JSQR_JSQ3                       ((uint32_t)0x00007C00)        /*!< JSQ3[4:0] bits (3rd conversion in injected sequence) */
S#define  ADC_JSQR_JSQ3_0                     ((uint32_t)0x00000400)        /*!< Bit 0 */
S#define  ADC_JSQR_JSQ3_1                     ((uint32_t)0x00000800)        /*!< Bit 1 */
S#define  ADC_JSQR_JSQ3_2                     ((uint32_t)0x00001000)        /*!< Bit 2 */
S#define  ADC_JSQR_JSQ3_3                     ((uint32_t)0x00002000)        /*!< Bit 3 */
S#define  ADC_JSQR_JSQ3_4                     ((uint32_t)0x00004000)        /*!< Bit 4 */
S
S#define  ADC_JSQR_JSQ4                       ((uint32_t)0x000F8000)        /*!< JSQ4[4:0] bits (4th conversion in injected sequence) */
S#define  ADC_JSQR_JSQ4_0                     ((uint32_t)0x00008000)        /*!< Bit 0 */
S#define  ADC_JSQR_JSQ4_1                     ((uint32_t)0x00010000)        /*!< Bit 1 */
S#define  ADC_JSQR_JSQ4_2                     ((uint32_t)0x00020000)        /*!< Bit 2 */
S#define  ADC_JSQR_JSQ4_3                     ((uint32_t)0x00040000)        /*!< Bit 3 */
S#define  ADC_JSQR_JSQ4_4                     ((uint32_t)0x00080000)        /*!< Bit 4 */
S
S#define  ADC_JSQR_JL                         ((uint32_t)0x00300000)        /*!< JL[1:0] bits (Injected Sequence length) */
S#define  ADC_JSQR_JL_0                       ((uint32_t)0x00100000)        /*!< Bit 0 */
S#define  ADC_JSQR_JL_1                       ((uint32_t)0x00200000)        /*!< Bit 1 */
S
S/*******************  Bit definition for ADC_JDR1 register  *******************/
S#define  ADC_JDR1_JDATA                      ((uint16_t)0xFFFF)            /*!< Injected data */
S
S/*******************  Bit definition for ADC_JDR2 register  *******************/
S#define  ADC_JDR2_JDATA                      ((uint16_t)0xFFFF)            /*!< Injected data */
S
S/*******************  Bit definition for ADC_JDR3 register  *******************/
S#define  ADC_JDR3_JDATA                      ((uint16_t)0xFFFF)            /*!< Injected data */
S
S/*******************  Bit definition for ADC_JDR4 register  *******************/
S#define  ADC_JDR4_JDATA                      ((uint16_t)0xFFFF)            /*!< Injected data */
S
S/********************  Bit definition for ADC_DR register  ********************/
S#define  ADC_DR_DATA                         ((uint32_t)0x0000FFFF)        /*!< Regular data */
S#define  ADC_DR_ADC2DATA                     ((uint32_t)0xFFFF0000)        /*!< ADC2 data */
S
S/******************************************************************************/
S/*                                                                            */
S/*                      Digital to Analog Converter                           */
S/*                                                                            */
S/******************************************************************************/
S
S/********************  Bit definition for DAC_CR register  ********************/
S#define  DAC_CR_EN1                          ((uint32_t)0x00000001)        /*!< DAC channel1 enable */
S#define  DAC_CR_BOFF1                        ((uint32_t)0x00000002)        /*!< DAC channel1 output buffer disable */
S#define  DAC_CR_TEN1                         ((uint32_t)0x00000004)        /*!< DAC channel1 Trigger enable */
S
S#define  DAC_CR_TSEL1                        ((uint32_t)0x00000038)        /*!< TSEL1[2:0] (DAC channel1 Trigger selection) */
S#define  DAC_CR_TSEL1_0                      ((uint32_t)0x00000008)        /*!< Bit 0 */
S#define  DAC_CR_TSEL1_1                      ((uint32_t)0x00000010)        /*!< Bit 1 */
S#define  DAC_CR_TSEL1_2                      ((uint32_t)0x00000020)        /*!< Bit 2 */
S
S#define  DAC_CR_WAVE1                        ((uint32_t)0x000000C0)        /*!< WAVE1[1:0] (DAC channel1 noise/triangle wave generation enable) */
S#define  DAC_CR_WAVE1_0                      ((uint32_t)0x00000040)        /*!< Bit 0 */
S#define  DAC_CR_WAVE1_1                      ((uint32_t)0x00000080)        /*!< Bit 1 */
S
S#define  DAC_CR_MAMP1                        ((uint32_t)0x00000F00)        /*!< MAMP1[3:0] (DAC channel1 Mask/Amplitude selector) */
S#define  DAC_CR_MAMP1_0                      ((uint32_t)0x00000100)        /*!< Bit 0 */
S#define  DAC_CR_MAMP1_1                      ((uint32_t)0x00000200)        /*!< Bit 1 */
S#define  DAC_CR_MAMP1_2                      ((uint32_t)0x00000400)        /*!< Bit 2 */
S#define  DAC_CR_MAMP1_3                      ((uint32_t)0x00000800)        /*!< Bit 3 */
S
S#define  DAC_CR_DMAEN1                       ((uint32_t)0x00001000)        /*!< DAC channel1 DMA enable */
S#define  DAC_CR_EN2                          ((uint32_t)0x00010000)        /*!< DAC channel2 enable */
S#define  DAC_CR_BOFF2                        ((uint32_t)0x00020000)        /*!< DAC channel2 output buffer disable */
S#define  DAC_CR_TEN2                         ((uint32_t)0x00040000)        /*!< DAC channel2 Trigger enable */
S
S#define  DAC_CR_TSEL2                        ((uint32_t)0x00380000)        /*!< TSEL2[2:0] (DAC channel2 Trigger selection) */
S#define  DAC_CR_TSEL2_0                      ((uint32_t)0x00080000)        /*!< Bit 0 */
S#define  DAC_CR_TSEL2_1                      ((uint32_t)0x00100000)        /*!< Bit 1 */
S#define  DAC_CR_TSEL2_2                      ((uint32_t)0x00200000)        /*!< Bit 2 */
S
S#define  DAC_CR_WAVE2                        ((uint32_t)0x00C00000)        /*!< WAVE2[1:0] (DAC channel2 noise/triangle wave generation enable) */
S#define  DAC_CR_WAVE2_0                      ((uint32_t)0x00400000)        /*!< Bit 0 */
S#define  DAC_CR_WAVE2_1                      ((uint32_t)0x00800000)        /*!< Bit 1 */
S
S#define  DAC_CR_MAMP2                        ((uint32_t)0x0F000000)        /*!< MAMP2[3:0] (DAC channel2 Mask/Amplitude selector) */
S#define  DAC_CR_MAMP2_0                      ((uint32_t)0x01000000)        /*!< Bit 0 */
S#define  DAC_CR_MAMP2_1                      ((uint32_t)0x02000000)        /*!< Bit 1 */
S#define  DAC_CR_MAMP2_2                      ((uint32_t)0x04000000)        /*!< Bit 2 */
S#define  DAC_CR_MAMP2_3                      ((uint32_t)0x08000000)        /*!< Bit 3 */
S
S#define  DAC_CR_DMAEN2                       ((uint32_t)0x10000000)        /*!< DAC channel2 DMA enabled */
S
S/*****************  Bit definition for DAC_SWTRIGR register  ******************/
S#define  DAC_SWTRIGR_SWTRIG1                 ((uint8_t)0x01)               /*!< DAC channel1 software trigger */
S#define  DAC_SWTRIGR_SWTRIG2                 ((uint8_t)0x02)               /*!< DAC channel2 software trigger */
S
S/*****************  Bit definition for DAC_DHR12R1 register  ******************/
S#define  DAC_DHR12R1_DACC1DHR                ((uint16_t)0x0FFF)            /*!< DAC channel1 12-bit Right aligned data */
S
S/*****************  Bit definition for DAC_DHR12L1 register  ******************/
S#define  DAC_DHR12L1_DACC1DHR                ((uint16_t)0xFFF0)            /*!< DAC channel1 12-bit Left aligned data */
S
S/******************  Bit definition for DAC_DHR8R1 register  ******************/
S#define  DAC_DHR8R1_DACC1DHR                 ((uint8_t)0xFF)               /*!< DAC channel1 8-bit Right aligned data */
S
S/*****************  Bit definition for DAC_DHR12R2 register  ******************/
S#define  DAC_DHR12R2_DACC2DHR                ((uint16_t)0x0FFF)            /*!< DAC channel2 12-bit Right aligned data */
S
S/*****************  Bit definition for DAC_DHR12L2 register  ******************/
S#define  DAC_DHR12L2_DACC2DHR                ((uint16_t)0xFFF0)            /*!< DAC channel2 12-bit Left aligned data */
S
S/******************  Bit definition for DAC_DHR8R2 register  ******************/
S#define  DAC_DHR8R2_DACC2DHR                 ((uint8_t)0xFF)               /*!< DAC channel2 8-bit Right aligned data */
S
S/*****************  Bit definition for DAC_DHR12RD register  ******************/
S#define  DAC_DHR12RD_DACC1DHR                ((uint32_t)0x00000FFF)        /*!< DAC channel1 12-bit Right aligned data */
S#define  DAC_DHR12RD_DACC2DHR                ((uint32_t)0x0FFF0000)        /*!< DAC channel2 12-bit Right aligned data */
S
S/*****************  Bit definition for DAC_DHR12LD register  ******************/
S#define  DAC_DHR12LD_DACC1DHR                ((uint32_t)0x0000FFF0)        /*!< DAC channel1 12-bit Left aligned data */
S#define  DAC_DHR12LD_DACC2DHR                ((uint32_t)0xFFF00000)        /*!< DAC channel2 12-bit Left aligned data */
S
S/******************  Bit definition for DAC_DHR8RD register  ******************/
S#define  DAC_DHR8RD_DACC1DHR                 ((uint16_t)0x00FF)            /*!< DAC channel1 8-bit Right aligned data */
S#define  DAC_DHR8RD_DACC2DHR                 ((uint16_t)0xFF00)            /*!< DAC channel2 8-bit Right aligned data */
S
S/*******************  Bit definition for DAC_DOR1 register  *******************/
S#define  DAC_DOR1_DACC1DOR                   ((uint16_t)0x0FFF)            /*!< DAC channel1 data output */
S
S/*******************  Bit definition for DAC_DOR2 register  *******************/
S#define  DAC_DOR2_DACC2DOR                   ((uint16_t)0x0FFF)            /*!< DAC channel2 data output */
S
S/********************  Bit definition for DAC_SR register  ********************/
S#define  DAC_SR_DMAUDR1                      ((uint32_t)0x00002000)        /*!< DAC channel1 DMA underrun flag */
S#define  DAC_SR_DMAUDR2                      ((uint32_t)0x20000000)        /*!< DAC channel2 DMA underrun flag */
S
S/******************************************************************************/
S/*                                                                            */
S/*                                    CEC                                     */
S/*                                                                            */
S/******************************************************************************/
S/********************  Bit definition for CEC_CFGR register  ******************/
S#define  CEC_CFGR_PE              ((uint16_t)0x0001)     /*!<  Peripheral Enable */
S#define  CEC_CFGR_IE              ((uint16_t)0x0002)     /*!<  Interrupt Enable */
S#define  CEC_CFGR_BTEM            ((uint16_t)0x0004)     /*!<  Bit Timing Error Mode */
S#define  CEC_CFGR_BPEM            ((uint16_t)0x0008)     /*!<  Bit Period Error Mode */
S
S/********************  Bit definition for CEC_OAR register  ******************/
S#define  CEC_OAR_OA               ((uint16_t)0x000F)     /*!<  OA[3:0]: Own Address */
S#define  CEC_OAR_OA_0             ((uint16_t)0x0001)     /*!<  Bit 0 */
S#define  CEC_OAR_OA_1             ((uint16_t)0x0002)     /*!<  Bit 1 */
S#define  CEC_OAR_OA_2             ((uint16_t)0x0004)     /*!<  Bit 2 */
S#define  CEC_OAR_OA_3             ((uint16_t)0x0008)     /*!<  Bit 3 */
S
S/********************  Bit definition for CEC_PRES register  ******************/
S#define  CEC_PRES_PRES            ((uint16_t)0x3FFF)   /*!<  Prescaler Counter Value */
S
S/********************  Bit definition for CEC_ESR register  ******************/
S#define  CEC_ESR_BTE              ((uint16_t)0x0001)     /*!<  Bit Timing Error */
S#define  CEC_ESR_BPE              ((uint16_t)0x0002)     /*!<  Bit Period Error */
S#define  CEC_ESR_RBTFE            ((uint16_t)0x0004)     /*!<  Rx Block Transfer Finished Error */
S#define  CEC_ESR_SBE              ((uint16_t)0x0008)     /*!<  Start Bit Error */
S#define  CEC_ESR_ACKE             ((uint16_t)0x0010)     /*!<  Block Acknowledge Error */
S#define  CEC_ESR_LINE             ((uint16_t)0x0020)     /*!<  Line Error */
S#define  CEC_ESR_TBTFE            ((uint16_t)0x0040)     /*!<  Tx Block Transfer Finished Error */
S
S/********************  Bit definition for CEC_CSR register  ******************/
S#define  CEC_CSR_TSOM             ((uint16_t)0x0001)     /*!<  Tx Start Of Message */
S#define  CEC_CSR_TEOM             ((uint16_t)0x0002)     /*!<  Tx End Of Message */
S#define  CEC_CSR_TERR             ((uint16_t)0x0004)     /*!<  Tx Error */
S#define  CEC_CSR_TBTRF            ((uint16_t)0x0008)     /*!<  Tx Byte Transfer Request or Block Transfer Finished */
S#define  CEC_CSR_RSOM             ((uint16_t)0x0010)     /*!<  Rx Start Of Message */
S#define  CEC_CSR_REOM             ((uint16_t)0x0020)     /*!<  Rx End Of Message */
S#define  CEC_CSR_RERR             ((uint16_t)0x0040)     /*!<  Rx Error */
S#define  CEC_CSR_RBTF             ((uint16_t)0x0080)     /*!<  Rx Block Transfer Finished */
S
S/********************  Bit definition for CEC_TXD register  ******************/
S#define  CEC_TXD_TXD              ((uint16_t)0x00FF)     /*!<  Tx Data register */
S
S/********************  Bit definition for CEC_RXD register  ******************/
S#define  CEC_RXD_RXD              ((uint16_t)0x00FF)     /*!<  Rx Data register */
S
S/******************************************************************************/
S/*                                                                            */
S/*                                    TIM                                     */
S/*                                                                            */
S/******************************************************************************/
S
S/*******************  Bit definition for TIM_CR1 register  ********************/
S#define  TIM_CR1_CEN                         ((uint16_t)0x0001)            /*!< Counter enable */
S#define  TIM_CR1_UDIS                        ((uint16_t)0x0002)            /*!< Update disable */
S#define  TIM_CR1_URS                         ((uint16_t)0x0004)            /*!< Update request source */
S#define  TIM_CR1_OPM                         ((uint16_t)0x0008)            /*!< One pulse mode */
S#define  TIM_CR1_DIR                         ((uint16_t)0x0010)            /*!< Direction */
S
S#define  TIM_CR1_CMS                         ((uint16_t)0x0060)            /*!< CMS[1:0] bits (Center-aligned mode selection) */
S#define  TIM_CR1_CMS_0                       ((uint16_t)0x0020)            /*!< Bit 0 */
S#define  TIM_CR1_CMS_1                       ((uint16_t)0x0040)            /*!< Bit 1 */
S
S#define  TIM_CR1_ARPE                        ((uint16_t)0x0080)            /*!< Auto-reload preload enable */
S
S#define  TIM_CR1_CKD                         ((uint16_t)0x0300)            /*!< CKD[1:0] bits (clock division) */
S#define  TIM_CR1_CKD_0                       ((uint16_t)0x0100)            /*!< Bit 0 */
S#define  TIM_CR1_CKD_1                       ((uint16_t)0x0200)            /*!< Bit 1 */
S
S/*******************  Bit definition for TIM_CR2 register  ********************/
S#define  TIM_CR2_CCPC                        ((uint16_t)0x0001)            /*!< Capture/Compare Preloaded Control */
S#define  TIM_CR2_CCUS                        ((uint16_t)0x0004)            /*!< Capture/Compare Control Update Selection */
S#define  TIM_CR2_CCDS                        ((uint16_t)0x0008)            /*!< Capture/Compare DMA Selection */
S
S#define  TIM_CR2_MMS                         ((uint16_t)0x0070)            /*!< MMS[2:0] bits (Master Mode Selection) */
S#define  TIM_CR2_MMS_0                       ((uint16_t)0x0010)            /*!< Bit 0 */
S#define  TIM_CR2_MMS_1                       ((uint16_t)0x0020)            /*!< Bit 1 */
S#define  TIM_CR2_MMS_2                       ((uint16_t)0x0040)            /*!< Bit 2 */
S
S#define  TIM_CR2_TI1S                        ((uint16_t)0x0080)            /*!< TI1 Selection */
S#define  TIM_CR2_OIS1                        ((uint16_t)0x0100)            /*!< Output Idle state 1 (OC1 output) */
S#define  TIM_CR2_OIS1N                       ((uint16_t)0x0200)            /*!< Output Idle state 1 (OC1N output) */
S#define  TIM_CR2_OIS2                        ((uint16_t)0x0400)            /*!< Output Idle state 2 (OC2 output) */
S#define  TIM_CR2_OIS2N                       ((uint16_t)0x0800)            /*!< Output Idle state 2 (OC2N output) */
S#define  TIM_CR2_OIS3                        ((uint16_t)0x1000)            /*!< Output Idle state 3 (OC3 output) */
S#define  TIM_CR2_OIS3N                       ((uint16_t)0x2000)            /*!< Output Idle state 3 (OC3N output) */
S#define  TIM_CR2_OIS4                        ((uint16_t)0x4000)            /*!< Output Idle state 4 (OC4 output) */
S
S/*******************  Bit definition for TIM_SMCR register  *******************/
S#define  TIM_SMCR_SMS                        ((uint16_t)0x0007)            /*!< SMS[2:0] bits (Slave mode selection) */
S#define  TIM_SMCR_SMS_0                      ((uint16_t)0x0001)            /*!< Bit 0 */
S#define  TIM_SMCR_SMS_1                      ((uint16_t)0x0002)            /*!< Bit 1 */
S#define  TIM_SMCR_SMS_2                      ((uint16_t)0x0004)            /*!< Bit 2 */
S
S#define  TIM_SMCR_TS                         ((uint16_t)0x0070)            /*!< TS[2:0] bits (Trigger selection) */
S#define  TIM_SMCR_TS_0                       ((uint16_t)0x0010)            /*!< Bit 0 */
S#define  TIM_SMCR_TS_1                       ((uint16_t)0x0020)            /*!< Bit 1 */
S#define  TIM_SMCR_TS_2                       ((uint16_t)0x0040)            /*!< Bit 2 */
S
S#define  TIM_SMCR_MSM                        ((uint16_t)0x0080)            /*!< Master/slave mode */
S
S#define  TIM_SMCR_ETF                        ((uint16_t)0x0F00)            /*!< ETF[3:0] bits (External trigger filter) */
S#define  TIM_SMCR_ETF_0                      ((uint16_t)0x0100)            /*!< Bit 0 */
S#define  TIM_SMCR_ETF_1                      ((uint16_t)0x0200)            /*!< Bit 1 */
S#define  TIM_SMCR_ETF_2                      ((uint16_t)0x0400)            /*!< Bit 2 */
S#define  TIM_SMCR_ETF_3                      ((uint16_t)0x0800)            /*!< Bit 3 */
S
S#define  TIM_SMCR_ETPS                       ((uint16_t)0x3000)            /*!< ETPS[1:0] bits (External trigger prescaler) */
S#define  TIM_SMCR_ETPS_0                     ((uint16_t)0x1000)            /*!< Bit 0 */
S#define  TIM_SMCR_ETPS_1                     ((uint16_t)0x2000)            /*!< Bit 1 */
S
S#define  TIM_SMCR_ECE                        ((uint16_t)0x4000)            /*!< External clock enable */
S#define  TIM_SMCR_ETP                        ((uint16_t)0x8000)            /*!< External trigger polarity */
S
S/*******************  Bit definition for TIM_DIER register  *******************/
S#define  TIM_DIER_UIE                        ((uint16_t)0x0001)            /*!< Update interrupt enable */
S#define  TIM_DIER_CC1IE                      ((uint16_t)0x0002)            /*!< Capture/Compare 1 interrupt enable */
S#define  TIM_DIER_CC2IE                      ((uint16_t)0x0004)            /*!< Capture/Compare 2 interrupt enable */
S#define  TIM_DIER_CC3IE                      ((uint16_t)0x0008)            /*!< Capture/Compare 3 interrupt enable */
S#define  TIM_DIER_CC4IE                      ((uint16_t)0x0010)            /*!< Capture/Compare 4 interrupt enable */
S#define  TIM_DIER_COMIE                      ((uint16_t)0x0020)            /*!< COM interrupt enable */
S#define  TIM_DIER_TIE                        ((uint16_t)0x0040)            /*!< Trigger interrupt enable */
S#define  TIM_DIER_BIE                        ((uint16_t)0x0080)            /*!< Break interrupt enable */
S#define  TIM_DIER_UDE                        ((uint16_t)0x0100)            /*!< Update DMA request enable */
S#define  TIM_DIER_CC1DE                      ((uint16_t)0x0200)            /*!< Capture/Compare 1 DMA request enable */
S#define  TIM_DIER_CC2DE                      ((uint16_t)0x0400)            /*!< Capture/Compare 2 DMA request enable */
S#define  TIM_DIER_CC3DE                      ((uint16_t)0x0800)            /*!< Capture/Compare 3 DMA request enable */
S#define  TIM_DIER_CC4DE                      ((uint16_t)0x1000)            /*!< Capture/Compare 4 DMA request enable */
S#define  TIM_DIER_COMDE                      ((uint16_t)0x2000)            /*!< COM DMA request enable */
S#define  TIM_DIER_TDE                        ((uint16_t)0x4000)            /*!< Trigger DMA request enable */
S
S/********************  Bit definition for TIM_SR register  ********************/
S#define  TIM_SR_UIF                          ((uint16_t)0x0001)            /*!< Update interrupt Flag */
S#define  TIM_SR_CC1IF                        ((uint16_t)0x0002)            /*!< Capture/Compare 1 interrupt Flag */
S#define  TIM_SR_CC2IF                        ((uint16_t)0x0004)            /*!< Capture/Compare 2 interrupt Flag */
S#define  TIM_SR_CC3IF                        ((uint16_t)0x0008)            /*!< Capture/Compare 3 interrupt Flag */
S#define  TIM_SR_CC4IF                        ((uint16_t)0x0010)            /*!< Capture/Compare 4 interrupt Flag */
S#define  TIM_SR_COMIF                        ((uint16_t)0x0020)            /*!< COM interrupt Flag */
S#define  TIM_SR_TIF                          ((uint16_t)0x0040)            /*!< Trigger interrupt Flag */
S#define  TIM_SR_BIF                          ((uint16_t)0x0080)            /*!< Break interrupt Flag */
S#define  TIM_SR_CC1OF                        ((uint16_t)0x0200)            /*!< Capture/Compare 1 Overcapture Flag */
S#define  TIM_SR_CC2OF                        ((uint16_t)0x0400)            /*!< Capture/Compare 2 Overcapture Flag */
S#define  TIM_SR_CC3OF                        ((uint16_t)0x0800)            /*!< Capture/Compare 3 Overcapture Flag */
S#define  TIM_SR_CC4OF                        ((uint16_t)0x1000)            /*!< Capture/Compare 4 Overcapture Flag */
S
S/*******************  Bit definition for TIM_EGR register  ********************/
S#define  TIM_EGR_UG                          ((uint8_t)0x01)               /*!< Update Generation */
S#define  TIM_EGR_CC1G                        ((uint8_t)0x02)               /*!< Capture/Compare 1 Generation */
S#define  TIM_EGR_CC2G                        ((uint8_t)0x04)               /*!< Capture/Compare 2 Generation */
S#define  TIM_EGR_CC3G                        ((uint8_t)0x08)               /*!< Capture/Compare 3 Generation */
S#define  TIM_EGR_CC4G                        ((uint8_t)0x10)               /*!< Capture/Compare 4 Generation */
S#define  TIM_EGR_COMG                        ((uint8_t)0x20)               /*!< Capture/Compare Control Update Generation */
S#define  TIM_EGR_TG                          ((uint8_t)0x40)               /*!< Trigger Generation */
S#define  TIM_EGR_BG                          ((uint8_t)0x80)               /*!< Break Generation */
S
S/******************  Bit definition for TIM_CCMR1 register  *******************/
S#define  TIM_CCMR1_CC1S                      ((uint16_t)0x0003)            /*!< CC1S[1:0] bits (Capture/Compare 1 Selection) */
S#define  TIM_CCMR1_CC1S_0                    ((uint16_t)0x0001)            /*!< Bit 0 */
S#define  TIM_CCMR1_CC1S_1                    ((uint16_t)0x0002)            /*!< Bit 1 */
S
S#define  TIM_CCMR1_OC1FE                     ((uint16_t)0x0004)            /*!< Output Compare 1 Fast enable */
S#define  TIM_CCMR1_OC1PE                     ((uint16_t)0x0008)            /*!< Output Compare 1 Preload enable */
S
S#define  TIM_CCMR1_OC1M                      ((uint16_t)0x0070)            /*!< OC1M[2:0] bits (Output Compare 1 Mode) */
S#define  TIM_CCMR1_OC1M_0                    ((uint16_t)0x0010)            /*!< Bit 0 */
S#define  TIM_CCMR1_OC1M_1                    ((uint16_t)0x0020)            /*!< Bit 1 */
S#define  TIM_CCMR1_OC1M_2                    ((uint16_t)0x0040)            /*!< Bit 2 */
S
S#define  TIM_CCMR1_OC1CE                     ((uint16_t)0x0080)            /*!< Output Compare 1Clear Enable */
S
S#define  TIM_CCMR1_CC2S                      ((uint16_t)0x0300)            /*!< CC2S[1:0] bits (Capture/Compare 2 Selection) */
S#define  TIM_CCMR1_CC2S_0                    ((uint16_t)0x0100)            /*!< Bit 0 */
S#define  TIM_CCMR1_CC2S_1                    ((uint16_t)0x0200)            /*!< Bit 1 */
S
S#define  TIM_CCMR1_OC2FE                     ((uint16_t)0x0400)            /*!< Output Compare 2 Fast enable */
S#define  TIM_CCMR1_OC2PE                     ((uint16_t)0x0800)            /*!< Output Compare 2 Preload enable */
S
S#define  TIM_CCMR1_OC2M                      ((uint16_t)0x7000)            /*!< OC2M[2:0] bits (Output Compare 2 Mode) */
S#define  TIM_CCMR1_OC2M_0                    ((uint16_t)0x1000)            /*!< Bit 0 */
S#define  TIM_CCMR1_OC2M_1                    ((uint16_t)0x2000)            /*!< Bit 1 */
S#define  TIM_CCMR1_OC2M_2                    ((uint16_t)0x4000)            /*!< Bit 2 */
S
S#define  TIM_CCMR1_OC2CE                     ((uint16_t)0x8000)            /*!< Output Compare 2 Clear Enable */
S
S/*----------------------------------------------------------------------------*/
S
S#define  TIM_CCMR1_IC1PSC                    ((uint16_t)0x000C)            /*!< IC1PSC[1:0] bits (Input Capture 1 Prescaler) */
S#define  TIM_CCMR1_IC1PSC_0                  ((uint16_t)0x0004)            /*!< Bit 0 */
S#define  TIM_CCMR1_IC1PSC_1                  ((uint16_t)0x0008)            /*!< Bit 1 */
S
S#define  TIM_CCMR1_IC1F                      ((uint16_t)0x00F0)            /*!< IC1F[3:0] bits (Input Capture 1 Filter) */
S#define  TIM_CCMR1_IC1F_0                    ((uint16_t)0x0010)            /*!< Bit 0 */
S#define  TIM_CCMR1_IC1F_1                    ((uint16_t)0x0020)            /*!< Bit 1 */
S#define  TIM_CCMR1_IC1F_2                    ((uint16_t)0x0040)            /*!< Bit 2 */
S#define  TIM_CCMR1_IC1F_3                    ((uint16_t)0x0080)            /*!< Bit 3 */
S
S#define  TIM_CCMR1_IC2PSC                    ((uint16_t)0x0C00)            /*!< IC2PSC[1:0] bits (Input Capture 2 Prescaler) */
S#define  TIM_CCMR1_IC2PSC_0                  ((uint16_t)0x0400)            /*!< Bit 0 */
S#define  TIM_CCMR1_IC2PSC_1                  ((uint16_t)0x0800)            /*!< Bit 1 */
S
S#define  TIM_CCMR1_IC2F                      ((uint16_t)0xF000)            /*!< IC2F[3:0] bits (Input Capture 2 Filter) */
S#define  TIM_CCMR1_IC2F_0                    ((uint16_t)0x1000)            /*!< Bit 0 */
S#define  TIM_CCMR1_IC2F_1                    ((uint16_t)0x2000)            /*!< Bit 1 */
S#define  TIM_CCMR1_IC2F_2                    ((uint16_t)0x4000)            /*!< Bit 2 */
S#define  TIM_CCMR1_IC2F_3                    ((uint16_t)0x8000)            /*!< Bit 3 */
S
S/******************  Bit definition for TIM_CCMR2 register  *******************/
S#define  TIM_CCMR2_CC3S                      ((uint16_t)0x0003)            /*!< CC3S[1:0] bits (Capture/Compare 3 Selection) */
S#define  TIM_CCMR2_CC3S_0                    ((uint16_t)0x0001)            /*!< Bit 0 */
S#define  TIM_CCMR2_CC3S_1                    ((uint16_t)0x0002)            /*!< Bit 1 */
S
S#define  TIM_CCMR2_OC3FE                     ((uint16_t)0x0004)            /*!< Output Compare 3 Fast enable */
S#define  TIM_CCMR2_OC3PE                     ((uint16_t)0x0008)            /*!< Output Compare 3 Preload enable */
S
S#define  TIM_CCMR2_OC3M                      ((uint16_t)0x0070)            /*!< OC3M[2:0] bits (Output Compare 3 Mode) */
S#define  TIM_CCMR2_OC3M_0                    ((uint16_t)0x0010)            /*!< Bit 0 */
S#define  TIM_CCMR2_OC3M_1                    ((uint16_t)0x0020)            /*!< Bit 1 */
S#define  TIM_CCMR2_OC3M_2                    ((uint16_t)0x0040)            /*!< Bit 2 */
S
S#define  TIM_CCMR2_OC3CE                     ((uint16_t)0x0080)            /*!< Output Compare 3 Clear Enable */
S
S#define  TIM_CCMR2_CC4S                      ((uint16_t)0x0300)            /*!< CC4S[1:0] bits (Capture/Compare 4 Selection) */
S#define  TIM_CCMR2_CC4S_0                    ((uint16_t)0x0100)            /*!< Bit 0 */
S#define  TIM_CCMR2_CC4S_1                    ((uint16_t)0x0200)            /*!< Bit 1 */
S
S#define  TIM_CCMR2_OC4FE                     ((uint16_t)0x0400)            /*!< Output Compare 4 Fast enable */
S#define  TIM_CCMR2_OC4PE                     ((uint16_t)0x0800)            /*!< Output Compare 4 Preload enable */
S
S#define  TIM_CCMR2_OC4M                      ((uint16_t)0x7000)            /*!< OC4M[2:0] bits (Output Compare 4 Mode) */
S#define  TIM_CCMR2_OC4M_0                    ((uint16_t)0x1000)            /*!< Bit 0 */
S#define  TIM_CCMR2_OC4M_1                    ((uint16_t)0x2000)            /*!< Bit 1 */
S#define  TIM_CCMR2_OC4M_2                    ((uint16_t)0x4000)            /*!< Bit 2 */
S
S#define  TIM_CCMR2_OC4CE                     ((uint16_t)0x8000)            /*!< Output Compare 4 Clear Enable */
S
S/*----------------------------------------------------------------------------*/
S
S#define  TIM_CCMR2_IC3PSC                    ((uint16_t)0x000C)            /*!< IC3PSC[1:0] bits (Input Capture 3 Prescaler) */
S#define  TIM_CCMR2_IC3PSC_0                  ((uint16_t)0x0004)            /*!< Bit 0 */
S#define  TIM_CCMR2_IC3PSC_1                  ((uint16_t)0x0008)            /*!< Bit 1 */
S
S#define  TIM_CCMR2_IC3F                      ((uint16_t)0x00F0)            /*!< IC3F[3:0] bits (Input Capture 3 Filter) */
S#define  TIM_CCMR2_IC3F_0                    ((uint16_t)0x0010)            /*!< Bit 0 */
S#define  TIM_CCMR2_IC3F_1                    ((uint16_t)0x0020)            /*!< Bit 1 */
S#define  TIM_CCMR2_IC3F_2                    ((uint16_t)0x0040)            /*!< Bit 2 */
S#define  TIM_CCMR2_IC3F_3                    ((uint16_t)0x0080)            /*!< Bit 3 */
S
S#define  TIM_CCMR2_IC4PSC                    ((uint16_t)0x0C00)            /*!< IC4PSC[1:0] bits (Input Capture 4 Prescaler) */
S#define  TIM_CCMR2_IC4PSC_0                  ((uint16_t)0x0400)            /*!< Bit 0 */
S#define  TIM_CCMR2_IC4PSC_1                  ((uint16_t)0x0800)            /*!< Bit 1 */
S
S#define  TIM_CCMR2_IC4F                      ((uint16_t)0xF000)            /*!< IC4F[3:0] bits (Input Capture 4 Filter) */
S#define  TIM_CCMR2_IC4F_0                    ((uint16_t)0x1000)            /*!< Bit 0 */
S#define  TIM_CCMR2_IC4F_1                    ((uint16_t)0x2000)            /*!< Bit 1 */
S#define  TIM_CCMR2_IC4F_2                    ((uint16_t)0x4000)            /*!< Bit 2 */
S#define  TIM_CCMR2_IC4F_3                    ((uint16_t)0x8000)            /*!< Bit 3 */
S
S/*******************  Bit definition for TIM_CCER register  *******************/
S#define  TIM_CCER_CC1E                       ((uint16_t)0x0001)            /*!< Capture/Compare 1 output enable */
S#define  TIM_CCER_CC1P                       ((uint16_t)0x0002)            /*!< Capture/Compare 1 output Polarity */
S#define  TIM_CCER_CC1NE                      ((uint16_t)0x0004)            /*!< Capture/Compare 1 Complementary output enable */
S#define  TIM_CCER_CC1NP                      ((uint16_t)0x0008)            /*!< Capture/Compare 1 Complementary output Polarity */
S#define  TIM_CCER_CC2E                       ((uint16_t)0x0010)            /*!< Capture/Compare 2 output enable */
S#define  TIM_CCER_CC2P                       ((uint16_t)0x0020)            /*!< Capture/Compare 2 output Polarity */
S#define  TIM_CCER_CC2NE                      ((uint16_t)0x0040)            /*!< Capture/Compare 2 Complementary output enable */
S#define  TIM_CCER_CC2NP                      ((uint16_t)0x0080)            /*!< Capture/Compare 2 Complementary output Polarity */
S#define  TIM_CCER_CC3E                       ((uint16_t)0x0100)            /*!< Capture/Compare 3 output enable */
S#define  TIM_CCER_CC3P                       ((uint16_t)0x0200)            /*!< Capture/Compare 3 output Polarity */
S#define  TIM_CCER_CC3NE                      ((uint16_t)0x0400)            /*!< Capture/Compare 3 Complementary output enable */
S#define  TIM_CCER_CC3NP                      ((uint16_t)0x0800)            /*!< Capture/Compare 3 Complementary output Polarity */
S#define  TIM_CCER_CC4E                       ((uint16_t)0x1000)            /*!< Capture/Compare 4 output enable */
S#define  TIM_CCER_CC4P                       ((uint16_t)0x2000)            /*!< Capture/Compare 4 output Polarity */
S#define  TIM_CCER_CC4NP                      ((uint16_t)0x8000)            /*!< Capture/Compare 4 Complementary output Polarity */
S
S/*******************  Bit definition for TIM_CNT register  ********************/
S#define  TIM_CNT_CNT                         ((uint16_t)0xFFFF)            /*!< Counter Value */
S
S/*******************  Bit definition for TIM_PSC register  ********************/
S#define  TIM_PSC_PSC                         ((uint16_t)0xFFFF)            /*!< Prescaler Value */
S
S/*******************  Bit definition for TIM_ARR register  ********************/
S#define  TIM_ARR_ARR                         ((uint16_t)0xFFFF)            /*!< actual auto-reload Value */
S
S/*******************  Bit definition for TIM_RCR register  ********************/
S#define  TIM_RCR_REP                         ((uint8_t)0xFF)               /*!< Repetition Counter Value */
S
S/*******************  Bit definition for TIM_CCR1 register  *******************/
S#define  TIM_CCR1_CCR1                       ((uint16_t)0xFFFF)            /*!< Capture/Compare 1 Value */
S
S/*******************  Bit definition for TIM_CCR2 register  *******************/
S#define  TIM_CCR2_CCR2                       ((uint16_t)0xFFFF)            /*!< Capture/Compare 2 Value */
S
S/*******************  Bit definition for TIM_CCR3 register  *******************/
S#define  TIM_CCR3_CCR3                       ((uint16_t)0xFFFF)            /*!< Capture/Compare 3 Value */
S
S/*******************  Bit definition for TIM_CCR4 register  *******************/
S#define  TIM_CCR4_CCR4                       ((uint16_t)0xFFFF)            /*!< Capture/Compare 4 Value */
S
S/*******************  Bit definition for TIM_BDTR register  *******************/
S#define  TIM_BDTR_DTG                        ((uint16_t)0x00FF)            /*!< DTG[0:7] bits (Dead-Time Generator set-up) */
S#define  TIM_BDTR_DTG_0                      ((uint16_t)0x0001)            /*!< Bit 0 */
S#define  TIM_BDTR_DTG_1                      ((uint16_t)0x0002)            /*!< Bit 1 */
S#define  TIM_BDTR_DTG_2                      ((uint16_t)0x0004)            /*!< Bit 2 */
S#define  TIM_BDTR_DTG_3                      ((uint16_t)0x0008)            /*!< Bit 3 */
S#define  TIM_BDTR_DTG_4                      ((uint16_t)0x0010)            /*!< Bit 4 */
S#define  TIM_BDTR_DTG_5                      ((uint16_t)0x0020)            /*!< Bit 5 */
S#define  TIM_BDTR_DTG_6                      ((uint16_t)0x0040)            /*!< Bit 6 */
S#define  TIM_BDTR_DTG_7                      ((uint16_t)0x0080)            /*!< Bit 7 */
S
S#define  TIM_BDTR_LOCK                       ((uint16_t)0x0300)            /*!< LOCK[1:0] bits (Lock Configuration) */
S#define  TIM_BDTR_LOCK_0                     ((uint16_t)0x0100)            /*!< Bit 0 */
S#define  TIM_BDTR_LOCK_1                     ((uint16_t)0x0200)            /*!< Bit 1 */
S
S#define  TIM_BDTR_OSSI                       ((uint16_t)0x0400)            /*!< Off-State Selection for Idle mode */
S#define  TIM_BDTR_OSSR                       ((uint16_t)0x0800)            /*!< Off-State Selection for Run mode */
S#define  TIM_BDTR_BKE                        ((uint16_t)0x1000)            /*!< Break enable */
S#define  TIM_BDTR_BKP                        ((uint16_t)0x2000)            /*!< Break Polarity */
S#define  TIM_BDTR_AOE                        ((uint16_t)0x4000)            /*!< Automatic Output enable */
S#define  TIM_BDTR_MOE                        ((uint16_t)0x8000)            /*!< Main Output enable */
S
S/*******************  Bit definition for TIM_DCR register  ********************/
S#define  TIM_DCR_DBA                         ((uint16_t)0x001F)            /*!< DBA[4:0] bits (DMA Base Address) */
S#define  TIM_DCR_DBA_0                       ((uint16_t)0x0001)            /*!< Bit 0 */
S#define  TIM_DCR_DBA_1                       ((uint16_t)0x0002)            /*!< Bit 1 */
S#define  TIM_DCR_DBA_2                       ((uint16_t)0x0004)            /*!< Bit 2 */
S#define  TIM_DCR_DBA_3                       ((uint16_t)0x0008)            /*!< Bit 3 */
S#define  TIM_DCR_DBA_4                       ((uint16_t)0x0010)            /*!< Bit 4 */
S
S#define  TIM_DCR_DBL                         ((uint16_t)0x1F00)            /*!< DBL[4:0] bits (DMA Burst Length) */
S#define  TIM_DCR_DBL_0                       ((uint16_t)0x0100)            /*!< Bit 0 */
S#define  TIM_DCR_DBL_1                       ((uint16_t)0x0200)            /*!< Bit 1 */
S#define  TIM_DCR_DBL_2                       ((uint16_t)0x0400)            /*!< Bit 2 */
S#define  TIM_DCR_DBL_3                       ((uint16_t)0x0800)            /*!< Bit 3 */
S#define  TIM_DCR_DBL_4                       ((uint16_t)0x1000)            /*!< Bit 4 */
S
S/*******************  Bit definition for TIM_DMAR register  *******************/
S#define  TIM_DMAR_DMAB                       ((uint16_t)0xFFFF)            /*!< DMA register for burst accesses */
S
S/******************************************************************************/
S/*                                                                            */
S/*                             Real-Time Clock                                */
S/*                                                                            */
S/******************************************************************************/
S
S/*******************  Bit definition for RTC_CRH register  ********************/
S#define  RTC_CRH_SECIE                       ((uint8_t)0x01)               /*!< Second Interrupt Enable */
S#define  RTC_CRH_ALRIE                       ((uint8_t)0x02)               /*!< Alarm Interrupt Enable */
S#define  RTC_CRH_OWIE                        ((uint8_t)0x04)               /*!< OverfloW Interrupt Enable */
S
S/*******************  Bit definition for RTC_CRL register  ********************/
S#define  RTC_CRL_SECF                        ((uint8_t)0x01)               /*!< Second Flag */
S#define  RTC_CRL_ALRF                        ((uint8_t)0x02)               /*!< Alarm Flag */
S#define  RTC_CRL_OWF                         ((uint8_t)0x04)               /*!< OverfloW Flag */
S#define  RTC_CRL_RSF                         ((uint8_t)0x08)               /*!< Registers Synchronized Flag */
S#define  RTC_CRL_CNF                         ((uint8_t)0x10)               /*!< Configuration Flag */
S#define  RTC_CRL_RTOFF                       ((uint8_t)0x20)               /*!< RTC operation OFF */
S
S/*******************  Bit definition for RTC_PRLH register  *******************/
S#define  RTC_PRLH_PRL                        ((uint16_t)0x000F)            /*!< RTC Prescaler Reload Value High */
S
S/*******************  Bit definition for RTC_PRLL register  *******************/
S#define  RTC_PRLL_PRL                        ((uint16_t)0xFFFF)            /*!< RTC Prescaler Reload Value Low */
S
S/*******************  Bit definition for RTC_DIVH register  *******************/
S#define  RTC_DIVH_RTC_DIV                    ((uint16_t)0x000F)            /*!< RTC Clock Divider High */
S
S/*******************  Bit definition for RTC_DIVL register  *******************/
S#define  RTC_DIVL_RTC_DIV                    ((uint16_t)0xFFFF)            /*!< RTC Clock Divider Low */
S
S/*******************  Bit definition for RTC_CNTH register  *******************/
S#define  RTC_CNTH_RTC_CNT                    ((uint16_t)0xFFFF)            /*!< RTC Counter High */
S
S/*******************  Bit definition for RTC_CNTL register  *******************/
S#define  RTC_CNTL_RTC_CNT                    ((uint16_t)0xFFFF)            /*!< RTC Counter Low */
S
S/*******************  Bit definition for RTC_ALRH register  *******************/
S#define  RTC_ALRH_RTC_ALR                    ((uint16_t)0xFFFF)            /*!< RTC Alarm High */
S
S/*******************  Bit definition for RTC_ALRL register  *******************/
S#define  RTC_ALRL_RTC_ALR                    ((uint16_t)0xFFFF)            /*!< RTC Alarm Low */
S
S/******************************************************************************/
S/*                                                                            */
S/*                           Independent WATCHDOG                             */
S/*                                                                            */
S/******************************************************************************/
S
S/*******************  Bit definition for IWDG_KR register  ********************/
S#define  IWDG_KR_KEY                         ((uint16_t)0xFFFF)            /*!< Key value (write only, read 0000h) */
S
S/*******************  Bit definition for IWDG_PR register  ********************/
S#define  IWDG_PR_PR                          ((uint8_t)0x07)               /*!< PR[2:0] (Prescaler divider) */
S#define  IWDG_PR_PR_0                        ((uint8_t)0x01)               /*!< Bit 0 */
S#define  IWDG_PR_PR_1                        ((uint8_t)0x02)               /*!< Bit 1 */
S#define  IWDG_PR_PR_2                        ((uint8_t)0x04)               /*!< Bit 2 */
S
S/*******************  Bit definition for IWDG_RLR register  *******************/
S#define  IWDG_RLR_RL                         ((uint16_t)0x0FFF)            /*!< Watchdog counter reload value */
S
S/*******************  Bit definition for IWDG_SR register  ********************/
S#define  IWDG_SR_PVU                         ((uint8_t)0x01)               /*!< Watchdog prescaler value update */
S#define  IWDG_SR_RVU                         ((uint8_t)0x02)               /*!< Watchdog counter reload value update */
S
S/******************************************************************************/
S/*                                                                            */
S/*                            Window WATCHDOG                                 */
S/*                                                                            */
S/******************************************************************************/
S
S/*******************  Bit definition for WWDG_CR register  ********************/
S#define  WWDG_CR_T                           ((uint8_t)0x7F)               /*!< T[6:0] bits (7-Bit counter (MSB to LSB)) */
S#define  WWDG_CR_T0                          ((uint8_t)0x01)               /*!< Bit 0 */
S#define  WWDG_CR_T1                          ((uint8_t)0x02)               /*!< Bit 1 */
S#define  WWDG_CR_T2                          ((uint8_t)0x04)               /*!< Bit 2 */
S#define  WWDG_CR_T3                          ((uint8_t)0x08)               /*!< Bit 3 */
S#define  WWDG_CR_T4                          ((uint8_t)0x10)               /*!< Bit 4 */
S#define  WWDG_CR_T5                          ((uint8_t)0x20)               /*!< Bit 5 */
S#define  WWDG_CR_T6                          ((uint8_t)0x40)               /*!< Bit 6 */
S
S#define  WWDG_CR_WDGA                        ((uint8_t)0x80)               /*!< Activation bit */
S
S/*******************  Bit definition for WWDG_CFR register  *******************/
S#define  WWDG_CFR_W                          ((uint16_t)0x007F)            /*!< W[6:0] bits (7-bit window value) */
S#define  WWDG_CFR_W0                         ((uint16_t)0x0001)            /*!< Bit 0 */
S#define  WWDG_CFR_W1                         ((uint16_t)0x0002)            /*!< Bit 1 */
S#define  WWDG_CFR_W2                         ((uint16_t)0x0004)            /*!< Bit 2 */
S#define  WWDG_CFR_W3                         ((uint16_t)0x0008)            /*!< Bit 3 */
S#define  WWDG_CFR_W4                         ((uint16_t)0x0010)            /*!< Bit 4 */
S#define  WWDG_CFR_W5                         ((uint16_t)0x0020)            /*!< Bit 5 */
S#define  WWDG_CFR_W6                         ((uint16_t)0x0040)            /*!< Bit 6 */
S
S#define  WWDG_CFR_WDGTB                      ((uint16_t)0x0180)            /*!< WDGTB[1:0] bits (Timer Base) */
S#define  WWDG_CFR_WDGTB0                     ((uint16_t)0x0080)            /*!< Bit 0 */
S#define  WWDG_CFR_WDGTB1                     ((uint16_t)0x0100)            /*!< Bit 1 */
S
S#define  WWDG_CFR_EWI                        ((uint16_t)0x0200)            /*!< Early Wakeup Interrupt */
S
S/*******************  Bit definition for WWDG_SR register  ********************/
S#define  WWDG_SR_EWIF                        ((uint8_t)0x01)               /*!< Early Wakeup Interrupt Flag */
S
S/******************************************************************************/
S/*                                                                            */
S/*                       Flexible Static Memory Controller                    */
S/*                                                                            */
S/******************************************************************************/
S
S/******************  Bit definition for FSMC_BCR1 register  *******************/
S#define  FSMC_BCR1_MBKEN                     ((uint32_t)0x00000001)        /*!< Memory bank enable bit */
S#define  FSMC_BCR1_MUXEN                     ((uint32_t)0x00000002)        /*!< Address/data multiplexing enable bit */
S
S#define  FSMC_BCR1_MTYP                      ((uint32_t)0x0000000C)        /*!< MTYP[1:0] bits (Memory type) */
S#define  FSMC_BCR1_MTYP_0                    ((uint32_t)0x00000004)        /*!< Bit 0 */
S#define  FSMC_BCR1_MTYP_1                    ((uint32_t)0x00000008)        /*!< Bit 1 */
S
S#define  FSMC_BCR1_MWID                      ((uint32_t)0x00000030)        /*!< MWID[1:0] bits (Memory data bus width) */
S#define  FSMC_BCR1_MWID_0                    ((uint32_t)0x00000010)        /*!< Bit 0 */
S#define  FSMC_BCR1_MWID_1                    ((uint32_t)0x00000020)        /*!< Bit 1 */
S
S#define  FSMC_BCR1_FACCEN                    ((uint32_t)0x00000040)        /*!< Flash access enable */
S#define  FSMC_BCR1_BURSTEN                   ((uint32_t)0x00000100)        /*!< Burst enable bit */
S#define  FSMC_BCR1_WAITPOL                   ((uint32_t)0x00000200)        /*!< Wait signal polarity bit */
S#define  FSMC_BCR1_WRAPMOD                   ((uint32_t)0x00000400)        /*!< Wrapped burst mode support */
S#define  FSMC_BCR1_WAITCFG                   ((uint32_t)0x00000800)        /*!< Wait timing configuration */
S#define  FSMC_BCR1_WREN                      ((uint32_t)0x00001000)        /*!< Write enable bit */
S#define  FSMC_BCR1_WAITEN                    ((uint32_t)0x00002000)        /*!< Wait enable bit */
S#define  FSMC_BCR1_EXTMOD                    ((uint32_t)0x00004000)        /*!< Extended mode enable */
S#define  FSMC_BCR1_ASYNCWAIT                 ((uint32_t)0x00008000)       /*!< Asynchronous wait */
S#define  FSMC_BCR1_CBURSTRW                  ((uint32_t)0x00080000)        /*!< Write burst enable */
S
S/******************  Bit definition for FSMC_BCR2 register  *******************/
S#define  FSMC_BCR2_MBKEN                     ((uint32_t)0x00000001)        /*!< Memory bank enable bit */
S#define  FSMC_BCR2_MUXEN                     ((uint32_t)0x00000002)        /*!< Address/data multiplexing enable bit */
S
S#define  FSMC_BCR2_MTYP                      ((uint32_t)0x0000000C)        /*!< MTYP[1:0] bits (Memory type) */
S#define  FSMC_BCR2_MTYP_0                    ((uint32_t)0x00000004)        /*!< Bit 0 */
S#define  FSMC_BCR2_MTYP_1                    ((uint32_t)0x00000008)        /*!< Bit 1 */
S
S#define  FSMC_BCR2_MWID                      ((uint32_t)0x00000030)        /*!< MWID[1:0] bits (Memory data bus width) */
S#define  FSMC_BCR2_MWID_0                    ((uint32_t)0x00000010)        /*!< Bit 0 */
S#define  FSMC_BCR2_MWID_1                    ((uint32_t)0x00000020)        /*!< Bit 1 */
S
S#define  FSMC_BCR2_FACCEN                    ((uint32_t)0x00000040)        /*!< Flash access enable */
S#define  FSMC_BCR2_BURSTEN                   ((uint32_t)0x00000100)        /*!< Burst enable bit */
S#define  FSMC_BCR2_WAITPOL                   ((uint32_t)0x00000200)        /*!< Wait signal polarity bit */
S#define  FSMC_BCR2_WRAPMOD                   ((uint32_t)0x00000400)        /*!< Wrapped burst mode support */
S#define  FSMC_BCR2_WAITCFG                   ((uint32_t)0x00000800)        /*!< Wait timing configuration */
S#define  FSMC_BCR2_WREN                      ((uint32_t)0x00001000)        /*!< Write enable bit */
S#define  FSMC_BCR2_WAITEN                    ((uint32_t)0x00002000)        /*!< Wait enable bit */
S#define  FSMC_BCR2_EXTMOD                    ((uint32_t)0x00004000)        /*!< Extended mode enable */
S#define  FSMC_BCR2_ASYNCWAIT                 ((uint32_t)0x00008000)       /*!< Asynchronous wait */
S#define  FSMC_BCR2_CBURSTRW                  ((uint32_t)0x00080000)        /*!< Write burst enable */
S
S/******************  Bit definition for FSMC_BCR3 register  *******************/
S#define  FSMC_BCR3_MBKEN                     ((uint32_t)0x00000001)        /*!< Memory bank enable bit */
S#define  FSMC_BCR3_MUXEN                     ((uint32_t)0x00000002)        /*!< Address/data multiplexing enable bit */
S
S#define  FSMC_BCR3_MTYP                      ((uint32_t)0x0000000C)        /*!< MTYP[1:0] bits (Memory type) */
S#define  FSMC_BCR3_MTYP_0                    ((uint32_t)0x00000004)        /*!< Bit 0 */
S#define  FSMC_BCR3_MTYP_1                    ((uint32_t)0x00000008)        /*!< Bit 1 */
S
S#define  FSMC_BCR3_MWID                      ((uint32_t)0x00000030)        /*!< MWID[1:0] bits (Memory data bus width) */
S#define  FSMC_BCR3_MWID_0                    ((uint32_t)0x00000010)        /*!< Bit 0 */
S#define  FSMC_BCR3_MWID_1                    ((uint32_t)0x00000020)        /*!< Bit 1 */
S
S#define  FSMC_BCR3_FACCEN                    ((uint32_t)0x00000040)        /*!< Flash access enable */
S#define  FSMC_BCR3_BURSTEN                   ((uint32_t)0x00000100)        /*!< Burst enable bit */
S#define  FSMC_BCR3_WAITPOL                   ((uint32_t)0x00000200)        /*!< Wait signal polarity bit. */
S#define  FSMC_BCR3_WRAPMOD                   ((uint32_t)0x00000400)        /*!< Wrapped burst mode support */
S#define  FSMC_BCR3_WAITCFG                   ((uint32_t)0x00000800)        /*!< Wait timing configuration */
S#define  FSMC_BCR3_WREN                      ((uint32_t)0x00001000)        /*!< Write enable bit */
S#define  FSMC_BCR3_WAITEN                    ((uint32_t)0x00002000)        /*!< Wait enable bit */
S#define  FSMC_BCR3_EXTMOD                    ((uint32_t)0x00004000)        /*!< Extended mode enable */
S#define  FSMC_BCR3_ASYNCWAIT                 ((uint32_t)0x00008000)       /*!< Asynchronous wait */
S#define  FSMC_BCR3_CBURSTRW                  ((uint32_t)0x00080000)        /*!< Write burst enable */
S
S/******************  Bit definition for FSMC_BCR4 register  *******************/
S#define  FSMC_BCR4_MBKEN                     ((uint32_t)0x00000001)        /*!< Memory bank enable bit */
S#define  FSMC_BCR4_MUXEN                     ((uint32_t)0x00000002)        /*!< Address/data multiplexing enable bit */
S
S#define  FSMC_BCR4_MTYP                      ((uint32_t)0x0000000C)        /*!< MTYP[1:0] bits (Memory type) */
S#define  FSMC_BCR4_MTYP_0                    ((uint32_t)0x00000004)        /*!< Bit 0 */
S#define  FSMC_BCR4_MTYP_1                    ((uint32_t)0x00000008)        /*!< Bit 1 */
S
S#define  FSMC_BCR4_MWID                      ((uint32_t)0x00000030)        /*!< MWID[1:0] bits (Memory data bus width) */
S#define  FSMC_BCR4_MWID_0                    ((uint32_t)0x00000010)        /*!< Bit 0 */
S#define  FSMC_BCR4_MWID_1                    ((uint32_t)0x00000020)        /*!< Bit 1 */
S
S#define  FSMC_BCR4_FACCEN                    ((uint32_t)0x00000040)        /*!< Flash access enable */
S#define  FSMC_BCR4_BURSTEN                   ((uint32_t)0x00000100)        /*!< Burst enable bit */
S#define  FSMC_BCR4_WAITPOL                   ((uint32_t)0x00000200)        /*!< Wait signal polarity bit */
S#define  FSMC_BCR4_WRAPMOD                   ((uint32_t)0x00000400)        /*!< Wrapped burst mode support */
S#define  FSMC_BCR4_WAITCFG                   ((uint32_t)0x00000800)        /*!< Wait timing configuration */
S#define  FSMC_BCR4_WREN                      ((uint32_t)0x00001000)        /*!< Write enable bit */
S#define  FSMC_BCR4_WAITEN                    ((uint32_t)0x00002000)        /*!< Wait enable bit */
S#define  FSMC_BCR4_EXTMOD                    ((uint32_t)0x00004000)        /*!< Extended mode enable */
S#define  FSMC_BCR4_ASYNCWAIT                 ((uint32_t)0x00008000)       /*!< Asynchronous wait */
S#define  FSMC_BCR4_CBURSTRW                  ((uint32_t)0x00080000)        /*!< Write burst enable */
S
S/******************  Bit definition for FSMC_BTR1 register  ******************/
S#define  FSMC_BTR1_ADDSET                    ((uint32_t)0x0000000F)        /*!< ADDSET[3:0] bits (Address setup phase duration) */
S#define  FSMC_BTR1_ADDSET_0                  ((uint32_t)0x00000001)        /*!< Bit 0 */
S#define  FSMC_BTR1_ADDSET_1                  ((uint32_t)0x00000002)        /*!< Bit 1 */
S#define  FSMC_BTR1_ADDSET_2                  ((uint32_t)0x00000004)        /*!< Bit 2 */
S#define  FSMC_BTR1_ADDSET_3                  ((uint32_t)0x00000008)        /*!< Bit 3 */
S
S#define  FSMC_BTR1_ADDHLD                    ((uint32_t)0x000000F0)        /*!< ADDHLD[3:0] bits (Address-hold phase duration) */
S#define  FSMC_BTR1_ADDHLD_0                  ((uint32_t)0x00000010)        /*!< Bit 0 */
S#define  FSMC_BTR1_ADDHLD_1                  ((uint32_t)0x00000020)        /*!< Bit 1 */
S#define  FSMC_BTR1_ADDHLD_2                  ((uint32_t)0x00000040)        /*!< Bit 2 */
S#define  FSMC_BTR1_ADDHLD_3                  ((uint32_t)0x00000080)        /*!< Bit 3 */
S
S#define  FSMC_BTR1_DATAST                    ((uint32_t)0x0000FF00)        /*!< DATAST [3:0] bits (Data-phase duration) */
S#define  FSMC_BTR1_DATAST_0                  ((uint32_t)0x00000100)        /*!< Bit 0 */
S#define  FSMC_BTR1_DATAST_1                  ((uint32_t)0x00000200)        /*!< Bit 1 */
S#define  FSMC_BTR1_DATAST_2                  ((uint32_t)0x00000400)        /*!< Bit 2 */
S#define  FSMC_BTR1_DATAST_3                  ((uint32_t)0x00000800)        /*!< Bit 3 */
S
S#define  FSMC_BTR1_BUSTURN                   ((uint32_t)0x000F0000)        /*!< BUSTURN[3:0] bits (Bus turnaround phase duration) */
S#define  FSMC_BTR1_BUSTURN_0                 ((uint32_t)0x00010000)        /*!< Bit 0 */
S#define  FSMC_BTR1_BUSTURN_1                 ((uint32_t)0x00020000)        /*!< Bit 1 */
S#define  FSMC_BTR1_BUSTURN_2                 ((uint32_t)0x00040000)        /*!< Bit 2 */
S#define  FSMC_BTR1_BUSTURN_3                 ((uint32_t)0x00080000)        /*!< Bit 3 */
S
S#define  FSMC_BTR1_CLKDIV                    ((uint32_t)0x00F00000)        /*!< CLKDIV[3:0] bits (Clock divide ratio) */
S#define  FSMC_BTR1_CLKDIV_0                  ((uint32_t)0x00100000)        /*!< Bit 0 */
S#define  FSMC_BTR1_CLKDIV_1                  ((uint32_t)0x00200000)        /*!< Bit 1 */
S#define  FSMC_BTR1_CLKDIV_2                  ((uint32_t)0x00400000)        /*!< Bit 2 */
S#define  FSMC_BTR1_CLKDIV_3                  ((uint32_t)0x00800000)        /*!< Bit 3 */
S
S#define  FSMC_BTR1_DATLAT                    ((uint32_t)0x0F000000)        /*!< DATLA[3:0] bits (Data latency) */
S#define  FSMC_BTR1_DATLAT_0                  ((uint32_t)0x01000000)        /*!< Bit 0 */
S#define  FSMC_BTR1_DATLAT_1                  ((uint32_t)0x02000000)        /*!< Bit 1 */
S#define  FSMC_BTR1_DATLAT_2                  ((uint32_t)0x04000000)        /*!< Bit 2 */
S#define  FSMC_BTR1_DATLAT_3                  ((uint32_t)0x08000000)        /*!< Bit 3 */
S
S#define  FSMC_BTR1_ACCMOD                    ((uint32_t)0x30000000)        /*!< ACCMOD[1:0] bits (Access mode) */
S#define  FSMC_BTR1_ACCMOD_0                  ((uint32_t)0x10000000)        /*!< Bit 0 */
S#define  FSMC_BTR1_ACCMOD_1                  ((uint32_t)0x20000000)        /*!< Bit 1 */
S
S/******************  Bit definition for FSMC_BTR2 register  *******************/
S#define  FSMC_BTR2_ADDSET                    ((uint32_t)0x0000000F)        /*!< ADDSET[3:0] bits (Address setup phase duration) */
S#define  FSMC_BTR2_ADDSET_0                  ((uint32_t)0x00000001)        /*!< Bit 0 */
S#define  FSMC_BTR2_ADDSET_1                  ((uint32_t)0x00000002)        /*!< Bit 1 */
S#define  FSMC_BTR2_ADDSET_2                  ((uint32_t)0x00000004)        /*!< Bit 2 */
S#define  FSMC_BTR2_ADDSET_3                  ((uint32_t)0x00000008)        /*!< Bit 3 */
S
S#define  FSMC_BTR2_ADDHLD                    ((uint32_t)0x000000F0)        /*!< ADDHLD[3:0] bits (Address-hold phase duration) */
S#define  FSMC_BTR2_ADDHLD_0                  ((uint32_t)0x00000010)        /*!< Bit 0 */
S#define  FSMC_BTR2_ADDHLD_1                  ((uint32_t)0x00000020)        /*!< Bit 1 */
S#define  FSMC_BTR2_ADDHLD_2                  ((uint32_t)0x00000040)        /*!< Bit 2 */
S#define  FSMC_BTR2_ADDHLD_3                  ((uint32_t)0x00000080)        /*!< Bit 3 */
S
S#define  FSMC_BTR2_DATAST                    ((uint32_t)0x0000FF00)        /*!< DATAST [3:0] bits (Data-phase duration) */
S#define  FSMC_BTR2_DATAST_0                  ((uint32_t)0x00000100)        /*!< Bit 0 */
S#define  FSMC_BTR2_DATAST_1                  ((uint32_t)0x00000200)        /*!< Bit 1 */
S#define  FSMC_BTR2_DATAST_2                  ((uint32_t)0x00000400)        /*!< Bit 2 */
S#define  FSMC_BTR2_DATAST_3                  ((uint32_t)0x00000800)        /*!< Bit 3 */
S
S#define  FSMC_BTR2_BUSTURN                   ((uint32_t)0x000F0000)        /*!< BUSTURN[3:0] bits (Bus turnaround phase duration) */
S#define  FSMC_BTR2_BUSTURN_0                 ((uint32_t)0x00010000)        /*!< Bit 0 */
S#define  FSMC_BTR2_BUSTURN_1                 ((uint32_t)0x00020000)        /*!< Bit 1 */
S#define  FSMC_BTR2_BUSTURN_2                 ((uint32_t)0x00040000)        /*!< Bit 2 */
S#define  FSMC_BTR2_BUSTURN_3                 ((uint32_t)0x00080000)        /*!< Bit 3 */
S
S#define  FSMC_BTR2_CLKDIV                    ((uint32_t)0x00F00000)        /*!< CLKDIV[3:0] bits (Clock divide ratio) */
S#define  FSMC_BTR2_CLKDIV_0                  ((uint32_t)0x00100000)        /*!< Bit 0 */
S#define  FSMC_BTR2_CLKDIV_1                  ((uint32_t)0x00200000)        /*!< Bit 1 */
S#define  FSMC_BTR2_CLKDIV_2                  ((uint32_t)0x00400000)        /*!< Bit 2 */
S#define  FSMC_BTR2_CLKDIV_3                  ((uint32_t)0x00800000)        /*!< Bit 3 */
S
S#define  FSMC_BTR2_DATLAT                    ((uint32_t)0x0F000000)        /*!< DATLA[3:0] bits (Data latency) */
S#define  FSMC_BTR2_DATLAT_0                  ((uint32_t)0x01000000)        /*!< Bit 0 */
S#define  FSMC_BTR2_DATLAT_1                  ((uint32_t)0x02000000)        /*!< Bit 1 */
S#define  FSMC_BTR2_DATLAT_2                  ((uint32_t)0x04000000)        /*!< Bit 2 */
S#define  FSMC_BTR2_DATLAT_3                  ((uint32_t)0x08000000)        /*!< Bit 3 */
S
S#define  FSMC_BTR2_ACCMOD                    ((uint32_t)0x30000000)        /*!< ACCMOD[1:0] bits (Access mode) */
S#define  FSMC_BTR2_ACCMOD_0                  ((uint32_t)0x10000000)        /*!< Bit 0 */
S#define  FSMC_BTR2_ACCMOD_1                  ((uint32_t)0x20000000)        /*!< Bit 1 */
S
S/*******************  Bit definition for FSMC_BTR3 register  *******************/
S#define  FSMC_BTR3_ADDSET                    ((uint32_t)0x0000000F)        /*!< ADDSET[3:0] bits (Address setup phase duration) */
S#define  FSMC_BTR3_ADDSET_0                  ((uint32_t)0x00000001)        /*!< Bit 0 */
S#define  FSMC_BTR3_ADDSET_1                  ((uint32_t)0x00000002)        /*!< Bit 1 */
S#define  FSMC_BTR3_ADDSET_2                  ((uint32_t)0x00000004)        /*!< Bit 2 */
S#define  FSMC_BTR3_ADDSET_3                  ((uint32_t)0x00000008)        /*!< Bit 3 */
S
S#define  FSMC_BTR3_ADDHLD                    ((uint32_t)0x000000F0)        /*!< ADDHLD[3:0] bits (Address-hold phase duration) */
S#define  FSMC_BTR3_ADDHLD_0                  ((uint32_t)0x00000010)        /*!< Bit 0 */
S#define  FSMC_BTR3_ADDHLD_1                  ((uint32_t)0x00000020)        /*!< Bit 1 */
S#define  FSMC_BTR3_ADDHLD_2                  ((uint32_t)0x00000040)        /*!< Bit 2 */
S#define  FSMC_BTR3_ADDHLD_3                  ((uint32_t)0x00000080)        /*!< Bit 3 */
S
S#define  FSMC_BTR3_DATAST                    ((uint32_t)0x0000FF00)        /*!< DATAST [3:0] bits (Data-phase duration) */
S#define  FSMC_BTR3_DATAST_0                  ((uint32_t)0x00000100)        /*!< Bit 0 */
S#define  FSMC_BTR3_DATAST_1                  ((uint32_t)0x00000200)        /*!< Bit 1 */
S#define  FSMC_BTR3_DATAST_2                  ((uint32_t)0x00000400)        /*!< Bit 2 */
S#define  FSMC_BTR3_DATAST_3                  ((uint32_t)0x00000800)        /*!< Bit 3 */
S
S#define  FSMC_BTR3_BUSTURN                   ((uint32_t)0x000F0000)        /*!< BUSTURN[3:0] bits (Bus turnaround phase duration) */
S#define  FSMC_BTR3_BUSTURN_0                 ((uint32_t)0x00010000)        /*!< Bit 0 */
S#define  FSMC_BTR3_BUSTURN_1                 ((uint32_t)0x00020000)        /*!< Bit 1 */
S#define  FSMC_BTR3_BUSTURN_2                 ((uint32_t)0x00040000)        /*!< Bit 2 */
S#define  FSMC_BTR3_BUSTURN_3                 ((uint32_t)0x00080000)        /*!< Bit 3 */
S
S#define  FSMC_BTR3_CLKDIV                    ((uint32_t)0x00F00000)        /*!< CLKDIV[3:0] bits (Clock divide ratio) */
S#define  FSMC_BTR3_CLKDIV_0                  ((uint32_t)0x00100000)        /*!< Bit 0 */
S#define  FSMC_BTR3_CLKDIV_1                  ((uint32_t)0x00200000)        /*!< Bit 1 */
S#define  FSMC_BTR3_CLKDIV_2                  ((uint32_t)0x00400000)        /*!< Bit 2 */
S#define  FSMC_BTR3_CLKDIV_3                  ((uint32_t)0x00800000)        /*!< Bit 3 */
S
S#define  FSMC_BTR3_DATLAT                    ((uint32_t)0x0F000000)        /*!< DATLA[3:0] bits (Data latency) */
S#define  FSMC_BTR3_DATLAT_0                  ((uint32_t)0x01000000)        /*!< Bit 0 */
S#define  FSMC_BTR3_DATLAT_1                  ((uint32_t)0x02000000)        /*!< Bit 1 */
S#define  FSMC_BTR3_DATLAT_2                  ((uint32_t)0x04000000)        /*!< Bit 2 */
S#define  FSMC_BTR3_DATLAT_3                  ((uint32_t)0x08000000)        /*!< Bit 3 */
S
S#define  FSMC_BTR3_ACCMOD                    ((uint32_t)0x30000000)        /*!< ACCMOD[1:0] bits (Access mode) */
S#define  FSMC_BTR3_ACCMOD_0                  ((uint32_t)0x10000000)        /*!< Bit 0 */
S#define  FSMC_BTR3_ACCMOD_1                  ((uint32_t)0x20000000)        /*!< Bit 1 */
S
S/******************  Bit definition for FSMC_BTR4 register  *******************/
S#define  FSMC_BTR4_ADDSET                    ((uint32_t)0x0000000F)        /*!< ADDSET[3:0] bits (Address setup phase duration) */
S#define  FSMC_BTR4_ADDSET_0                  ((uint32_t)0x00000001)        /*!< Bit 0 */
S#define  FSMC_BTR4_ADDSET_1                  ((uint32_t)0x00000002)        /*!< Bit 1 */
S#define  FSMC_BTR4_ADDSET_2                  ((uint32_t)0x00000004)        /*!< Bit 2 */
S#define  FSMC_BTR4_ADDSET_3                  ((uint32_t)0x00000008)        /*!< Bit 3 */
S
S#define  FSMC_BTR4_ADDHLD                    ((uint32_t)0x000000F0)        /*!< ADDHLD[3:0] bits (Address-hold phase duration) */
S#define  FSMC_BTR4_ADDHLD_0                  ((uint32_t)0x00000010)        /*!< Bit 0 */
S#define  FSMC_BTR4_ADDHLD_1                  ((uint32_t)0x00000020)        /*!< Bit 1 */
S#define  FSMC_BTR4_ADDHLD_2                  ((uint32_t)0x00000040)        /*!< Bit 2 */
S#define  FSMC_BTR4_ADDHLD_3                  ((uint32_t)0x00000080)        /*!< Bit 3 */
S
S#define  FSMC_BTR4_DATAST                    ((uint32_t)0x0000FF00)        /*!< DATAST [3:0] bits (Data-phase duration) */
S#define  FSMC_BTR4_DATAST_0                  ((uint32_t)0x00000100)        /*!< Bit 0 */
S#define  FSMC_BTR4_DATAST_1                  ((uint32_t)0x00000200)        /*!< Bit 1 */
S#define  FSMC_BTR4_DATAST_2                  ((uint32_t)0x00000400)        /*!< Bit 2 */
S#define  FSMC_BTR4_DATAST_3                  ((uint32_t)0x00000800)        /*!< Bit 3 */
S
S#define  FSMC_BTR4_BUSTURN                   ((uint32_t)0x000F0000)        /*!< BUSTURN[3:0] bits (Bus turnaround phase duration) */
S#define  FSMC_BTR4_BUSTURN_0                 ((uint32_t)0x00010000)        /*!< Bit 0 */
S#define  FSMC_BTR4_BUSTURN_1                 ((uint32_t)0x00020000)        /*!< Bit 1 */
S#define  FSMC_BTR4_BUSTURN_2                 ((uint32_t)0x00040000)        /*!< Bit 2 */
S#define  FSMC_BTR4_BUSTURN_3                 ((uint32_t)0x00080000)        /*!< Bit 3 */
S
S#define  FSMC_BTR4_CLKDIV                    ((uint32_t)0x00F00000)        /*!< CLKDIV[3:0] bits (Clock divide ratio) */
S#define  FSMC_BTR4_CLKDIV_0                  ((uint32_t)0x00100000)        /*!< Bit 0 */
S#define  FSMC_BTR4_CLKDIV_1                  ((uint32_t)0x00200000)        /*!< Bit 1 */
S#define  FSMC_BTR4_CLKDIV_2                  ((uint32_t)0x00400000)        /*!< Bit 2 */
S#define  FSMC_BTR4_CLKDIV_3                  ((uint32_t)0x00800000)        /*!< Bit 3 */
S
S#define  FSMC_BTR4_DATLAT                    ((uint32_t)0x0F000000)        /*!< DATLA[3:0] bits (Data latency) */
S#define  FSMC_BTR4_DATLAT_0                  ((uint32_t)0x01000000)        /*!< Bit 0 */
S#define  FSMC_BTR4_DATLAT_1                  ((uint32_t)0x02000000)        /*!< Bit 1 */
S#define  FSMC_BTR4_DATLAT_2                  ((uint32_t)0x04000000)        /*!< Bit 2 */
S#define  FSMC_BTR4_DATLAT_3                  ((uint32_t)0x08000000)        /*!< Bit 3 */
S
S#define  FSMC_BTR4_ACCMOD                    ((uint32_t)0x30000000)        /*!< ACCMOD[1:0] bits (Access mode) */
S#define  FSMC_BTR4_ACCMOD_0                  ((uint32_t)0x10000000)        /*!< Bit 0 */
S#define  FSMC_BTR4_ACCMOD_1                  ((uint32_t)0x20000000)        /*!< Bit 1 */
S
S/******************  Bit definition for FSMC_BWTR1 register  ******************/
S#define  FSMC_BWTR1_ADDSET                   ((uint32_t)0x0000000F)        /*!< ADDSET[3:0] bits (Address setup phase duration) */
S#define  FSMC_BWTR1_ADDSET_0                 ((uint32_t)0x00000001)        /*!< Bit 0 */
S#define  FSMC_BWTR1_ADDSET_1                 ((uint32_t)0x00000002)        /*!< Bit 1 */
S#define  FSMC_BWTR1_ADDSET_2                 ((uint32_t)0x00000004)        /*!< Bit 2 */
S#define  FSMC_BWTR1_ADDSET_3                 ((uint32_t)0x00000008)        /*!< Bit 3 */
S
S#define  FSMC_BWTR1_ADDHLD                   ((uint32_t)0x000000F0)        /*!< ADDHLD[3:0] bits (Address-hold phase duration) */
S#define  FSMC_BWTR1_ADDHLD_0                 ((uint32_t)0x00000010)        /*!< Bit 0 */
S#define  FSMC_BWTR1_ADDHLD_1                 ((uint32_t)0x00000020)        /*!< Bit 1 */
S#define  FSMC_BWTR1_ADDHLD_2                 ((uint32_t)0x00000040)        /*!< Bit 2 */
S#define  FSMC_BWTR1_ADDHLD_3                 ((uint32_t)0x00000080)        /*!< Bit 3 */
S
S#define  FSMC_BWTR1_DATAST                   ((uint32_t)0x0000FF00)        /*!< DATAST [3:0] bits (Data-phase duration) */
S#define  FSMC_BWTR1_DATAST_0                 ((uint32_t)0x00000100)        /*!< Bit 0 */
S#define  FSMC_BWTR1_DATAST_1                 ((uint32_t)0x00000200)        /*!< Bit 1 */
S#define  FSMC_BWTR1_DATAST_2                 ((uint32_t)0x00000400)        /*!< Bit 2 */
S#define  FSMC_BWTR1_DATAST_3                 ((uint32_t)0x00000800)        /*!< Bit 3 */
S
S#define  FSMC_BWTR1_CLKDIV                   ((uint32_t)0x00F00000)        /*!< CLKDIV[3:0] bits (Clock divide ratio) */
S#define  FSMC_BWTR1_CLKDIV_0                 ((uint32_t)0x00100000)        /*!< Bit 0 */
S#define  FSMC_BWTR1_CLKDIV_1                 ((uint32_t)0x00200000)        /*!< Bit 1 */
S#define  FSMC_BWTR1_CLKDIV_2                 ((uint32_t)0x00400000)        /*!< Bit 2 */
S#define  FSMC_BWTR1_CLKDIV_3                 ((uint32_t)0x00800000)        /*!< Bit 3 */
S
S#define  FSMC_BWTR1_DATLAT                   ((uint32_t)0x0F000000)        /*!< DATLA[3:0] bits (Data latency) */
S#define  FSMC_BWTR1_DATLAT_0                 ((uint32_t)0x01000000)        /*!< Bit 0 */
S#define  FSMC_BWTR1_DATLAT_1                 ((uint32_t)0x02000000)        /*!< Bit 1 */
S#define  FSMC_BWTR1_DATLAT_2                 ((uint32_t)0x04000000)        /*!< Bit 2 */
S#define  FSMC_BWTR1_DATLAT_3                 ((uint32_t)0x08000000)        /*!< Bit 3 */
S
S#define  FSMC_BWTR1_ACCMOD                   ((uint32_t)0x30000000)        /*!< ACCMOD[1:0] bits (Access mode) */
S#define  FSMC_BWTR1_ACCMOD_0                 ((uint32_t)0x10000000)        /*!< Bit 0 */
S#define  FSMC_BWTR1_ACCMOD_1                 ((uint32_t)0x20000000)        /*!< Bit 1 */
S
S/******************  Bit definition for FSMC_BWTR2 register  ******************/
S#define  FSMC_BWTR2_ADDSET                   ((uint32_t)0x0000000F)        /*!< ADDSET[3:0] bits (Address setup phase duration) */
S#define  FSMC_BWTR2_ADDSET_0                 ((uint32_t)0x00000001)        /*!< Bit 0 */
S#define  FSMC_BWTR2_ADDSET_1                 ((uint32_t)0x00000002)        /*!< Bit 1 */
S#define  FSMC_BWTR2_ADDSET_2                 ((uint32_t)0x00000004)        /*!< Bit 2 */
S#define  FSMC_BWTR2_ADDSET_3                 ((uint32_t)0x00000008)        /*!< Bit 3 */
S
S#define  FSMC_BWTR2_ADDHLD                   ((uint32_t)0x000000F0)        /*!< ADDHLD[3:0] bits (Address-hold phase duration) */
S#define  FSMC_BWTR2_ADDHLD_0                 ((uint32_t)0x00000010)        /*!< Bit 0 */
S#define  FSMC_BWTR2_ADDHLD_1                 ((uint32_t)0x00000020)        /*!< Bit 1 */
S#define  FSMC_BWTR2_ADDHLD_2                 ((uint32_t)0x00000040)        /*!< Bit 2 */
S#define  FSMC_BWTR2_ADDHLD_3                 ((uint32_t)0x00000080)        /*!< Bit 3 */
S
S#define  FSMC_BWTR2_DATAST                   ((uint32_t)0x0000FF00)        /*!< DATAST [3:0] bits (Data-phase duration) */
S#define  FSMC_BWTR2_DATAST_0                 ((uint32_t)0x00000100)        /*!< Bit 0 */
S#define  FSMC_BWTR2_DATAST_1                 ((uint32_t)0x00000200)        /*!< Bit 1 */
S#define  FSMC_BWTR2_DATAST_2                 ((uint32_t)0x00000400)        /*!< Bit 2 */
S#define  FSMC_BWTR2_DATAST_3                 ((uint32_t)0x00000800)        /*!< Bit 3 */
S
S#define  FSMC_BWTR2_CLKDIV                   ((uint32_t)0x00F00000)        /*!< CLKDIV[3:0] bits (Clock divide ratio) */
S#define  FSMC_BWTR2_CLKDIV_0                 ((uint32_t)0x00100000)        /*!< Bit 0 */
S#define  FSMC_BWTR2_CLKDIV_1                 ((uint32_t)0x00200000)        /*!< Bit 1*/
S#define  FSMC_BWTR2_CLKDIV_2                 ((uint32_t)0x00400000)        /*!< Bit 2 */
S#define  FSMC_BWTR2_CLKDIV_3                 ((uint32_t)0x00800000)        /*!< Bit 3 */
S
S#define  FSMC_BWTR2_DATLAT                   ((uint32_t)0x0F000000)        /*!< DATLA[3:0] bits (Data latency) */
S#define  FSMC_BWTR2_DATLAT_0                 ((uint32_t)0x01000000)        /*!< Bit 0 */
S#define  FSMC_BWTR2_DATLAT_1                 ((uint32_t)0x02000000)        /*!< Bit 1 */
S#define  FSMC_BWTR2_DATLAT_2                 ((uint32_t)0x04000000)        /*!< Bit 2 */
S#define  FSMC_BWTR2_DATLAT_3                 ((uint32_t)0x08000000)        /*!< Bit 3 */
S
S#define  FSMC_BWTR2_ACCMOD                   ((uint32_t)0x30000000)        /*!< ACCMOD[1:0] bits (Access mode) */
S#define  FSMC_BWTR2_ACCMOD_0                 ((uint32_t)0x10000000)        /*!< Bit 0 */
S#define  FSMC_BWTR2_ACCMOD_1                 ((uint32_t)0x20000000)        /*!< Bit 1 */
S
S/******************  Bit definition for FSMC_BWTR3 register  ******************/
S#define  FSMC_BWTR3_ADDSET                   ((uint32_t)0x0000000F)        /*!< ADDSET[3:0] bits (Address setup phase duration) */
S#define  FSMC_BWTR3_ADDSET_0                 ((uint32_t)0x00000001)        /*!< Bit 0 */
S#define  FSMC_BWTR3_ADDSET_1                 ((uint32_t)0x00000002)        /*!< Bit 1 */
S#define  FSMC_BWTR3_ADDSET_2                 ((uint32_t)0x00000004)        /*!< Bit 2 */
S#define  FSMC_BWTR3_ADDSET_3                 ((uint32_t)0x00000008)        /*!< Bit 3 */
S
S#define  FSMC_BWTR3_ADDHLD                   ((uint32_t)0x000000F0)        /*!< ADDHLD[3:0] bits (Address-hold phase duration) */
S#define  FSMC_BWTR3_ADDHLD_0                 ((uint32_t)0x00000010)        /*!< Bit 0 */
S#define  FSMC_BWTR3_ADDHLD_1                 ((uint32_t)0x00000020)        /*!< Bit 1 */
S#define  FSMC_BWTR3_ADDHLD_2                 ((uint32_t)0x00000040)        /*!< Bit 2 */
S#define  FSMC_BWTR3_ADDHLD_3                 ((uint32_t)0x00000080)        /*!< Bit 3 */
S
S#define  FSMC_BWTR3_DATAST                   ((uint32_t)0x0000FF00)        /*!< DATAST [3:0] bits (Data-phase duration) */
S#define  FSMC_BWTR3_DATAST_0                 ((uint32_t)0x00000100)        /*!< Bit 0 */
S#define  FSMC_BWTR3_DATAST_1                 ((uint32_t)0x00000200)        /*!< Bit 1 */
S#define  FSMC_BWTR3_DATAST_2                 ((uint32_t)0x00000400)        /*!< Bit 2 */
S#define  FSMC_BWTR3_DATAST_3                 ((uint32_t)0x00000800)        /*!< Bit 3 */
S
S#define  FSMC_BWTR3_CLKDIV                   ((uint32_t)0x00F00000)        /*!< CLKDIV[3:0] bits (Clock divide ratio) */
S#define  FSMC_BWTR3_CLKDIV_0                 ((uint32_t)0x00100000)        /*!< Bit 0 */
S#define  FSMC_BWTR3_CLKDIV_1                 ((uint32_t)0x00200000)        /*!< Bit 1 */
S#define  FSMC_BWTR3_CLKDIV_2                 ((uint32_t)0x00400000)        /*!< Bit 2 */
S#define  FSMC_BWTR3_CLKDIV_3                 ((uint32_t)0x00800000)        /*!< Bit 3 */
S
S#define  FSMC_BWTR3_DATLAT                   ((uint32_t)0x0F000000)        /*!< DATLA[3:0] bits (Data latency) */
S#define  FSMC_BWTR3_DATLAT_0                 ((uint32_t)0x01000000)        /*!< Bit 0 */
S#define  FSMC_BWTR3_DATLAT_1                 ((uint32_t)0x02000000)        /*!< Bit 1 */
S#define  FSMC_BWTR3_DATLAT_2                 ((uint32_t)0x04000000)        /*!< Bit 2 */
S#define  FSMC_BWTR3_DATLAT_3                 ((uint32_t)0x08000000)        /*!< Bit 3 */
S
S#define  FSMC_BWTR3_ACCMOD                   ((uint32_t)0x30000000)        /*!< ACCMOD[1:0] bits (Access mode) */
S#define  FSMC_BWTR3_ACCMOD_0                 ((uint32_t)0x10000000)        /*!< Bit 0 */
S#define  FSMC_BWTR3_ACCMOD_1                 ((uint32_t)0x20000000)        /*!< Bit 1 */
S
S/******************  Bit definition for FSMC_BWTR4 register  ******************/
S#define  FSMC_BWTR4_ADDSET                   ((uint32_t)0x0000000F)        /*!< ADDSET[3:0] bits (Address setup phase duration) */
S#define  FSMC_BWTR4_ADDSET_0                 ((uint32_t)0x00000001)        /*!< Bit 0 */
S#define  FSMC_BWTR4_ADDSET_1                 ((uint32_t)0x00000002)        /*!< Bit 1 */
S#define  FSMC_BWTR4_ADDSET_2                 ((uint32_t)0x00000004)        /*!< Bit 2 */
S#define  FSMC_BWTR4_ADDSET_3                 ((uint32_t)0x00000008)        /*!< Bit 3 */
S
S#define  FSMC_BWTR4_ADDHLD                   ((uint32_t)0x000000F0)        /*!< ADDHLD[3:0] bits (Address-hold phase duration) */
S#define  FSMC_BWTR4_ADDHLD_0                 ((uint32_t)0x00000010)        /*!< Bit 0 */
S#define  FSMC_BWTR4_ADDHLD_1                 ((uint32_t)0x00000020)        /*!< Bit 1 */
S#define  FSMC_BWTR4_ADDHLD_2                 ((uint32_t)0x00000040)        /*!< Bit 2 */
S#define  FSMC_BWTR4_ADDHLD_3                 ((uint32_t)0x00000080)        /*!< Bit 3 */
S
S#define  FSMC_BWTR4_DATAST                   ((uint32_t)0x0000FF00)        /*!< DATAST [3:0] bits (Data-phase duration) */
S#define  FSMC_BWTR4_DATAST_0                 ((uint32_t)0x00000100)        /*!< Bit 0 */
S#define  FSMC_BWTR4_DATAST_1                 ((uint32_t)0x00000200)        /*!< Bit 1 */
S#define  FSMC_BWTR4_DATAST_2                 ((uint32_t)0x00000400)        /*!< Bit 2 */
S#define  FSMC_BWTR4_DATAST_3                 ((uint32_t)0x00000800)        /*!< Bit 3 */
S
S#define  FSMC_BWTR4_CLKDIV                   ((uint32_t)0x00F00000)        /*!< CLKDIV[3:0] bits (Clock divide ratio) */
S#define  FSMC_BWTR4_CLKDIV_0                 ((uint32_t)0x00100000)        /*!< Bit 0 */
S#define  FSMC_BWTR4_CLKDIV_1                 ((uint32_t)0x00200000)        /*!< Bit 1 */
S#define  FSMC_BWTR4_CLKDIV_2                 ((uint32_t)0x00400000)        /*!< Bit 2 */
S#define  FSMC_BWTR4_CLKDIV_3                 ((uint32_t)0x00800000)        /*!< Bit 3 */
S
S#define  FSMC_BWTR4_DATLAT                   ((uint32_t)0x0F000000)        /*!< DATLA[3:0] bits (Data latency) */
S#define  FSMC_BWTR4_DATLAT_0                 ((uint32_t)0x01000000)        /*!< Bit 0 */
S#define  FSMC_BWTR4_DATLAT_1                 ((uint32_t)0x02000000)        /*!< Bit 1 */
S#define  FSMC_BWTR4_DATLAT_2                 ((uint32_t)0x04000000)        /*!< Bit 2 */
S#define  FSMC_BWTR4_DATLAT_3                 ((uint32_t)0x08000000)        /*!< Bit 3 */
S
S#define  FSMC_BWTR4_ACCMOD                   ((uint32_t)0x30000000)        /*!< ACCMOD[1:0] bits (Access mode) */
S#define  FSMC_BWTR4_ACCMOD_0                 ((uint32_t)0x10000000)        /*!< Bit 0 */
S#define  FSMC_BWTR4_ACCMOD_1                 ((uint32_t)0x20000000)        /*!< Bit 1 */
S
S/******************  Bit definition for FSMC_PCR2 register  *******************/
S#define  FSMC_PCR2_PWAITEN                   ((uint32_t)0x00000002)        /*!< Wait feature enable bit */
S#define  FSMC_PCR2_PBKEN                     ((uint32_t)0x00000004)        /*!< PC Card/NAND Flash memory bank enable bit */
S#define  FSMC_PCR2_PTYP                      ((uint32_t)0x00000008)        /*!< Memory type */
S
S#define  FSMC_PCR2_PWID                      ((uint32_t)0x00000030)        /*!< PWID[1:0] bits (NAND Flash databus width) */
S#define  FSMC_PCR2_PWID_0                    ((uint32_t)0x00000010)        /*!< Bit 0 */
S#define  FSMC_PCR2_PWID_1                    ((uint32_t)0x00000020)        /*!< Bit 1 */
S
S#define  FSMC_PCR2_ECCEN                     ((uint32_t)0x00000040)        /*!< ECC computation logic enable bit */
S
S#define  FSMC_PCR2_TCLR                      ((uint32_t)0x00001E00)        /*!< TCLR[3:0] bits (CLE to RE delay) */
S#define  FSMC_PCR2_TCLR_0                    ((uint32_t)0x00000200)        /*!< Bit 0 */
S#define  FSMC_PCR2_TCLR_1                    ((uint32_t)0x00000400)        /*!< Bit 1 */
S#define  FSMC_PCR2_TCLR_2                    ((uint32_t)0x00000800)        /*!< Bit 2 */
S#define  FSMC_PCR2_TCLR_3                    ((uint32_t)0x00001000)        /*!< Bit 3 */
S
S#define  FSMC_PCR2_TAR                       ((uint32_t)0x0001E000)        /*!< TAR[3:0] bits (ALE to RE delay) */
S#define  FSMC_PCR2_TAR_0                     ((uint32_t)0x00002000)        /*!< Bit 0 */
S#define  FSMC_PCR2_TAR_1                     ((uint32_t)0x00004000)        /*!< Bit 1 */
S#define  FSMC_PCR2_TAR_2                     ((uint32_t)0x00008000)        /*!< Bit 2 */
S#define  FSMC_PCR2_TAR_3                     ((uint32_t)0x00010000)        /*!< Bit 3 */
S
S#define  FSMC_PCR2_ECCPS                     ((uint32_t)0x000E0000)        /*!< ECCPS[1:0] bits (ECC page size) */
S#define  FSMC_PCR2_ECCPS_0                   ((uint32_t)0x00020000)        /*!< Bit 0 */
S#define  FSMC_PCR2_ECCPS_1                   ((uint32_t)0x00040000)        /*!< Bit 1 */
S#define  FSMC_PCR2_ECCPS_2                   ((uint32_t)0x00080000)        /*!< Bit 2 */
S
S/******************  Bit definition for FSMC_PCR3 register  *******************/
S#define  FSMC_PCR3_PWAITEN                   ((uint32_t)0x00000002)        /*!< Wait feature enable bit */
S#define  FSMC_PCR3_PBKEN                     ((uint32_t)0x00000004)        /*!< PC Card/NAND Flash memory bank enable bit */
S#define  FSMC_PCR3_PTYP                      ((uint32_t)0x00000008)        /*!< Memory type */
S
S#define  FSMC_PCR3_PWID                      ((uint32_t)0x00000030)        /*!< PWID[1:0] bits (NAND Flash databus width) */
S#define  FSMC_PCR3_PWID_0                    ((uint32_t)0x00000010)        /*!< Bit 0 */
S#define  FSMC_PCR3_PWID_1                    ((uint32_t)0x00000020)        /*!< Bit 1 */
S
S#define  FSMC_PCR3_ECCEN                     ((uint32_t)0x00000040)        /*!< ECC computation logic enable bit */
S
S#define  FSMC_PCR3_TCLR                      ((uint32_t)0x00001E00)        /*!< TCLR[3:0] bits (CLE to RE delay) */
S#define  FSMC_PCR3_TCLR_0                    ((uint32_t)0x00000200)        /*!< Bit 0 */
S#define  FSMC_PCR3_TCLR_1                    ((uint32_t)0x00000400)        /*!< Bit 1 */
S#define  FSMC_PCR3_TCLR_2                    ((uint32_t)0x00000800)        /*!< Bit 2 */
S#define  FSMC_PCR3_TCLR_3                    ((uint32_t)0x00001000)        /*!< Bit 3 */
S
S#define  FSMC_PCR3_TAR                       ((uint32_t)0x0001E000)        /*!< TAR[3:0] bits (ALE to RE delay) */
S#define  FSMC_PCR3_TAR_0                     ((uint32_t)0x00002000)        /*!< Bit 0 */
S#define  FSMC_PCR3_TAR_1                     ((uint32_t)0x00004000)        /*!< Bit 1 */
S#define  FSMC_PCR3_TAR_2                     ((uint32_t)0x00008000)        /*!< Bit 2 */
S#define  FSMC_PCR3_TAR_3                     ((uint32_t)0x00010000)        /*!< Bit 3 */
S
S#define  FSMC_PCR3_ECCPS                     ((uint32_t)0x000E0000)        /*!< ECCPS[2:0] bits (ECC page size) */
S#define  FSMC_PCR3_ECCPS_0                   ((uint32_t)0x00020000)        /*!< Bit 0 */
S#define  FSMC_PCR3_ECCPS_1                   ((uint32_t)0x00040000)        /*!< Bit 1 */
S#define  FSMC_PCR3_ECCPS_2                   ((uint32_t)0x00080000)        /*!< Bit 2 */
S
S/******************  Bit definition for FSMC_PCR4 register  *******************/
S#define  FSMC_PCR4_PWAITEN                   ((uint32_t)0x00000002)        /*!< Wait feature enable bit */
S#define  FSMC_PCR4_PBKEN                     ((uint32_t)0x00000004)        /*!< PC Card/NAND Flash memory bank enable bit */
S#define  FSMC_PCR4_PTYP                      ((uint32_t)0x00000008)        /*!< Memory type */
S
S#define  FSMC_PCR4_PWID                      ((uint32_t)0x00000030)        /*!< PWID[1:0] bits (NAND Flash databus width) */
S#define  FSMC_PCR4_PWID_0                    ((uint32_t)0x00000010)        /*!< Bit 0 */
S#define  FSMC_PCR4_PWID_1                    ((uint32_t)0x00000020)        /*!< Bit 1 */
S
S#define  FSMC_PCR4_ECCEN                     ((uint32_t)0x00000040)        /*!< ECC computation logic enable bit */
S
S#define  FSMC_PCR4_TCLR                      ((uint32_t)0x00001E00)        /*!< TCLR[3:0] bits (CLE to RE delay) */
S#define  FSMC_PCR4_TCLR_0                    ((uint32_t)0x00000200)        /*!< Bit 0 */
S#define  FSMC_PCR4_TCLR_1                    ((uint32_t)0x00000400)        /*!< Bit 1 */
S#define  FSMC_PCR4_TCLR_2                    ((uint32_t)0x00000800)        /*!< Bit 2 */
S#define  FSMC_PCR4_TCLR_3                    ((uint32_t)0x00001000)        /*!< Bit 3 */
S
S#define  FSMC_PCR4_TAR                       ((uint32_t)0x0001E000)        /*!< TAR[3:0] bits (ALE to RE delay) */
S#define  FSMC_PCR4_TAR_0                     ((uint32_t)0x00002000)        /*!< Bit 0 */
S#define  FSMC_PCR4_TAR_1                     ((uint32_t)0x00004000)        /*!< Bit 1 */
S#define  FSMC_PCR4_TAR_2                     ((uint32_t)0x00008000)        /*!< Bit 2 */
S#define  FSMC_PCR4_TAR_3                     ((uint32_t)0x00010000)        /*!< Bit 3 */
S
S#define  FSMC_PCR4_ECCPS                     ((uint32_t)0x000E0000)        /*!< ECCPS[2:0] bits (ECC page size) */
S#define  FSMC_PCR4_ECCPS_0                   ((uint32_t)0x00020000)        /*!< Bit 0 */
S#define  FSMC_PCR4_ECCPS_1                   ((uint32_t)0x00040000)        /*!< Bit 1 */
S#define  FSMC_PCR4_ECCPS_2                   ((uint32_t)0x00080000)        /*!< Bit 2 */
S
S/*******************  Bit definition for FSMC_SR2 register  *******************/
S#define  FSMC_SR2_IRS                        ((uint8_t)0x01)               /*!< Interrupt Rising Edge status */
S#define  FSMC_SR2_ILS                        ((uint8_t)0x02)               /*!< Interrupt Level status */
S#define  FSMC_SR2_IFS                        ((uint8_t)0x04)               /*!< Interrupt Falling Edge status */
S#define  FSMC_SR2_IREN                       ((uint8_t)0x08)               /*!< Interrupt Rising Edge detection Enable bit */
S#define  FSMC_SR2_ILEN                       ((uint8_t)0x10)               /*!< Interrupt Level detection Enable bit */
S#define  FSMC_SR2_IFEN                       ((uint8_t)0x20)               /*!< Interrupt Falling Edge detection Enable bit */
S#define  FSMC_SR2_FEMPT                      ((uint8_t)0x40)               /*!< FIFO empty */
S
S/*******************  Bit definition for FSMC_SR3 register  *******************/
S#define  FSMC_SR3_IRS                        ((uint8_t)0x01)               /*!< Interrupt Rising Edge status */
S#define  FSMC_SR3_ILS                        ((uint8_t)0x02)               /*!< Interrupt Level status */
S#define  FSMC_SR3_IFS                        ((uint8_t)0x04)               /*!< Interrupt Falling Edge status */
S#define  FSMC_SR3_IREN                       ((uint8_t)0x08)               /*!< Interrupt Rising Edge detection Enable bit */
S#define  FSMC_SR3_ILEN                       ((uint8_t)0x10)               /*!< Interrupt Level detection Enable bit */
S#define  FSMC_SR3_IFEN                       ((uint8_t)0x20)               /*!< Interrupt Falling Edge detection Enable bit */
S#define  FSMC_SR3_FEMPT                      ((uint8_t)0x40)               /*!< FIFO empty */
S
S/*******************  Bit definition for FSMC_SR4 register  *******************/
S#define  FSMC_SR4_IRS                        ((uint8_t)0x01)               /*!< Interrupt Rising Edge status */
S#define  FSMC_SR4_ILS                        ((uint8_t)0x02)               /*!< Interrupt Level status */
S#define  FSMC_SR4_IFS                        ((uint8_t)0x04)               /*!< Interrupt Falling Edge status */
S#define  FSMC_SR4_IREN                       ((uint8_t)0x08)               /*!< Interrupt Rising Edge detection Enable bit */
S#define  FSMC_SR4_ILEN                       ((uint8_t)0x10)               /*!< Interrupt Level detection Enable bit */
S#define  FSMC_SR4_IFEN                       ((uint8_t)0x20)               /*!< Interrupt Falling Edge detection Enable bit */
S#define  FSMC_SR4_FEMPT                      ((uint8_t)0x40)               /*!< FIFO empty */
S
S/******************  Bit definition for FSMC_PMEM2 register  ******************/
S#define  FSMC_PMEM2_MEMSET2                  ((uint32_t)0x000000FF)        /*!< MEMSET2[7:0] bits (Common memory 2 setup time) */
S#define  FSMC_PMEM2_MEMSET2_0                ((uint32_t)0x00000001)        /*!< Bit 0 */
S#define  FSMC_PMEM2_MEMSET2_1                ((uint32_t)0x00000002)        /*!< Bit 1 */
S#define  FSMC_PMEM2_MEMSET2_2                ((uint32_t)0x00000004)        /*!< Bit 2 */
S#define  FSMC_PMEM2_MEMSET2_3                ((uint32_t)0x00000008)        /*!< Bit 3 */
S#define  FSMC_PMEM2_MEMSET2_4                ((uint32_t)0x00000010)        /*!< Bit 4 */
S#define  FSMC_PMEM2_MEMSET2_5                ((uint32_t)0x00000020)        /*!< Bit 5 */
S#define  FSMC_PMEM2_MEMSET2_6                ((uint32_t)0x00000040)        /*!< Bit 6 */
S#define  FSMC_PMEM2_MEMSET2_7                ((uint32_t)0x00000080)        /*!< Bit 7 */
S
S#define  FSMC_PMEM2_MEMWAIT2                 ((uint32_t)0x0000FF00)        /*!< MEMWAIT2[7:0] bits (Common memory 2 wait time) */
S#define  FSMC_PMEM2_MEMWAIT2_0               ((uint32_t)0x00000100)        /*!< Bit 0 */
S#define  FSMC_PMEM2_MEMWAIT2_1               ((uint32_t)0x00000200)        /*!< Bit 1 */
S#define  FSMC_PMEM2_MEMWAIT2_2               ((uint32_t)0x00000400)        /*!< Bit 2 */
S#define  FSMC_PMEM2_MEMWAIT2_3               ((uint32_t)0x00000800)        /*!< Bit 3 */
S#define  FSMC_PMEM2_MEMWAIT2_4               ((uint32_t)0x00001000)        /*!< Bit 4 */
S#define  FSMC_PMEM2_MEMWAIT2_5               ((uint32_t)0x00002000)        /*!< Bit 5 */
S#define  FSMC_PMEM2_MEMWAIT2_6               ((uint32_t)0x00004000)        /*!< Bit 6 */
S#define  FSMC_PMEM2_MEMWAIT2_7               ((uint32_t)0x00008000)        /*!< Bit 7 */
S
S#define  FSMC_PMEM2_MEMHOLD2                 ((uint32_t)0x00FF0000)        /*!< MEMHOLD2[7:0] bits (Common memory 2 hold time) */
S#define  FSMC_PMEM2_MEMHOLD2_0               ((uint32_t)0x00010000)        /*!< Bit 0 */
S#define  FSMC_PMEM2_MEMHOLD2_1               ((uint32_t)0x00020000)        /*!< Bit 1 */
S#define  FSMC_PMEM2_MEMHOLD2_2               ((uint32_t)0x00040000)        /*!< Bit 2 */
S#define  FSMC_PMEM2_MEMHOLD2_3               ((uint32_t)0x00080000)        /*!< Bit 3 */
S#define  FSMC_PMEM2_MEMHOLD2_4               ((uint32_t)0x00100000)        /*!< Bit 4 */
S#define  FSMC_PMEM2_MEMHOLD2_5               ((uint32_t)0x00200000)        /*!< Bit 5 */
S#define  FSMC_PMEM2_MEMHOLD2_6               ((uint32_t)0x00400000)        /*!< Bit 6 */
S#define  FSMC_PMEM2_MEMHOLD2_7               ((uint32_t)0x00800000)        /*!< Bit 7 */
S
S#define  FSMC_PMEM2_MEMHIZ2                  ((uint32_t)0xFF000000)        /*!< MEMHIZ2[7:0] bits (Common memory 2 databus HiZ time) */
S#define  FSMC_PMEM2_MEMHIZ2_0                ((uint32_t)0x01000000)        /*!< Bit 0 */
S#define  FSMC_PMEM2_MEMHIZ2_1                ((uint32_t)0x02000000)        /*!< Bit 1 */
S#define  FSMC_PMEM2_MEMHIZ2_2                ((uint32_t)0x04000000)        /*!< Bit 2 */
S#define  FSMC_PMEM2_MEMHIZ2_3                ((uint32_t)0x08000000)        /*!< Bit 3 */
S#define  FSMC_PMEM2_MEMHIZ2_4                ((uint32_t)0x10000000)        /*!< Bit 4 */
S#define  FSMC_PMEM2_MEMHIZ2_5                ((uint32_t)0x20000000)        /*!< Bit 5 */
S#define  FSMC_PMEM2_MEMHIZ2_6                ((uint32_t)0x40000000)        /*!< Bit 6 */
S#define  FSMC_PMEM2_MEMHIZ2_7                ((uint32_t)0x80000000)        /*!< Bit 7 */
S
S/******************  Bit definition for FSMC_PMEM3 register  ******************/
S#define  FSMC_PMEM3_MEMSET3                  ((uint32_t)0x000000FF)        /*!< MEMSET3[7:0] bits (Common memory 3 setup time) */
S#define  FSMC_PMEM3_MEMSET3_0                ((uint32_t)0x00000001)        /*!< Bit 0 */
S#define  FSMC_PMEM3_MEMSET3_1                ((uint32_t)0x00000002)        /*!< Bit 1 */
S#define  FSMC_PMEM3_MEMSET3_2                ((uint32_t)0x00000004)        /*!< Bit 2 */
S#define  FSMC_PMEM3_MEMSET3_3                ((uint32_t)0x00000008)        /*!< Bit 3 */
S#define  FSMC_PMEM3_MEMSET3_4                ((uint32_t)0x00000010)        /*!< Bit 4 */
S#define  FSMC_PMEM3_MEMSET3_5                ((uint32_t)0x00000020)        /*!< Bit 5 */
S#define  FSMC_PMEM3_MEMSET3_6                ((uint32_t)0x00000040)        /*!< Bit 6 */
S#define  FSMC_PMEM3_MEMSET3_7                ((uint32_t)0x00000080)        /*!< Bit 7 */
S
S#define  FSMC_PMEM3_MEMWAIT3                 ((uint32_t)0x0000FF00)        /*!< MEMWAIT3[7:0] bits (Common memory 3 wait time) */
S#define  FSMC_PMEM3_MEMWAIT3_0               ((uint32_t)0x00000100)        /*!< Bit 0 */
S#define  FSMC_PMEM3_MEMWAIT3_1               ((uint32_t)0x00000200)        /*!< Bit 1 */
S#define  FSMC_PMEM3_MEMWAIT3_2               ((uint32_t)0x00000400)        /*!< Bit 2 */
S#define  FSMC_PMEM3_MEMWAIT3_3               ((uint32_t)0x00000800)        /*!< Bit 3 */
S#define  FSMC_PMEM3_MEMWAIT3_4               ((uint32_t)0x00001000)        /*!< Bit 4 */
S#define  FSMC_PMEM3_MEMWAIT3_5               ((uint32_t)0x00002000)        /*!< Bit 5 */
S#define  FSMC_PMEM3_MEMWAIT3_6               ((uint32_t)0x00004000)        /*!< Bit 6 */
S#define  FSMC_PMEM3_MEMWAIT3_7               ((uint32_t)0x00008000)        /*!< Bit 7 */
S
S#define  FSMC_PMEM3_MEMHOLD3                 ((uint32_t)0x00FF0000)        /*!< MEMHOLD3[7:0] bits (Common memory 3 hold time) */
S#define  FSMC_PMEM3_MEMHOLD3_0               ((uint32_t)0x00010000)        /*!< Bit 0 */
S#define  FSMC_PMEM3_MEMHOLD3_1               ((uint32_t)0x00020000)        /*!< Bit 1 */
S#define  FSMC_PMEM3_MEMHOLD3_2               ((uint32_t)0x00040000)        /*!< Bit 2 */
S#define  FSMC_PMEM3_MEMHOLD3_3               ((uint32_t)0x00080000)        /*!< Bit 3 */
S#define  FSMC_PMEM3_MEMHOLD3_4               ((uint32_t)0x00100000)        /*!< Bit 4 */
S#define  FSMC_PMEM3_MEMHOLD3_5               ((uint32_t)0x00200000)        /*!< Bit 5 */
S#define  FSMC_PMEM3_MEMHOLD3_6               ((uint32_t)0x00400000)        /*!< Bit 6 */
S#define  FSMC_PMEM3_MEMHOLD3_7               ((uint32_t)0x00800000)        /*!< Bit 7 */
S
S#define  FSMC_PMEM3_MEMHIZ3                  ((uint32_t)0xFF000000)        /*!< MEMHIZ3[7:0] bits (Common memory 3 databus HiZ time) */
S#define  FSMC_PMEM3_MEMHIZ3_0                ((uint32_t)0x01000000)        /*!< Bit 0 */
S#define  FSMC_PMEM3_MEMHIZ3_1                ((uint32_t)0x02000000)        /*!< Bit 1 */
S#define  FSMC_PMEM3_MEMHIZ3_2                ((uint32_t)0x04000000)        /*!< Bit 2 */
S#define  FSMC_PMEM3_MEMHIZ3_3                ((uint32_t)0x08000000)        /*!< Bit 3 */
S#define  FSMC_PMEM3_MEMHIZ3_4                ((uint32_t)0x10000000)        /*!< Bit 4 */
S#define  FSMC_PMEM3_MEMHIZ3_5                ((uint32_t)0x20000000)        /*!< Bit 5 */
S#define  FSMC_PMEM3_MEMHIZ3_6                ((uint32_t)0x40000000)        /*!< Bit 6 */
S#define  FSMC_PMEM3_MEMHIZ3_7                ((uint32_t)0x80000000)        /*!< Bit 7 */
S
S/******************  Bit definition for FSMC_PMEM4 register  ******************/
S#define  FSMC_PMEM4_MEMSET4                  ((uint32_t)0x000000FF)        /*!< MEMSET4[7:0] bits (Common memory 4 setup time) */
S#define  FSMC_PMEM4_MEMSET4_0                ((uint32_t)0x00000001)        /*!< Bit 0 */
S#define  FSMC_PMEM4_MEMSET4_1                ((uint32_t)0x00000002)        /*!< Bit 1 */
S#define  FSMC_PMEM4_MEMSET4_2                ((uint32_t)0x00000004)        /*!< Bit 2 */
S#define  FSMC_PMEM4_MEMSET4_3                ((uint32_t)0x00000008)        /*!< Bit 3 */
S#define  FSMC_PMEM4_MEMSET4_4                ((uint32_t)0x00000010)        /*!< Bit 4 */
S#define  FSMC_PMEM4_MEMSET4_5                ((uint32_t)0x00000020)        /*!< Bit 5 */
S#define  FSMC_PMEM4_MEMSET4_6                ((uint32_t)0x00000040)        /*!< Bit 6 */
S#define  FSMC_PMEM4_MEMSET4_7                ((uint32_t)0x00000080)        /*!< Bit 7 */
S
S#define  FSMC_PMEM4_MEMWAIT4                 ((uint32_t)0x0000FF00)        /*!< MEMWAIT4[7:0] bits (Common memory 4 wait time) */
S#define  FSMC_PMEM4_MEMWAIT4_0               ((uint32_t)0x00000100)        /*!< Bit 0 */
S#define  FSMC_PMEM4_MEMWAIT4_1               ((uint32_t)0x00000200)        /*!< Bit 1 */
S#define  FSMC_PMEM4_MEMWAIT4_2               ((uint32_t)0x00000400)        /*!< Bit 2 */
S#define  FSMC_PMEM4_MEMWAIT4_3               ((uint32_t)0x00000800)        /*!< Bit 3 */
S#define  FSMC_PMEM4_MEMWAIT4_4               ((uint32_t)0x00001000)        /*!< Bit 4 */
S#define  FSMC_PMEM4_MEMWAIT4_5               ((uint32_t)0x00002000)        /*!< Bit 5 */
S#define  FSMC_PMEM4_MEMWAIT4_6               ((uint32_t)0x00004000)        /*!< Bit 6 */
S#define  FSMC_PMEM4_MEMWAIT4_7               ((uint32_t)0x00008000)        /*!< Bit 7 */
S
S#define  FSMC_PMEM4_MEMHOLD4                 ((uint32_t)0x00FF0000)        /*!< MEMHOLD4[7:0] bits (Common memory 4 hold time) */
S#define  FSMC_PMEM4_MEMHOLD4_0               ((uint32_t)0x00010000)        /*!< Bit 0 */
S#define  FSMC_PMEM4_MEMHOLD4_1               ((uint32_t)0x00020000)        /*!< Bit 1 */
S#define  FSMC_PMEM4_MEMHOLD4_2               ((uint32_t)0x00040000)        /*!< Bit 2 */
S#define  FSMC_PMEM4_MEMHOLD4_3               ((uint32_t)0x00080000)        /*!< Bit 3 */
S#define  FSMC_PMEM4_MEMHOLD4_4               ((uint32_t)0x00100000)        /*!< Bit 4 */
S#define  FSMC_PMEM4_MEMHOLD4_5               ((uint32_t)0x00200000)        /*!< Bit 5 */
S#define  FSMC_PMEM4_MEMHOLD4_6               ((uint32_t)0x00400000)        /*!< Bit 6 */
S#define  FSMC_PMEM4_MEMHOLD4_7               ((uint32_t)0x00800000)        /*!< Bit 7 */
S
S#define  FSMC_PMEM4_MEMHIZ4                  ((uint32_t)0xFF000000)        /*!< MEMHIZ4[7:0] bits (Common memory 4 databus HiZ time) */
S#define  FSMC_PMEM4_MEMHIZ4_0                ((uint32_t)0x01000000)        /*!< Bit 0 */
S#define  FSMC_PMEM4_MEMHIZ4_1                ((uint32_t)0x02000000)        /*!< Bit 1 */
S#define  FSMC_PMEM4_MEMHIZ4_2                ((uint32_t)0x04000000)        /*!< Bit 2 */
S#define  FSMC_PMEM4_MEMHIZ4_3                ((uint32_t)0x08000000)        /*!< Bit 3 */
S#define  FSMC_PMEM4_MEMHIZ4_4                ((uint32_t)0x10000000)        /*!< Bit 4 */
S#define  FSMC_PMEM4_MEMHIZ4_5                ((uint32_t)0x20000000)        /*!< Bit 5 */
S#define  FSMC_PMEM4_MEMHIZ4_6                ((uint32_t)0x40000000)        /*!< Bit 6 */
S#define  FSMC_PMEM4_MEMHIZ4_7                ((uint32_t)0x80000000)        /*!< Bit 7 */
S
S/******************  Bit definition for FSMC_PATT2 register  ******************/
S#define  FSMC_PATT2_ATTSET2                  ((uint32_t)0x000000FF)        /*!< ATTSET2[7:0] bits (Attribute memory 2 setup time) */
S#define  FSMC_PATT2_ATTSET2_0                ((uint32_t)0x00000001)        /*!< Bit 0 */
S#define  FSMC_PATT2_ATTSET2_1                ((uint32_t)0x00000002)        /*!< Bit 1 */
S#define  FSMC_PATT2_ATTSET2_2                ((uint32_t)0x00000004)        /*!< Bit 2 */
S#define  FSMC_PATT2_ATTSET2_3                ((uint32_t)0x00000008)        /*!< Bit 3 */
S#define  FSMC_PATT2_ATTSET2_4                ((uint32_t)0x00000010)        /*!< Bit 4 */
S#define  FSMC_PATT2_ATTSET2_5                ((uint32_t)0x00000020)        /*!< Bit 5 */
S#define  FSMC_PATT2_ATTSET2_6                ((uint32_t)0x00000040)        /*!< Bit 6 */
S#define  FSMC_PATT2_ATTSET2_7                ((uint32_t)0x00000080)        /*!< Bit 7 */
S
S#define  FSMC_PATT2_ATTWAIT2                 ((uint32_t)0x0000FF00)        /*!< ATTWAIT2[7:0] bits (Attribute memory 2 wait time) */
S#define  FSMC_PATT2_ATTWAIT2_0               ((uint32_t)0x00000100)        /*!< Bit 0 */
S#define  FSMC_PATT2_ATTWAIT2_1               ((uint32_t)0x00000200)        /*!< Bit 1 */
S#define  FSMC_PATT2_ATTWAIT2_2               ((uint32_t)0x00000400)        /*!< Bit 2 */
S#define  FSMC_PATT2_ATTWAIT2_3               ((uint32_t)0x00000800)        /*!< Bit 3 */
S#define  FSMC_PATT2_ATTWAIT2_4               ((uint32_t)0x00001000)        /*!< Bit 4 */
S#define  FSMC_PATT2_ATTWAIT2_5               ((uint32_t)0x00002000)        /*!< Bit 5 */
S#define  FSMC_PATT2_ATTWAIT2_6               ((uint32_t)0x00004000)        /*!< Bit 6 */
S#define  FSMC_PATT2_ATTWAIT2_7               ((uint32_t)0x00008000)        /*!< Bit 7 */
S
S#define  FSMC_PATT2_ATTHOLD2                 ((uint32_t)0x00FF0000)        /*!< ATTHOLD2[7:0] bits (Attribute memory 2 hold time) */
S#define  FSMC_PATT2_ATTHOLD2_0               ((uint32_t)0x00010000)        /*!< Bit 0 */
S#define  FSMC_PATT2_ATTHOLD2_1               ((uint32_t)0x00020000)        /*!< Bit 1 */
S#define  FSMC_PATT2_ATTHOLD2_2               ((uint32_t)0x00040000)        /*!< Bit 2 */
S#define  FSMC_PATT2_ATTHOLD2_3               ((uint32_t)0x00080000)        /*!< Bit 3 */
S#define  FSMC_PATT2_ATTHOLD2_4               ((uint32_t)0x00100000)        /*!< Bit 4 */
S#define  FSMC_PATT2_ATTHOLD2_5               ((uint32_t)0x00200000)        /*!< Bit 5 */
S#define  FSMC_PATT2_ATTHOLD2_6               ((uint32_t)0x00400000)        /*!< Bit 6 */
S#define  FSMC_PATT2_ATTHOLD2_7               ((uint32_t)0x00800000)        /*!< Bit 7 */
S
S#define  FSMC_PATT2_ATTHIZ2                  ((uint32_t)0xFF000000)        /*!< ATTHIZ2[7:0] bits (Attribute memory 2 databus HiZ time) */
S#define  FSMC_PATT2_ATTHIZ2_0                ((uint32_t)0x01000000)        /*!< Bit 0 */
S#define  FSMC_PATT2_ATTHIZ2_1                ((uint32_t)0x02000000)        /*!< Bit 1 */
S#define  FSMC_PATT2_ATTHIZ2_2                ((uint32_t)0x04000000)        /*!< Bit 2 */
S#define  FSMC_PATT2_ATTHIZ2_3                ((uint32_t)0x08000000)        /*!< Bit 3 */
S#define  FSMC_PATT2_ATTHIZ2_4                ((uint32_t)0x10000000)        /*!< Bit 4 */
S#define  FSMC_PATT2_ATTHIZ2_5                ((uint32_t)0x20000000)        /*!< Bit 5 */
S#define  FSMC_PATT2_ATTHIZ2_6                ((uint32_t)0x40000000)        /*!< Bit 6 */
S#define  FSMC_PATT2_ATTHIZ2_7                ((uint32_t)0x80000000)        /*!< Bit 7 */
S
S/******************  Bit definition for FSMC_PATT3 register  ******************/
S#define  FSMC_PATT3_ATTSET3                  ((uint32_t)0x000000FF)        /*!< ATTSET3[7:0] bits (Attribute memory 3 setup time) */
S#define  FSMC_PATT3_ATTSET3_0                ((uint32_t)0x00000001)        /*!< Bit 0 */
S#define  FSMC_PATT3_ATTSET3_1                ((uint32_t)0x00000002)        /*!< Bit 1 */
S#define  FSMC_PATT3_ATTSET3_2                ((uint32_t)0x00000004)        /*!< Bit 2 */
S#define  FSMC_PATT3_ATTSET3_3                ((uint32_t)0x00000008)        /*!< Bit 3 */
S#define  FSMC_PATT3_ATTSET3_4                ((uint32_t)0x00000010)        /*!< Bit 4 */
S#define  FSMC_PATT3_ATTSET3_5                ((uint32_t)0x00000020)        /*!< Bit 5 */
S#define  FSMC_PATT3_ATTSET3_6                ((uint32_t)0x00000040)        /*!< Bit 6 */
S#define  FSMC_PATT3_ATTSET3_7                ((uint32_t)0x00000080)        /*!< Bit 7 */
S
S#define  FSMC_PATT3_ATTWAIT3                 ((uint32_t)0x0000FF00)        /*!< ATTWAIT3[7:0] bits (Attribute memory 3 wait time) */
S#define  FSMC_PATT3_ATTWAIT3_0               ((uint32_t)0x00000100)        /*!< Bit 0 */
S#define  FSMC_PATT3_ATTWAIT3_1               ((uint32_t)0x00000200)        /*!< Bit 1 */
S#define  FSMC_PATT3_ATTWAIT3_2               ((uint32_t)0x00000400)        /*!< Bit 2 */
S#define  FSMC_PATT3_ATTWAIT3_3               ((uint32_t)0x00000800)        /*!< Bit 3 */
S#define  FSMC_PATT3_ATTWAIT3_4               ((uint32_t)0x00001000)        /*!< Bit 4 */
S#define  FSMC_PATT3_ATTWAIT3_5               ((uint32_t)0x00002000)        /*!< Bit 5 */
S#define  FSMC_PATT3_ATTWAIT3_6               ((uint32_t)0x00004000)        /*!< Bit 6 */
S#define  FSMC_PATT3_ATTWAIT3_7               ((uint32_t)0x00008000)        /*!< Bit 7 */
S
S#define  FSMC_PATT3_ATTHOLD3                 ((uint32_t)0x00FF0000)        /*!< ATTHOLD3[7:0] bits (Attribute memory 3 hold time) */
S#define  FSMC_PATT3_ATTHOLD3_0               ((uint32_t)0x00010000)        /*!< Bit 0 */
S#define  FSMC_PATT3_ATTHOLD3_1               ((uint32_t)0x00020000)        /*!< Bit 1 */
S#define  FSMC_PATT3_ATTHOLD3_2               ((uint32_t)0x00040000)        /*!< Bit 2 */
S#define  FSMC_PATT3_ATTHOLD3_3               ((uint32_t)0x00080000)        /*!< Bit 3 */
S#define  FSMC_PATT3_ATTHOLD3_4               ((uint32_t)0x00100000)        /*!< Bit 4 */
S#define  FSMC_PATT3_ATTHOLD3_5               ((uint32_t)0x00200000)        /*!< Bit 5 */
S#define  FSMC_PATT3_ATTHOLD3_6               ((uint32_t)0x00400000)        /*!< Bit 6 */
S#define  FSMC_PATT3_ATTHOLD3_7               ((uint32_t)0x00800000)        /*!< Bit 7 */
S
S#define  FSMC_PATT3_ATTHIZ3                  ((uint32_t)0xFF000000)        /*!< ATTHIZ3[7:0] bits (Attribute memory 3 databus HiZ time) */
S#define  FSMC_PATT3_ATTHIZ3_0                ((uint32_t)0x01000000)        /*!< Bit 0 */
S#define  FSMC_PATT3_ATTHIZ3_1                ((uint32_t)0x02000000)        /*!< Bit 1 */
S#define  FSMC_PATT3_ATTHIZ3_2                ((uint32_t)0x04000000)        /*!< Bit 2 */
S#define  FSMC_PATT3_ATTHIZ3_3                ((uint32_t)0x08000000)        /*!< Bit 3 */
S#define  FSMC_PATT3_ATTHIZ3_4                ((uint32_t)0x10000000)        /*!< Bit 4 */
S#define  FSMC_PATT3_ATTHIZ3_5                ((uint32_t)0x20000000)        /*!< Bit 5 */
S#define  FSMC_PATT3_ATTHIZ3_6                ((uint32_t)0x40000000)        /*!< Bit 6 */
S#define  FSMC_PATT3_ATTHIZ3_7                ((uint32_t)0x80000000)        /*!< Bit 7 */
S
S/******************  Bit definition for FSMC_PATT4 register  ******************/
S#define  FSMC_PATT4_ATTSET4                  ((uint32_t)0x000000FF)        /*!< ATTSET4[7:0] bits (Attribute memory 4 setup time) */
S#define  FSMC_PATT4_ATTSET4_0                ((uint32_t)0x00000001)        /*!< Bit 0 */
S#define  FSMC_PATT4_ATTSET4_1                ((uint32_t)0x00000002)        /*!< Bit 1 */
S#define  FSMC_PATT4_ATTSET4_2                ((uint32_t)0x00000004)        /*!< Bit 2 */
S#define  FSMC_PATT4_ATTSET4_3                ((uint32_t)0x00000008)        /*!< Bit 3 */
S#define  FSMC_PATT4_ATTSET4_4                ((uint32_t)0x00000010)        /*!< Bit 4 */
S#define  FSMC_PATT4_ATTSET4_5                ((uint32_t)0x00000020)        /*!< Bit 5 */
S#define  FSMC_PATT4_ATTSET4_6                ((uint32_t)0x00000040)        /*!< Bit 6 */
S#define  FSMC_PATT4_ATTSET4_7                ((uint32_t)0x00000080)        /*!< Bit 7 */
S
S#define  FSMC_PATT4_ATTWAIT4                 ((uint32_t)0x0000FF00)        /*!< ATTWAIT4[7:0] bits (Attribute memory 4 wait time) */
S#define  FSMC_PATT4_ATTWAIT4_0               ((uint32_t)0x00000100)        /*!< Bit 0 */
S#define  FSMC_PATT4_ATTWAIT4_1               ((uint32_t)0x00000200)        /*!< Bit 1 */
S#define  FSMC_PATT4_ATTWAIT4_2               ((uint32_t)0x00000400)        /*!< Bit 2 */
S#define  FSMC_PATT4_ATTWAIT4_3               ((uint32_t)0x00000800)        /*!< Bit 3 */
S#define  FSMC_PATT4_ATTWAIT4_4               ((uint32_t)0x00001000)        /*!< Bit 4 */
S#define  FSMC_PATT4_ATTWAIT4_5               ((uint32_t)0x00002000)        /*!< Bit 5 */
S#define  FSMC_PATT4_ATTWAIT4_6               ((uint32_t)0x00004000)        /*!< Bit 6 */
S#define  FSMC_PATT4_ATTWAIT4_7               ((uint32_t)0x00008000)        /*!< Bit 7 */
S
S#define  FSMC_PATT4_ATTHOLD4                 ((uint32_t)0x00FF0000)        /*!< ATTHOLD4[7:0] bits (Attribute memory 4 hold time) */
S#define  FSMC_PATT4_ATTHOLD4_0               ((uint32_t)0x00010000)        /*!< Bit 0 */
S#define  FSMC_PATT4_ATTHOLD4_1               ((uint32_t)0x00020000)        /*!< Bit 1 */
S#define  FSMC_PATT4_ATTHOLD4_2               ((uint32_t)0x00040000)        /*!< Bit 2 */
S#define  FSMC_PATT4_ATTHOLD4_3               ((uint32_t)0x00080000)        /*!< Bit 3 */
S#define  FSMC_PATT4_ATTHOLD4_4               ((uint32_t)0x00100000)        /*!< Bit 4 */
S#define  FSMC_PATT4_ATTHOLD4_5               ((uint32_t)0x00200000)        /*!< Bit 5 */
S#define  FSMC_PATT4_ATTHOLD4_6               ((uint32_t)0x00400000)        /*!< Bit 6 */
S#define  FSMC_PATT4_ATTHOLD4_7               ((uint32_t)0x00800000)        /*!< Bit 7 */
S
S#define  FSMC_PATT4_ATTHIZ4                  ((uint32_t)0xFF000000)        /*!< ATTHIZ4[7:0] bits (Attribute memory 4 databus HiZ time) */
S#define  FSMC_PATT4_ATTHIZ4_0                ((uint32_t)0x01000000)        /*!< Bit 0 */
S#define  FSMC_PATT4_ATTHIZ4_1                ((uint32_t)0x02000000)        /*!< Bit 1 */
S#define  FSMC_PATT4_ATTHIZ4_2                ((uint32_t)0x04000000)        /*!< Bit 2 */
S#define  FSMC_PATT4_ATTHIZ4_3                ((uint32_t)0x08000000)        /*!< Bit 3 */
S#define  FSMC_PATT4_ATTHIZ4_4                ((uint32_t)0x10000000)        /*!< Bit 4 */
S#define  FSMC_PATT4_ATTHIZ4_5                ((uint32_t)0x20000000)        /*!< Bit 5 */
S#define  FSMC_PATT4_ATTHIZ4_6                ((uint32_t)0x40000000)        /*!< Bit 6 */
S#define  FSMC_PATT4_ATTHIZ4_7                ((uint32_t)0x80000000)        /*!< Bit 7 */
S
S/******************  Bit definition for FSMC_PIO4 register  *******************/
S#define  FSMC_PIO4_IOSET4                    ((uint32_t)0x000000FF)        /*!< IOSET4[7:0] bits (I/O 4 setup time) */
S#define  FSMC_PIO4_IOSET4_0                  ((uint32_t)0x00000001)        /*!< Bit 0 */
S#define  FSMC_PIO4_IOSET4_1                  ((uint32_t)0x00000002)        /*!< Bit 1 */
S#define  FSMC_PIO4_IOSET4_2                  ((uint32_t)0x00000004)        /*!< Bit 2 */
S#define  FSMC_PIO4_IOSET4_3                  ((uint32_t)0x00000008)        /*!< Bit 3 */
S#define  FSMC_PIO4_IOSET4_4                  ((uint32_t)0x00000010)        /*!< Bit 4 */
S#define  FSMC_PIO4_IOSET4_5                  ((uint32_t)0x00000020)        /*!< Bit 5 */
S#define  FSMC_PIO4_IOSET4_6                  ((uint32_t)0x00000040)        /*!< Bit 6 */
S#define  FSMC_PIO4_IOSET4_7                  ((uint32_t)0x00000080)        /*!< Bit 7 */
S
S#define  FSMC_PIO4_IOWAIT4                   ((uint32_t)0x0000FF00)        /*!< IOWAIT4[7:0] bits (I/O 4 wait time) */
S#define  FSMC_PIO4_IOWAIT4_0                 ((uint32_t)0x00000100)        /*!< Bit 0 */
S#define  FSMC_PIO4_IOWAIT4_1                 ((uint32_t)0x00000200)        /*!< Bit 1 */
S#define  FSMC_PIO4_IOWAIT4_2                 ((uint32_t)0x00000400)        /*!< Bit 2 */
S#define  FSMC_PIO4_IOWAIT4_3                 ((uint32_t)0x00000800)        /*!< Bit 3 */
S#define  FSMC_PIO4_IOWAIT4_4                 ((uint32_t)0x00001000)        /*!< Bit 4 */
S#define  FSMC_PIO4_IOWAIT4_5                 ((uint32_t)0x00002000)        /*!< Bit 5 */
S#define  FSMC_PIO4_IOWAIT4_6                 ((uint32_t)0x00004000)        /*!< Bit 6 */
S#define  FSMC_PIO4_IOWAIT4_7                 ((uint32_t)0x00008000)        /*!< Bit 7 */
S
S#define  FSMC_PIO4_IOHOLD4                   ((uint32_t)0x00FF0000)        /*!< IOHOLD4[7:0] bits (I/O 4 hold time) */
S#define  FSMC_PIO4_IOHOLD4_0                 ((uint32_t)0x00010000)        /*!< Bit 0 */
S#define  FSMC_PIO4_IOHOLD4_1                 ((uint32_t)0x00020000)        /*!< Bit 1 */
S#define  FSMC_PIO4_IOHOLD4_2                 ((uint32_t)0x00040000)        /*!< Bit 2 */
S#define  FSMC_PIO4_IOHOLD4_3                 ((uint32_t)0x00080000)        /*!< Bit 3 */
S#define  FSMC_PIO4_IOHOLD4_4                 ((uint32_t)0x00100000)        /*!< Bit 4 */
S#define  FSMC_PIO4_IOHOLD4_5                 ((uint32_t)0x00200000)        /*!< Bit 5 */
S#define  FSMC_PIO4_IOHOLD4_6                 ((uint32_t)0x00400000)        /*!< Bit 6 */
S#define  FSMC_PIO4_IOHOLD4_7                 ((uint32_t)0x00800000)        /*!< Bit 7 */
S
S#define  FSMC_PIO4_IOHIZ4                    ((uint32_t)0xFF000000)        /*!< IOHIZ4[7:0] bits (I/O 4 databus HiZ time) */
S#define  FSMC_PIO4_IOHIZ4_0                  ((uint32_t)0x01000000)        /*!< Bit 0 */
S#define  FSMC_PIO4_IOHIZ4_1                  ((uint32_t)0x02000000)        /*!< Bit 1 */
S#define  FSMC_PIO4_IOHIZ4_2                  ((uint32_t)0x04000000)        /*!< Bit 2 */
S#define  FSMC_PIO4_IOHIZ4_3                  ((uint32_t)0x08000000)        /*!< Bit 3 */
S#define  FSMC_PIO4_IOHIZ4_4                  ((uint32_t)0x10000000)        /*!< Bit 4 */
S#define  FSMC_PIO4_IOHIZ4_5                  ((uint32_t)0x20000000)        /*!< Bit 5 */
S#define  FSMC_PIO4_IOHIZ4_6                  ((uint32_t)0x40000000)        /*!< Bit 6 */
S#define  FSMC_PIO4_IOHIZ4_7                  ((uint32_t)0x80000000)        /*!< Bit 7 */
S
S/******************  Bit definition for FSMC_ECCR2 register  ******************/
S#define  FSMC_ECCR2_ECC2                     ((uint32_t)0xFFFFFFFF)        /*!< ECC result */
S
S/******************  Bit definition for FSMC_ECCR3 register  ******************/
S#define  FSMC_ECCR3_ECC3                     ((uint32_t)0xFFFFFFFF)        /*!< ECC result */
S
S/******************************************************************************/
S/*                                                                            */
S/*                          SD host Interface                                 */
S/*                                                                            */
S/******************************************************************************/
S
S/******************  Bit definition for SDIO_POWER register  ******************/
S#define  SDIO_POWER_PWRCTRL                  ((uint8_t)0x03)               /*!< PWRCTRL[1:0] bits (Power supply control bits) */
S#define  SDIO_POWER_PWRCTRL_0                ((uint8_t)0x01)               /*!< Bit 0 */
S#define  SDIO_POWER_PWRCTRL_1                ((uint8_t)0x02)               /*!< Bit 1 */
S
S/******************  Bit definition for SDIO_CLKCR register  ******************/
S#define  SDIO_CLKCR_CLKDIV                   ((uint16_t)0x00FF)            /*!< Clock divide factor */
S#define  SDIO_CLKCR_CLKEN                    ((uint16_t)0x0100)            /*!< Clock enable bit */
S#define  SDIO_CLKCR_PWRSAV                   ((uint16_t)0x0200)            /*!< Power saving configuration bit */
S#define  SDIO_CLKCR_BYPASS                   ((uint16_t)0x0400)            /*!< Clock divider bypass enable bit */
S
S#define  SDIO_CLKCR_WIDBUS                   ((uint16_t)0x1800)            /*!< WIDBUS[1:0] bits (Wide bus mode enable bit) */
S#define  SDIO_CLKCR_WIDBUS_0                 ((uint16_t)0x0800)            /*!< Bit 0 */
S#define  SDIO_CLKCR_WIDBUS_1                 ((uint16_t)0x1000)            /*!< Bit 1 */
S
S#define  SDIO_CLKCR_NEGEDGE                  ((uint16_t)0x2000)            /*!< SDIO_CK dephasing selection bit */
S#define  SDIO_CLKCR_HWFC_EN                  ((uint16_t)0x4000)            /*!< HW Flow Control enable */
S
S/*******************  Bit definition for SDIO_ARG register  *******************/
S#define  SDIO_ARG_CMDARG                     ((uint32_t)0xFFFFFFFF)            /*!< Command argument */
S
S/*******************  Bit definition for SDIO_CMD register  *******************/
S#define  SDIO_CMD_CMDINDEX                   ((uint16_t)0x003F)            /*!< Command Index */
S
S#define  SDIO_CMD_WAITRESP                   ((uint16_t)0x00C0)            /*!< WAITRESP[1:0] bits (Wait for response bits) */
S#define  SDIO_CMD_WAITRESP_0                 ((uint16_t)0x0040)            /*!<  Bit 0 */
S#define  SDIO_CMD_WAITRESP_1                 ((uint16_t)0x0080)            /*!<  Bit 1 */
S
S#define  SDIO_CMD_WAITINT                    ((uint16_t)0x0100)            /*!< CPSM Waits for Interrupt Request */
S#define  SDIO_CMD_WAITPEND                   ((uint16_t)0x0200)            /*!< CPSM Waits for ends of data transfer (CmdPend internal signal) */
S#define  SDIO_CMD_CPSMEN                     ((uint16_t)0x0400)            /*!< Command path state machine (CPSM) Enable bit */
S#define  SDIO_CMD_SDIOSUSPEND                ((uint16_t)0x0800)            /*!< SD I/O suspend command */
S#define  SDIO_CMD_ENCMDCOMPL                 ((uint16_t)0x1000)            /*!< Enable CMD completion */
S#define  SDIO_CMD_NIEN                       ((uint16_t)0x2000)            /*!< Not Interrupt Enable */
S#define  SDIO_CMD_CEATACMD                   ((uint16_t)0x4000)            /*!< CE-ATA command */
S
S/*****************  Bit definition for SDIO_RESPCMD register  *****************/
S#define  SDIO_RESPCMD_RESPCMD                ((uint8_t)0x3F)               /*!< Response command index */
S
S/******************  Bit definition for SDIO_RESP0 register  ******************/
S#define  SDIO_RESP0_CARDSTATUS0              ((uint32_t)0xFFFFFFFF)        /*!< Card Status */
S
S/******************  Bit definition for SDIO_RESP1 register  ******************/
S#define  SDIO_RESP1_CARDSTATUS1              ((uint32_t)0xFFFFFFFF)        /*!< Card Status */
S
S/******************  Bit definition for SDIO_RESP2 register  ******************/
S#define  SDIO_RESP2_CARDSTATUS2              ((uint32_t)0xFFFFFFFF)        /*!< Card Status */
S
S/******************  Bit definition for SDIO_RESP3 register  ******************/
S#define  SDIO_RESP3_CARDSTATUS3              ((uint32_t)0xFFFFFFFF)        /*!< Card Status */
S
S/******************  Bit definition for SDIO_RESP4 register  ******************/
S#define  SDIO_RESP4_CARDSTATUS4              ((uint32_t)0xFFFFFFFF)        /*!< Card Status */
S
S/******************  Bit definition for SDIO_DTIMER register  *****************/
S#define  SDIO_DTIMER_DATATIME                ((uint32_t)0xFFFFFFFF)        /*!< Data timeout period. */
S
S/******************  Bit definition for SDIO_DLEN register  *******************/
S#define  SDIO_DLEN_DATALENGTH                ((uint32_t)0x01FFFFFF)        /*!< Data length value */
S
S/******************  Bit definition for SDIO_DCTRL register  ******************/
S#define  SDIO_DCTRL_DTEN                     ((uint16_t)0x0001)            /*!< Data transfer enabled bit */
S#define  SDIO_DCTRL_DTDIR                    ((uint16_t)0x0002)            /*!< Data transfer direction selection */
S#define  SDIO_DCTRL_DTMODE                   ((uint16_t)0x0004)            /*!< Data transfer mode selection */
S#define  SDIO_DCTRL_DMAEN                    ((uint16_t)0x0008)            /*!< DMA enabled bit */
S
S#define  SDIO_DCTRL_DBLOCKSIZE               ((uint16_t)0x00F0)            /*!< DBLOCKSIZE[3:0] bits (Data block size) */
S#define  SDIO_DCTRL_DBLOCKSIZE_0             ((uint16_t)0x0010)            /*!< Bit 0 */
S#define  SDIO_DCTRL_DBLOCKSIZE_1             ((uint16_t)0x0020)            /*!< Bit 1 */
S#define  SDIO_DCTRL_DBLOCKSIZE_2             ((uint16_t)0x0040)            /*!< Bit 2 */
S#define  SDIO_DCTRL_DBLOCKSIZE_3             ((uint16_t)0x0080)            /*!< Bit 3 */
S
S#define  SDIO_DCTRL_RWSTART                  ((uint16_t)0x0100)            /*!< Read wait start */
S#define  SDIO_DCTRL_RWSTOP                   ((uint16_t)0x0200)            /*!< Read wait stop */
S#define  SDIO_DCTRL_RWMOD                    ((uint16_t)0x0400)            /*!< Read wait mode */
S#define  SDIO_DCTRL_SDIOEN                   ((uint16_t)0x0800)            /*!< SD I/O enable functions */
S
S/******************  Bit definition for SDIO_DCOUNT register  *****************/
S#define  SDIO_DCOUNT_DATACOUNT               ((uint32_t)0x01FFFFFF)        /*!< Data count value */
S
S/******************  Bit definition for SDIO_STA register  ********************/
S#define  SDIO_STA_CCRCFAIL                   ((uint32_t)0x00000001)        /*!< Command response received (CRC check failed) */
S#define  SDIO_STA_DCRCFAIL                   ((uint32_t)0x00000002)        /*!< Data block sent/received (CRC check failed) */
S#define  SDIO_STA_CTIMEOUT                   ((uint32_t)0x00000004)        /*!< Command response timeout */
S#define  SDIO_STA_DTIMEOUT                   ((uint32_t)0x00000008)        /*!< Data timeout */
S#define  SDIO_STA_TXUNDERR                   ((uint32_t)0x00000010)        /*!< Transmit FIFO underrun error */
S#define  SDIO_STA_RXOVERR                    ((uint32_t)0x00000020)        /*!< Received FIFO overrun error */
S#define  SDIO_STA_CMDREND                    ((uint32_t)0x00000040)        /*!< Command response received (CRC check passed) */
S#define  SDIO_STA_CMDSENT                    ((uint32_t)0x00000080)        /*!< Command sent (no response required) */
S#define  SDIO_STA_DATAEND                    ((uint32_t)0x00000100)        /*!< Data end (data counter, SDIDCOUNT, is zero) */
S#define  SDIO_STA_STBITERR                   ((uint32_t)0x00000200)        /*!< Start bit not detected on all data signals in wide bus mode */
S#define  SDIO_STA_DBCKEND                    ((uint32_t)0x00000400)        /*!< Data block sent/received (CRC check passed) */
S#define  SDIO_STA_CMDACT                     ((uint32_t)0x00000800)        /*!< Command transfer in progress */
S#define  SDIO_STA_TXACT                      ((uint32_t)0x00001000)        /*!< Data transmit in progress */
S#define  SDIO_STA_RXACT                      ((uint32_t)0x00002000)        /*!< Data receive in progress */
S#define  SDIO_STA_TXFIFOHE                   ((uint32_t)0x00004000)        /*!< Transmit FIFO Half Empty: at least 8 words can be written into the FIFO */
S#define  SDIO_STA_RXFIFOHF                   ((uint32_t)0x00008000)        /*!< Receive FIFO Half Full: there are at least 8 words in the FIFO */
S#define  SDIO_STA_TXFIFOF                    ((uint32_t)0x00010000)        /*!< Transmit FIFO full */
S#define  SDIO_STA_RXFIFOF                    ((uint32_t)0x00020000)        /*!< Receive FIFO full */
S#define  SDIO_STA_TXFIFOE                    ((uint32_t)0x00040000)        /*!< Transmit FIFO empty */
S#define  SDIO_STA_RXFIFOE                    ((uint32_t)0x00080000)        /*!< Receive FIFO empty */
S#define  SDIO_STA_TXDAVL                     ((uint32_t)0x00100000)        /*!< Data available in transmit FIFO */
S#define  SDIO_STA_RXDAVL                     ((uint32_t)0x00200000)        /*!< Data available in receive FIFO */
S#define  SDIO_STA_SDIOIT                     ((uint32_t)0x00400000)        /*!< SDIO interrupt received */
S#define  SDIO_STA_CEATAEND                   ((uint32_t)0x00800000)        /*!< CE-ATA command completion signal received for CMD61 */
S
S/*******************  Bit definition for SDIO_ICR register  *******************/
S#define  SDIO_ICR_CCRCFAILC                  ((uint32_t)0x00000001)        /*!< CCRCFAIL flag clear bit */
S#define  SDIO_ICR_DCRCFAILC                  ((uint32_t)0x00000002)        /*!< DCRCFAIL flag clear bit */
S#define  SDIO_ICR_CTIMEOUTC                  ((uint32_t)0x00000004)        /*!< CTIMEOUT flag clear bit */
S#define  SDIO_ICR_DTIMEOUTC                  ((uint32_t)0x00000008)        /*!< DTIMEOUT flag clear bit */
S#define  SDIO_ICR_TXUNDERRC                  ((uint32_t)0x00000010)        /*!< TXUNDERR flag clear bit */
S#define  SDIO_ICR_RXOVERRC                   ((uint32_t)0x00000020)        /*!< RXOVERR flag clear bit */
S#define  SDIO_ICR_CMDRENDC                   ((uint32_t)0x00000040)        /*!< CMDREND flag clear bit */
S#define  SDIO_ICR_CMDSENTC                   ((uint32_t)0x00000080)        /*!< CMDSENT flag clear bit */
S#define  SDIO_ICR_DATAENDC                   ((uint32_t)0x00000100)        /*!< DATAEND flag clear bit */
S#define  SDIO_ICR_STBITERRC                  ((uint32_t)0x00000200)        /*!< STBITERR flag clear bit */
S#define  SDIO_ICR_DBCKENDC                   ((uint32_t)0x00000400)        /*!< DBCKEND flag clear bit */
S#define  SDIO_ICR_SDIOITC                    ((uint32_t)0x00400000)        /*!< SDIOIT flag clear bit */
S#define  SDIO_ICR_CEATAENDC                  ((uint32_t)0x00800000)        /*!< CEATAEND flag clear bit */
S
S/******************  Bit definition for SDIO_MASK register  *******************/
S#define  SDIO_MASK_CCRCFAILIE                ((uint32_t)0x00000001)        /*!< Command CRC Fail Interrupt Enable */
S#define  SDIO_MASK_DCRCFAILIE                ((uint32_t)0x00000002)        /*!< Data CRC Fail Interrupt Enable */
S#define  SDIO_MASK_CTIMEOUTIE                ((uint32_t)0x00000004)        /*!< Command TimeOut Interrupt Enable */
S#define  SDIO_MASK_DTIMEOUTIE                ((uint32_t)0x00000008)        /*!< Data TimeOut Interrupt Enable */
S#define  SDIO_MASK_TXUNDERRIE                ((uint32_t)0x00000010)        /*!< Tx FIFO UnderRun Error Interrupt Enable */
S#define  SDIO_MASK_RXOVERRIE                 ((uint32_t)0x00000020)        /*!< Rx FIFO OverRun Error Interrupt Enable */
S#define  SDIO_MASK_CMDRENDIE                 ((uint32_t)0x00000040)        /*!< Command Response Received Interrupt Enable */
S#define  SDIO_MASK_CMDSENTIE                 ((uint32_t)0x00000080)        /*!< Command Sent Interrupt Enable */
S#define  SDIO_MASK_DATAENDIE                 ((uint32_t)0x00000100)        /*!< Data End Interrupt Enable */
S#define  SDIO_MASK_STBITERRIE                ((uint32_t)0x00000200)        /*!< Start Bit Error Interrupt Enable */
S#define  SDIO_MASK_DBCKENDIE                 ((uint32_t)0x00000400)        /*!< Data Block End Interrupt Enable */
S#define  SDIO_MASK_CMDACTIE                  ((uint32_t)0x00000800)        /*!< Command Acting Interrupt Enable */
S#define  SDIO_MASK_TXACTIE                   ((uint32_t)0x00001000)        /*!< Data Transmit Acting Interrupt Enable */
S#define  SDIO_MASK_RXACTIE                   ((uint32_t)0x00002000)        /*!< Data receive acting interrupt enabled */
S#define  SDIO_MASK_TXFIFOHEIE                ((uint32_t)0x00004000)        /*!< Tx FIFO Half Empty interrupt Enable */
S#define  SDIO_MASK_RXFIFOHFIE                ((uint32_t)0x00008000)        /*!< Rx FIFO Half Full interrupt Enable */
S#define  SDIO_MASK_TXFIFOFIE                 ((uint32_t)0x00010000)        /*!< Tx FIFO Full interrupt Enable */
S#define  SDIO_MASK_RXFIFOFIE                 ((uint32_t)0x00020000)        /*!< Rx FIFO Full interrupt Enable */
S#define  SDIO_MASK_TXFIFOEIE                 ((uint32_t)0x00040000)        /*!< Tx FIFO Empty interrupt Enable */
S#define  SDIO_MASK_RXFIFOEIE                 ((uint32_t)0x00080000)        /*!< Rx FIFO Empty interrupt Enable */
S#define  SDIO_MASK_TXDAVLIE                  ((uint32_t)0x00100000)        /*!< Data available in Tx FIFO interrupt Enable */
S#define  SDIO_MASK_RXDAVLIE                  ((uint32_t)0x00200000)        /*!< Data available in Rx FIFO interrupt Enable */
S#define  SDIO_MASK_SDIOITIE                  ((uint32_t)0x00400000)        /*!< SDIO Mode Interrupt Received interrupt Enable */
S#define  SDIO_MASK_CEATAENDIE                ((uint32_t)0x00800000)        /*!< CE-ATA command completion signal received Interrupt Enable */
S
S/*****************  Bit definition for SDIO_FIFOCNT register  *****************/
S#define  SDIO_FIFOCNT_FIFOCOUNT              ((uint32_t)0x00FFFFFF)        /*!< Remaining number of words to be written to or read from the FIFO */
S
S/******************  Bit definition for SDIO_FIFO register  *******************/
S#define  SDIO_FIFO_FIFODATA                  ((uint32_t)0xFFFFFFFF)        /*!< Receive and transmit FIFO data */
S
S/******************************************************************************/
S/*                                                                            */
S/*                                   USB Device FS                            */
S/*                                                                            */
S/******************************************************************************/
S
S/*!< Endpoint-specific registers */
S/*******************  Bit definition for USB_EP0R register  *******************/
S#define  USB_EP0R_EA                         ((uint16_t)0x000F)            /*!< Endpoint Address */
S
S#define  USB_EP0R_STAT_TX                    ((uint16_t)0x0030)            /*!< STAT_TX[1:0] bits (Status bits, for transmission transfers) */
S#define  USB_EP0R_STAT_TX_0                  ((uint16_t)0x0010)            /*!< Bit 0 */
S#define  USB_EP0R_STAT_TX_1                  ((uint16_t)0x0020)            /*!< Bit 1 */
S
S#define  USB_EP0R_DTOG_TX                    ((uint16_t)0x0040)            /*!< Data Toggle, for transmission transfers */
S#define  USB_EP0R_CTR_TX                     ((uint16_t)0x0080)            /*!< Correct Transfer for transmission */
S#define  USB_EP0R_EP_KIND                    ((uint16_t)0x0100)            /*!< Endpoint Kind */
S
S#define  USB_EP0R_EP_TYPE                    ((uint16_t)0x0600)            /*!< EP_TYPE[1:0] bits (Endpoint type) */
S#define  USB_EP0R_EP_TYPE_0                  ((uint16_t)0x0200)            /*!< Bit 0 */
S#define  USB_EP0R_EP_TYPE_1                  ((uint16_t)0x0400)            /*!< Bit 1 */
S
S#define  USB_EP0R_SETUP                      ((uint16_t)0x0800)            /*!< Setup transaction completed */
S
S#define  USB_EP0R_STAT_RX                    ((uint16_t)0x3000)            /*!< STAT_RX[1:0] bits (Status bits, for reception transfers) */
S#define  USB_EP0R_STAT_RX_0                  ((uint16_t)0x1000)            /*!< Bit 0 */
S#define  USB_EP0R_STAT_RX_1                  ((uint16_t)0x2000)            /*!< Bit 1 */
S
S#define  USB_EP0R_DTOG_RX                    ((uint16_t)0x4000)            /*!< Data Toggle, for reception transfers */
S#define  USB_EP0R_CTR_RX                     ((uint16_t)0x8000)            /*!< Correct Transfer for reception */
S
S/*******************  Bit definition for USB_EP1R register  *******************/
S#define  USB_EP1R_EA                         ((uint16_t)0x000F)            /*!< Endpoint Address */
S
S#define  USB_EP1R_STAT_TX                    ((uint16_t)0x0030)            /*!< STAT_TX[1:0] bits (Status bits, for transmission transfers) */
S#define  USB_EP1R_STAT_TX_0                  ((uint16_t)0x0010)            /*!< Bit 0 */
S#define  USB_EP1R_STAT_TX_1                  ((uint16_t)0x0020)            /*!< Bit 1 */
S
S#define  USB_EP1R_DTOG_TX                    ((uint16_t)0x0040)            /*!< Data Toggle, for transmission transfers */
S#define  USB_EP1R_CTR_TX                     ((uint16_t)0x0080)            /*!< Correct Transfer for transmission */
S#define  USB_EP1R_EP_KIND                    ((uint16_t)0x0100)            /*!< Endpoint Kind */
S
S#define  USB_EP1R_EP_TYPE                    ((uint16_t)0x0600)            /*!< EP_TYPE[1:0] bits (Endpoint type) */
S#define  USB_EP1R_EP_TYPE_0                  ((uint16_t)0x0200)            /*!< Bit 0 */
S#define  USB_EP1R_EP_TYPE_1                  ((uint16_t)0x0400)            /*!< Bit 1 */
S
S#define  USB_EP1R_SETUP                      ((uint16_t)0x0800)            /*!< Setup transaction completed */
S
S#define  USB_EP1R_STAT_RX                    ((uint16_t)0x3000)            /*!< STAT_RX[1:0] bits (Status bits, for reception transfers) */
S#define  USB_EP1R_STAT_RX_0                  ((uint16_t)0x1000)            /*!< Bit 0 */
S#define  USB_EP1R_STAT_RX_1                  ((uint16_t)0x2000)            /*!< Bit 1 */
S
S#define  USB_EP1R_DTOG_RX                    ((uint16_t)0x4000)            /*!< Data Toggle, for reception transfers */
S#define  USB_EP1R_CTR_RX                     ((uint16_t)0x8000)            /*!< Correct Transfer for reception */
S
S/*******************  Bit definition for USB_EP2R register  *******************/
S#define  USB_EP2R_EA                         ((uint16_t)0x000F)            /*!< Endpoint Address */
S
S#define  USB_EP2R_STAT_TX                    ((uint16_t)0x0030)            /*!< STAT_TX[1:0] bits (Status bits, for transmission transfers) */
S#define  USB_EP2R_STAT_TX_0                  ((uint16_t)0x0010)            /*!< Bit 0 */
S#define  USB_EP2R_STAT_TX_1                  ((uint16_t)0x0020)            /*!< Bit 1 */
S
S#define  USB_EP2R_DTOG_TX                    ((uint16_t)0x0040)            /*!< Data Toggle, for transmission transfers */
S#define  USB_EP2R_CTR_TX                     ((uint16_t)0x0080)            /*!< Correct Transfer for transmission */
S#define  USB_EP2R_EP_KIND                    ((uint16_t)0x0100)            /*!< Endpoint Kind */
S
S#define  USB_EP2R_EP_TYPE                    ((uint16_t)0x0600)            /*!< EP_TYPE[1:0] bits (Endpoint type) */
S#define  USB_EP2R_EP_TYPE_0                  ((uint16_t)0x0200)            /*!< Bit 0 */
S#define  USB_EP2R_EP_TYPE_1                  ((uint16_t)0x0400)            /*!< Bit 1 */
S
S#define  USB_EP2R_SETUP                      ((uint16_t)0x0800)            /*!< Setup transaction completed */
S
S#define  USB_EP2R_STAT_RX                    ((uint16_t)0x3000)            /*!< STAT_RX[1:0] bits (Status bits, for reception transfers) */
S#define  USB_EP2R_STAT_RX_0                  ((uint16_t)0x1000)            /*!< Bit 0 */
S#define  USB_EP2R_STAT_RX_1                  ((uint16_t)0x2000)            /*!< Bit 1 */
S
S#define  USB_EP2R_DTOG_RX                    ((uint16_t)0x4000)            /*!< Data Toggle, for reception transfers */
S#define  USB_EP2R_CTR_RX                     ((uint16_t)0x8000)            /*!< Correct Transfer for reception */
S
S/*******************  Bit definition for USB_EP3R register  *******************/
S#define  USB_EP3R_EA                         ((uint16_t)0x000F)            /*!< Endpoint Address */
S
S#define  USB_EP3R_STAT_TX                    ((uint16_t)0x0030)            /*!< STAT_TX[1:0] bits (Status bits, for transmission transfers) */
S#define  USB_EP3R_STAT_TX_0                  ((uint16_t)0x0010)            /*!< Bit 0 */
S#define  USB_EP3R_STAT_TX_1                  ((uint16_t)0x0020)            /*!< Bit 1 */
S
S#define  USB_EP3R_DTOG_TX                    ((uint16_t)0x0040)            /*!< Data Toggle, for transmission transfers */
S#define  USB_EP3R_CTR_TX                     ((uint16_t)0x0080)            /*!< Correct Transfer for transmission */
S#define  USB_EP3R_EP_KIND                    ((uint16_t)0x0100)            /*!< Endpoint Kind */
S
S#define  USB_EP3R_EP_TYPE                    ((uint16_t)0x0600)            /*!< EP_TYPE[1:0] bits (Endpoint type) */
S#define  USB_EP3R_EP_TYPE_0                  ((uint16_t)0x0200)            /*!< Bit 0 */
S#define  USB_EP3R_EP_TYPE_1                  ((uint16_t)0x0400)            /*!< Bit 1 */
S
S#define  USB_EP3R_SETUP                      ((uint16_t)0x0800)            /*!< Setup transaction completed */
S
S#define  USB_EP3R_STAT_RX                    ((uint16_t)0x3000)            /*!< STAT_RX[1:0] bits (Status bits, for reception transfers) */
S#define  USB_EP3R_STAT_RX_0                  ((uint16_t)0x1000)            /*!< Bit 0 */
S#define  USB_EP3R_STAT_RX_1                  ((uint16_t)0x2000)            /*!< Bit 1 */
S
S#define  USB_EP3R_DTOG_RX                    ((uint16_t)0x4000)            /*!< Data Toggle, for reception transfers */
S#define  USB_EP3R_CTR_RX                     ((uint16_t)0x8000)            /*!< Correct Transfer for reception */
S
S/*******************  Bit definition for USB_EP4R register  *******************/
S#define  USB_EP4R_EA                         ((uint16_t)0x000F)            /*!< Endpoint Address */
S
S#define  USB_EP4R_STAT_TX                    ((uint16_t)0x0030)            /*!< STAT_TX[1:0] bits (Status bits, for transmission transfers) */
S#define  USB_EP4R_STAT_TX_0                  ((uint16_t)0x0010)            /*!< Bit 0 */
S#define  USB_EP4R_STAT_TX_1                  ((uint16_t)0x0020)            /*!< Bit 1 */
S
S#define  USB_EP4R_DTOG_TX                    ((uint16_t)0x0040)            /*!< Data Toggle, for transmission transfers */
S#define  USB_EP4R_CTR_TX                     ((uint16_t)0x0080)            /*!< Correct Transfer for transmission */
S#define  USB_EP4R_EP_KIND                    ((uint16_t)0x0100)            /*!< Endpoint Kind */
S
S#define  USB_EP4R_EP_TYPE                    ((uint16_t)0x0600)            /*!< EP_TYPE[1:0] bits (Endpoint type) */
S#define  USB_EP4R_EP_TYPE_0                  ((uint16_t)0x0200)            /*!< Bit 0 */
S#define  USB_EP4R_EP_TYPE_1                  ((uint16_t)0x0400)            /*!< Bit 1 */
S
S#define  USB_EP4R_SETUP                      ((uint16_t)0x0800)            /*!< Setup transaction completed */
S
S#define  USB_EP4R_STAT_RX                    ((uint16_t)0x3000)            /*!< STAT_RX[1:0] bits (Status bits, for reception transfers) */
S#define  USB_EP4R_STAT_RX_0                  ((uint16_t)0x1000)            /*!< Bit 0 */
S#define  USB_EP4R_STAT_RX_1                  ((uint16_t)0x2000)            /*!< Bit 1 */
S
S#define  USB_EP4R_DTOG_RX                    ((uint16_t)0x4000)            /*!< Data Toggle, for reception transfers */
S#define  USB_EP4R_CTR_RX                     ((uint16_t)0x8000)            /*!< Correct Transfer for reception */
S
S/*******************  Bit definition for USB_EP5R register  *******************/
S#define  USB_EP5R_EA                         ((uint16_t)0x000F)            /*!< Endpoint Address */
S
S#define  USB_EP5R_STAT_TX                    ((uint16_t)0x0030)            /*!< STAT_TX[1:0] bits (Status bits, for transmission transfers) */
S#define  USB_EP5R_STAT_TX_0                  ((uint16_t)0x0010)            /*!< Bit 0 */
S#define  USB_EP5R_STAT_TX_1                  ((uint16_t)0x0020)            /*!< Bit 1 */
S
S#define  USB_EP5R_DTOG_TX                    ((uint16_t)0x0040)            /*!< Data Toggle, for transmission transfers */
S#define  USB_EP5R_CTR_TX                     ((uint16_t)0x0080)            /*!< Correct Transfer for transmission */
S#define  USB_EP5R_EP_KIND                    ((uint16_t)0x0100)            /*!< Endpoint Kind */
S
S#define  USB_EP5R_EP_TYPE                    ((uint16_t)0x0600)            /*!< EP_TYPE[1:0] bits (Endpoint type) */
S#define  USB_EP5R_EP_TYPE_0                  ((uint16_t)0x0200)            /*!< Bit 0 */
S#define  USB_EP5R_EP_TYPE_1                  ((uint16_t)0x0400)            /*!< Bit 1 */
S
S#define  USB_EP5R_SETUP                      ((uint16_t)0x0800)            /*!< Setup transaction completed */
S
S#define  USB_EP5R_STAT_RX                    ((uint16_t)0x3000)            /*!< STAT_RX[1:0] bits (Status bits, for reception transfers) */
S#define  USB_EP5R_STAT_RX_0                  ((uint16_t)0x1000)            /*!< Bit 0 */
S#define  USB_EP5R_STAT_RX_1                  ((uint16_t)0x2000)            /*!< Bit 1 */
S
S#define  USB_EP5R_DTOG_RX                    ((uint16_t)0x4000)            /*!< Data Toggle, for reception transfers */
S#define  USB_EP5R_CTR_RX                     ((uint16_t)0x8000)            /*!< Correct Transfer for reception */
S
S/*******************  Bit definition for USB_EP6R register  *******************/
S#define  USB_EP6R_EA                         ((uint16_t)0x000F)            /*!< Endpoint Address */
S
S#define  USB_EP6R_STAT_TX                    ((uint16_t)0x0030)            /*!< STAT_TX[1:0] bits (Status bits, for transmission transfers) */
S#define  USB_EP6R_STAT_TX_0                  ((uint16_t)0x0010)            /*!< Bit 0 */
S#define  USB_EP6R_STAT_TX_1                  ((uint16_t)0x0020)            /*!< Bit 1 */
S
S#define  USB_EP6R_DTOG_TX                    ((uint16_t)0x0040)            /*!< Data Toggle, for transmission transfers */
S#define  USB_EP6R_CTR_TX                     ((uint16_t)0x0080)            /*!< Correct Transfer for transmission */
S#define  USB_EP6R_EP_KIND                    ((uint16_t)0x0100)            /*!< Endpoint Kind */
S
S#define  USB_EP6R_EP_TYPE                    ((uint16_t)0x0600)            /*!< EP_TYPE[1:0] bits (Endpoint type) */
S#define  USB_EP6R_EP_TYPE_0                  ((uint16_t)0x0200)            /*!< Bit 0 */
S#define  USB_EP6R_EP_TYPE_1                  ((uint16_t)0x0400)            /*!< Bit 1 */
S
S#define  USB_EP6R_SETUP                      ((uint16_t)0x0800)            /*!< Setup transaction completed */
S
S#define  USB_EP6R_STAT_RX                    ((uint16_t)0x3000)            /*!< STAT_RX[1:0] bits (Status bits, for reception transfers) */
S#define  USB_EP6R_STAT_RX_0                  ((uint16_t)0x1000)            /*!< Bit 0 */
S#define  USB_EP6R_STAT_RX_1                  ((uint16_t)0x2000)            /*!< Bit 1 */
S
S#define  USB_EP6R_DTOG_RX                    ((uint16_t)0x4000)            /*!< Data Toggle, for reception transfers */
S#define  USB_EP6R_CTR_RX                     ((uint16_t)0x8000)            /*!< Correct Transfer for reception */
S
S/*******************  Bit definition for USB_EP7R register  *******************/
S#define  USB_EP7R_EA                         ((uint16_t)0x000F)            /*!< Endpoint Address */
S
S#define  USB_EP7R_STAT_TX                    ((uint16_t)0x0030)            /*!< STAT_TX[1:0] bits (Status bits, for transmission transfers) */
S#define  USB_EP7R_STAT_TX_0                  ((uint16_t)0x0010)            /*!< Bit 0 */
S#define  USB_EP7R_STAT_TX_1                  ((uint16_t)0x0020)            /*!< Bit 1 */
S
S#define  USB_EP7R_DTOG_TX                    ((uint16_t)0x0040)            /*!< Data Toggle, for transmission transfers */
S#define  USB_EP7R_CTR_TX                     ((uint16_t)0x0080)            /*!< Correct Transfer for transmission */
S#define  USB_EP7R_EP_KIND                    ((uint16_t)0x0100)            /*!< Endpoint Kind */
S
S#define  USB_EP7R_EP_TYPE                    ((uint16_t)0x0600)            /*!< EP_TYPE[1:0] bits (Endpoint type) */
S#define  USB_EP7R_EP_TYPE_0                  ((uint16_t)0x0200)            /*!< Bit 0 */
S#define  USB_EP7R_EP_TYPE_1                  ((uint16_t)0x0400)            /*!< Bit 1 */
S
S#define  USB_EP7R_SETUP                      ((uint16_t)0x0800)            /*!< Setup transaction completed */
S
S#define  USB_EP7R_STAT_RX                    ((uint16_t)0x3000)            /*!< STAT_RX[1:0] bits (Status bits, for reception transfers) */
S#define  USB_EP7R_STAT_RX_0                  ((uint16_t)0x1000)            /*!< Bit 0 */
S#define  USB_EP7R_STAT_RX_1                  ((uint16_t)0x2000)            /*!< Bit 1 */
S
S#define  USB_EP7R_DTOG_RX                    ((uint16_t)0x4000)            /*!< Data Toggle, for reception transfers */
S#define  USB_EP7R_CTR_RX                     ((uint16_t)0x8000)            /*!< Correct Transfer for reception */
S
S/*!< Common registers */
S/*******************  Bit definition for USB_CNTR register  *******************/
S#define  USB_CNTR_FRES                       ((uint16_t)0x0001)            /*!< Force USB Reset */
S#define  USB_CNTR_PDWN                       ((uint16_t)0x0002)            /*!< Power down */
S#define  USB_CNTR_LP_MODE                    ((uint16_t)0x0004)            /*!< Low-power mode */
S#define  USB_CNTR_FSUSP                      ((uint16_t)0x0008)            /*!< Force suspend */
S#define  USB_CNTR_RESUME                     ((uint16_t)0x0010)            /*!< Resume request */
S#define  USB_CNTR_ESOFM                      ((uint16_t)0x0100)            /*!< Expected Start Of Frame Interrupt Mask */
S#define  USB_CNTR_SOFM                       ((uint16_t)0x0200)            /*!< Start Of Frame Interrupt Mask */
S#define  USB_CNTR_RESETM                     ((uint16_t)0x0400)            /*!< RESET Interrupt Mask */
S#define  USB_CNTR_SUSPM                      ((uint16_t)0x0800)            /*!< Suspend mode Interrupt Mask */
S#define  USB_CNTR_WKUPM                      ((uint16_t)0x1000)            /*!< Wakeup Interrupt Mask */
S#define  USB_CNTR_ERRM                       ((uint16_t)0x2000)            /*!< Error Interrupt Mask */
S#define  USB_CNTR_PMAOVRM                    ((uint16_t)0x4000)            /*!< Packet Memory Area Over / Underrun Interrupt Mask */
S#define  USB_CNTR_CTRM                       ((uint16_t)0x8000)            /*!< Correct Transfer Interrupt Mask */
S
S/*******************  Bit definition for USB_ISTR register  *******************/
S#define  USB_ISTR_EP_ID                      ((uint16_t)0x000F)            /*!< Endpoint Identifier */
S#define  USB_ISTR_DIR                        ((uint16_t)0x0010)            /*!< Direction of transaction */
S#define  USB_ISTR_ESOF                       ((uint16_t)0x0100)            /*!< Expected Start Of Frame */
S#define  USB_ISTR_SOF                        ((uint16_t)0x0200)            /*!< Start Of Frame */
S#define  USB_ISTR_RESET                      ((uint16_t)0x0400)            /*!< USB RESET request */
S#define  USB_ISTR_SUSP                       ((uint16_t)0x0800)            /*!< Suspend mode request */
S#define  USB_ISTR_WKUP                       ((uint16_t)0x1000)            /*!< Wake up */
S#define  USB_ISTR_ERR                        ((uint16_t)0x2000)            /*!< Error */
S#define  USB_ISTR_PMAOVR                     ((uint16_t)0x4000)            /*!< Packet Memory Area Over / Underrun */
S#define  USB_ISTR_CTR                        ((uint16_t)0x8000)            /*!< Correct Transfer */
S
S/*******************  Bit definition for USB_FNR register  ********************/
S#define  USB_FNR_FN                          ((uint16_t)0x07FF)            /*!< Frame Number */
S#define  USB_FNR_LSOF                        ((uint16_t)0x1800)            /*!< Lost SOF */
S#define  USB_FNR_LCK                         ((uint16_t)0x2000)            /*!< Locked */
S#define  USB_FNR_RXDM                        ((uint16_t)0x4000)            /*!< Receive Data - Line Status */
S#define  USB_FNR_RXDP                        ((uint16_t)0x8000)            /*!< Receive Data + Line Status */
S
S/******************  Bit definition for USB_DADDR register  *******************/
S#define  USB_DADDR_ADD                       ((uint8_t)0x7F)               /*!< ADD[6:0] bits (Device Address) */
S#define  USB_DADDR_ADD0                      ((uint8_t)0x01)               /*!< Bit 0 */
S#define  USB_DADDR_ADD1                      ((uint8_t)0x02)               /*!< Bit 1 */
S#define  USB_DADDR_ADD2                      ((uint8_t)0x04)               /*!< Bit 2 */
S#define  USB_DADDR_ADD3                      ((uint8_t)0x08)               /*!< Bit 3 */
S#define  USB_DADDR_ADD4                      ((uint8_t)0x10)               /*!< Bit 4 */
S#define  USB_DADDR_ADD5                      ((uint8_t)0x20)               /*!< Bit 5 */
S#define  USB_DADDR_ADD6                      ((uint8_t)0x40)               /*!< Bit 6 */
S
S#define  USB_DADDR_EF                        ((uint8_t)0x80)               /*!< Enable Function */
S
S/******************  Bit definition for USB_BTABLE register  ******************/    
S#define  USB_BTABLE_BTABLE                   ((uint16_t)0xFFF8)            /*!< Buffer Table */
S
S/*!< Buffer descriptor table */
S/*****************  Bit definition for USB_ADDR0_TX register  *****************/
S#define  USB_ADDR0_TX_ADDR0_TX               ((uint16_t)0xFFFE)            /*!< Transmission Buffer Address 0 */
S
S/*****************  Bit definition for USB_ADDR1_TX register  *****************/
S#define  USB_ADDR1_TX_ADDR1_TX               ((uint16_t)0xFFFE)            /*!< Transmission Buffer Address 1 */
S
S/*****************  Bit definition for USB_ADDR2_TX register  *****************/
S#define  USB_ADDR2_TX_ADDR2_TX               ((uint16_t)0xFFFE)            /*!< Transmission Buffer Address 2 */
S
S/*****************  Bit definition for USB_ADDR3_TX register  *****************/
S#define  USB_ADDR3_TX_ADDR3_TX               ((uint16_t)0xFFFE)            /*!< Transmission Buffer Address 3 */
S
S/*****************  Bit definition for USB_ADDR4_TX register  *****************/
S#define  USB_ADDR4_TX_ADDR4_TX               ((uint16_t)0xFFFE)            /*!< Transmission Buffer Address 4 */
S
S/*****************  Bit definition for USB_ADDR5_TX register  *****************/
S#define  USB_ADDR5_TX_ADDR5_TX               ((uint16_t)0xFFFE)            /*!< Transmission Buffer Address 5 */
S
S/*****************  Bit definition for USB_ADDR6_TX register  *****************/
S#define  USB_ADDR6_TX_ADDR6_TX               ((uint16_t)0xFFFE)            /*!< Transmission Buffer Address 6 */
S
S/*****************  Bit definition for USB_ADDR7_TX register  *****************/
S#define  USB_ADDR7_TX_ADDR7_TX               ((uint16_t)0xFFFE)            /*!< Transmission Buffer Address 7 */
S
S/*----------------------------------------------------------------------------*/
S
S/*****************  Bit definition for USB_COUNT0_TX register  ****************/
S#define  USB_COUNT0_TX_COUNT0_TX             ((uint16_t)0x03FF)            /*!< Transmission Byte Count 0 */
S
S/*****************  Bit definition for USB_COUNT1_TX register  ****************/
S#define  USB_COUNT1_TX_COUNT1_TX             ((uint16_t)0x03FF)            /*!< Transmission Byte Count 1 */
S
S/*****************  Bit definition for USB_COUNT2_TX register  ****************/
S#define  USB_COUNT2_TX_COUNT2_TX             ((uint16_t)0x03FF)            /*!< Transmission Byte Count 2 */
S
S/*****************  Bit definition for USB_COUNT3_TX register  ****************/
S#define  USB_COUNT3_TX_COUNT3_TX             ((uint16_t)0x03FF)            /*!< Transmission Byte Count 3 */
S
S/*****************  Bit definition for USB_COUNT4_TX register  ****************/
S#define  USB_COUNT4_TX_COUNT4_TX             ((uint16_t)0x03FF)            /*!< Transmission Byte Count 4 */
S
S/*****************  Bit definition for USB_COUNT5_TX register  ****************/
S#define  USB_COUNT5_TX_COUNT5_TX             ((uint16_t)0x03FF)            /*!< Transmission Byte Count 5 */
S
S/*****************  Bit definition for USB_COUNT6_TX register  ****************/
S#define  USB_COUNT6_TX_COUNT6_TX             ((uint16_t)0x03FF)            /*!< Transmission Byte Count 6 */
S
S/*****************  Bit definition for USB_COUNT7_TX register  ****************/
S#define  USB_COUNT7_TX_COUNT7_TX             ((uint16_t)0x03FF)            /*!< Transmission Byte Count 7 */
S
S/*----------------------------------------------------------------------------*/
S
S/****************  Bit definition for USB_COUNT0_TX_0 register  ***************/
S#define  USB_COUNT0_TX_0_COUNT0_TX_0         ((uint32_t)0x000003FF)        /*!< Transmission Byte Count 0 (low) */
S
S/****************  Bit definition for USB_COUNT0_TX_1 register  ***************/
S#define  USB_COUNT0_TX_1_COUNT0_TX_1         ((uint32_t)0x03FF0000)        /*!< Transmission Byte Count 0 (high) */
S
S/****************  Bit definition for USB_COUNT1_TX_0 register  ***************/
S#define  USB_COUNT1_TX_0_COUNT1_TX_0          ((uint32_t)0x000003FF)        /*!< Transmission Byte Count 1 (low) */
S
S/****************  Bit definition for USB_COUNT1_TX_1 register  ***************/
S#define  USB_COUNT1_TX_1_COUNT1_TX_1          ((uint32_t)0x03FF0000)        /*!< Transmission Byte Count 1 (high) */
S
S/****************  Bit definition for USB_COUNT2_TX_0 register  ***************/
S#define  USB_COUNT2_TX_0_COUNT2_TX_0         ((uint32_t)0x000003FF)        /*!< Transmission Byte Count 2 (low) */
S
S/****************  Bit definition for USB_COUNT2_TX_1 register  ***************/
S#define  USB_COUNT2_TX_1_COUNT2_TX_1         ((uint32_t)0x03FF0000)        /*!< Transmission Byte Count 2 (high) */
S
S/****************  Bit definition for USB_COUNT3_TX_0 register  ***************/
S#define  USB_COUNT3_TX_0_COUNT3_TX_0         ((uint16_t)0x000003FF)        /*!< Transmission Byte Count 3 (low) */
S
S/****************  Bit definition for USB_COUNT3_TX_1 register  ***************/
S#define  USB_COUNT3_TX_1_COUNT3_TX_1         ((uint16_t)0x03FF0000)        /*!< Transmission Byte Count 3 (high) */
S
S/****************  Bit definition for USB_COUNT4_TX_0 register  ***************/
S#define  USB_COUNT4_TX_0_COUNT4_TX_0         ((uint32_t)0x000003FF)        /*!< Transmission Byte Count 4 (low) */
S
S/****************  Bit definition for USB_COUNT4_TX_1 register  ***************/
S#define  USB_COUNT4_TX_1_COUNT4_TX_1         ((uint32_t)0x03FF0000)        /*!< Transmission Byte Count 4 (high) */
S
S/****************  Bit definition for USB_COUNT5_TX_0 register  ***************/
S#define  USB_COUNT5_TX_0_COUNT5_TX_0         ((uint32_t)0x000003FF)        /*!< Transmission Byte Count 5 (low) */
S
S/****************  Bit definition for USB_COUNT5_TX_1 register  ***************/
S#define  USB_COUNT5_TX_1_COUNT5_TX_1         ((uint32_t)0x03FF0000)        /*!< Transmission Byte Count 5 (high) */
S
S/****************  Bit definition for USB_COUNT6_TX_0 register  ***************/
S#define  USB_COUNT6_TX_0_COUNT6_TX_0         ((uint32_t)0x000003FF)        /*!< Transmission Byte Count 6 (low) */
S
S/****************  Bit definition for USB_COUNT6_TX_1 register  ***************/
S#define  USB_COUNT6_TX_1_COUNT6_TX_1         ((uint32_t)0x03FF0000)        /*!< Transmission Byte Count 6 (high) */
S
S/****************  Bit definition for USB_COUNT7_TX_0 register  ***************/
S#define  USB_COUNT7_TX_0_COUNT7_TX_0         ((uint32_t)0x000003FF)        /*!< Transmission Byte Count 7 (low) */
S
S/****************  Bit definition for USB_COUNT7_TX_1 register  ***************/
S#define  USB_COUNT7_TX_1_COUNT7_TX_1         ((uint32_t)0x03FF0000)        /*!< Transmission Byte Count 7 (high) */
S
S/*----------------------------------------------------------------------------*/
S
S/*****************  Bit definition for USB_ADDR0_RX register  *****************/
S#define  USB_ADDR0_RX_ADDR0_RX               ((uint16_t)0xFFFE)            /*!< Reception Buffer Address 0 */
S
S/*****************  Bit definition for USB_ADDR1_RX register  *****************/
S#define  USB_ADDR1_RX_ADDR1_RX               ((uint16_t)0xFFFE)            /*!< Reception Buffer Address 1 */
S
S/*****************  Bit definition for USB_ADDR2_RX register  *****************/
S#define  USB_ADDR2_RX_ADDR2_RX               ((uint16_t)0xFFFE)            /*!< Reception Buffer Address 2 */
S
S/*****************  Bit definition for USB_ADDR3_RX register  *****************/
S#define  USB_ADDR3_RX_ADDR3_RX               ((uint16_t)0xFFFE)            /*!< Reception Buffer Address 3 */
S
S/*****************  Bit definition for USB_ADDR4_RX register  *****************/
S#define  USB_ADDR4_RX_ADDR4_RX               ((uint16_t)0xFFFE)            /*!< Reception Buffer Address 4 */
S
S/*****************  Bit definition for USB_ADDR5_RX register  *****************/
S#define  USB_ADDR5_RX_ADDR5_RX               ((uint16_t)0xFFFE)            /*!< Reception Buffer Address 5 */
S
S/*****************  Bit definition for USB_ADDR6_RX register  *****************/
S#define  USB_ADDR6_RX_ADDR6_RX               ((uint16_t)0xFFFE)            /*!< Reception Buffer Address 6 */
S
S/*****************  Bit definition for USB_ADDR7_RX register  *****************/
S#define  USB_ADDR7_RX_ADDR7_RX               ((uint16_t)0xFFFE)            /*!< Reception Buffer Address 7 */
S
S/*----------------------------------------------------------------------------*/
S
S/*****************  Bit definition for USB_COUNT0_RX register  ****************/
S#define  USB_COUNT0_RX_COUNT0_RX             ((uint16_t)0x03FF)            /*!< Reception Byte Count */
S
S#define  USB_COUNT0_RX_NUM_BLOCK             ((uint16_t)0x7C00)            /*!< NUM_BLOCK[4:0] bits (Number of blocks) */
S#define  USB_COUNT0_RX_NUM_BLOCK_0           ((uint16_t)0x0400)            /*!< Bit 0 */
S#define  USB_COUNT0_RX_NUM_BLOCK_1           ((uint16_t)0x0800)            /*!< Bit 1 */
S#define  USB_COUNT0_RX_NUM_BLOCK_2           ((uint16_t)0x1000)            /*!< Bit 2 */
S#define  USB_COUNT0_RX_NUM_BLOCK_3           ((uint16_t)0x2000)            /*!< Bit 3 */
S#define  USB_COUNT0_RX_NUM_BLOCK_4           ((uint16_t)0x4000)            /*!< Bit 4 */
S
S#define  USB_COUNT0_RX_BLSIZE                ((uint16_t)0x8000)            /*!< BLock SIZE */
S
S/*****************  Bit definition for USB_COUNT1_RX register  ****************/
S#define  USB_COUNT1_RX_COUNT1_RX             ((uint16_t)0x03FF)            /*!< Reception Byte Count */
S
S#define  USB_COUNT1_RX_NUM_BLOCK             ((uint16_t)0x7C00)            /*!< NUM_BLOCK[4:0] bits (Number of blocks) */
S#define  USB_COUNT1_RX_NUM_BLOCK_0           ((uint16_t)0x0400)            /*!< Bit 0 */
S#define  USB_COUNT1_RX_NUM_BLOCK_1           ((uint16_t)0x0800)            /*!< Bit 1 */
S#define  USB_COUNT1_RX_NUM_BLOCK_2           ((uint16_t)0x1000)            /*!< Bit 2 */
S#define  USB_COUNT1_RX_NUM_BLOCK_3           ((uint16_t)0x2000)            /*!< Bit 3 */
S#define  USB_COUNT1_RX_NUM_BLOCK_4           ((uint16_t)0x4000)            /*!< Bit 4 */
S
S#define  USB_COUNT1_RX_BLSIZE                ((uint16_t)0x8000)            /*!< BLock SIZE */
S
S/*****************  Bit definition for USB_COUNT2_RX register  ****************/
S#define  USB_COUNT2_RX_COUNT2_RX             ((uint16_t)0x03FF)            /*!< Reception Byte Count */
S
S#define  USB_COUNT2_RX_NUM_BLOCK             ((uint16_t)0x7C00)            /*!< NUM_BLOCK[4:0] bits (Number of blocks) */
S#define  USB_COUNT2_RX_NUM_BLOCK_0           ((uint16_t)0x0400)            /*!< Bit 0 */
S#define  USB_COUNT2_RX_NUM_BLOCK_1           ((uint16_t)0x0800)            /*!< Bit 1 */
S#define  USB_COUNT2_RX_NUM_BLOCK_2           ((uint16_t)0x1000)            /*!< Bit 2 */
S#define  USB_COUNT2_RX_NUM_BLOCK_3           ((uint16_t)0x2000)            /*!< Bit 3 */
S#define  USB_COUNT2_RX_NUM_BLOCK_4           ((uint16_t)0x4000)            /*!< Bit 4 */
S
S#define  USB_COUNT2_RX_BLSIZE                ((uint16_t)0x8000)            /*!< BLock SIZE */
S
S/*****************  Bit definition for USB_COUNT3_RX register  ****************/
S#define  USB_COUNT3_RX_COUNT3_RX             ((uint16_t)0x03FF)            /*!< Reception Byte Count */
S
S#define  USB_COUNT3_RX_NUM_BLOCK             ((uint16_t)0x7C00)            /*!< NUM_BLOCK[4:0] bits (Number of blocks) */
S#define  USB_COUNT3_RX_NUM_BLOCK_0           ((uint16_t)0x0400)            /*!< Bit 0 */
S#define  USB_COUNT3_RX_NUM_BLOCK_1           ((uint16_t)0x0800)            /*!< Bit 1 */
S#define  USB_COUNT3_RX_NUM_BLOCK_2           ((uint16_t)0x1000)            /*!< Bit 2 */
S#define  USB_COUNT3_RX_NUM_BLOCK_3           ((uint16_t)0x2000)            /*!< Bit 3 */
S#define  USB_COUNT3_RX_NUM_BLOCK_4           ((uint16_t)0x4000)            /*!< Bit 4 */
S
S#define  USB_COUNT3_RX_BLSIZE                ((uint16_t)0x8000)            /*!< BLock SIZE */
S
S/*****************  Bit definition for USB_COUNT4_RX register  ****************/
S#define  USB_COUNT4_RX_COUNT4_RX             ((uint16_t)0x03FF)            /*!< Reception Byte Count */
S
S#define  USB_COUNT4_RX_NUM_BLOCK             ((uint16_t)0x7C00)            /*!< NUM_BLOCK[4:0] bits (Number of blocks) */
S#define  USB_COUNT4_RX_NUM_BLOCK_0           ((uint16_t)0x0400)            /*!< Bit 0 */
S#define  USB_COUNT4_RX_NUM_BLOCK_1           ((uint16_t)0x0800)            /*!< Bit 1 */
S#define  USB_COUNT4_RX_NUM_BLOCK_2           ((uint16_t)0x1000)            /*!< Bit 2 */
S#define  USB_COUNT4_RX_NUM_BLOCK_3           ((uint16_t)0x2000)            /*!< Bit 3 */
S#define  USB_COUNT4_RX_NUM_BLOCK_4           ((uint16_t)0x4000)            /*!< Bit 4 */
S
S#define  USB_COUNT4_RX_BLSIZE                ((uint16_t)0x8000)            /*!< BLock SIZE */
S
S/*****************  Bit definition for USB_COUNT5_RX register  ****************/
S#define  USB_COUNT5_RX_COUNT5_RX             ((uint16_t)0x03FF)            /*!< Reception Byte Count */
S
S#define  USB_COUNT5_RX_NUM_BLOCK             ((uint16_t)0x7C00)            /*!< NUM_BLOCK[4:0] bits (Number of blocks) */
S#define  USB_COUNT5_RX_NUM_BLOCK_0           ((uint16_t)0x0400)            /*!< Bit 0 */
S#define  USB_COUNT5_RX_NUM_BLOCK_1           ((uint16_t)0x0800)            /*!< Bit 1 */
S#define  USB_COUNT5_RX_NUM_BLOCK_2           ((uint16_t)0x1000)            /*!< Bit 2 */
S#define  USB_COUNT5_RX_NUM_BLOCK_3           ((uint16_t)0x2000)            /*!< Bit 3 */
S#define  USB_COUNT5_RX_NUM_BLOCK_4           ((uint16_t)0x4000)            /*!< Bit 4 */
S
S#define  USB_COUNT5_RX_BLSIZE                ((uint16_t)0x8000)            /*!< BLock SIZE */
S
S/*****************  Bit definition for USB_COUNT6_RX register  ****************/
S#define  USB_COUNT6_RX_COUNT6_RX             ((uint16_t)0x03FF)            /*!< Reception Byte Count */
S
S#define  USB_COUNT6_RX_NUM_BLOCK             ((uint16_t)0x7C00)            /*!< NUM_BLOCK[4:0] bits (Number of blocks) */
S#define  USB_COUNT6_RX_NUM_BLOCK_0           ((uint16_t)0x0400)            /*!< Bit 0 */
S#define  USB_COUNT6_RX_NUM_BLOCK_1           ((uint16_t)0x0800)            /*!< Bit 1 */
S#define  USB_COUNT6_RX_NUM_BLOCK_2           ((uint16_t)0x1000)            /*!< Bit 2 */
S#define  USB_COUNT6_RX_NUM_BLOCK_3           ((uint16_t)0x2000)            /*!< Bit 3 */
S#define  USB_COUNT6_RX_NUM_BLOCK_4           ((uint16_t)0x4000)            /*!< Bit 4 */
S
S#define  USB_COUNT6_RX_BLSIZE                ((uint16_t)0x8000)            /*!< BLock SIZE */
S
S/*****************  Bit definition for USB_COUNT7_RX register  ****************/
S#define  USB_COUNT7_RX_COUNT7_RX             ((uint16_t)0x03FF)            /*!< Reception Byte Count */
S
S#define  USB_COUNT7_RX_NUM_BLOCK             ((uint16_t)0x7C00)            /*!< NUM_BLOCK[4:0] bits (Number of blocks) */
S#define  USB_COUNT7_RX_NUM_BLOCK_0           ((uint16_t)0x0400)            /*!< Bit 0 */
S#define  USB_COUNT7_RX_NUM_BLOCK_1           ((uint16_t)0x0800)            /*!< Bit 1 */
S#define  USB_COUNT7_RX_NUM_BLOCK_2           ((uint16_t)0x1000)            /*!< Bit 2 */
S#define  USB_COUNT7_RX_NUM_BLOCK_3           ((uint16_t)0x2000)            /*!< Bit 3 */
S#define  USB_COUNT7_RX_NUM_BLOCK_4           ((uint16_t)0x4000)            /*!< Bit 4 */
S
S#define  USB_COUNT7_RX_BLSIZE                ((uint16_t)0x8000)            /*!< BLock SIZE */
S
S/*----------------------------------------------------------------------------*/
S
S/****************  Bit definition for USB_COUNT0_RX_0 register  ***************/
S#define  USB_COUNT0_RX_0_COUNT0_RX_0         ((uint32_t)0x000003FF)        /*!< Reception Byte Count (low) */
S
S#define  USB_COUNT0_RX_0_NUM_BLOCK_0         ((uint32_t)0x00007C00)        /*!< NUM_BLOCK_0[4:0] bits (Number of blocks) (low) */
S#define  USB_COUNT0_RX_0_NUM_BLOCK_0_0       ((uint32_t)0x00000400)        /*!< Bit 0 */
S#define  USB_COUNT0_RX_0_NUM_BLOCK_0_1       ((uint32_t)0x00000800)        /*!< Bit 1 */
S#define  USB_COUNT0_RX_0_NUM_BLOCK_0_2       ((uint32_t)0x00001000)        /*!< Bit 2 */
S#define  USB_COUNT0_RX_0_NUM_BLOCK_0_3       ((uint32_t)0x00002000)        /*!< Bit 3 */
S#define  USB_COUNT0_RX_0_NUM_BLOCK_0_4       ((uint32_t)0x00004000)        /*!< Bit 4 */
S
S#define  USB_COUNT0_RX_0_BLSIZE_0            ((uint32_t)0x00008000)        /*!< BLock SIZE (low) */
S
S/****************  Bit definition for USB_COUNT0_RX_1 register  ***************/
S#define  USB_COUNT0_RX_1_COUNT0_RX_1         ((uint32_t)0x03FF0000)        /*!< Reception Byte Count (high) */
S
S#define  USB_COUNT0_RX_1_NUM_BLOCK_1         ((uint32_t)0x7C000000)        /*!< NUM_BLOCK_1[4:0] bits (Number of blocks) (high) */
S#define  USB_COUNT0_RX_1_NUM_BLOCK_1_0       ((uint32_t)0x04000000)        /*!< Bit 1 */
S#define  USB_COUNT0_RX_1_NUM_BLOCK_1_1       ((uint32_t)0x08000000)        /*!< Bit 1 */
S#define  USB_COUNT0_RX_1_NUM_BLOCK_1_2       ((uint32_t)0x10000000)        /*!< Bit 2 */
S#define  USB_COUNT0_RX_1_NUM_BLOCK_1_3       ((uint32_t)0x20000000)        /*!< Bit 3 */
S#define  USB_COUNT0_RX_1_NUM_BLOCK_1_4       ((uint32_t)0x40000000)        /*!< Bit 4 */
S
S#define  USB_COUNT0_RX_1_BLSIZE_1            ((uint32_t)0x80000000)        /*!< BLock SIZE (high) */
S
S/****************  Bit definition for USB_COUNT1_RX_0 register  ***************/
S#define  USB_COUNT1_RX_0_COUNT1_RX_0         ((uint32_t)0x000003FF)        /*!< Reception Byte Count (low) */
S
S#define  USB_COUNT1_RX_0_NUM_BLOCK_0         ((uint32_t)0x00007C00)        /*!< NUM_BLOCK_0[4:0] bits (Number of blocks) (low) */
S#define  USB_COUNT1_RX_0_NUM_BLOCK_0_0       ((uint32_t)0x00000400)        /*!< Bit 0 */
S#define  USB_COUNT1_RX_0_NUM_BLOCK_0_1       ((uint32_t)0x00000800)        /*!< Bit 1 */
S#define  USB_COUNT1_RX_0_NUM_BLOCK_0_2       ((uint32_t)0x00001000)        /*!< Bit 2 */
S#define  USB_COUNT1_RX_0_NUM_BLOCK_0_3       ((uint32_t)0x00002000)        /*!< Bit 3 */
S#define  USB_COUNT1_RX_0_NUM_BLOCK_0_4       ((uint32_t)0x00004000)        /*!< Bit 4 */
S
S#define  USB_COUNT1_RX_0_BLSIZE_0            ((uint32_t)0x00008000)        /*!< BLock SIZE (low) */
S
S/****************  Bit definition for USB_COUNT1_RX_1 register  ***************/
S#define  USB_COUNT1_RX_1_COUNT1_RX_1         ((uint32_t)0x03FF0000)        /*!< Reception Byte Count (high) */
S
S#define  USB_COUNT1_RX_1_NUM_BLOCK_1         ((uint32_t)0x7C000000)        /*!< NUM_BLOCK_1[4:0] bits (Number of blocks) (high) */
S#define  USB_COUNT1_RX_1_NUM_BLOCK_1_0       ((uint32_t)0x04000000)        /*!< Bit 0 */
S#define  USB_COUNT1_RX_1_NUM_BLOCK_1_1       ((uint32_t)0x08000000)        /*!< Bit 1 */
S#define  USB_COUNT1_RX_1_NUM_BLOCK_1_2       ((uint32_t)0x10000000)        /*!< Bit 2 */
S#define  USB_COUNT1_RX_1_NUM_BLOCK_1_3       ((uint32_t)0x20000000)        /*!< Bit 3 */
S#define  USB_COUNT1_RX_1_NUM_BLOCK_1_4       ((uint32_t)0x40000000)        /*!< Bit 4 */
S
S#define  USB_COUNT1_RX_1_BLSIZE_1            ((uint32_t)0x80000000)        /*!< BLock SIZE (high) */
S
S/****************  Bit definition for USB_COUNT2_RX_0 register  ***************/
S#define  USB_COUNT2_RX_0_COUNT2_RX_0         ((uint32_t)0x000003FF)        /*!< Reception Byte Count (low) */
S
S#define  USB_COUNT2_RX_0_NUM_BLOCK_0         ((uint32_t)0x00007C00)        /*!< NUM_BLOCK_0[4:0] bits (Number of blocks) (low) */
S#define  USB_COUNT2_RX_0_NUM_BLOCK_0_0       ((uint32_t)0x00000400)        /*!< Bit 0 */
S#define  USB_COUNT2_RX_0_NUM_BLOCK_0_1       ((uint32_t)0x00000800)        /*!< Bit 1 */
S#define  USB_COUNT2_RX_0_NUM_BLOCK_0_2       ((uint32_t)0x00001000)        /*!< Bit 2 */
S#define  USB_COUNT2_RX_0_NUM_BLOCK_0_3       ((uint32_t)0x00002000)        /*!< Bit 3 */
S#define  USB_COUNT2_RX_0_NUM_BLOCK_0_4       ((uint32_t)0x00004000)        /*!< Bit 4 */
S
S#define  USB_COUNT2_RX_0_BLSIZE_0            ((uint32_t)0x00008000)        /*!< BLock SIZE (low) */
S
S/****************  Bit definition for USB_COUNT2_RX_1 register  ***************/
S#define  USB_COUNT2_RX_1_COUNT2_RX_1         ((uint32_t)0x03FF0000)        /*!< Reception Byte Count (high) */
S
S#define  USB_COUNT2_RX_1_NUM_BLOCK_1         ((uint32_t)0x7C000000)        /*!< NUM_BLOCK_1[4:0] bits (Number of blocks) (high) */
S#define  USB_COUNT2_RX_1_NUM_BLOCK_1_0       ((uint32_t)0x04000000)        /*!< Bit 0 */
S#define  USB_COUNT2_RX_1_NUM_BLOCK_1_1       ((uint32_t)0x08000000)        /*!< Bit 1 */
S#define  USB_COUNT2_RX_1_NUM_BLOCK_1_2       ((uint32_t)0x10000000)        /*!< Bit 2 */
S#define  USB_COUNT2_RX_1_NUM_BLOCK_1_3       ((uint32_t)0x20000000)        /*!< Bit 3 */
S#define  USB_COUNT2_RX_1_NUM_BLOCK_1_4       ((uint32_t)0x40000000)        /*!< Bit 4 */
S
S#define  USB_COUNT2_RX_1_BLSIZE_1            ((uint32_t)0x80000000)        /*!< BLock SIZE (high) */
S
S/****************  Bit definition for USB_COUNT3_RX_0 register  ***************/
S#define  USB_COUNT3_RX_0_COUNT3_RX_0         ((uint32_t)0x000003FF)        /*!< Reception Byte Count (low) */
S
S#define  USB_COUNT3_RX_0_NUM_BLOCK_0         ((uint32_t)0x00007C00)        /*!< NUM_BLOCK_0[4:0] bits (Number of blocks) (low) */
S#define  USB_COUNT3_RX_0_NUM_BLOCK_0_0       ((uint32_t)0x00000400)        /*!< Bit 0 */
S#define  USB_COUNT3_RX_0_NUM_BLOCK_0_1       ((uint32_t)0x00000800)        /*!< Bit 1 */
S#define  USB_COUNT3_RX_0_NUM_BLOCK_0_2       ((uint32_t)0x00001000)        /*!< Bit 2 */
S#define  USB_COUNT3_RX_0_NUM_BLOCK_0_3       ((uint32_t)0x00002000)        /*!< Bit 3 */
S#define  USB_COUNT3_RX_0_NUM_BLOCK_0_4       ((uint32_t)0x00004000)        /*!< Bit 4 */
S
S#define  USB_COUNT3_RX_0_BLSIZE_0            ((uint32_t)0x00008000)        /*!< BLock SIZE (low) */
S
S/****************  Bit definition for USB_COUNT3_RX_1 register  ***************/
S#define  USB_COUNT3_RX_1_COUNT3_RX_1         ((uint32_t)0x03FF0000)        /*!< Reception Byte Count (high) */
S
S#define  USB_COUNT3_RX_1_NUM_BLOCK_1         ((uint32_t)0x7C000000)        /*!< NUM_BLOCK_1[4:0] bits (Number of blocks) (high) */
S#define  USB_COUNT3_RX_1_NUM_BLOCK_1_0       ((uint32_t)0x04000000)        /*!< Bit 0 */
S#define  USB_COUNT3_RX_1_NUM_BLOCK_1_1       ((uint32_t)0x08000000)        /*!< Bit 1 */
S#define  USB_COUNT3_RX_1_NUM_BLOCK_1_2       ((uint32_t)0x10000000)        /*!< Bit 2 */
S#define  USB_COUNT3_RX_1_NUM_BLOCK_1_3       ((uint32_t)0x20000000)        /*!< Bit 3 */
S#define  USB_COUNT3_RX_1_NUM_BLOCK_1_4       ((uint32_t)0x40000000)        /*!< Bit 4 */
S
S#define  USB_COUNT3_RX_1_BLSIZE_1            ((uint32_t)0x80000000)        /*!< BLock SIZE (high) */
S
S/****************  Bit definition for USB_COUNT4_RX_0 register  ***************/
S#define  USB_COUNT4_RX_0_COUNT4_RX_0         ((uint32_t)0x000003FF)        /*!< Reception Byte Count (low) */
S
S#define  USB_COUNT4_RX_0_NUM_BLOCK_0         ((uint32_t)0x00007C00)        /*!< NUM_BLOCK_0[4:0] bits (Number of blocks) (low) */
S#define  USB_COUNT4_RX_0_NUM_BLOCK_0_0      ((uint32_t)0x00000400)        /*!< Bit 0 */
S#define  USB_COUNT4_RX_0_NUM_BLOCK_0_1      ((uint32_t)0x00000800)        /*!< Bit 1 */
S#define  USB_COUNT4_RX_0_NUM_BLOCK_0_2      ((uint32_t)0x00001000)        /*!< Bit 2 */
S#define  USB_COUNT4_RX_0_NUM_BLOCK_0_3      ((uint32_t)0x00002000)        /*!< Bit 3 */
S#define  USB_COUNT4_RX_0_NUM_BLOCK_0_4      ((uint32_t)0x00004000)        /*!< Bit 4 */
S
S#define  USB_COUNT4_RX_0_BLSIZE_0            ((uint32_t)0x00008000)        /*!< BLock SIZE (low) */
S
S/****************  Bit definition for USB_COUNT4_RX_1 register  ***************/
S#define  USB_COUNT4_RX_1_COUNT4_RX_1         ((uint32_t)0x03FF0000)        /*!< Reception Byte Count (high) */
S
S#define  USB_COUNT4_RX_1_NUM_BLOCK_1         ((uint32_t)0x7C000000)        /*!< NUM_BLOCK_1[4:0] bits (Number of blocks) (high) */
S#define  USB_COUNT4_RX_1_NUM_BLOCK_1_0       ((uint32_t)0x04000000)        /*!< Bit 0 */
S#define  USB_COUNT4_RX_1_NUM_BLOCK_1_1       ((uint32_t)0x08000000)        /*!< Bit 1 */
S#define  USB_COUNT4_RX_1_NUM_BLOCK_1_2       ((uint32_t)0x10000000)        /*!< Bit 2 */
S#define  USB_COUNT4_RX_1_NUM_BLOCK_1_3       ((uint32_t)0x20000000)        /*!< Bit 3 */
S#define  USB_COUNT4_RX_1_NUM_BLOCK_1_4       ((uint32_t)0x40000000)        /*!< Bit 4 */
S
S#define  USB_COUNT4_RX_1_BLSIZE_1            ((uint32_t)0x80000000)        /*!< BLock SIZE (high) */
S
S/****************  Bit definition for USB_COUNT5_RX_0 register  ***************/
S#define  USB_COUNT5_RX_0_COUNT5_RX_0         ((uint32_t)0x000003FF)        /*!< Reception Byte Count (low) */
S
S#define  USB_COUNT5_RX_0_NUM_BLOCK_0         ((uint32_t)0x00007C00)        /*!< NUM_BLOCK_0[4:0] bits (Number of blocks) (low) */
S#define  USB_COUNT5_RX_0_NUM_BLOCK_0_0       ((uint32_t)0x00000400)        /*!< Bit 0 */
S#define  USB_COUNT5_RX_0_NUM_BLOCK_0_1       ((uint32_t)0x00000800)        /*!< Bit 1 */
S#define  USB_COUNT5_RX_0_NUM_BLOCK_0_2       ((uint32_t)0x00001000)        /*!< Bit 2 */
S#define  USB_COUNT5_RX_0_NUM_BLOCK_0_3       ((uint32_t)0x00002000)        /*!< Bit 3 */
S#define  USB_COUNT5_RX_0_NUM_BLOCK_0_4       ((uint32_t)0x00004000)        /*!< Bit 4 */
S
S#define  USB_COUNT5_RX_0_BLSIZE_0            ((uint32_t)0x00008000)        /*!< BLock SIZE (low) */
S
S/****************  Bit definition for USB_COUNT5_RX_1 register  ***************/
S#define  USB_COUNT5_RX_1_COUNT5_RX_1         ((uint32_t)0x03FF0000)        /*!< Reception Byte Count (high) */
S
S#define  USB_COUNT5_RX_1_NUM_BLOCK_1         ((uint32_t)0x7C000000)        /*!< NUM_BLOCK_1[4:0] bits (Number of blocks) (high) */
S#define  USB_COUNT5_RX_1_NUM_BLOCK_1_0       ((uint32_t)0x04000000)        /*!< Bit 0 */
S#define  USB_COUNT5_RX_1_NUM_BLOCK_1_1       ((uint32_t)0x08000000)        /*!< Bit 1 */
S#define  USB_COUNT5_RX_1_NUM_BLOCK_1_2       ((uint32_t)0x10000000)        /*!< Bit 2 */
S#define  USB_COUNT5_RX_1_NUM_BLOCK_1_3       ((uint32_t)0x20000000)        /*!< Bit 3 */
S#define  USB_COUNT5_RX_1_NUM_BLOCK_1_4       ((uint32_t)0x40000000)        /*!< Bit 4 */
S
S#define  USB_COUNT5_RX_1_BLSIZE_1            ((uint32_t)0x80000000)        /*!< BLock SIZE (high) */
S
S/***************  Bit definition for USB_COUNT6_RX_0  register  ***************/
S#define  USB_COUNT6_RX_0_COUNT6_RX_0         ((uint32_t)0x000003FF)        /*!< Reception Byte Count (low) */
S
S#define  USB_COUNT6_RX_0_NUM_BLOCK_0         ((uint32_t)0x00007C00)        /*!< NUM_BLOCK_0[4:0] bits (Number of blocks) (low) */
S#define  USB_COUNT6_RX_0_NUM_BLOCK_0_0       ((uint32_t)0x00000400)        /*!< Bit 0 */
S#define  USB_COUNT6_RX_0_NUM_BLOCK_0_1       ((uint32_t)0x00000800)        /*!< Bit 1 */
S#define  USB_COUNT6_RX_0_NUM_BLOCK_0_2       ((uint32_t)0x00001000)        /*!< Bit 2 */
S#define  USB_COUNT6_RX_0_NUM_BLOCK_0_3       ((uint32_t)0x00002000)        /*!< Bit 3 */
S#define  USB_COUNT6_RX_0_NUM_BLOCK_0_4       ((uint32_t)0x00004000)        /*!< Bit 4 */
S
S#define  USB_COUNT6_RX_0_BLSIZE_0            ((uint32_t)0x00008000)        /*!< BLock SIZE (low) */
S
S/****************  Bit definition for USB_COUNT6_RX_1 register  ***************/
S#define  USB_COUNT6_RX_1_COUNT6_RX_1         ((uint32_t)0x03FF0000)        /*!< Reception Byte Count (high) */
S
S#define  USB_COUNT6_RX_1_NUM_BLOCK_1         ((uint32_t)0x7C000000)        /*!< NUM_BLOCK_1[4:0] bits (Number of blocks) (high) */
S#define  USB_COUNT6_RX_1_NUM_BLOCK_1_0       ((uint32_t)0x04000000)        /*!< Bit 0 */
S#define  USB_COUNT6_RX_1_NUM_BLOCK_1_1       ((uint32_t)0x08000000)        /*!< Bit 1 */
S#define  USB_COUNT6_RX_1_NUM_BLOCK_1_2       ((uint32_t)0x10000000)        /*!< Bit 2 */
S#define  USB_COUNT6_RX_1_NUM_BLOCK_1_3       ((uint32_t)0x20000000)        /*!< Bit 3 */
S#define  USB_COUNT6_RX_1_NUM_BLOCK_1_4       ((uint32_t)0x40000000)        /*!< Bit 4 */
S
S#define  USB_COUNT6_RX_1_BLSIZE_1            ((uint32_t)0x80000000)        /*!< BLock SIZE (high) */
S
S/***************  Bit definition for USB_COUNT7_RX_0 register  ****************/
S#define  USB_COUNT7_RX_0_COUNT7_RX_0         ((uint32_t)0x000003FF)        /*!< Reception Byte Count (low) */
S
S#define  USB_COUNT7_RX_0_NUM_BLOCK_0         ((uint32_t)0x00007C00)        /*!< NUM_BLOCK_0[4:0] bits (Number of blocks) (low) */
S#define  USB_COUNT7_RX_0_NUM_BLOCK_0_0       ((uint32_t)0x00000400)        /*!< Bit 0 */
S#define  USB_COUNT7_RX_0_NUM_BLOCK_0_1       ((uint32_t)0x00000800)        /*!< Bit 1 */
S#define  USB_COUNT7_RX_0_NUM_BLOCK_0_2       ((uint32_t)0x00001000)        /*!< Bit 2 */
S#define  USB_COUNT7_RX_0_NUM_BLOCK_0_3       ((uint32_t)0x00002000)        /*!< Bit 3 */
S#define  USB_COUNT7_RX_0_NUM_BLOCK_0_4       ((uint32_t)0x00004000)        /*!< Bit 4 */
S
S#define  USB_COUNT7_RX_0_BLSIZE_0            ((uint32_t)0x00008000)        /*!< BLock SIZE (low) */
S
S/***************  Bit definition for USB_COUNT7_RX_1 register  ****************/
S#define  USB_COUNT7_RX_1_COUNT7_RX_1         ((uint32_t)0x03FF0000)        /*!< Reception Byte Count (high) */
S
S#define  USB_COUNT7_RX_1_NUM_BLOCK_1         ((uint32_t)0x7C000000)        /*!< NUM_BLOCK_1[4:0] bits (Number of blocks) (high) */
S#define  USB_COUNT7_RX_1_NUM_BLOCK_1_0       ((uint32_t)0x04000000)        /*!< Bit 0 */
S#define  USB_COUNT7_RX_1_NUM_BLOCK_1_1       ((uint32_t)0x08000000)        /*!< Bit 1 */
S#define  USB_COUNT7_RX_1_NUM_BLOCK_1_2       ((uint32_t)0x10000000)        /*!< Bit 2 */
S#define  USB_COUNT7_RX_1_NUM_BLOCK_1_3       ((uint32_t)0x20000000)        /*!< Bit 3 */
S#define  USB_COUNT7_RX_1_NUM_BLOCK_1_4       ((uint32_t)0x40000000)        /*!< Bit 4 */
S
S#define  USB_COUNT7_RX_1_BLSIZE_1            ((uint32_t)0x80000000)        /*!< BLock SIZE (high) */
S
S/******************************************************************************/
S/*                                                                            */
S/*                         Controller Area Network                            */
S/*                                                                            */
S/******************************************************************************/
S
S/*!< CAN control and status registers */
S/*******************  Bit definition for CAN_MCR register  ********************/
S#define  CAN_MCR_INRQ                        ((uint16_t)0x0001)            /*!< Initialization Request */
S#define  CAN_MCR_SLEEP                       ((uint16_t)0x0002)            /*!< Sleep Mode Request */
S#define  CAN_MCR_TXFP                        ((uint16_t)0x0004)            /*!< Transmit FIFO Priority */
S#define  CAN_MCR_RFLM                        ((uint16_t)0x0008)            /*!< Receive FIFO Locked Mode */
S#define  CAN_MCR_NART                        ((uint16_t)0x0010)            /*!< No Automatic Retransmission */
S#define  CAN_MCR_AWUM                        ((uint16_t)0x0020)            /*!< Automatic Wakeup Mode */
S#define  CAN_MCR_ABOM                        ((uint16_t)0x0040)            /*!< Automatic Bus-Off Management */
S#define  CAN_MCR_TTCM                        ((uint16_t)0x0080)            /*!< Time Triggered Communication Mode */
S#define  CAN_MCR_RESET                       ((uint16_t)0x8000)            /*!< CAN software master reset */
S
S/*******************  Bit definition for CAN_MSR register  ********************/
S#define  CAN_MSR_INAK                        ((uint16_t)0x0001)            /*!< Initialization Acknowledge */
S#define  CAN_MSR_SLAK                        ((uint16_t)0x0002)            /*!< Sleep Acknowledge */
S#define  CAN_MSR_ERRI                        ((uint16_t)0x0004)            /*!< Error Interrupt */
S#define  CAN_MSR_WKUI                        ((uint16_t)0x0008)            /*!< Wakeup Interrupt */
S#define  CAN_MSR_SLAKI                       ((uint16_t)0x0010)            /*!< Sleep Acknowledge Interrupt */
S#define  CAN_MSR_TXM                         ((uint16_t)0x0100)            /*!< Transmit Mode */
S#define  CAN_MSR_RXM                         ((uint16_t)0x0200)            /*!< Receive Mode */
S#define  CAN_MSR_SAMP                        ((uint16_t)0x0400)            /*!< Last Sample Point */
S#define  CAN_MSR_RX                          ((uint16_t)0x0800)            /*!< CAN Rx Signal */
S
S/*******************  Bit definition for CAN_TSR register  ********************/
S#define  CAN_TSR_RQCP0                       ((uint32_t)0x00000001)        /*!< Request Completed Mailbox0 */
S#define  CAN_TSR_TXOK0                       ((uint32_t)0x00000002)        /*!< Transmission OK of Mailbox0 */
S#define  CAN_TSR_ALST0                       ((uint32_t)0x00000004)        /*!< Arbitration Lost for Mailbox0 */
S#define  CAN_TSR_TERR0                       ((uint32_t)0x00000008)        /*!< Transmission Error of Mailbox0 */
S#define  CAN_TSR_ABRQ0                       ((uint32_t)0x00000080)        /*!< Abort Request for Mailbox0 */
S#define  CAN_TSR_RQCP1                       ((uint32_t)0x00000100)        /*!< Request Completed Mailbox1 */
S#define  CAN_TSR_TXOK1                       ((uint32_t)0x00000200)        /*!< Transmission OK of Mailbox1 */
S#define  CAN_TSR_ALST1                       ((uint32_t)0x00000400)        /*!< Arbitration Lost for Mailbox1 */
S#define  CAN_TSR_TERR1                       ((uint32_t)0x00000800)        /*!< Transmission Error of Mailbox1 */
S#define  CAN_TSR_ABRQ1                       ((uint32_t)0x00008000)        /*!< Abort Request for Mailbox 1 */
S#define  CAN_TSR_RQCP2                       ((uint32_t)0x00010000)        /*!< Request Completed Mailbox2 */
S#define  CAN_TSR_TXOK2                       ((uint32_t)0x00020000)        /*!< Transmission OK of Mailbox 2 */
S#define  CAN_TSR_ALST2                       ((uint32_t)0x00040000)        /*!< Arbitration Lost for mailbox 2 */
S#define  CAN_TSR_TERR2                       ((uint32_t)0x00080000)        /*!< Transmission Error of Mailbox 2 */
S#define  CAN_TSR_ABRQ2                       ((uint32_t)0x00800000)        /*!< Abort Request for Mailbox 2 */
S#define  CAN_TSR_CODE                        ((uint32_t)0x03000000)        /*!< Mailbox Code */
S
S#define  CAN_TSR_TME                         ((uint32_t)0x1C000000)        /*!< TME[2:0] bits */
S#define  CAN_TSR_TME0                        ((uint32_t)0x04000000)        /*!< Transmit Mailbox 0 Empty */
S#define  CAN_TSR_TME1                        ((uint32_t)0x08000000)        /*!< Transmit Mailbox 1 Empty */
S#define  CAN_TSR_TME2                        ((uint32_t)0x10000000)        /*!< Transmit Mailbox 2 Empty */
S
S#define  CAN_TSR_LOW                         ((uint32_t)0xE0000000)        /*!< LOW[2:0] bits */
S#define  CAN_TSR_LOW0                        ((uint32_t)0x20000000)        /*!< Lowest Priority Flag for Mailbox 0 */
S#define  CAN_TSR_LOW1                        ((uint32_t)0x40000000)        /*!< Lowest Priority Flag for Mailbox 1 */
S#define  CAN_TSR_LOW2                        ((uint32_t)0x80000000)        /*!< Lowest Priority Flag for Mailbox 2 */
S
S/*******************  Bit definition for CAN_RF0R register  *******************/
S#define  CAN_RF0R_FMP0                       ((uint8_t)0x03)               /*!< FIFO 0 Message Pending */
S#define  CAN_RF0R_FULL0                      ((uint8_t)0x08)               /*!< FIFO 0 Full */
S#define  CAN_RF0R_FOVR0                      ((uint8_t)0x10)               /*!< FIFO 0 Overrun */
S#define  CAN_RF0R_RFOM0                      ((uint8_t)0x20)               /*!< Release FIFO 0 Output Mailbox */
S
S/*******************  Bit definition for CAN_RF1R register  *******************/
S#define  CAN_RF1R_FMP1                       ((uint8_t)0x03)               /*!< FIFO 1 Message Pending */
S#define  CAN_RF1R_FULL1                      ((uint8_t)0x08)               /*!< FIFO 1 Full */
S#define  CAN_RF1R_FOVR1                      ((uint8_t)0x10)               /*!< FIFO 1 Overrun */
S#define  CAN_RF1R_RFOM1                      ((uint8_t)0x20)               /*!< Release FIFO 1 Output Mailbox */
S
S/********************  Bit definition for CAN_IER register  *******************/
S#define  CAN_IER_TMEIE                       ((uint32_t)0x00000001)        /*!< Transmit Mailbox Empty Interrupt Enable */
S#define  CAN_IER_FMPIE0                      ((uint32_t)0x00000002)        /*!< FIFO Message Pending Interrupt Enable */
S#define  CAN_IER_FFIE0                       ((uint32_t)0x00000004)        /*!< FIFO Full Interrupt Enable */
S#define  CAN_IER_FOVIE0                      ((uint32_t)0x00000008)        /*!< FIFO Overrun Interrupt Enable */
S#define  CAN_IER_FMPIE1                      ((uint32_t)0x00000010)        /*!< FIFO Message Pending Interrupt Enable */
S#define  CAN_IER_FFIE1                       ((uint32_t)0x00000020)        /*!< FIFO Full Interrupt Enable */
S#define  CAN_IER_FOVIE1                      ((uint32_t)0x00000040)        /*!< FIFO Overrun Interrupt Enable */
S#define  CAN_IER_EWGIE                       ((uint32_t)0x00000100)        /*!< Error Warning Interrupt Enable */
S#define  CAN_IER_EPVIE                       ((uint32_t)0x00000200)        /*!< Error Passive Interrupt Enable */
S#define  CAN_IER_BOFIE                       ((uint32_t)0x00000400)        /*!< Bus-Off Interrupt Enable */
S#define  CAN_IER_LECIE                       ((uint32_t)0x00000800)        /*!< Last Error Code Interrupt Enable */
S#define  CAN_IER_ERRIE                       ((uint32_t)0x00008000)        /*!< Error Interrupt Enable */
S#define  CAN_IER_WKUIE                       ((uint32_t)0x00010000)        /*!< Wakeup Interrupt Enable */
S#define  CAN_IER_SLKIE                       ((uint32_t)0x00020000)        /*!< Sleep Interrupt Enable */
S
S/********************  Bit definition for CAN_ESR register  *******************/
S#define  CAN_ESR_EWGF                        ((uint32_t)0x00000001)        /*!< Error Warning Flag */
S#define  CAN_ESR_EPVF                        ((uint32_t)0x00000002)        /*!< Error Passive Flag */
S#define  CAN_ESR_BOFF                        ((uint32_t)0x00000004)        /*!< Bus-Off Flag */
S
S#define  CAN_ESR_LEC                         ((uint32_t)0x00000070)        /*!< LEC[2:0] bits (Last Error Code) */
S#define  CAN_ESR_LEC_0                       ((uint32_t)0x00000010)        /*!< Bit 0 */
S#define  CAN_ESR_LEC_1                       ((uint32_t)0x00000020)        /*!< Bit 1 */
S#define  CAN_ESR_LEC_2                       ((uint32_t)0x00000040)        /*!< Bit 2 */
S
S#define  CAN_ESR_TEC                         ((uint32_t)0x00FF0000)        /*!< Least significant byte of the 9-bit Transmit Error Counter */
S#define  CAN_ESR_REC                         ((uint32_t)0xFF000000)        /*!< Receive Error Counter */
S
S/*******************  Bit definition for CAN_BTR register  ********************/
S#define  CAN_BTR_BRP                         ((uint32_t)0x000003FF)        /*!< Baud Rate Prescaler */
S#define  CAN_BTR_TS1                         ((uint32_t)0x000F0000)        /*!< Time Segment 1 */
S#define  CAN_BTR_TS2                         ((uint32_t)0x00700000)        /*!< Time Segment 2 */
S#define  CAN_BTR_SJW                         ((uint32_t)0x03000000)        /*!< Resynchronization Jump Width */
S#define  CAN_BTR_LBKM                        ((uint32_t)0x40000000)        /*!< Loop Back Mode (Debug) */
S#define  CAN_BTR_SILM                        ((uint32_t)0x80000000)        /*!< Silent Mode */
S
S/*!< Mailbox registers */
S/******************  Bit definition for CAN_TI0R register  ********************/
S#define  CAN_TI0R_TXRQ                       ((uint32_t)0x00000001)        /*!< Transmit Mailbox Request */
S#define  CAN_TI0R_RTR                        ((uint32_t)0x00000002)        /*!< Remote Transmission Request */
S#define  CAN_TI0R_IDE                        ((uint32_t)0x00000004)        /*!< Identifier Extension */
S#define  CAN_TI0R_EXID                       ((uint32_t)0x001FFFF8)        /*!< Extended Identifier */
S#define  CAN_TI0R_STID                       ((uint32_t)0xFFE00000)        /*!< Standard Identifier or Extended Identifier */
S
S/******************  Bit definition for CAN_TDT0R register  *******************/
S#define  CAN_TDT0R_DLC                       ((uint32_t)0x0000000F)        /*!< Data Length Code */
S#define  CAN_TDT0R_TGT                       ((uint32_t)0x00000100)        /*!< Transmit Global Time */
S#define  CAN_TDT0R_TIME                      ((uint32_t)0xFFFF0000)        /*!< Message Time Stamp */
S
S/******************  Bit definition for CAN_TDL0R register  *******************/
S#define  CAN_TDL0R_DATA0                     ((uint32_t)0x000000FF)        /*!< Data byte 0 */
S#define  CAN_TDL0R_DATA1                     ((uint32_t)0x0000FF00)        /*!< Data byte 1 */
S#define  CAN_TDL0R_DATA2                     ((uint32_t)0x00FF0000)        /*!< Data byte 2 */
S#define  CAN_TDL0R_DATA3                     ((uint32_t)0xFF000000)        /*!< Data byte 3 */
S
S/******************  Bit definition for CAN_TDH0R register  *******************/
S#define  CAN_TDH0R_DATA4                     ((uint32_t)0x000000FF)        /*!< Data byte 4 */
S#define  CAN_TDH0R_DATA5                     ((uint32_t)0x0000FF00)        /*!< Data byte 5 */
S#define  CAN_TDH0R_DATA6                     ((uint32_t)0x00FF0000)        /*!< Data byte 6 */
S#define  CAN_TDH0R_DATA7                     ((uint32_t)0xFF000000)        /*!< Data byte 7 */
S
S/*******************  Bit definition for CAN_TI1R register  *******************/
S#define  CAN_TI1R_TXRQ                       ((uint32_t)0x00000001)        /*!< Transmit Mailbox Request */
S#define  CAN_TI1R_RTR                        ((uint32_t)0x00000002)        /*!< Remote Transmission Request */
S#define  CAN_TI1R_IDE                        ((uint32_t)0x00000004)        /*!< Identifier Extension */
S#define  CAN_TI1R_EXID                       ((uint32_t)0x001FFFF8)        /*!< Extended Identifier */
S#define  CAN_TI1R_STID                       ((uint32_t)0xFFE00000)        /*!< Standard Identifier or Extended Identifier */
S
S/*******************  Bit definition for CAN_TDT1R register  ******************/
S#define  CAN_TDT1R_DLC                       ((uint32_t)0x0000000F)        /*!< Data Length Code */
S#define  CAN_TDT1R_TGT                       ((uint32_t)0x00000100)        /*!< Transmit Global Time */
S#define  CAN_TDT1R_TIME                      ((uint32_t)0xFFFF0000)        /*!< Message Time Stamp */
S
S/*******************  Bit definition for CAN_TDL1R register  ******************/
S#define  CAN_TDL1R_DATA0                     ((uint32_t)0x000000FF)        /*!< Data byte 0 */
S#define  CAN_TDL1R_DATA1                     ((uint32_t)0x0000FF00)        /*!< Data byte 1 */
S#define  CAN_TDL1R_DATA2                     ((uint32_t)0x00FF0000)        /*!< Data byte 2 */
S#define  CAN_TDL1R_DATA3                     ((uint32_t)0xFF000000)        /*!< Data byte 3 */
S
S/*******************  Bit definition for CAN_TDH1R register  ******************/
S#define  CAN_TDH1R_DATA4                     ((uint32_t)0x000000FF)        /*!< Data byte 4 */
S#define  CAN_TDH1R_DATA5                     ((uint32_t)0x0000FF00)        /*!< Data byte 5 */
S#define  CAN_TDH1R_DATA6                     ((uint32_t)0x00FF0000)        /*!< Data byte 6 */
S#define  CAN_TDH1R_DATA7                     ((uint32_t)0xFF000000)        /*!< Data byte 7 */
S
S/*******************  Bit definition for CAN_TI2R register  *******************/
S#define  CAN_TI2R_TXRQ                       ((uint32_t)0x00000001)        /*!< Transmit Mailbox Request */
S#define  CAN_TI2R_RTR                        ((uint32_t)0x00000002)        /*!< Remote Transmission Request */
S#define  CAN_TI2R_IDE                        ((uint32_t)0x00000004)        /*!< Identifier Extension */
S#define  CAN_TI2R_EXID                       ((uint32_t)0x001FFFF8)        /*!< Extended identifier */
S#define  CAN_TI2R_STID                       ((uint32_t)0xFFE00000)        /*!< Standard Identifier or Extended Identifier */
S
S/*******************  Bit definition for CAN_TDT2R register  ******************/  
S#define  CAN_TDT2R_DLC                       ((uint32_t)0x0000000F)        /*!< Data Length Code */
S#define  CAN_TDT2R_TGT                       ((uint32_t)0x00000100)        /*!< Transmit Global Time */
S#define  CAN_TDT2R_TIME                      ((uint32_t)0xFFFF0000)        /*!< Message Time Stamp */
S
S/*******************  Bit definition for CAN_TDL2R register  ******************/
S#define  CAN_TDL2R_DATA0                     ((uint32_t)0x000000FF)        /*!< Data byte 0 */
S#define  CAN_TDL2R_DATA1                     ((uint32_t)0x0000FF00)        /*!< Data byte 1 */
S#define  CAN_TDL2R_DATA2                     ((uint32_t)0x00FF0000)        /*!< Data byte 2 */
S#define  CAN_TDL2R_DATA3                     ((uint32_t)0xFF000000)        /*!< Data byte 3 */
S
S/*******************  Bit definition for CAN_TDH2R register  ******************/
S#define  CAN_TDH2R_DATA4                     ((uint32_t)0x000000FF)        /*!< Data byte 4 */
S#define  CAN_TDH2R_DATA5                     ((uint32_t)0x0000FF00)        /*!< Data byte 5 */
S#define  CAN_TDH2R_DATA6                     ((uint32_t)0x00FF0000)        /*!< Data byte 6 */
S#define  CAN_TDH2R_DATA7                     ((uint32_t)0xFF000000)        /*!< Data byte 7 */
S
S/*******************  Bit definition for CAN_RI0R register  *******************/
S#define  CAN_RI0R_RTR                        ((uint32_t)0x00000002)        /*!< Remote Transmission Request */
S#define  CAN_RI0R_IDE                        ((uint32_t)0x00000004)        /*!< Identifier Extension */
S#define  CAN_RI0R_EXID                       ((uint32_t)0x001FFFF8)        /*!< Extended Identifier */
S#define  CAN_RI0R_STID                       ((uint32_t)0xFFE00000)        /*!< Standard Identifier or Extended Identifier */
S
S/*******************  Bit definition for CAN_RDT0R register  ******************/
S#define  CAN_RDT0R_DLC                       ((uint32_t)0x0000000F)        /*!< Data Length Code */
S#define  CAN_RDT0R_FMI                       ((uint32_t)0x0000FF00)        /*!< Filter Match Index */
S#define  CAN_RDT0R_TIME                      ((uint32_t)0xFFFF0000)        /*!< Message Time Stamp */
S
S/*******************  Bit definition for CAN_RDL0R register  ******************/
S#define  CAN_RDL0R_DATA0                     ((uint32_t)0x000000FF)        /*!< Data byte 0 */
S#define  CAN_RDL0R_DATA1                     ((uint32_t)0x0000FF00)        /*!< Data byte 1 */
S#define  CAN_RDL0R_DATA2                     ((uint32_t)0x00FF0000)        /*!< Data byte 2 */
S#define  CAN_RDL0R_DATA3                     ((uint32_t)0xFF000000)        /*!< Data byte 3 */
S
S/*******************  Bit definition for CAN_RDH0R register  ******************/
S#define  CAN_RDH0R_DATA4                     ((uint32_t)0x000000FF)        /*!< Data byte 4 */
S#define  CAN_RDH0R_DATA5                     ((uint32_t)0x0000FF00)        /*!< Data byte 5 */
S#define  CAN_RDH0R_DATA6                     ((uint32_t)0x00FF0000)        /*!< Data byte 6 */
S#define  CAN_RDH0R_DATA7                     ((uint32_t)0xFF000000)        /*!< Data byte 7 */
S
S/*******************  Bit definition for CAN_RI1R register  *******************/
S#define  CAN_RI1R_RTR                        ((uint32_t)0x00000002)        /*!< Remote Transmission Request */
S#define  CAN_RI1R_IDE                        ((uint32_t)0x00000004)        /*!< Identifier Extension */
S#define  CAN_RI1R_EXID                       ((uint32_t)0x001FFFF8)        /*!< Extended identifier */
S#define  CAN_RI1R_STID                       ((uint32_t)0xFFE00000)        /*!< Standard Identifier or Extended Identifier */
S
S/*******************  Bit definition for CAN_RDT1R register  ******************/
S#define  CAN_RDT1R_DLC                       ((uint32_t)0x0000000F)        /*!< Data Length Code */
S#define  CAN_RDT1R_FMI                       ((uint32_t)0x0000FF00)        /*!< Filter Match Index */
S#define  CAN_RDT1R_TIME                      ((uint32_t)0xFFFF0000)        /*!< Message Time Stamp */
S
S/*******************  Bit definition for CAN_RDL1R register  ******************/
S#define  CAN_RDL1R_DATA0                     ((uint32_t)0x000000FF)        /*!< Data byte 0 */
S#define  CAN_RDL1R_DATA1                     ((uint32_t)0x0000FF00)        /*!< Data byte 1 */
S#define  CAN_RDL1R_DATA2                     ((uint32_t)0x00FF0000)        /*!< Data byte 2 */
S#define  CAN_RDL1R_DATA3                     ((uint32_t)0xFF000000)        /*!< Data byte 3 */
S
S/*******************  Bit definition for CAN_RDH1R register  ******************/
S#define  CAN_RDH1R_DATA4                     ((uint32_t)0x000000FF)        /*!< Data byte 4 */
S#define  CAN_RDH1R_DATA5                     ((uint32_t)0x0000FF00)        /*!< Data byte 5 */
S#define  CAN_RDH1R_DATA6                     ((uint32_t)0x00FF0000)        /*!< Data byte 6 */
S#define  CAN_RDH1R_DATA7                     ((uint32_t)0xFF000000)        /*!< Data byte 7 */
S
S/*!< CAN filter registers */
S/*******************  Bit definition for CAN_FMR register  ********************/
S#define  CAN_FMR_FINIT                       ((uint8_t)0x01)               /*!< Filter Init Mode */
S
S/*******************  Bit definition for CAN_FM1R register  *******************/
S#define  CAN_FM1R_FBM                        ((uint16_t)0x3FFF)            /*!< Filter Mode */
S#define  CAN_FM1R_FBM0                       ((uint16_t)0x0001)            /*!< Filter Init Mode bit 0 */
S#define  CAN_FM1R_FBM1                       ((uint16_t)0x0002)            /*!< Filter Init Mode bit 1 */
S#define  CAN_FM1R_FBM2                       ((uint16_t)0x0004)            /*!< Filter Init Mode bit 2 */
S#define  CAN_FM1R_FBM3                       ((uint16_t)0x0008)            /*!< Filter Init Mode bit 3 */
S#define  CAN_FM1R_FBM4                       ((uint16_t)0x0010)            /*!< Filter Init Mode bit 4 */
S#define  CAN_FM1R_FBM5                       ((uint16_t)0x0020)            /*!< Filter Init Mode bit 5 */
S#define  CAN_FM1R_FBM6                       ((uint16_t)0x0040)            /*!< Filter Init Mode bit 6 */
S#define  CAN_FM1R_FBM7                       ((uint16_t)0x0080)            /*!< Filter Init Mode bit 7 */
S#define  CAN_FM1R_FBM8                       ((uint16_t)0x0100)            /*!< Filter Init Mode bit 8 */
S#define  CAN_FM1R_FBM9                       ((uint16_t)0x0200)            /*!< Filter Init Mode bit 9 */
S#define  CAN_FM1R_FBM10                      ((uint16_t)0x0400)            /*!< Filter Init Mode bit 10 */
S#define  CAN_FM1R_FBM11                      ((uint16_t)0x0800)            /*!< Filter Init Mode bit 11 */
S#define  CAN_FM1R_FBM12                      ((uint16_t)0x1000)            /*!< Filter Init Mode bit 12 */
S#define  CAN_FM1R_FBM13                      ((uint16_t)0x2000)            /*!< Filter Init Mode bit 13 */
S
S/*******************  Bit definition for CAN_FS1R register  *******************/
S#define  CAN_FS1R_FSC                        ((uint16_t)0x3FFF)            /*!< Filter Scale Configuration */
S#define  CAN_FS1R_FSC0                       ((uint16_t)0x0001)            /*!< Filter Scale Configuration bit 0 */
S#define  CAN_FS1R_FSC1                       ((uint16_t)0x0002)            /*!< Filter Scale Configuration bit 1 */
S#define  CAN_FS1R_FSC2                       ((uint16_t)0x0004)            /*!< Filter Scale Configuration bit 2 */
S#define  CAN_FS1R_FSC3                       ((uint16_t)0x0008)            /*!< Filter Scale Configuration bit 3 */
S#define  CAN_FS1R_FSC4                       ((uint16_t)0x0010)            /*!< Filter Scale Configuration bit 4 */
S#define  CAN_FS1R_FSC5                       ((uint16_t)0x0020)            /*!< Filter Scale Configuration bit 5 */
S#define  CAN_FS1R_FSC6                       ((uint16_t)0x0040)            /*!< Filter Scale Configuration bit 6 */
S#define  CAN_FS1R_FSC7                       ((uint16_t)0x0080)            /*!< Filter Scale Configuration bit 7 */
S#define  CAN_FS1R_FSC8                       ((uint16_t)0x0100)            /*!< Filter Scale Configuration bit 8 */
S#define  CAN_FS1R_FSC9                       ((uint16_t)0x0200)            /*!< Filter Scale Configuration bit 9 */
S#define  CAN_FS1R_FSC10                      ((uint16_t)0x0400)            /*!< Filter Scale Configuration bit 10 */
S#define  CAN_FS1R_FSC11                      ((uint16_t)0x0800)            /*!< Filter Scale Configuration bit 11 */
S#define  CAN_FS1R_FSC12                      ((uint16_t)0x1000)            /*!< Filter Scale Configuration bit 12 */
S#define  CAN_FS1R_FSC13                      ((uint16_t)0x2000)            /*!< Filter Scale Configuration bit 13 */
S
S/******************  Bit definition for CAN_FFA1R register  *******************/
S#define  CAN_FFA1R_FFA                       ((uint16_t)0x3FFF)            /*!< Filter FIFO Assignment */
S#define  CAN_FFA1R_FFA0                      ((uint16_t)0x0001)            /*!< Filter FIFO Assignment for Filter 0 */
S#define  CAN_FFA1R_FFA1                      ((uint16_t)0x0002)            /*!< Filter FIFO Assignment for Filter 1 */
S#define  CAN_FFA1R_FFA2                      ((uint16_t)0x0004)            /*!< Filter FIFO Assignment for Filter 2 */
S#define  CAN_FFA1R_FFA3                      ((uint16_t)0x0008)            /*!< Filter FIFO Assignment for Filter 3 */
S#define  CAN_FFA1R_FFA4                      ((uint16_t)0x0010)            /*!< Filter FIFO Assignment for Filter 4 */
S#define  CAN_FFA1R_FFA5                      ((uint16_t)0x0020)            /*!< Filter FIFO Assignment for Filter 5 */
S#define  CAN_FFA1R_FFA6                      ((uint16_t)0x0040)            /*!< Filter FIFO Assignment for Filter 6 */
S#define  CAN_FFA1R_FFA7                      ((uint16_t)0x0080)            /*!< Filter FIFO Assignment for Filter 7 */
S#define  CAN_FFA1R_FFA8                      ((uint16_t)0x0100)            /*!< Filter FIFO Assignment for Filter 8 */
S#define  CAN_FFA1R_FFA9                      ((uint16_t)0x0200)            /*!< Filter FIFO Assignment for Filter 9 */
S#define  CAN_FFA1R_FFA10                     ((uint16_t)0x0400)            /*!< Filter FIFO Assignment for Filter 10 */
S#define  CAN_FFA1R_FFA11                     ((uint16_t)0x0800)            /*!< Filter FIFO Assignment for Filter 11 */
S#define  CAN_FFA1R_FFA12                     ((uint16_t)0x1000)            /*!< Filter FIFO Assignment for Filter 12 */
S#define  CAN_FFA1R_FFA13                     ((uint16_t)0x2000)            /*!< Filter FIFO Assignment for Filter 13 */
S
S/*******************  Bit definition for CAN_FA1R register  *******************/
S#define  CAN_FA1R_FACT                       ((uint16_t)0x3FFF)            /*!< Filter Active */
S#define  CAN_FA1R_FACT0                      ((uint16_t)0x0001)            /*!< Filter 0 Active */
S#define  CAN_FA1R_FACT1                      ((uint16_t)0x0002)            /*!< Filter 1 Active */
S#define  CAN_FA1R_FACT2                      ((uint16_t)0x0004)            /*!< Filter 2 Active */
S#define  CAN_FA1R_FACT3                      ((uint16_t)0x0008)            /*!< Filter 3 Active */
S#define  CAN_FA1R_FACT4                      ((uint16_t)0x0010)            /*!< Filter 4 Active */
S#define  CAN_FA1R_FACT5                      ((uint16_t)0x0020)            /*!< Filter 5 Active */
S#define  CAN_FA1R_FACT6                      ((uint16_t)0x0040)            /*!< Filter 6 Active */
S#define  CAN_FA1R_FACT7                      ((uint16_t)0x0080)            /*!< Filter 7 Active */
S#define  CAN_FA1R_FACT8                      ((uint16_t)0x0100)            /*!< Filter 8 Active */
S#define  CAN_FA1R_FACT9                      ((uint16_t)0x0200)            /*!< Filter 9 Active */
S#define  CAN_FA1R_FACT10                     ((uint16_t)0x0400)            /*!< Filter 10 Active */
S#define  CAN_FA1R_FACT11                     ((uint16_t)0x0800)            /*!< Filter 11 Active */
S#define  CAN_FA1R_FACT12                     ((uint16_t)0x1000)            /*!< Filter 12 Active */
S#define  CAN_FA1R_FACT13                     ((uint16_t)0x2000)            /*!< Filter 13 Active */
S
S/*******************  Bit definition for CAN_F0R1 register  *******************/
S#define  CAN_F0R1_FB0                        ((uint32_t)0x00000001)        /*!< Filter bit 0 */
S#define  CAN_F0R1_FB1                        ((uint32_t)0x00000002)        /*!< Filter bit 1 */
S#define  CAN_F0R1_FB2                        ((uint32_t)0x00000004)        /*!< Filter bit 2 */
S#define  CAN_F0R1_FB3                        ((uint32_t)0x00000008)        /*!< Filter bit 3 */
S#define  CAN_F0R1_FB4                        ((uint32_t)0x00000010)        /*!< Filter bit 4 */
S#define  CAN_F0R1_FB5                        ((uint32_t)0x00000020)        /*!< Filter bit 5 */
S#define  CAN_F0R1_FB6                        ((uint32_t)0x00000040)        /*!< Filter bit 6 */
S#define  CAN_F0R1_FB7                        ((uint32_t)0x00000080)        /*!< Filter bit 7 */
S#define  CAN_F0R1_FB8                        ((uint32_t)0x00000100)        /*!< Filter bit 8 */
S#define  CAN_F0R1_FB9                        ((uint32_t)0x00000200)        /*!< Filter bit 9 */
S#define  CAN_F0R1_FB10                       ((uint32_t)0x00000400)        /*!< Filter bit 10 */
S#define  CAN_F0R1_FB11                       ((uint32_t)0x00000800)        /*!< Filter bit 11 */
S#define  CAN_F0R1_FB12                       ((uint32_t)0x00001000)        /*!< Filter bit 12 */
S#define  CAN_F0R1_FB13                       ((uint32_t)0x00002000)        /*!< Filter bit 13 */
S#define  CAN_F0R1_FB14                       ((uint32_t)0x00004000)        /*!< Filter bit 14 */
S#define  CAN_F0R1_FB15                       ((uint32_t)0x00008000)        /*!< Filter bit 15 */
S#define  CAN_F0R1_FB16                       ((uint32_t)0x00010000)        /*!< Filter bit 16 */
S#define  CAN_F0R1_FB17                       ((uint32_t)0x00020000)        /*!< Filter bit 17 */
S#define  CAN_F0R1_FB18                       ((uint32_t)0x00040000)        /*!< Filter bit 18 */
S#define  CAN_F0R1_FB19                       ((uint32_t)0x00080000)        /*!< Filter bit 19 */
S#define  CAN_F0R1_FB20                       ((uint32_t)0x00100000)        /*!< Filter bit 20 */
S#define  CAN_F0R1_FB21                       ((uint32_t)0x00200000)        /*!< Filter bit 21 */
S#define  CAN_F0R1_FB22                       ((uint32_t)0x00400000)        /*!< Filter bit 22 */
S#define  CAN_F0R1_FB23                       ((uint32_t)0x00800000)        /*!< Filter bit 23 */
S#define  CAN_F0R1_FB24                       ((uint32_t)0x01000000)        /*!< Filter bit 24 */
S#define  CAN_F0R1_FB25                       ((uint32_t)0x02000000)        /*!< Filter bit 25 */
S#define  CAN_F0R1_FB26                       ((uint32_t)0x04000000)        /*!< Filter bit 26 */
S#define  CAN_F0R1_FB27                       ((uint32_t)0x08000000)        /*!< Filter bit 27 */
S#define  CAN_F0R1_FB28                       ((uint32_t)0x10000000)        /*!< Filter bit 28 */
S#define  CAN_F0R1_FB29                       ((uint32_t)0x20000000)        /*!< Filter bit 29 */
S#define  CAN_F0R1_FB30                       ((uint32_t)0x40000000)        /*!< Filter bit 30 */
S#define  CAN_F0R1_FB31                       ((uint32_t)0x80000000)        /*!< Filter bit 31 */
S
S/*******************  Bit definition for CAN_F1R1 register  *******************/
S#define  CAN_F1R1_FB0                        ((uint32_t)0x00000001)        /*!< Filter bit 0 */
S#define  CAN_F1R1_FB1                        ((uint32_t)0x00000002)        /*!< Filter bit 1 */
S#define  CAN_F1R1_FB2                        ((uint32_t)0x00000004)        /*!< Filter bit 2 */
S#define  CAN_F1R1_FB3                        ((uint32_t)0x00000008)        /*!< Filter bit 3 */
S#define  CAN_F1R1_FB4                        ((uint32_t)0x00000010)        /*!< Filter bit 4 */
S#define  CAN_F1R1_FB5                        ((uint32_t)0x00000020)        /*!< Filter bit 5 */
S#define  CAN_F1R1_FB6                        ((uint32_t)0x00000040)        /*!< Filter bit 6 */
S#define  CAN_F1R1_FB7                        ((uint32_t)0x00000080)        /*!< Filter bit 7 */
S#define  CAN_F1R1_FB8                        ((uint32_t)0x00000100)        /*!< Filter bit 8 */
S#define  CAN_F1R1_FB9                        ((uint32_t)0x00000200)        /*!< Filter bit 9 */
S#define  CAN_F1R1_FB10                       ((uint32_t)0x00000400)        /*!< Filter bit 10 */
S#define  CAN_F1R1_FB11                       ((uint32_t)0x00000800)        /*!< Filter bit 11 */
S#define  CAN_F1R1_FB12                       ((uint32_t)0x00001000)        /*!< Filter bit 12 */
S#define  CAN_F1R1_FB13                       ((uint32_t)0x00002000)        /*!< Filter bit 13 */
S#define  CAN_F1R1_FB14                       ((uint32_t)0x00004000)        /*!< Filter bit 14 */
S#define  CAN_F1R1_FB15                       ((uint32_t)0x00008000)        /*!< Filter bit 15 */
S#define  CAN_F1R1_FB16                       ((uint32_t)0x00010000)        /*!< Filter bit 16 */
S#define  CAN_F1R1_FB17                       ((uint32_t)0x00020000)        /*!< Filter bit 17 */
S#define  CAN_F1R1_FB18                       ((uint32_t)0x00040000)        /*!< Filter bit 18 */
S#define  CAN_F1R1_FB19                       ((uint32_t)0x00080000)        /*!< Filter bit 19 */
S#define  CAN_F1R1_FB20                       ((uint32_t)0x00100000)        /*!< Filter bit 20 */
S#define  CAN_F1R1_FB21                       ((uint32_t)0x00200000)        /*!< Filter bit 21 */
S#define  CAN_F1R1_FB22                       ((uint32_t)0x00400000)        /*!< Filter bit 22 */
S#define  CAN_F1R1_FB23                       ((uint32_t)0x00800000)        /*!< Filter bit 23 */
S#define  CAN_F1R1_FB24                       ((uint32_t)0x01000000)        /*!< Filter bit 24 */
S#define  CAN_F1R1_FB25                       ((uint32_t)0x02000000)        /*!< Filter bit 25 */
S#define  CAN_F1R1_FB26                       ((uint32_t)0x04000000)        /*!< Filter bit 26 */
S#define  CAN_F1R1_FB27                       ((uint32_t)0x08000000)        /*!< Filter bit 27 */
S#define  CAN_F1R1_FB28                       ((uint32_t)0x10000000)        /*!< Filter bit 28 */
S#define  CAN_F1R1_FB29                       ((uint32_t)0x20000000)        /*!< Filter bit 29 */
S#define  CAN_F1R1_FB30                       ((uint32_t)0x40000000)        /*!< Filter bit 30 */
S#define  CAN_F1R1_FB31                       ((uint32_t)0x80000000)        /*!< Filter bit 31 */
S
S/*******************  Bit definition for CAN_F2R1 register  *******************/
S#define  CAN_F2R1_FB0                        ((uint32_t)0x00000001)        /*!< Filter bit 0 */
S#define  CAN_F2R1_FB1                        ((uint32_t)0x00000002)        /*!< Filter bit 1 */
S#define  CAN_F2R1_FB2                        ((uint32_t)0x00000004)        /*!< Filter bit 2 */
S#define  CAN_F2R1_FB3                        ((uint32_t)0x00000008)        /*!< Filter bit 3 */
S#define  CAN_F2R1_FB4                        ((uint32_t)0x00000010)        /*!< Filter bit 4 */
S#define  CAN_F2R1_FB5                        ((uint32_t)0x00000020)        /*!< Filter bit 5 */
S#define  CAN_F2R1_FB6                        ((uint32_t)0x00000040)        /*!< Filter bit 6 */
S#define  CAN_F2R1_FB7                        ((uint32_t)0x00000080)        /*!< Filter bit 7 */
S#define  CAN_F2R1_FB8                        ((uint32_t)0x00000100)        /*!< Filter bit 8 */
S#define  CAN_F2R1_FB9                        ((uint32_t)0x00000200)        /*!< Filter bit 9 */
S#define  CAN_F2R1_FB10                       ((uint32_t)0x00000400)        /*!< Filter bit 10 */
S#define  CAN_F2R1_FB11                       ((uint32_t)0x00000800)        /*!< Filter bit 11 */
S#define  CAN_F2R1_FB12                       ((uint32_t)0x00001000)        /*!< Filter bit 12 */
S#define  CAN_F2R1_FB13                       ((uint32_t)0x00002000)        /*!< Filter bit 13 */
S#define  CAN_F2R1_FB14                       ((uint32_t)0x00004000)        /*!< Filter bit 14 */
S#define  CAN_F2R1_FB15                       ((uint32_t)0x00008000)        /*!< Filter bit 15 */
S#define  CAN_F2R1_FB16                       ((uint32_t)0x00010000)        /*!< Filter bit 16 */
S#define  CAN_F2R1_FB17                       ((uint32_t)0x00020000)        /*!< Filter bit 17 */
S#define  CAN_F2R1_FB18                       ((uint32_t)0x00040000)        /*!< Filter bit 18 */
S#define  CAN_F2R1_FB19                       ((uint32_t)0x00080000)        /*!< Filter bit 19 */
S#define  CAN_F2R1_FB20                       ((uint32_t)0x00100000)        /*!< Filter bit 20 */
S#define  CAN_F2R1_FB21                       ((uint32_t)0x00200000)        /*!< Filter bit 21 */
S#define  CAN_F2R1_FB22                       ((uint32_t)0x00400000)        /*!< Filter bit 22 */
S#define  CAN_F2R1_FB23                       ((uint32_t)0x00800000)        /*!< Filter bit 23 */
S#define  CAN_F2R1_FB24                       ((uint32_t)0x01000000)        /*!< Filter bit 24 */
S#define  CAN_F2R1_FB25                       ((uint32_t)0x02000000)        /*!< Filter bit 25 */
S#define  CAN_F2R1_FB26                       ((uint32_t)0x04000000)        /*!< Filter bit 26 */
S#define  CAN_F2R1_FB27                       ((uint32_t)0x08000000)        /*!< Filter bit 27 */
S#define  CAN_F2R1_FB28                       ((uint32_t)0x10000000)        /*!< Filter bit 28 */
S#define  CAN_F2R1_FB29                       ((uint32_t)0x20000000)        /*!< Filter bit 29 */
S#define  CAN_F2R1_FB30                       ((uint32_t)0x40000000)        /*!< Filter bit 30 */
S#define  CAN_F2R1_FB31                       ((uint32_t)0x80000000)        /*!< Filter bit 31 */
S
S/*******************  Bit definition for CAN_F3R1 register  *******************/
S#define  CAN_F3R1_FB0                        ((uint32_t)0x00000001)        /*!< Filter bit 0 */
S#define  CAN_F3R1_FB1                        ((uint32_t)0x00000002)        /*!< Filter bit 1 */
S#define  CAN_F3R1_FB2                        ((uint32_t)0x00000004)        /*!< Filter bit 2 */
S#define  CAN_F3R1_FB3                        ((uint32_t)0x00000008)        /*!< Filter bit 3 */
S#define  CAN_F3R1_FB4                        ((uint32_t)0x00000010)        /*!< Filter bit 4 */
S#define  CAN_F3R1_FB5                        ((uint32_t)0x00000020)        /*!< Filter bit 5 */
S#define  CAN_F3R1_FB6                        ((uint32_t)0x00000040)        /*!< Filter bit 6 */
S#define  CAN_F3R1_FB7                        ((uint32_t)0x00000080)        /*!< Filter bit 7 */
S#define  CAN_F3R1_FB8                        ((uint32_t)0x00000100)        /*!< Filter bit 8 */
S#define  CAN_F3R1_FB9                        ((uint32_t)0x00000200)        /*!< Filter bit 9 */
S#define  CAN_F3R1_FB10                       ((uint32_t)0x00000400)        /*!< Filter bit 10 */
S#define  CAN_F3R1_FB11                       ((uint32_t)0x00000800)        /*!< Filter bit 11 */
S#define  CAN_F3R1_FB12                       ((uint32_t)0x00001000)        /*!< Filter bit 12 */
S#define  CAN_F3R1_FB13                       ((uint32_t)0x00002000)        /*!< Filter bit 13 */
S#define  CAN_F3R1_FB14                       ((uint32_t)0x00004000)        /*!< Filter bit 14 */
S#define  CAN_F3R1_FB15                       ((uint32_t)0x00008000)        /*!< Filter bit 15 */
S#define  CAN_F3R1_FB16                       ((uint32_t)0x00010000)        /*!< Filter bit 16 */
S#define  CAN_F3R1_FB17                       ((uint32_t)0x00020000)        /*!< Filter bit 17 */
S#define  CAN_F3R1_FB18                       ((uint32_t)0x00040000)        /*!< Filter bit 18 */
S#define  CAN_F3R1_FB19                       ((uint32_t)0x00080000)        /*!< Filter bit 19 */
S#define  CAN_F3R1_FB20                       ((uint32_t)0x00100000)        /*!< Filter bit 20 */
S#define  CAN_F3R1_FB21                       ((uint32_t)0x00200000)        /*!< Filter bit 21 */
S#define  CAN_F3R1_FB22                       ((uint32_t)0x00400000)        /*!< Filter bit 22 */
S#define  CAN_F3R1_FB23                       ((uint32_t)0x00800000)        /*!< Filter bit 23 */
S#define  CAN_F3R1_FB24                       ((uint32_t)0x01000000)        /*!< Filter bit 24 */
S#define  CAN_F3R1_FB25                       ((uint32_t)0x02000000)        /*!< Filter bit 25 */
S#define  CAN_F3R1_FB26                       ((uint32_t)0x04000000)        /*!< Filter bit 26 */
S#define  CAN_F3R1_FB27                       ((uint32_t)0x08000000)        /*!< Filter bit 27 */
S#define  CAN_F3R1_FB28                       ((uint32_t)0x10000000)        /*!< Filter bit 28 */
S#define  CAN_F3R1_FB29                       ((uint32_t)0x20000000)        /*!< Filter bit 29 */
S#define  CAN_F3R1_FB30                       ((uint32_t)0x40000000)        /*!< Filter bit 30 */
S#define  CAN_F3R1_FB31                       ((uint32_t)0x80000000)        /*!< Filter bit 31 */
S
S/*******************  Bit definition for CAN_F4R1 register  *******************/
S#define  CAN_F4R1_FB0                        ((uint32_t)0x00000001)        /*!< Filter bit 0 */
S#define  CAN_F4R1_FB1                        ((uint32_t)0x00000002)        /*!< Filter bit 1 */
S#define  CAN_F4R1_FB2                        ((uint32_t)0x00000004)        /*!< Filter bit 2 */
S#define  CAN_F4R1_FB3                        ((uint32_t)0x00000008)        /*!< Filter bit 3 */
S#define  CAN_F4R1_FB4                        ((uint32_t)0x00000010)        /*!< Filter bit 4 */
S#define  CAN_F4R1_FB5                        ((uint32_t)0x00000020)        /*!< Filter bit 5 */
S#define  CAN_F4R1_FB6                        ((uint32_t)0x00000040)        /*!< Filter bit 6 */
S#define  CAN_F4R1_FB7                        ((uint32_t)0x00000080)        /*!< Filter bit 7 */
S#define  CAN_F4R1_FB8                        ((uint32_t)0x00000100)        /*!< Filter bit 8 */
S#define  CAN_F4R1_FB9                        ((uint32_t)0x00000200)        /*!< Filter bit 9 */
S#define  CAN_F4R1_FB10                       ((uint32_t)0x00000400)        /*!< Filter bit 10 */
S#define  CAN_F4R1_FB11                       ((uint32_t)0x00000800)        /*!< Filter bit 11 */
S#define  CAN_F4R1_FB12                       ((uint32_t)0x00001000)        /*!< Filter bit 12 */
S#define  CAN_F4R1_FB13                       ((uint32_t)0x00002000)        /*!< Filter bit 13 */
S#define  CAN_F4R1_FB14                       ((uint32_t)0x00004000)        /*!< Filter bit 14 */
S#define  CAN_F4R1_FB15                       ((uint32_t)0x00008000)        /*!< Filter bit 15 */
S#define  CAN_F4R1_FB16                       ((uint32_t)0x00010000)        /*!< Filter bit 16 */
S#define  CAN_F4R1_FB17                       ((uint32_t)0x00020000)        /*!< Filter bit 17 */
S#define  CAN_F4R1_FB18                       ((uint32_t)0x00040000)        /*!< Filter bit 18 */
S#define  CAN_F4R1_FB19                       ((uint32_t)0x00080000)        /*!< Filter bit 19 */
S#define  CAN_F4R1_FB20                       ((uint32_t)0x00100000)        /*!< Filter bit 20 */
S#define  CAN_F4R1_FB21                       ((uint32_t)0x00200000)        /*!< Filter bit 21 */
S#define  CAN_F4R1_FB22                       ((uint32_t)0x00400000)        /*!< Filter bit 22 */
S#define  CAN_F4R1_FB23                       ((uint32_t)0x00800000)        /*!< Filter bit 23 */
S#define  CAN_F4R1_FB24                       ((uint32_t)0x01000000)        /*!< Filter bit 24 */
S#define  CAN_F4R1_FB25                       ((uint32_t)0x02000000)        /*!< Filter bit 25 */
S#define  CAN_F4R1_FB26                       ((uint32_t)0x04000000)        /*!< Filter bit 26 */
S#define  CAN_F4R1_FB27                       ((uint32_t)0x08000000)        /*!< Filter bit 27 */
S#define  CAN_F4R1_FB28                       ((uint32_t)0x10000000)        /*!< Filter bit 28 */
S#define  CAN_F4R1_FB29                       ((uint32_t)0x20000000)        /*!< Filter bit 29 */
S#define  CAN_F4R1_FB30                       ((uint32_t)0x40000000)        /*!< Filter bit 30 */
S#define  CAN_F4R1_FB31                       ((uint32_t)0x80000000)        /*!< Filter bit 31 */
S
S/*******************  Bit definition for CAN_F5R1 register  *******************/
S#define  CAN_F5R1_FB0                        ((uint32_t)0x00000001)        /*!< Filter bit 0 */
S#define  CAN_F5R1_FB1                        ((uint32_t)0x00000002)        /*!< Filter bit 1 */
S#define  CAN_F5R1_FB2                        ((uint32_t)0x00000004)        /*!< Filter bit 2 */
S#define  CAN_F5R1_FB3                        ((uint32_t)0x00000008)        /*!< Filter bit 3 */
S#define  CAN_F5R1_FB4                        ((uint32_t)0x00000010)        /*!< Filter bit 4 */
S#define  CAN_F5R1_FB5                        ((uint32_t)0x00000020)        /*!< Filter bit 5 */
S#define  CAN_F5R1_FB6                        ((uint32_t)0x00000040)        /*!< Filter bit 6 */
S#define  CAN_F5R1_FB7                        ((uint32_t)0x00000080)        /*!< Filter bit 7 */
S#define  CAN_F5R1_FB8                        ((uint32_t)0x00000100)        /*!< Filter bit 8 */
S#define  CAN_F5R1_FB9                        ((uint32_t)0x00000200)        /*!< Filter bit 9 */
S#define  CAN_F5R1_FB10                       ((uint32_t)0x00000400)        /*!< Filter bit 10 */
S#define  CAN_F5R1_FB11                       ((uint32_t)0x00000800)        /*!< Filter bit 11 */
S#define  CAN_F5R1_FB12                       ((uint32_t)0x00001000)        /*!< Filter bit 12 */
S#define  CAN_F5R1_FB13                       ((uint32_t)0x00002000)        /*!< Filter bit 13 */
S#define  CAN_F5R1_FB14                       ((uint32_t)0x00004000)        /*!< Filter bit 14 */
S#define  CAN_F5R1_FB15                       ((uint32_t)0x00008000)        /*!< Filter bit 15 */
S#define  CAN_F5R1_FB16                       ((uint32_t)0x00010000)        /*!< Filter bit 16 */
S#define  CAN_F5R1_FB17                       ((uint32_t)0x00020000)        /*!< Filter bit 17 */
S#define  CAN_F5R1_FB18                       ((uint32_t)0x00040000)        /*!< Filter bit 18 */
S#define  CAN_F5R1_FB19                       ((uint32_t)0x00080000)        /*!< Filter bit 19 */
S#define  CAN_F5R1_FB20                       ((uint32_t)0x00100000)        /*!< Filter bit 20 */
S#define  CAN_F5R1_FB21                       ((uint32_t)0x00200000)        /*!< Filter bit 21 */
S#define  CAN_F5R1_FB22                       ((uint32_t)0x00400000)        /*!< Filter bit 22 */
S#define  CAN_F5R1_FB23                       ((uint32_t)0x00800000)        /*!< Filter bit 23 */
S#define  CAN_F5R1_FB24                       ((uint32_t)0x01000000)        /*!< Filter bit 24 */
S#define  CAN_F5R1_FB25                       ((uint32_t)0x02000000)        /*!< Filter bit 25 */
S#define  CAN_F5R1_FB26                       ((uint32_t)0x04000000)        /*!< Filter bit 26 */
S#define  CAN_F5R1_FB27                       ((uint32_t)0x08000000)        /*!< Filter bit 27 */
S#define  CAN_F5R1_FB28                       ((uint32_t)0x10000000)        /*!< Filter bit 28 */
S#define  CAN_F5R1_FB29                       ((uint32_t)0x20000000)        /*!< Filter bit 29 */
S#define  CAN_F5R1_FB30                       ((uint32_t)0x40000000)        /*!< Filter bit 30 */
S#define  CAN_F5R1_FB31                       ((uint32_t)0x80000000)        /*!< Filter bit 31 */
S
S/*******************  Bit definition for CAN_F6R1 register  *******************/
S#define  CAN_F6R1_FB0                        ((uint32_t)0x00000001)        /*!< Filter bit 0 */
S#define  CAN_F6R1_FB1                        ((uint32_t)0x00000002)        /*!< Filter bit 1 */
S#define  CAN_F6R1_FB2                        ((uint32_t)0x00000004)        /*!< Filter bit 2 */
S#define  CAN_F6R1_FB3                        ((uint32_t)0x00000008)        /*!< Filter bit 3 */
S#define  CAN_F6R1_FB4                        ((uint32_t)0x00000010)        /*!< Filter bit 4 */
S#define  CAN_F6R1_FB5                        ((uint32_t)0x00000020)        /*!< Filter bit 5 */
S#define  CAN_F6R1_FB6                        ((uint32_t)0x00000040)        /*!< Filter bit 6 */
S#define  CAN_F6R1_FB7                        ((uint32_t)0x00000080)        /*!< Filter bit 7 */
S#define  CAN_F6R1_FB8                        ((uint32_t)0x00000100)        /*!< Filter bit 8 */
S#define  CAN_F6R1_FB9                        ((uint32_t)0x00000200)        /*!< Filter bit 9 */
S#define  CAN_F6R1_FB10                       ((uint32_t)0x00000400)        /*!< Filter bit 10 */
S#define  CAN_F6R1_FB11                       ((uint32_t)0x00000800)        /*!< Filter bit 11 */
S#define  CAN_F6R1_FB12                       ((uint32_t)0x00001000)        /*!< Filter bit 12 */
S#define  CAN_F6R1_FB13                       ((uint32_t)0x00002000)        /*!< Filter bit 13 */
S#define  CAN_F6R1_FB14                       ((uint32_t)0x00004000)        /*!< Filter bit 14 */
S#define  CAN_F6R1_FB15                       ((uint32_t)0x00008000)        /*!< Filter bit 15 */
S#define  CAN_F6R1_FB16                       ((uint32_t)0x00010000)        /*!< Filter bit 16 */
S#define  CAN_F6R1_FB17                       ((uint32_t)0x00020000)        /*!< Filter bit 17 */
S#define  CAN_F6R1_FB18                       ((uint32_t)0x00040000)        /*!< Filter bit 18 */
S#define  CAN_F6R1_FB19                       ((uint32_t)0x00080000)        /*!< Filter bit 19 */
S#define  CAN_F6R1_FB20                       ((uint32_t)0x00100000)        /*!< Filter bit 20 */
S#define  CAN_F6R1_FB21                       ((uint32_t)0x00200000)        /*!< Filter bit 21 */
S#define  CAN_F6R1_FB22                       ((uint32_t)0x00400000)        /*!< Filter bit 22 */
S#define  CAN_F6R1_FB23                       ((uint32_t)0x00800000)        /*!< Filter bit 23 */
S#define  CAN_F6R1_FB24                       ((uint32_t)0x01000000)        /*!< Filter bit 24 */
S#define  CAN_F6R1_FB25                       ((uint32_t)0x02000000)        /*!< Filter bit 25 */
S#define  CAN_F6R1_FB26                       ((uint32_t)0x04000000)        /*!< Filter bit 26 */
S#define  CAN_F6R1_FB27                       ((uint32_t)0x08000000)        /*!< Filter bit 27 */
S#define  CAN_F6R1_FB28                       ((uint32_t)0x10000000)        /*!< Filter bit 28 */
S#define  CAN_F6R1_FB29                       ((uint32_t)0x20000000)        /*!< Filter bit 29 */
S#define  CAN_F6R1_FB30                       ((uint32_t)0x40000000)        /*!< Filter bit 30 */
S#define  CAN_F6R1_FB31                       ((uint32_t)0x80000000)        /*!< Filter bit 31 */
S
S/*******************  Bit definition for CAN_F7R1 register  *******************/
S#define  CAN_F7R1_FB0                        ((uint32_t)0x00000001)        /*!< Filter bit 0 */
S#define  CAN_F7R1_FB1                        ((uint32_t)0x00000002)        /*!< Filter bit 1 */
S#define  CAN_F7R1_FB2                        ((uint32_t)0x00000004)        /*!< Filter bit 2 */
S#define  CAN_F7R1_FB3                        ((uint32_t)0x00000008)        /*!< Filter bit 3 */
S#define  CAN_F7R1_FB4                        ((uint32_t)0x00000010)        /*!< Filter bit 4 */
S#define  CAN_F7R1_FB5                        ((uint32_t)0x00000020)        /*!< Filter bit 5 */
S#define  CAN_F7R1_FB6                        ((uint32_t)0x00000040)        /*!< Filter bit 6 */
S#define  CAN_F7R1_FB7                        ((uint32_t)0x00000080)        /*!< Filter bit 7 */
S#define  CAN_F7R1_FB8                        ((uint32_t)0x00000100)        /*!< Filter bit 8 */
S#define  CAN_F7R1_FB9                        ((uint32_t)0x00000200)        /*!< Filter bit 9 */
S#define  CAN_F7R1_FB10                       ((uint32_t)0x00000400)        /*!< Filter bit 10 */
S#define  CAN_F7R1_FB11                       ((uint32_t)0x00000800)        /*!< Filter bit 11 */
S#define  CAN_F7R1_FB12                       ((uint32_t)0x00001000)        /*!< Filter bit 12 */
S#define  CAN_F7R1_FB13                       ((uint32_t)0x00002000)        /*!< Filter bit 13 */
S#define  CAN_F7R1_FB14                       ((uint32_t)0x00004000)        /*!< Filter bit 14 */
S#define  CAN_F7R1_FB15                       ((uint32_t)0x00008000)        /*!< Filter bit 15 */
S#define  CAN_F7R1_FB16                       ((uint32_t)0x00010000)        /*!< Filter bit 16 */
S#define  CAN_F7R1_FB17                       ((uint32_t)0x00020000)        /*!< Filter bit 17 */
S#define  CAN_F7R1_FB18                       ((uint32_t)0x00040000)        /*!< Filter bit 18 */
S#define  CAN_F7R1_FB19                       ((uint32_t)0x00080000)        /*!< Filter bit 19 */
S#define  CAN_F7R1_FB20                       ((uint32_t)0x00100000)        /*!< Filter bit 20 */
S#define  CAN_F7R1_FB21                       ((uint32_t)0x00200000)        /*!< Filter bit 21 */
S#define  CAN_F7R1_FB22                       ((uint32_t)0x00400000)        /*!< Filter bit 22 */
S#define  CAN_F7R1_FB23                       ((uint32_t)0x00800000)        /*!< Filter bit 23 */
S#define  CAN_F7R1_FB24                       ((uint32_t)0x01000000)        /*!< Filter bit 24 */
S#define  CAN_F7R1_FB25                       ((uint32_t)0x02000000)        /*!< Filter bit 25 */
S#define  CAN_F7R1_FB26                       ((uint32_t)0x04000000)        /*!< Filter bit 26 */
S#define  CAN_F7R1_FB27                       ((uint32_t)0x08000000)        /*!< Filter bit 27 */
S#define  CAN_F7R1_FB28                       ((uint32_t)0x10000000)        /*!< Filter bit 28 */
S#define  CAN_F7R1_FB29                       ((uint32_t)0x20000000)        /*!< Filter bit 29 */
S#define  CAN_F7R1_FB30                       ((uint32_t)0x40000000)        /*!< Filter bit 30 */
S#define  CAN_F7R1_FB31                       ((uint32_t)0x80000000)        /*!< Filter bit 31 */
S
S/*******************  Bit definition for CAN_F8R1 register  *******************/
S#define  CAN_F8R1_FB0                        ((uint32_t)0x00000001)        /*!< Filter bit 0 */
S#define  CAN_F8R1_FB1                        ((uint32_t)0x00000002)        /*!< Filter bit 1 */
S#define  CAN_F8R1_FB2                        ((uint32_t)0x00000004)        /*!< Filter bit 2 */
S#define  CAN_F8R1_FB3                        ((uint32_t)0x00000008)        /*!< Filter bit 3 */
S#define  CAN_F8R1_FB4                        ((uint32_t)0x00000010)        /*!< Filter bit 4 */
S#define  CAN_F8R1_FB5                        ((uint32_t)0x00000020)        /*!< Filter bit 5 */
S#define  CAN_F8R1_FB6                        ((uint32_t)0x00000040)        /*!< Filter bit 6 */
S#define  CAN_F8R1_FB7                        ((uint32_t)0x00000080)        /*!< Filter bit 7 */
S#define  CAN_F8R1_FB8                        ((uint32_t)0x00000100)        /*!< Filter bit 8 */
S#define  CAN_F8R1_FB9                        ((uint32_t)0x00000200)        /*!< Filter bit 9 */
S#define  CAN_F8R1_FB10                       ((uint32_t)0x00000400)        /*!< Filter bit 10 */
S#define  CAN_F8R1_FB11                       ((uint32_t)0x00000800)        /*!< Filter bit 11 */
S#define  CAN_F8R1_FB12                       ((uint32_t)0x00001000)        /*!< Filter bit 12 */
S#define  CAN_F8R1_FB13                       ((uint32_t)0x00002000)        /*!< Filter bit 13 */
S#define  CAN_F8R1_FB14                       ((uint32_t)0x00004000)        /*!< Filter bit 14 */
S#define  CAN_F8R1_FB15                       ((uint32_t)0x00008000)        /*!< Filter bit 15 */
S#define  CAN_F8R1_FB16                       ((uint32_t)0x00010000)        /*!< Filter bit 16 */
S#define  CAN_F8R1_FB17                       ((uint32_t)0x00020000)        /*!< Filter bit 17 */
S#define  CAN_F8R1_FB18                       ((uint32_t)0x00040000)        /*!< Filter bit 18 */
S#define  CAN_F8R1_FB19                       ((uint32_t)0x00080000)        /*!< Filter bit 19 */
S#define  CAN_F8R1_FB20                       ((uint32_t)0x00100000)        /*!< Filter bit 20 */
S#define  CAN_F8R1_FB21                       ((uint32_t)0x00200000)        /*!< Filter bit 21 */
S#define  CAN_F8R1_FB22                       ((uint32_t)0x00400000)        /*!< Filter bit 22 */
S#define  CAN_F8R1_FB23                       ((uint32_t)0x00800000)        /*!< Filter bit 23 */
S#define  CAN_F8R1_FB24                       ((uint32_t)0x01000000)        /*!< Filter bit 24 */
S#define  CAN_F8R1_FB25                       ((uint32_t)0x02000000)        /*!< Filter bit 25 */
S#define  CAN_F8R1_FB26                       ((uint32_t)0x04000000)        /*!< Filter bit 26 */
S#define  CAN_F8R1_FB27                       ((uint32_t)0x08000000)        /*!< Filter bit 27 */
S#define  CAN_F8R1_FB28                       ((uint32_t)0x10000000)        /*!< Filter bit 28 */
S#define  CAN_F8R1_FB29                       ((uint32_t)0x20000000)        /*!< Filter bit 29 */
S#define  CAN_F8R1_FB30                       ((uint32_t)0x40000000)        /*!< Filter bit 30 */
S#define  CAN_F8R1_FB31                       ((uint32_t)0x80000000)        /*!< Filter bit 31 */
S
S/*******************  Bit definition for CAN_F9R1 register  *******************/
S#define  CAN_F9R1_FB0                        ((uint32_t)0x00000001)        /*!< Filter bit 0 */
S#define  CAN_F9R1_FB1                        ((uint32_t)0x00000002)        /*!< Filter bit 1 */
S#define  CAN_F9R1_FB2                        ((uint32_t)0x00000004)        /*!< Filter bit 2 */
S#define  CAN_F9R1_FB3                        ((uint32_t)0x00000008)        /*!< Filter bit 3 */
S#define  CAN_F9R1_FB4                        ((uint32_t)0x00000010)        /*!< Filter bit 4 */
S#define  CAN_F9R1_FB5                        ((uint32_t)0x00000020)        /*!< Filter bit 5 */
S#define  CAN_F9R1_FB6                        ((uint32_t)0x00000040)        /*!< Filter bit 6 */
S#define  CAN_F9R1_FB7                        ((uint32_t)0x00000080)        /*!< Filter bit 7 */
S#define  CAN_F9R1_FB8                        ((uint32_t)0x00000100)        /*!< Filter bit 8 */
S#define  CAN_F9R1_FB9                        ((uint32_t)0x00000200)        /*!< Filter bit 9 */
S#define  CAN_F9R1_FB10                       ((uint32_t)0x00000400)        /*!< Filter bit 10 */
S#define  CAN_F9R1_FB11                       ((uint32_t)0x00000800)        /*!< Filter bit 11 */
S#define  CAN_F9R1_FB12                       ((uint32_t)0x00001000)        /*!< Filter bit 12 */
S#define  CAN_F9R1_FB13                       ((uint32_t)0x00002000)        /*!< Filter bit 13 */
S#define  CAN_F9R1_FB14                       ((uint32_t)0x00004000)        /*!< Filter bit 14 */
S#define  CAN_F9R1_FB15                       ((uint32_t)0x00008000)        /*!< Filter bit 15 */
S#define  CAN_F9R1_FB16                       ((uint32_t)0x00010000)        /*!< Filter bit 16 */
S#define  CAN_F9R1_FB17                       ((uint32_t)0x00020000)        /*!< Filter bit 17 */
S#define  CAN_F9R1_FB18                       ((uint32_t)0x00040000)        /*!< Filter bit 18 */
S#define  CAN_F9R1_FB19                       ((uint32_t)0x00080000)        /*!< Filter bit 19 */
S#define  CAN_F9R1_FB20                       ((uint32_t)0x00100000)        /*!< Filter bit 20 */
S#define  CAN_F9R1_FB21                       ((uint32_t)0x00200000)        /*!< Filter bit 21 */
S#define  CAN_F9R1_FB22                       ((uint32_t)0x00400000)        /*!< Filter bit 22 */
S#define  CAN_F9R1_FB23                       ((uint32_t)0x00800000)        /*!< Filter bit 23 */
S#define  CAN_F9R1_FB24                       ((uint32_t)0x01000000)        /*!< Filter bit 24 */
S#define  CAN_F9R1_FB25                       ((uint32_t)0x02000000)        /*!< Filter bit 25 */
S#define  CAN_F9R1_FB26                       ((uint32_t)0x04000000)        /*!< Filter bit 26 */
S#define  CAN_F9R1_FB27                       ((uint32_t)0x08000000)        /*!< Filter bit 27 */
S#define  CAN_F9R1_FB28                       ((uint32_t)0x10000000)        /*!< Filter bit 28 */
S#define  CAN_F9R1_FB29                       ((uint32_t)0x20000000)        /*!< Filter bit 29 */
S#define  CAN_F9R1_FB30                       ((uint32_t)0x40000000)        /*!< Filter bit 30 */
S#define  CAN_F9R1_FB31                       ((uint32_t)0x80000000)        /*!< Filter bit 31 */
S
S/*******************  Bit definition for CAN_F10R1 register  ******************/
S#define  CAN_F10R1_FB0                       ((uint32_t)0x00000001)        /*!< Filter bit 0 */
S#define  CAN_F10R1_FB1                       ((uint32_t)0x00000002)        /*!< Filter bit 1 */
S#define  CAN_F10R1_FB2                       ((uint32_t)0x00000004)        /*!< Filter bit 2 */
S#define  CAN_F10R1_FB3                       ((uint32_t)0x00000008)        /*!< Filter bit 3 */
S#define  CAN_F10R1_FB4                       ((uint32_t)0x00000010)        /*!< Filter bit 4 */
S#define  CAN_F10R1_FB5                       ((uint32_t)0x00000020)        /*!< Filter bit 5 */
S#define  CAN_F10R1_FB6                       ((uint32_t)0x00000040)        /*!< Filter bit 6 */
S#define  CAN_F10R1_FB7                       ((uint32_t)0x00000080)        /*!< Filter bit 7 */
S#define  CAN_F10R1_FB8                       ((uint32_t)0x00000100)        /*!< Filter bit 8 */
S#define  CAN_F10R1_FB9                       ((uint32_t)0x00000200)        /*!< Filter bit 9 */
S#define  CAN_F10R1_FB10                      ((uint32_t)0x00000400)        /*!< Filter bit 10 */
S#define  CAN_F10R1_FB11                      ((uint32_t)0x00000800)        /*!< Filter bit 11 */
S#define  CAN_F10R1_FB12                      ((uint32_t)0x00001000)        /*!< Filter bit 12 */
S#define  CAN_F10R1_FB13                      ((uint32_t)0x00002000)        /*!< Filter bit 13 */
S#define  CAN_F10R1_FB14                      ((uint32_t)0x00004000)        /*!< Filter bit 14 */
S#define  CAN_F10R1_FB15                      ((uint32_t)0x00008000)        /*!< Filter bit 15 */
S#define  CAN_F10R1_FB16                      ((uint32_t)0x00010000)        /*!< Filter bit 16 */
S#define  CAN_F10R1_FB17                      ((uint32_t)0x00020000)        /*!< Filter bit 17 */
S#define  CAN_F10R1_FB18                      ((uint32_t)0x00040000)        /*!< Filter bit 18 */
S#define  CAN_F10R1_FB19                      ((uint32_t)0x00080000)        /*!< Filter bit 19 */
S#define  CAN_F10R1_FB20                      ((uint32_t)0x00100000)        /*!< Filter bit 20 */
S#define  CAN_F10R1_FB21                      ((uint32_t)0x00200000)        /*!< Filter bit 21 */
S#define  CAN_F10R1_FB22                      ((uint32_t)0x00400000)        /*!< Filter bit 22 */
S#define  CAN_F10R1_FB23                      ((uint32_t)0x00800000)        /*!< Filter bit 23 */
S#define  CAN_F10R1_FB24                      ((uint32_t)0x01000000)        /*!< Filter bit 24 */
S#define  CAN_F10R1_FB25                      ((uint32_t)0x02000000)        /*!< Filter bit 25 */
S#define  CAN_F10R1_FB26                      ((uint32_t)0x04000000)        /*!< Filter bit 26 */
S#define  CAN_F10R1_FB27                      ((uint32_t)0x08000000)        /*!< Filter bit 27 */
S#define  CAN_F10R1_FB28                      ((uint32_t)0x10000000)        /*!< Filter bit 28 */
S#define  CAN_F10R1_FB29                      ((uint32_t)0x20000000)        /*!< Filter bit 29 */
S#define  CAN_F10R1_FB30                      ((uint32_t)0x40000000)        /*!< Filter bit 30 */
S#define  CAN_F10R1_FB31                      ((uint32_t)0x80000000)        /*!< Filter bit 31 */
S
S/*******************  Bit definition for CAN_F11R1 register  ******************/
S#define  CAN_F11R1_FB0                       ((uint32_t)0x00000001)        /*!< Filter bit 0 */
S#define  CAN_F11R1_FB1                       ((uint32_t)0x00000002)        /*!< Filter bit 1 */
S#define  CAN_F11R1_FB2                       ((uint32_t)0x00000004)        /*!< Filter bit 2 */
S#define  CAN_F11R1_FB3                       ((uint32_t)0x00000008)        /*!< Filter bit 3 */
S#define  CAN_F11R1_FB4                       ((uint32_t)0x00000010)        /*!< Filter bit 4 */
S#define  CAN_F11R1_FB5                       ((uint32_t)0x00000020)        /*!< Filter bit 5 */
S#define  CAN_F11R1_FB6                       ((uint32_t)0x00000040)        /*!< Filter bit 6 */
S#define  CAN_F11R1_FB7                       ((uint32_t)0x00000080)        /*!< Filter bit 7 */
S#define  CAN_F11R1_FB8                       ((uint32_t)0x00000100)        /*!< Filter bit 8 */
S#define  CAN_F11R1_FB9                       ((uint32_t)0x00000200)        /*!< Filter bit 9 */
S#define  CAN_F11R1_FB10                      ((uint32_t)0x00000400)        /*!< Filter bit 10 */
S#define  CAN_F11R1_FB11                      ((uint32_t)0x00000800)        /*!< Filter bit 11 */
S#define  CAN_F11R1_FB12                      ((uint32_t)0x00001000)        /*!< Filter bit 12 */
S#define  CAN_F11R1_FB13                      ((uint32_t)0x00002000)        /*!< Filter bit 13 */
S#define  CAN_F11R1_FB14                      ((uint32_t)0x00004000)        /*!< Filter bit 14 */
S#define  CAN_F11R1_FB15                      ((uint32_t)0x00008000)        /*!< Filter bit 15 */
S#define  CAN_F11R1_FB16                      ((uint32_t)0x00010000)        /*!< Filter bit 16 */
S#define  CAN_F11R1_FB17                      ((uint32_t)0x00020000)        /*!< Filter bit 17 */
S#define  CAN_F11R1_FB18                      ((uint32_t)0x00040000)        /*!< Filter bit 18 */
S#define  CAN_F11R1_FB19                      ((uint32_t)0x00080000)        /*!< Filter bit 19 */
S#define  CAN_F11R1_FB20                      ((uint32_t)0x00100000)        /*!< Filter bit 20 */
S#define  CAN_F11R1_FB21                      ((uint32_t)0x00200000)        /*!< Filter bit 21 */
S#define  CAN_F11R1_FB22                      ((uint32_t)0x00400000)        /*!< Filter bit 22 */
S#define  CAN_F11R1_FB23                      ((uint32_t)0x00800000)        /*!< Filter bit 23 */
S#define  CAN_F11R1_FB24                      ((uint32_t)0x01000000)        /*!< Filter bit 24 */
S#define  CAN_F11R1_FB25                      ((uint32_t)0x02000000)        /*!< Filter bit 25 */
S#define  CAN_F11R1_FB26                      ((uint32_t)0x04000000)        /*!< Filter bit 26 */
S#define  CAN_F11R1_FB27                      ((uint32_t)0x08000000)        /*!< Filter bit 27 */
S#define  CAN_F11R1_FB28                      ((uint32_t)0x10000000)        /*!< Filter bit 28 */
S#define  CAN_F11R1_FB29                      ((uint32_t)0x20000000)        /*!< Filter bit 29 */
S#define  CAN_F11R1_FB30                      ((uint32_t)0x40000000)        /*!< Filter bit 30 */
S#define  CAN_F11R1_FB31                      ((uint32_t)0x80000000)        /*!< Filter bit 31 */
S
S/*******************  Bit definition for CAN_F12R1 register  ******************/
S#define  CAN_F12R1_FB0                       ((uint32_t)0x00000001)        /*!< Filter bit 0 */
S#define  CAN_F12R1_FB1                       ((uint32_t)0x00000002)        /*!< Filter bit 1 */
S#define  CAN_F12R1_FB2                       ((uint32_t)0x00000004)        /*!< Filter bit 2 */
S#define  CAN_F12R1_FB3                       ((uint32_t)0x00000008)        /*!< Filter bit 3 */
S#define  CAN_F12R1_FB4                       ((uint32_t)0x00000010)        /*!< Filter bit 4 */
S#define  CAN_F12R1_FB5                       ((uint32_t)0x00000020)        /*!< Filter bit 5 */
S#define  CAN_F12R1_FB6                       ((uint32_t)0x00000040)        /*!< Filter bit 6 */
S#define  CAN_F12R1_FB7                       ((uint32_t)0x00000080)        /*!< Filter bit 7 */
S#define  CAN_F12R1_FB8                       ((uint32_t)0x00000100)        /*!< Filter bit 8 */
S#define  CAN_F12R1_FB9                       ((uint32_t)0x00000200)        /*!< Filter bit 9 */
S#define  CAN_F12R1_FB10                      ((uint32_t)0x00000400)        /*!< Filter bit 10 */
S#define  CAN_F12R1_FB11                      ((uint32_t)0x00000800)        /*!< Filter bit 11 */
S#define  CAN_F12R1_FB12                      ((uint32_t)0x00001000)        /*!< Filter bit 12 */
S#define  CAN_F12R1_FB13                      ((uint32_t)0x00002000)        /*!< Filter bit 13 */
S#define  CAN_F12R1_FB14                      ((uint32_t)0x00004000)        /*!< Filter bit 14 */
S#define  CAN_F12R1_FB15                      ((uint32_t)0x00008000)        /*!< Filter bit 15 */
S#define  CAN_F12R1_FB16                      ((uint32_t)0x00010000)        /*!< Filter bit 16 */
S#define  CAN_F12R1_FB17                      ((uint32_t)0x00020000)        /*!< Filter bit 17 */
S#define  CAN_F12R1_FB18                      ((uint32_t)0x00040000)        /*!< Filter bit 18 */
S#define  CAN_F12R1_FB19                      ((uint32_t)0x00080000)        /*!< Filter bit 19 */
S#define  CAN_F12R1_FB20                      ((uint32_t)0x00100000)        /*!< Filter bit 20 */
S#define  CAN_F12R1_FB21                      ((uint32_t)0x00200000)        /*!< Filter bit 21 */
S#define  CAN_F12R1_FB22                      ((uint32_t)0x00400000)        /*!< Filter bit 22 */
S#define  CAN_F12R1_FB23                      ((uint32_t)0x00800000)        /*!< Filter bit 23 */
S#define  CAN_F12R1_FB24                      ((uint32_t)0x01000000)        /*!< Filter bit 24 */
S#define  CAN_F12R1_FB25                      ((uint32_t)0x02000000)        /*!< Filter bit 25 */
S#define  CAN_F12R1_FB26                      ((uint32_t)0x04000000)        /*!< Filter bit 26 */
S#define  CAN_F12R1_FB27                      ((uint32_t)0x08000000)        /*!< Filter bit 27 */
S#define  CAN_F12R1_FB28                      ((uint32_t)0x10000000)        /*!< Filter bit 28 */
S#define  CAN_F12R1_FB29                      ((uint32_t)0x20000000)        /*!< Filter bit 29 */
S#define  CAN_F12R1_FB30                      ((uint32_t)0x40000000)        /*!< Filter bit 30 */
S#define  CAN_F12R1_FB31                      ((uint32_t)0x80000000)        /*!< Filter bit 31 */
S
S/*******************  Bit definition for CAN_F13R1 register  ******************/
S#define  CAN_F13R1_FB0                       ((uint32_t)0x00000001)        /*!< Filter bit 0 */
S#define  CAN_F13R1_FB1                       ((uint32_t)0x00000002)        /*!< Filter bit 1 */
S#define  CAN_F13R1_FB2                       ((uint32_t)0x00000004)        /*!< Filter bit 2 */
S#define  CAN_F13R1_FB3                       ((uint32_t)0x00000008)        /*!< Filter bit 3 */
S#define  CAN_F13R1_FB4                       ((uint32_t)0x00000010)        /*!< Filter bit 4 */
S#define  CAN_F13R1_FB5                       ((uint32_t)0x00000020)        /*!< Filter bit 5 */
S#define  CAN_F13R1_FB6                       ((uint32_t)0x00000040)        /*!< Filter bit 6 */
S#define  CAN_F13R1_FB7                       ((uint32_t)0x00000080)        /*!< Filter bit 7 */
S#define  CAN_F13R1_FB8                       ((uint32_t)0x00000100)        /*!< Filter bit 8 */
S#define  CAN_F13R1_FB9                       ((uint32_t)0x00000200)        /*!< Filter bit 9 */
S#define  CAN_F13R1_FB10                      ((uint32_t)0x00000400)        /*!< Filter bit 10 */
S#define  CAN_F13R1_FB11                      ((uint32_t)0x00000800)        /*!< Filter bit 11 */
S#define  CAN_F13R1_FB12                      ((uint32_t)0x00001000)        /*!< Filter bit 12 */
S#define  CAN_F13R1_FB13                      ((uint32_t)0x00002000)        /*!< Filter bit 13 */
S#define  CAN_F13R1_FB14                      ((uint32_t)0x00004000)        /*!< Filter bit 14 */
S#define  CAN_F13R1_FB15                      ((uint32_t)0x00008000)        /*!< Filter bit 15 */
S#define  CAN_F13R1_FB16                      ((uint32_t)0x00010000)        /*!< Filter bit 16 */
S#define  CAN_F13R1_FB17                      ((uint32_t)0x00020000)        /*!< Filter bit 17 */
S#define  CAN_F13R1_FB18                      ((uint32_t)0x00040000)        /*!< Filter bit 18 */
S#define  CAN_F13R1_FB19                      ((uint32_t)0x00080000)        /*!< Filter bit 19 */
S#define  CAN_F13R1_FB20                      ((uint32_t)0x00100000)        /*!< Filter bit 20 */
S#define  CAN_F13R1_FB21                      ((uint32_t)0x00200000)        /*!< Filter bit 21 */
S#define  CAN_F13R1_FB22                      ((uint32_t)0x00400000)        /*!< Filter bit 22 */
S#define  CAN_F13R1_FB23                      ((uint32_t)0x00800000)        /*!< Filter bit 23 */
S#define  CAN_F13R1_FB24                      ((uint32_t)0x01000000)        /*!< Filter bit 24 */
S#define  CAN_F13R1_FB25                      ((uint32_t)0x02000000)        /*!< Filter bit 25 */
S#define  CAN_F13R1_FB26                      ((uint32_t)0x04000000)        /*!< Filter bit 26 */
S#define  CAN_F13R1_FB27                      ((uint32_t)0x08000000)        /*!< Filter bit 27 */
S#define  CAN_F13R1_FB28                      ((uint32_t)0x10000000)        /*!< Filter bit 28 */
S#define  CAN_F13R1_FB29                      ((uint32_t)0x20000000)        /*!< Filter bit 29 */
S#define  CAN_F13R1_FB30                      ((uint32_t)0x40000000)        /*!< Filter bit 30 */
S#define  CAN_F13R1_FB31                      ((uint32_t)0x80000000)        /*!< Filter bit 31 */
S
S/*******************  Bit definition for CAN_F0R2 register  *******************/
S#define  CAN_F0R2_FB0                        ((uint32_t)0x00000001)        /*!< Filter bit 0 */
S#define  CAN_F0R2_FB1                        ((uint32_t)0x00000002)        /*!< Filter bit 1 */
S#define  CAN_F0R2_FB2                        ((uint32_t)0x00000004)        /*!< Filter bit 2 */
S#define  CAN_F0R2_FB3                        ((uint32_t)0x00000008)        /*!< Filter bit 3 */
S#define  CAN_F0R2_FB4                        ((uint32_t)0x00000010)        /*!< Filter bit 4 */
S#define  CAN_F0R2_FB5                        ((uint32_t)0x00000020)        /*!< Filter bit 5 */
S#define  CAN_F0R2_FB6                        ((uint32_t)0x00000040)        /*!< Filter bit 6 */
S#define  CAN_F0R2_FB7                        ((uint32_t)0x00000080)        /*!< Filter bit 7 */
S#define  CAN_F0R2_FB8                        ((uint32_t)0x00000100)        /*!< Filter bit 8 */
S#define  CAN_F0R2_FB9                        ((uint32_t)0x00000200)        /*!< Filter bit 9 */
S#define  CAN_F0R2_FB10                       ((uint32_t)0x00000400)        /*!< Filter bit 10 */
S#define  CAN_F0R2_FB11                       ((uint32_t)0x00000800)        /*!< Filter bit 11 */
S#define  CAN_F0R2_FB12                       ((uint32_t)0x00001000)        /*!< Filter bit 12 */
S#define  CAN_F0R2_FB13                       ((uint32_t)0x00002000)        /*!< Filter bit 13 */
S#define  CAN_F0R2_FB14                       ((uint32_t)0x00004000)        /*!< Filter bit 14 */
S#define  CAN_F0R2_FB15                       ((uint32_t)0x00008000)        /*!< Filter bit 15 */
S#define  CAN_F0R2_FB16                       ((uint32_t)0x00010000)        /*!< Filter bit 16 */
S#define  CAN_F0R2_FB17                       ((uint32_t)0x00020000)        /*!< Filter bit 17 */
S#define  CAN_F0R2_FB18                       ((uint32_t)0x00040000)        /*!< Filter bit 18 */
S#define  CAN_F0R2_FB19                       ((uint32_t)0x00080000)        /*!< Filter bit 19 */
S#define  CAN_F0R2_FB20                       ((uint32_t)0x00100000)        /*!< Filter bit 20 */
S#define  CAN_F0R2_FB21                       ((uint32_t)0x00200000)        /*!< Filter bit 21 */
S#define  CAN_F0R2_FB22                       ((uint32_t)0x00400000)        /*!< Filter bit 22 */
S#define  CAN_F0R2_FB23                       ((uint32_t)0x00800000)        /*!< Filter bit 23 */
S#define  CAN_F0R2_FB24                       ((uint32_t)0x01000000)        /*!< Filter bit 24 */
S#define  CAN_F0R2_FB25                       ((uint32_t)0x02000000)        /*!< Filter bit 25 */
S#define  CAN_F0R2_FB26                       ((uint32_t)0x04000000)        /*!< Filter bit 26 */
S#define  CAN_F0R2_FB27                       ((uint32_t)0x08000000)        /*!< Filter bit 27 */
S#define  CAN_F0R2_FB28                       ((uint32_t)0x10000000)        /*!< Filter bit 28 */
S#define  CAN_F0R2_FB29                       ((uint32_t)0x20000000)        /*!< Filter bit 29 */
S#define  CAN_F0R2_FB30                       ((uint32_t)0x40000000)        /*!< Filter bit 30 */
S#define  CAN_F0R2_FB31                       ((uint32_t)0x80000000)        /*!< Filter bit 31 */
S
S/*******************  Bit definition for CAN_F1R2 register  *******************/
S#define  CAN_F1R2_FB0                        ((uint32_t)0x00000001)        /*!< Filter bit 0 */
S#define  CAN_F1R2_FB1                        ((uint32_t)0x00000002)        /*!< Filter bit 1 */
S#define  CAN_F1R2_FB2                        ((uint32_t)0x00000004)        /*!< Filter bit 2 */
S#define  CAN_F1R2_FB3                        ((uint32_t)0x00000008)        /*!< Filter bit 3 */
S#define  CAN_F1R2_FB4                        ((uint32_t)0x00000010)        /*!< Filter bit 4 */
S#define  CAN_F1R2_FB5                        ((uint32_t)0x00000020)        /*!< Filter bit 5 */
S#define  CAN_F1R2_FB6                        ((uint32_t)0x00000040)        /*!< Filter bit 6 */
S#define  CAN_F1R2_FB7                        ((uint32_t)0x00000080)        /*!< Filter bit 7 */
S#define  CAN_F1R2_FB8                        ((uint32_t)0x00000100)        /*!< Filter bit 8 */
S#define  CAN_F1R2_FB9                        ((uint32_t)0x00000200)        /*!< Filter bit 9 */
S#define  CAN_F1R2_FB10                       ((uint32_t)0x00000400)        /*!< Filter bit 10 */
S#define  CAN_F1R2_FB11                       ((uint32_t)0x00000800)        /*!< Filter bit 11 */
S#define  CAN_F1R2_FB12                       ((uint32_t)0x00001000)        /*!< Filter bit 12 */
S#define  CAN_F1R2_FB13                       ((uint32_t)0x00002000)        /*!< Filter bit 13 */
S#define  CAN_F1R2_FB14                       ((uint32_t)0x00004000)        /*!< Filter bit 14 */
S#define  CAN_F1R2_FB15                       ((uint32_t)0x00008000)        /*!< Filter bit 15 */
S#define  CAN_F1R2_FB16                       ((uint32_t)0x00010000)        /*!< Filter bit 16 */
S#define  CAN_F1R2_FB17                       ((uint32_t)0x00020000)        /*!< Filter bit 17 */
S#define  CAN_F1R2_FB18                       ((uint32_t)0x00040000)        /*!< Filter bit 18 */
S#define  CAN_F1R2_FB19                       ((uint32_t)0x00080000)        /*!< Filter bit 19 */
S#define  CAN_F1R2_FB20                       ((uint32_t)0x00100000)        /*!< Filter bit 20 */
S#define  CAN_F1R2_FB21                       ((uint32_t)0x00200000)        /*!< Filter bit 21 */
S#define  CAN_F1R2_FB22                       ((uint32_t)0x00400000)        /*!< Filter bit 22 */
S#define  CAN_F1R2_FB23                       ((uint32_t)0x00800000)        /*!< Filter bit 23 */
S#define  CAN_F1R2_FB24                       ((uint32_t)0x01000000)        /*!< Filter bit 24 */
S#define  CAN_F1R2_FB25                       ((uint32_t)0x02000000)        /*!< Filter bit 25 */
S#define  CAN_F1R2_FB26                       ((uint32_t)0x04000000)        /*!< Filter bit 26 */
S#define  CAN_F1R2_FB27                       ((uint32_t)0x08000000)        /*!< Filter bit 27 */
S#define  CAN_F1R2_FB28                       ((uint32_t)0x10000000)        /*!< Filter bit 28 */
S#define  CAN_F1R2_FB29                       ((uint32_t)0x20000000)        /*!< Filter bit 29 */
S#define  CAN_F1R2_FB30                       ((uint32_t)0x40000000)        /*!< Filter bit 30 */
S#define  CAN_F1R2_FB31                       ((uint32_t)0x80000000)        /*!< Filter bit 31 */
S
S/*******************  Bit definition for CAN_F2R2 register  *******************/
S#define  CAN_F2R2_FB0                        ((uint32_t)0x00000001)        /*!< Filter bit 0 */
S#define  CAN_F2R2_FB1                        ((uint32_t)0x00000002)        /*!< Filter bit 1 */
S#define  CAN_F2R2_FB2                        ((uint32_t)0x00000004)        /*!< Filter bit 2 */
S#define  CAN_F2R2_FB3                        ((uint32_t)0x00000008)        /*!< Filter bit 3 */
S#define  CAN_F2R2_FB4                        ((uint32_t)0x00000010)        /*!< Filter bit 4 */
S#define  CAN_F2R2_FB5                        ((uint32_t)0x00000020)        /*!< Filter bit 5 */
S#define  CAN_F2R2_FB6                        ((uint32_t)0x00000040)        /*!< Filter bit 6 */
S#define  CAN_F2R2_FB7                        ((uint32_t)0x00000080)        /*!< Filter bit 7 */
S#define  CAN_F2R2_FB8                        ((uint32_t)0x00000100)        /*!< Filter bit 8 */
S#define  CAN_F2R2_FB9                        ((uint32_t)0x00000200)        /*!< Filter bit 9 */
S#define  CAN_F2R2_FB10                       ((uint32_t)0x00000400)        /*!< Filter bit 10 */
S#define  CAN_F2R2_FB11                       ((uint32_t)0x00000800)        /*!< Filter bit 11 */
S#define  CAN_F2R2_FB12                       ((uint32_t)0x00001000)        /*!< Filter bit 12 */
S#define  CAN_F2R2_FB13                       ((uint32_t)0x00002000)        /*!< Filter bit 13 */
S#define  CAN_F2R2_FB14                       ((uint32_t)0x00004000)        /*!< Filter bit 14 */
S#define  CAN_F2R2_FB15                       ((uint32_t)0x00008000)        /*!< Filter bit 15 */
S#define  CAN_F2R2_FB16                       ((uint32_t)0x00010000)        /*!< Filter bit 16 */
S#define  CAN_F2R2_FB17                       ((uint32_t)0x00020000)        /*!< Filter bit 17 */
S#define  CAN_F2R2_FB18                       ((uint32_t)0x00040000)        /*!< Filter bit 18 */
S#define  CAN_F2R2_FB19                       ((uint32_t)0x00080000)        /*!< Filter bit 19 */
S#define  CAN_F2R2_FB20                       ((uint32_t)0x00100000)        /*!< Filter bit 20 */
S#define  CAN_F2R2_FB21                       ((uint32_t)0x00200000)        /*!< Filter bit 21 */
S#define  CAN_F2R2_FB22                       ((uint32_t)0x00400000)        /*!< Filter bit 22 */
S#define  CAN_F2R2_FB23                       ((uint32_t)0x00800000)        /*!< Filter bit 23 */
S#define  CAN_F2R2_FB24                       ((uint32_t)0x01000000)        /*!< Filter bit 24 */
S#define  CAN_F2R2_FB25                       ((uint32_t)0x02000000)        /*!< Filter bit 25 */
S#define  CAN_F2R2_FB26                       ((uint32_t)0x04000000)        /*!< Filter bit 26 */
S#define  CAN_F2R2_FB27                       ((uint32_t)0x08000000)        /*!< Filter bit 27 */
S#define  CAN_F2R2_FB28                       ((uint32_t)0x10000000)        /*!< Filter bit 28 */
S#define  CAN_F2R2_FB29                       ((uint32_t)0x20000000)        /*!< Filter bit 29 */
S#define  CAN_F2R2_FB30                       ((uint32_t)0x40000000)        /*!< Filter bit 30 */
S#define  CAN_F2R2_FB31                       ((uint32_t)0x80000000)        /*!< Filter bit 31 */
S
S/*******************  Bit definition for CAN_F3R2 register  *******************/
S#define  CAN_F3R2_FB0                        ((uint32_t)0x00000001)        /*!< Filter bit 0 */
S#define  CAN_F3R2_FB1                        ((uint32_t)0x00000002)        /*!< Filter bit 1 */
S#define  CAN_F3R2_FB2                        ((uint32_t)0x00000004)        /*!< Filter bit 2 */
S#define  CAN_F3R2_FB3                        ((uint32_t)0x00000008)        /*!< Filter bit 3 */
S#define  CAN_F3R2_FB4                        ((uint32_t)0x00000010)        /*!< Filter bit 4 */
S#define  CAN_F3R2_FB5                        ((uint32_t)0x00000020)        /*!< Filter bit 5 */
S#define  CAN_F3R2_FB6                        ((uint32_t)0x00000040)        /*!< Filter bit 6 */
S#define  CAN_F3R2_FB7                        ((uint32_t)0x00000080)        /*!< Filter bit 7 */
S#define  CAN_F3R2_FB8                        ((uint32_t)0x00000100)        /*!< Filter bit 8 */
S#define  CAN_F3R2_FB9                        ((uint32_t)0x00000200)        /*!< Filter bit 9 */
S#define  CAN_F3R2_FB10                       ((uint32_t)0x00000400)        /*!< Filter bit 10 */
S#define  CAN_F3R2_FB11                       ((uint32_t)0x00000800)        /*!< Filter bit 11 */
S#define  CAN_F3R2_FB12                       ((uint32_t)0x00001000)        /*!< Filter bit 12 */
S#define  CAN_F3R2_FB13                       ((uint32_t)0x00002000)        /*!< Filter bit 13 */
S#define  CAN_F3R2_FB14                       ((uint32_t)0x00004000)        /*!< Filter bit 14 */
S#define  CAN_F3R2_FB15                       ((uint32_t)0x00008000)        /*!< Filter bit 15 */
S#define  CAN_F3R2_FB16                       ((uint32_t)0x00010000)        /*!< Filter bit 16 */
S#define  CAN_F3R2_FB17                       ((uint32_t)0x00020000)        /*!< Filter bit 17 */
S#define  CAN_F3R2_FB18                       ((uint32_t)0x00040000)        /*!< Filter bit 18 */
S#define  CAN_F3R2_FB19                       ((uint32_t)0x00080000)        /*!< Filter bit 19 */
S#define  CAN_F3R2_FB20                       ((uint32_t)0x00100000)        /*!< Filter bit 20 */
S#define  CAN_F3R2_FB21                       ((uint32_t)0x00200000)        /*!< Filter bit 21 */
S#define  CAN_F3R2_FB22                       ((uint32_t)0x00400000)        /*!< Filter bit 22 */
S#define  CAN_F3R2_FB23                       ((uint32_t)0x00800000)        /*!< Filter bit 23 */
S#define  CAN_F3R2_FB24                       ((uint32_t)0x01000000)        /*!< Filter bit 24 */
S#define  CAN_F3R2_FB25                       ((uint32_t)0x02000000)        /*!< Filter bit 25 */
S#define  CAN_F3R2_FB26                       ((uint32_t)0x04000000)        /*!< Filter bit 26 */
S#define  CAN_F3R2_FB27                       ((uint32_t)0x08000000)        /*!< Filter bit 27 */
S#define  CAN_F3R2_FB28                       ((uint32_t)0x10000000)        /*!< Filter bit 28 */
S#define  CAN_F3R2_FB29                       ((uint32_t)0x20000000)        /*!< Filter bit 29 */
S#define  CAN_F3R2_FB30                       ((uint32_t)0x40000000)        /*!< Filter bit 30 */
S#define  CAN_F3R2_FB31                       ((uint32_t)0x80000000)        /*!< Filter bit 31 */
S
S/*******************  Bit definition for CAN_F4R2 register  *******************/
S#define  CAN_F4R2_FB0                        ((uint32_t)0x00000001)        /*!< Filter bit 0 */
S#define  CAN_F4R2_FB1                        ((uint32_t)0x00000002)        /*!< Filter bit 1 */
S#define  CAN_F4R2_FB2                        ((uint32_t)0x00000004)        /*!< Filter bit 2 */
S#define  CAN_F4R2_FB3                        ((uint32_t)0x00000008)        /*!< Filter bit 3 */
S#define  CAN_F4R2_FB4                        ((uint32_t)0x00000010)        /*!< Filter bit 4 */
S#define  CAN_F4R2_FB5                        ((uint32_t)0x00000020)        /*!< Filter bit 5 */
S#define  CAN_F4R2_FB6                        ((uint32_t)0x00000040)        /*!< Filter bit 6 */
S#define  CAN_F4R2_FB7                        ((uint32_t)0x00000080)        /*!< Filter bit 7 */
S#define  CAN_F4R2_FB8                        ((uint32_t)0x00000100)        /*!< Filter bit 8 */
S#define  CAN_F4R2_FB9                        ((uint32_t)0x00000200)        /*!< Filter bit 9 */
S#define  CAN_F4R2_FB10                       ((uint32_t)0x00000400)        /*!< Filter bit 10 */
S#define  CAN_F4R2_FB11                       ((uint32_t)0x00000800)        /*!< Filter bit 11 */
S#define  CAN_F4R2_FB12                       ((uint32_t)0x00001000)        /*!< Filter bit 12 */
S#define  CAN_F4R2_FB13                       ((uint32_t)0x00002000)        /*!< Filter bit 13 */
S#define  CAN_F4R2_FB14                       ((uint32_t)0x00004000)        /*!< Filter bit 14 */
S#define  CAN_F4R2_FB15                       ((uint32_t)0x00008000)        /*!< Filter bit 15 */
S#define  CAN_F4R2_FB16                       ((uint32_t)0x00010000)        /*!< Filter bit 16 */
S#define  CAN_F4R2_FB17                       ((uint32_t)0x00020000)        /*!< Filter bit 17 */
S#define  CAN_F4R2_FB18                       ((uint32_t)0x00040000)        /*!< Filter bit 18 */
S#define  CAN_F4R2_FB19                       ((uint32_t)0x00080000)        /*!< Filter bit 19 */
S#define  CAN_F4R2_FB20                       ((uint32_t)0x00100000)        /*!< Filter bit 20 */
S#define  CAN_F4R2_FB21                       ((uint32_t)0x00200000)        /*!< Filter bit 21 */
S#define  CAN_F4R2_FB22                       ((uint32_t)0x00400000)        /*!< Filter bit 22 */
S#define  CAN_F4R2_FB23                       ((uint32_t)0x00800000)        /*!< Filter bit 23 */
S#define  CAN_F4R2_FB24                       ((uint32_t)0x01000000)        /*!< Filter bit 24 */
S#define  CAN_F4R2_FB25                       ((uint32_t)0x02000000)        /*!< Filter bit 25 */
S#define  CAN_F4R2_FB26                       ((uint32_t)0x04000000)        /*!< Filter bit 26 */
S#define  CAN_F4R2_FB27                       ((uint32_t)0x08000000)        /*!< Filter bit 27 */
S#define  CAN_F4R2_FB28                       ((uint32_t)0x10000000)        /*!< Filter bit 28 */
S#define  CAN_F4R2_FB29                       ((uint32_t)0x20000000)        /*!< Filter bit 29 */
S#define  CAN_F4R2_FB30                       ((uint32_t)0x40000000)        /*!< Filter bit 30 */
S#define  CAN_F4R2_FB31                       ((uint32_t)0x80000000)        /*!< Filter bit 31 */
S
S/*******************  Bit definition for CAN_F5R2 register  *******************/
S#define  CAN_F5R2_FB0                        ((uint32_t)0x00000001)        /*!< Filter bit 0 */
S#define  CAN_F5R2_FB1                        ((uint32_t)0x00000002)        /*!< Filter bit 1 */
S#define  CAN_F5R2_FB2                        ((uint32_t)0x00000004)        /*!< Filter bit 2 */
S#define  CAN_F5R2_FB3                        ((uint32_t)0x00000008)        /*!< Filter bit 3 */
S#define  CAN_F5R2_FB4                        ((uint32_t)0x00000010)        /*!< Filter bit 4 */
S#define  CAN_F5R2_FB5                        ((uint32_t)0x00000020)        /*!< Filter bit 5 */
S#define  CAN_F5R2_FB6                        ((uint32_t)0x00000040)        /*!< Filter bit 6 */
S#define  CAN_F5R2_FB7                        ((uint32_t)0x00000080)        /*!< Filter bit 7 */
S#define  CAN_F5R2_FB8                        ((uint32_t)0x00000100)        /*!< Filter bit 8 */
S#define  CAN_F5R2_FB9                        ((uint32_t)0x00000200)        /*!< Filter bit 9 */
S#define  CAN_F5R2_FB10                       ((uint32_t)0x00000400)        /*!< Filter bit 10 */
S#define  CAN_F5R2_FB11                       ((uint32_t)0x00000800)        /*!< Filter bit 11 */
S#define  CAN_F5R2_FB12                       ((uint32_t)0x00001000)        /*!< Filter bit 12 */
S#define  CAN_F5R2_FB13                       ((uint32_t)0x00002000)        /*!< Filter bit 13 */
S#define  CAN_F5R2_FB14                       ((uint32_t)0x00004000)        /*!< Filter bit 14 */
S#define  CAN_F5R2_FB15                       ((uint32_t)0x00008000)        /*!< Filter bit 15 */
S#define  CAN_F5R2_FB16                       ((uint32_t)0x00010000)        /*!< Filter bit 16 */
S#define  CAN_F5R2_FB17                       ((uint32_t)0x00020000)        /*!< Filter bit 17 */
S#define  CAN_F5R2_FB18                       ((uint32_t)0x00040000)        /*!< Filter bit 18 */
S#define  CAN_F5R2_FB19                       ((uint32_t)0x00080000)        /*!< Filter bit 19 */
S#define  CAN_F5R2_FB20                       ((uint32_t)0x00100000)        /*!< Filter bit 20 */
S#define  CAN_F5R2_FB21                       ((uint32_t)0x00200000)        /*!< Filter bit 21 */
S#define  CAN_F5R2_FB22                       ((uint32_t)0x00400000)        /*!< Filter bit 22 */
S#define  CAN_F5R2_FB23                       ((uint32_t)0x00800000)        /*!< Filter bit 23 */
S#define  CAN_F5R2_FB24                       ((uint32_t)0x01000000)        /*!< Filter bit 24 */
S#define  CAN_F5R2_FB25                       ((uint32_t)0x02000000)        /*!< Filter bit 25 */
S#define  CAN_F5R2_FB26                       ((uint32_t)0x04000000)        /*!< Filter bit 26 */
S#define  CAN_F5R2_FB27                       ((uint32_t)0x08000000)        /*!< Filter bit 27 */
S#define  CAN_F5R2_FB28                       ((uint32_t)0x10000000)        /*!< Filter bit 28 */
S#define  CAN_F5R2_FB29                       ((uint32_t)0x20000000)        /*!< Filter bit 29 */
S#define  CAN_F5R2_FB30                       ((uint32_t)0x40000000)        /*!< Filter bit 30 */
S#define  CAN_F5R2_FB31                       ((uint32_t)0x80000000)        /*!< Filter bit 31 */
S
S/*******************  Bit definition for CAN_F6R2 register  *******************/
S#define  CAN_F6R2_FB0                        ((uint32_t)0x00000001)        /*!< Filter bit 0 */
S#define  CAN_F6R2_FB1                        ((uint32_t)0x00000002)        /*!< Filter bit 1 */
S#define  CAN_F6R2_FB2                        ((uint32_t)0x00000004)        /*!< Filter bit 2 */
S#define  CAN_F6R2_FB3                        ((uint32_t)0x00000008)        /*!< Filter bit 3 */
S#define  CAN_F6R2_FB4                        ((uint32_t)0x00000010)        /*!< Filter bit 4 */
S#define  CAN_F6R2_FB5                        ((uint32_t)0x00000020)        /*!< Filter bit 5 */
S#define  CAN_F6R2_FB6                        ((uint32_t)0x00000040)        /*!< Filter bit 6 */
S#define  CAN_F6R2_FB7                        ((uint32_t)0x00000080)        /*!< Filter bit 7 */
S#define  CAN_F6R2_FB8                        ((uint32_t)0x00000100)        /*!< Filter bit 8 */
S#define  CAN_F6R2_FB9                        ((uint32_t)0x00000200)        /*!< Filter bit 9 */
S#define  CAN_F6R2_FB10                       ((uint32_t)0x00000400)        /*!< Filter bit 10 */
S#define  CAN_F6R2_FB11                       ((uint32_t)0x00000800)        /*!< Filter bit 11 */
S#define  CAN_F6R2_FB12                       ((uint32_t)0x00001000)        /*!< Filter bit 12 */
S#define  CAN_F6R2_FB13                       ((uint32_t)0x00002000)        /*!< Filter bit 13 */
S#define  CAN_F6R2_FB14                       ((uint32_t)0x00004000)        /*!< Filter bit 14 */
S#define  CAN_F6R2_FB15                       ((uint32_t)0x00008000)        /*!< Filter bit 15 */
S#define  CAN_F6R2_FB16                       ((uint32_t)0x00010000)        /*!< Filter bit 16 */
S#define  CAN_F6R2_FB17                       ((uint32_t)0x00020000)        /*!< Filter bit 17 */
S#define  CAN_F6R2_FB18                       ((uint32_t)0x00040000)        /*!< Filter bit 18 */
S#define  CAN_F6R2_FB19                       ((uint32_t)0x00080000)        /*!< Filter bit 19 */
S#define  CAN_F6R2_FB20                       ((uint32_t)0x00100000)        /*!< Filter bit 20 */
S#define  CAN_F6R2_FB21                       ((uint32_t)0x00200000)        /*!< Filter bit 21 */
S#define  CAN_F6R2_FB22                       ((uint32_t)0x00400000)        /*!< Filter bit 22 */
S#define  CAN_F6R2_FB23                       ((uint32_t)0x00800000)        /*!< Filter bit 23 */
S#define  CAN_F6R2_FB24                       ((uint32_t)0x01000000)        /*!< Filter bit 24 */
S#define  CAN_F6R2_FB25                       ((uint32_t)0x02000000)        /*!< Filter bit 25 */
S#define  CAN_F6R2_FB26                       ((uint32_t)0x04000000)        /*!< Filter bit 26 */
S#define  CAN_F6R2_FB27                       ((uint32_t)0x08000000)        /*!< Filter bit 27 */
S#define  CAN_F6R2_FB28                       ((uint32_t)0x10000000)        /*!< Filter bit 28 */
S#define  CAN_F6R2_FB29                       ((uint32_t)0x20000000)        /*!< Filter bit 29 */
S#define  CAN_F6R2_FB30                       ((uint32_t)0x40000000)        /*!< Filter bit 30 */
S#define  CAN_F6R2_FB31                       ((uint32_t)0x80000000)        /*!< Filter bit 31 */
S
S/*******************  Bit definition for CAN_F7R2 register  *******************/
S#define  CAN_F7R2_FB0                        ((uint32_t)0x00000001)        /*!< Filter bit 0 */
S#define  CAN_F7R2_FB1                        ((uint32_t)0x00000002)        /*!< Filter bit 1 */
S#define  CAN_F7R2_FB2                        ((uint32_t)0x00000004)        /*!< Filter bit 2 */
S#define  CAN_F7R2_FB3                        ((uint32_t)0x00000008)        /*!< Filter bit 3 */
S#define  CAN_F7R2_FB4                        ((uint32_t)0x00000010)        /*!< Filter bit 4 */
S#define  CAN_F7R2_FB5                        ((uint32_t)0x00000020)        /*!< Filter bit 5 */
S#define  CAN_F7R2_FB6                        ((uint32_t)0x00000040)        /*!< Filter bit 6 */
S#define  CAN_F7R2_FB7                        ((uint32_t)0x00000080)        /*!< Filter bit 7 */
S#define  CAN_F7R2_FB8                        ((uint32_t)0x00000100)        /*!< Filter bit 8 */
S#define  CAN_F7R2_FB9                        ((uint32_t)0x00000200)        /*!< Filter bit 9 */
S#define  CAN_F7R2_FB10                       ((uint32_t)0x00000400)        /*!< Filter bit 10 */
S#define  CAN_F7R2_FB11                       ((uint32_t)0x00000800)        /*!< Filter bit 11 */
S#define  CAN_F7R2_FB12                       ((uint32_t)0x00001000)        /*!< Filter bit 12 */
S#define  CAN_F7R2_FB13                       ((uint32_t)0x00002000)        /*!< Filter bit 13 */
S#define  CAN_F7R2_FB14                       ((uint32_t)0x00004000)        /*!< Filter bit 14 */
S#define  CAN_F7R2_FB15                       ((uint32_t)0x00008000)        /*!< Filter bit 15 */
S#define  CAN_F7R2_FB16                       ((uint32_t)0x00010000)        /*!< Filter bit 16 */
S#define  CAN_F7R2_FB17                       ((uint32_t)0x00020000)        /*!< Filter bit 17 */
S#define  CAN_F7R2_FB18                       ((uint32_t)0x00040000)        /*!< Filter bit 18 */
S#define  CAN_F7R2_FB19                       ((uint32_t)0x00080000)        /*!< Filter bit 19 */
S#define  CAN_F7R2_FB20                       ((uint32_t)0x00100000)        /*!< Filter bit 20 */
S#define  CAN_F7R2_FB21                       ((uint32_t)0x00200000)        /*!< Filter bit 21 */
S#define  CAN_F7R2_FB22                       ((uint32_t)0x00400000)        /*!< Filter bit 22 */
S#define  CAN_F7R2_FB23                       ((uint32_t)0x00800000)        /*!< Filter bit 23 */
S#define  CAN_F7R2_FB24                       ((uint32_t)0x01000000)        /*!< Filter bit 24 */
S#define  CAN_F7R2_FB25                       ((uint32_t)0x02000000)        /*!< Filter bit 25 */
S#define  CAN_F7R2_FB26                       ((uint32_t)0x04000000)        /*!< Filter bit 26 */
S#define  CAN_F7R2_FB27                       ((uint32_t)0x08000000)        /*!< Filter bit 27 */
S#define  CAN_F7R2_FB28                       ((uint32_t)0x10000000)        /*!< Filter bit 28 */
S#define  CAN_F7R2_FB29                       ((uint32_t)0x20000000)        /*!< Filter bit 29 */
S#define  CAN_F7R2_FB30                       ((uint32_t)0x40000000)        /*!< Filter bit 30 */
S#define  CAN_F7R2_FB31                       ((uint32_t)0x80000000)        /*!< Filter bit 31 */
S
S/*******************  Bit definition for CAN_F8R2 register  *******************/
S#define  CAN_F8R2_FB0                        ((uint32_t)0x00000001)        /*!< Filter bit 0 */
S#define  CAN_F8R2_FB1                        ((uint32_t)0x00000002)        /*!< Filter bit 1 */
S#define  CAN_F8R2_FB2                        ((uint32_t)0x00000004)        /*!< Filter bit 2 */
S#define  CAN_F8R2_FB3                        ((uint32_t)0x00000008)        /*!< Filter bit 3 */
S#define  CAN_F8R2_FB4                        ((uint32_t)0x00000010)        /*!< Filter bit 4 */
S#define  CAN_F8R2_FB5                        ((uint32_t)0x00000020)        /*!< Filter bit 5 */
S#define  CAN_F8R2_FB6                        ((uint32_t)0x00000040)        /*!< Filter bit 6 */
S#define  CAN_F8R2_FB7                        ((uint32_t)0x00000080)        /*!< Filter bit 7 */
S#define  CAN_F8R2_FB8                        ((uint32_t)0x00000100)        /*!< Filter bit 8 */
S#define  CAN_F8R2_FB9                        ((uint32_t)0x00000200)        /*!< Filter bit 9 */
S#define  CAN_F8R2_FB10                       ((uint32_t)0x00000400)        /*!< Filter bit 10 */
S#define  CAN_F8R2_FB11                       ((uint32_t)0x00000800)        /*!< Filter bit 11 */
S#define  CAN_F8R2_FB12                       ((uint32_t)0x00001000)        /*!< Filter bit 12 */
S#define  CAN_F8R2_FB13                       ((uint32_t)0x00002000)        /*!< Filter bit 13 */
S#define  CAN_F8R2_FB14                       ((uint32_t)0x00004000)        /*!< Filter bit 14 */
S#define  CAN_F8R2_FB15                       ((uint32_t)0x00008000)        /*!< Filter bit 15 */
S#define  CAN_F8R2_FB16                       ((uint32_t)0x00010000)        /*!< Filter bit 16 */
S#define  CAN_F8R2_FB17                       ((uint32_t)0x00020000)        /*!< Filter bit 17 */
S#define  CAN_F8R2_FB18                       ((uint32_t)0x00040000)        /*!< Filter bit 18 */
S#define  CAN_F8R2_FB19                       ((uint32_t)0x00080000)        /*!< Filter bit 19 */
S#define  CAN_F8R2_FB20                       ((uint32_t)0x00100000)        /*!< Filter bit 20 */
S#define  CAN_F8R2_FB21                       ((uint32_t)0x00200000)        /*!< Filter bit 21 */
S#define  CAN_F8R2_FB22                       ((uint32_t)0x00400000)        /*!< Filter bit 22 */
S#define  CAN_F8R2_FB23                       ((uint32_t)0x00800000)        /*!< Filter bit 23 */
S#define  CAN_F8R2_FB24                       ((uint32_t)0x01000000)        /*!< Filter bit 24 */
S#define  CAN_F8R2_FB25                       ((uint32_t)0x02000000)        /*!< Filter bit 25 */
S#define  CAN_F8R2_FB26                       ((uint32_t)0x04000000)        /*!< Filter bit 26 */
S#define  CAN_F8R2_FB27                       ((uint32_t)0x08000000)        /*!< Filter bit 27 */
S#define  CAN_F8R2_FB28                       ((uint32_t)0x10000000)        /*!< Filter bit 28 */
S#define  CAN_F8R2_FB29                       ((uint32_t)0x20000000)        /*!< Filter bit 29 */
S#define  CAN_F8R2_FB30                       ((uint32_t)0x40000000)        /*!< Filter bit 30 */
S#define  CAN_F8R2_FB31                       ((uint32_t)0x80000000)        /*!< Filter bit 31 */
S
S/*******************  Bit definition for CAN_F9R2 register  *******************/
S#define  CAN_F9R2_FB0                        ((uint32_t)0x00000001)        /*!< Filter bit 0 */
S#define  CAN_F9R2_FB1                        ((uint32_t)0x00000002)        /*!< Filter bit 1 */
S#define  CAN_F9R2_FB2                        ((uint32_t)0x00000004)        /*!< Filter bit 2 */
S#define  CAN_F9R2_FB3                        ((uint32_t)0x00000008)        /*!< Filter bit 3 */
S#define  CAN_F9R2_FB4                        ((uint32_t)0x00000010)        /*!< Filter bit 4 */
S#define  CAN_F9R2_FB5                        ((uint32_t)0x00000020)        /*!< Filter bit 5 */
S#define  CAN_F9R2_FB6                        ((uint32_t)0x00000040)        /*!< Filter bit 6 */
S#define  CAN_F9R2_FB7                        ((uint32_t)0x00000080)        /*!< Filter bit 7 */
S#define  CAN_F9R2_FB8                        ((uint32_t)0x00000100)        /*!< Filter bit 8 */
S#define  CAN_F9R2_FB9                        ((uint32_t)0x00000200)        /*!< Filter bit 9 */
S#define  CAN_F9R2_FB10                       ((uint32_t)0x00000400)        /*!< Filter bit 10 */
S#define  CAN_F9R2_FB11                       ((uint32_t)0x00000800)        /*!< Filter bit 11 */
S#define  CAN_F9R2_FB12                       ((uint32_t)0x00001000)        /*!< Filter bit 12 */
S#define  CAN_F9R2_FB13                       ((uint32_t)0x00002000)        /*!< Filter bit 13 */
S#define  CAN_F9R2_FB14                       ((uint32_t)0x00004000)        /*!< Filter bit 14 */
S#define  CAN_F9R2_FB15                       ((uint32_t)0x00008000)        /*!< Filter bit 15 */
S#define  CAN_F9R2_FB16                       ((uint32_t)0x00010000)        /*!< Filter bit 16 */
S#define  CAN_F9R2_FB17                       ((uint32_t)0x00020000)        /*!< Filter bit 17 */
S#define  CAN_F9R2_FB18                       ((uint32_t)0x00040000)        /*!< Filter bit 18 */
S#define  CAN_F9R2_FB19                       ((uint32_t)0x00080000)        /*!< Filter bit 19 */
S#define  CAN_F9R2_FB20                       ((uint32_t)0x00100000)        /*!< Filter bit 20 */
S#define  CAN_F9R2_FB21                       ((uint32_t)0x00200000)        /*!< Filter bit 21 */
S#define  CAN_F9R2_FB22                       ((uint32_t)0x00400000)        /*!< Filter bit 22 */
S#define  CAN_F9R2_FB23                       ((uint32_t)0x00800000)        /*!< Filter bit 23 */
S#define  CAN_F9R2_FB24                       ((uint32_t)0x01000000)        /*!< Filter bit 24 */
S#define  CAN_F9R2_FB25                       ((uint32_t)0x02000000)        /*!< Filter bit 25 */
S#define  CAN_F9R2_FB26                       ((uint32_t)0x04000000)        /*!< Filter bit 26 */
S#define  CAN_F9R2_FB27                       ((uint32_t)0x08000000)        /*!< Filter bit 27 */
S#define  CAN_F9R2_FB28                       ((uint32_t)0x10000000)        /*!< Filter bit 28 */
S#define  CAN_F9R2_FB29                       ((uint32_t)0x20000000)        /*!< Filter bit 29 */
S#define  CAN_F9R2_FB30                       ((uint32_t)0x40000000)        /*!< Filter bit 30 */
S#define  CAN_F9R2_FB31                       ((uint32_t)0x80000000)        /*!< Filter bit 31 */
S
S/*******************  Bit definition for CAN_F10R2 register  ******************/
S#define  CAN_F10R2_FB0                       ((uint32_t)0x00000001)        /*!< Filter bit 0 */
S#define  CAN_F10R2_FB1                       ((uint32_t)0x00000002)        /*!< Filter bit 1 */
S#define  CAN_F10R2_FB2                       ((uint32_t)0x00000004)        /*!< Filter bit 2 */
S#define  CAN_F10R2_FB3                       ((uint32_t)0x00000008)        /*!< Filter bit 3 */
S#define  CAN_F10R2_FB4                       ((uint32_t)0x00000010)        /*!< Filter bit 4 */
S#define  CAN_F10R2_FB5                       ((uint32_t)0x00000020)        /*!< Filter bit 5 */
S#define  CAN_F10R2_FB6                       ((uint32_t)0x00000040)        /*!< Filter bit 6 */
S#define  CAN_F10R2_FB7                       ((uint32_t)0x00000080)        /*!< Filter bit 7 */
S#define  CAN_F10R2_FB8                       ((uint32_t)0x00000100)        /*!< Filter bit 8 */
S#define  CAN_F10R2_FB9                       ((uint32_t)0x00000200)        /*!< Filter bit 9 */
S#define  CAN_F10R2_FB10                      ((uint32_t)0x00000400)        /*!< Filter bit 10 */
S#define  CAN_F10R2_FB11                      ((uint32_t)0x00000800)        /*!< Filter bit 11 */
S#define  CAN_F10R2_FB12                      ((uint32_t)0x00001000)        /*!< Filter bit 12 */
S#define  CAN_F10R2_FB13                      ((uint32_t)0x00002000)        /*!< Filter bit 13 */
S#define  CAN_F10R2_FB14                      ((uint32_t)0x00004000)        /*!< Filter bit 14 */
S#define  CAN_F10R2_FB15                      ((uint32_t)0x00008000)        /*!< Filter bit 15 */
S#define  CAN_F10R2_FB16                      ((uint32_t)0x00010000)        /*!< Filter bit 16 */
S#define  CAN_F10R2_FB17                      ((uint32_t)0x00020000)        /*!< Filter bit 17 */
S#define  CAN_F10R2_FB18                      ((uint32_t)0x00040000)        /*!< Filter bit 18 */
S#define  CAN_F10R2_FB19                      ((uint32_t)0x00080000)        /*!< Filter bit 19 */
S#define  CAN_F10R2_FB20                      ((uint32_t)0x00100000)        /*!< Filter bit 20 */
S#define  CAN_F10R2_FB21                      ((uint32_t)0x00200000)        /*!< Filter bit 21 */
S#define  CAN_F10R2_FB22                      ((uint32_t)0x00400000)        /*!< Filter bit 22 */
S#define  CAN_F10R2_FB23                      ((uint32_t)0x00800000)        /*!< Filter bit 23 */
S#define  CAN_F10R2_FB24                      ((uint32_t)0x01000000)        /*!< Filter bit 24 */
S#define  CAN_F10R2_FB25                      ((uint32_t)0x02000000)        /*!< Filter bit 25 */
S#define  CAN_F10R2_FB26                      ((uint32_t)0x04000000)        /*!< Filter bit 26 */
S#define  CAN_F10R2_FB27                      ((uint32_t)0x08000000)        /*!< Filter bit 27 */
S#define  CAN_F10R2_FB28                      ((uint32_t)0x10000000)        /*!< Filter bit 28 */
S#define  CAN_F10R2_FB29                      ((uint32_t)0x20000000)        /*!< Filter bit 29 */
S#define  CAN_F10R2_FB30                      ((uint32_t)0x40000000)        /*!< Filter bit 30 */
S#define  CAN_F10R2_FB31                      ((uint32_t)0x80000000)        /*!< Filter bit 31 */
S
S/*******************  Bit definition for CAN_F11R2 register  ******************/
S#define  CAN_F11R2_FB0                       ((uint32_t)0x00000001)        /*!< Filter bit 0 */
S#define  CAN_F11R2_FB1                       ((uint32_t)0x00000002)        /*!< Filter bit 1 */
S#define  CAN_F11R2_FB2                       ((uint32_t)0x00000004)        /*!< Filter bit 2 */
S#define  CAN_F11R2_FB3                       ((uint32_t)0x00000008)        /*!< Filter bit 3 */
S#define  CAN_F11R2_FB4                       ((uint32_t)0x00000010)        /*!< Filter bit 4 */
S#define  CAN_F11R2_FB5                       ((uint32_t)0x00000020)        /*!< Filter bit 5 */
S#define  CAN_F11R2_FB6                       ((uint32_t)0x00000040)        /*!< Filter bit 6 */
S#define  CAN_F11R2_FB7                       ((uint32_t)0x00000080)        /*!< Filter bit 7 */
S#define  CAN_F11R2_FB8                       ((uint32_t)0x00000100)        /*!< Filter bit 8 */
S#define  CAN_F11R2_FB9                       ((uint32_t)0x00000200)        /*!< Filter bit 9 */
S#define  CAN_F11R2_FB10                      ((uint32_t)0x00000400)        /*!< Filter bit 10 */
S#define  CAN_F11R2_FB11                      ((uint32_t)0x00000800)        /*!< Filter bit 11 */
S#define  CAN_F11R2_FB12                      ((uint32_t)0x00001000)        /*!< Filter bit 12 */
S#define  CAN_F11R2_FB13                      ((uint32_t)0x00002000)        /*!< Filter bit 13 */
S#define  CAN_F11R2_FB14                      ((uint32_t)0x00004000)        /*!< Filter bit 14 */
S#define  CAN_F11R2_FB15                      ((uint32_t)0x00008000)        /*!< Filter bit 15 */
S#define  CAN_F11R2_FB16                      ((uint32_t)0x00010000)        /*!< Filter bit 16 */
S#define  CAN_F11R2_FB17                      ((uint32_t)0x00020000)        /*!< Filter bit 17 */
S#define  CAN_F11R2_FB18                      ((uint32_t)0x00040000)        /*!< Filter bit 18 */
S#define  CAN_F11R2_FB19                      ((uint32_t)0x00080000)        /*!< Filter bit 19 */
S#define  CAN_F11R2_FB20                      ((uint32_t)0x00100000)        /*!< Filter bit 20 */
S#define  CAN_F11R2_FB21                      ((uint32_t)0x00200000)        /*!< Filter bit 21 */
S#define  CAN_F11R2_FB22                      ((uint32_t)0x00400000)        /*!< Filter bit 22 */
S#define  CAN_F11R2_FB23                      ((uint32_t)0x00800000)        /*!< Filter bit 23 */
S#define  CAN_F11R2_FB24                      ((uint32_t)0x01000000)        /*!< Filter bit 24 */
S#define  CAN_F11R2_FB25                      ((uint32_t)0x02000000)        /*!< Filter bit 25 */
S#define  CAN_F11R2_FB26                      ((uint32_t)0x04000000)        /*!< Filter bit 26 */
S#define  CAN_F11R2_FB27                      ((uint32_t)0x08000000)        /*!< Filter bit 27 */
S#define  CAN_F11R2_FB28                      ((uint32_t)0x10000000)        /*!< Filter bit 28 */
S#define  CAN_F11R2_FB29                      ((uint32_t)0x20000000)        /*!< Filter bit 29 */
S#define  CAN_F11R2_FB30                      ((uint32_t)0x40000000)        /*!< Filter bit 30 */
S#define  CAN_F11R2_FB31                      ((uint32_t)0x80000000)        /*!< Filter bit 31 */
S
S/*******************  Bit definition for CAN_F12R2 register  ******************/
S#define  CAN_F12R2_FB0                       ((uint32_t)0x00000001)        /*!< Filter bit 0 */
S#define  CAN_F12R2_FB1                       ((uint32_t)0x00000002)        /*!< Filter bit 1 */
S#define  CAN_F12R2_FB2                       ((uint32_t)0x00000004)        /*!< Filter bit 2 */
S#define  CAN_F12R2_FB3                       ((uint32_t)0x00000008)        /*!< Filter bit 3 */
S#define  CAN_F12R2_FB4                       ((uint32_t)0x00000010)        /*!< Filter bit 4 */
S#define  CAN_F12R2_FB5                       ((uint32_t)0x00000020)        /*!< Filter bit 5 */
S#define  CAN_F12R2_FB6                       ((uint32_t)0x00000040)        /*!< Filter bit 6 */
S#define  CAN_F12R2_FB7                       ((uint32_t)0x00000080)        /*!< Filter bit 7 */
S#define  CAN_F12R2_FB8                       ((uint32_t)0x00000100)        /*!< Filter bit 8 */
S#define  CAN_F12R2_FB9                       ((uint32_t)0x00000200)        /*!< Filter bit 9 */
S#define  CAN_F12R2_FB10                      ((uint32_t)0x00000400)        /*!< Filter bit 10 */
S#define  CAN_F12R2_FB11                      ((uint32_t)0x00000800)        /*!< Filter bit 11 */
S#define  CAN_F12R2_FB12                      ((uint32_t)0x00001000)        /*!< Filter bit 12 */
S#define  CAN_F12R2_FB13                      ((uint32_t)0x00002000)        /*!< Filter bit 13 */
S#define  CAN_F12R2_FB14                      ((uint32_t)0x00004000)        /*!< Filter bit 14 */
S#define  CAN_F12R2_FB15                      ((uint32_t)0x00008000)        /*!< Filter bit 15 */
S#define  CAN_F12R2_FB16                      ((uint32_t)0x00010000)        /*!< Filter bit 16 */
S#define  CAN_F12R2_FB17                      ((uint32_t)0x00020000)        /*!< Filter bit 17 */
S#define  CAN_F12R2_FB18                      ((uint32_t)0x00040000)        /*!< Filter bit 18 */
S#define  CAN_F12R2_FB19                      ((uint32_t)0x00080000)        /*!< Filter bit 19 */
S#define  CAN_F12R2_FB20                      ((uint32_t)0x00100000)        /*!< Filter bit 20 */
S#define  CAN_F12R2_FB21                      ((uint32_t)0x00200000)        /*!< Filter bit 21 */
S#define  CAN_F12R2_FB22                      ((uint32_t)0x00400000)        /*!< Filter bit 22 */
S#define  CAN_F12R2_FB23                      ((uint32_t)0x00800000)        /*!< Filter bit 23 */
S#define  CAN_F12R2_FB24                      ((uint32_t)0x01000000)        /*!< Filter bit 24 */
S#define  CAN_F12R2_FB25                      ((uint32_t)0x02000000)        /*!< Filter bit 25 */
S#define  CAN_F12R2_FB26                      ((uint32_t)0x04000000)        /*!< Filter bit 26 */
S#define  CAN_F12R2_FB27                      ((uint32_t)0x08000000)        /*!< Filter bit 27 */
S#define  CAN_F12R2_FB28                      ((uint32_t)0x10000000)        /*!< Filter bit 28 */
S#define  CAN_F12R2_FB29                      ((uint32_t)0x20000000)        /*!< Filter bit 29 */
S#define  CAN_F12R2_FB30                      ((uint32_t)0x40000000)        /*!< Filter bit 30 */
S#define  CAN_F12R2_FB31                      ((uint32_t)0x80000000)        /*!< Filter bit 31 */
S
S/*******************  Bit definition for CAN_F13R2 register  ******************/
S#define  CAN_F13R2_FB0                       ((uint32_t)0x00000001)        /*!< Filter bit 0 */
S#define  CAN_F13R2_FB1                       ((uint32_t)0x00000002)        /*!< Filter bit 1 */
S#define  CAN_F13R2_FB2                       ((uint32_t)0x00000004)        /*!< Filter bit 2 */
S#define  CAN_F13R2_FB3                       ((uint32_t)0x00000008)        /*!< Filter bit 3 */
S#define  CAN_F13R2_FB4                       ((uint32_t)0x00000010)        /*!< Filter bit 4 */
S#define  CAN_F13R2_FB5                       ((uint32_t)0x00000020)        /*!< Filter bit 5 */
S#define  CAN_F13R2_FB6                       ((uint32_t)0x00000040)        /*!< Filter bit 6 */
S#define  CAN_F13R2_FB7                       ((uint32_t)0x00000080)        /*!< Filter bit 7 */
S#define  CAN_F13R2_FB8                       ((uint32_t)0x00000100)        /*!< Filter bit 8 */
S#define  CAN_F13R2_FB9                       ((uint32_t)0x00000200)        /*!< Filter bit 9 */
S#define  CAN_F13R2_FB10                      ((uint32_t)0x00000400)        /*!< Filter bit 10 */
S#define  CAN_F13R2_FB11                      ((uint32_t)0x00000800)        /*!< Filter bit 11 */
S#define  CAN_F13R2_FB12                      ((uint32_t)0x00001000)        /*!< Filter bit 12 */
S#define  CAN_F13R2_FB13                      ((uint32_t)0x00002000)        /*!< Filter bit 13 */
S#define  CAN_F13R2_FB14                      ((uint32_t)0x00004000)        /*!< Filter bit 14 */
S#define  CAN_F13R2_FB15                      ((uint32_t)0x00008000)        /*!< Filter bit 15 */
S#define  CAN_F13R2_FB16                      ((uint32_t)0x00010000)        /*!< Filter bit 16 */
S#define  CAN_F13R2_FB17                      ((uint32_t)0x00020000)        /*!< Filter bit 17 */
S#define  CAN_F13R2_FB18                      ((uint32_t)0x00040000)        /*!< Filter bit 18 */
S#define  CAN_F13R2_FB19                      ((uint32_t)0x00080000)        /*!< Filter bit 19 */
S#define  CAN_F13R2_FB20                      ((uint32_t)0x00100000)        /*!< Filter bit 20 */
S#define  CAN_F13R2_FB21                      ((uint32_t)0x00200000)        /*!< Filter bit 21 */
S#define  CAN_F13R2_FB22                      ((uint32_t)0x00400000)        /*!< Filter bit 22 */
S#define  CAN_F13R2_FB23                      ((uint32_t)0x00800000)        /*!< Filter bit 23 */
S#define  CAN_F13R2_FB24                      ((uint32_t)0x01000000)        /*!< Filter bit 24 */
S#define  CAN_F13R2_FB25                      ((uint32_t)0x02000000)        /*!< Filter bit 25 */
S#define  CAN_F13R2_FB26                      ((uint32_t)0x04000000)        /*!< Filter bit 26 */
S#define  CAN_F13R2_FB27                      ((uint32_t)0x08000000)        /*!< Filter bit 27 */
S#define  CAN_F13R2_FB28                      ((uint32_t)0x10000000)        /*!< Filter bit 28 */
S#define  CAN_F13R2_FB29                      ((uint32_t)0x20000000)        /*!< Filter bit 29 */
S#define  CAN_F13R2_FB30                      ((uint32_t)0x40000000)        /*!< Filter bit 30 */
S#define  CAN_F13R2_FB31                      ((uint32_t)0x80000000)        /*!< Filter bit 31 */
S
S/******************************************************************************/
S/*                                                                            */
S/*                        Serial Peripheral Interface                         */
S/*                                                                            */
S/******************************************************************************/
S
S/*******************  Bit definition for SPI_CR1 register  ********************/
S#define  SPI_CR1_CPHA                        ((uint16_t)0x0001)            /*!< Clock Phase */
S#define  SPI_CR1_CPOL                        ((uint16_t)0x0002)            /*!< Clock Polarity */
S#define  SPI_CR1_MSTR                        ((uint16_t)0x0004)            /*!< Master Selection */
S
S#define  SPI_CR1_BR                          ((uint16_t)0x0038)            /*!< BR[2:0] bits (Baud Rate Control) */
S#define  SPI_CR1_BR_0                        ((uint16_t)0x0008)            /*!< Bit 0 */
S#define  SPI_CR1_BR_1                        ((uint16_t)0x0010)            /*!< Bit 1 */
S#define  SPI_CR1_BR_2                        ((uint16_t)0x0020)            /*!< Bit 2 */
S
S#define  SPI_CR1_SPE                         ((uint16_t)0x0040)            /*!< SPI Enable */
S#define  SPI_CR1_LSBFIRST                    ((uint16_t)0x0080)            /*!< Frame Format */
S#define  SPI_CR1_SSI                         ((uint16_t)0x0100)            /*!< Internal slave select */
S#define  SPI_CR1_SSM                         ((uint16_t)0x0200)            /*!< Software slave management */
S#define  SPI_CR1_RXONLY                      ((uint16_t)0x0400)            /*!< Receive only */
S#define  SPI_CR1_DFF                         ((uint16_t)0x0800)            /*!< Data Frame Format */
S#define  SPI_CR1_CRCNEXT                     ((uint16_t)0x1000)            /*!< Transmit CRC next */
S#define  SPI_CR1_CRCEN                       ((uint16_t)0x2000)            /*!< Hardware CRC calculation enable */
S#define  SPI_CR1_BIDIOE                      ((uint16_t)0x4000)            /*!< Output enable in bidirectional mode */
S#define  SPI_CR1_BIDIMODE                    ((uint16_t)0x8000)            /*!< Bidirectional data mode enable */
S
S/*******************  Bit definition for SPI_CR2 register  ********************/
S#define  SPI_CR2_RXDMAEN                     ((uint8_t)0x01)               /*!< Rx Buffer DMA Enable */
S#define  SPI_CR2_TXDMAEN                     ((uint8_t)0x02)               /*!< Tx Buffer DMA Enable */
S#define  SPI_CR2_SSOE                        ((uint8_t)0x04)               /*!< SS Output Enable */
S#define  SPI_CR2_ERRIE                       ((uint8_t)0x20)               /*!< Error Interrupt Enable */
S#define  SPI_CR2_RXNEIE                      ((uint8_t)0x40)               /*!< RX buffer Not Empty Interrupt Enable */
S#define  SPI_CR2_TXEIE                       ((uint8_t)0x80)               /*!< Tx buffer Empty Interrupt Enable */
S
S/********************  Bit definition for SPI_SR register  ********************/
S#define  SPI_SR_RXNE                         ((uint8_t)0x01)               /*!< Receive buffer Not Empty */
S#define  SPI_SR_TXE                          ((uint8_t)0x02)               /*!< Transmit buffer Empty */
S#define  SPI_SR_CHSIDE                       ((uint8_t)0x04)               /*!< Channel side */
S#define  SPI_SR_UDR                          ((uint8_t)0x08)               /*!< Underrun flag */
S#define  SPI_SR_CRCERR                       ((uint8_t)0x10)               /*!< CRC Error flag */
S#define  SPI_SR_MODF                         ((uint8_t)0x20)               /*!< Mode fault */
S#define  SPI_SR_OVR                          ((uint8_t)0x40)               /*!< Overrun flag */
S#define  SPI_SR_BSY                          ((uint8_t)0x80)               /*!< Busy flag */
S
S/********************  Bit definition for SPI_DR register  ********************/
S#define  SPI_DR_DR                           ((uint16_t)0xFFFF)            /*!< Data Register */
S
S/*******************  Bit definition for SPI_CRCPR register  ******************/
S#define  SPI_CRCPR_CRCPOLY                   ((uint16_t)0xFFFF)            /*!< CRC polynomial register */
S
S/******************  Bit definition for SPI_RXCRCR register  ******************/
S#define  SPI_RXCRCR_RXCRC                    ((uint16_t)0xFFFF)            /*!< Rx CRC Register */
S
S/******************  Bit definition for SPI_TXCRCR register  ******************/
S#define  SPI_TXCRCR_TXCRC                    ((uint16_t)0xFFFF)            /*!< Tx CRC Register */
S
S/******************  Bit definition for SPI_I2SCFGR register  *****************/
S#define  SPI_I2SCFGR_CHLEN                   ((uint16_t)0x0001)            /*!< Channel length (number of bits per audio channel) */
S
S#define  SPI_I2SCFGR_DATLEN                  ((uint16_t)0x0006)            /*!< DATLEN[1:0] bits (Data length to be transferred) */
S#define  SPI_I2SCFGR_DATLEN_0                ((uint16_t)0x0002)            /*!< Bit 0 */
S#define  SPI_I2SCFGR_DATLEN_1                ((uint16_t)0x0004)            /*!< Bit 1 */
S
S#define  SPI_I2SCFGR_CKPOL                   ((uint16_t)0x0008)            /*!< steady state clock polarity */
S
S#define  SPI_I2SCFGR_I2SSTD                  ((uint16_t)0x0030)            /*!< I2SSTD[1:0] bits (I2S standard selection) */
S#define  SPI_I2SCFGR_I2SSTD_0                ((uint16_t)0x0010)            /*!< Bit 0 */
S#define  SPI_I2SCFGR_I2SSTD_1                ((uint16_t)0x0020)            /*!< Bit 1 */
S
S#define  SPI_I2SCFGR_PCMSYNC                 ((uint16_t)0x0080)            /*!< PCM frame synchronization */
S
S#define  SPI_I2SCFGR_I2SCFG                  ((uint16_t)0x0300)            /*!< I2SCFG[1:0] bits (I2S configuration mode) */
S#define  SPI_I2SCFGR_I2SCFG_0                ((uint16_t)0x0100)            /*!< Bit 0 */
S#define  SPI_I2SCFGR_I2SCFG_1                ((uint16_t)0x0200)            /*!< Bit 1 */
S
S#define  SPI_I2SCFGR_I2SE                    ((uint16_t)0x0400)            /*!< I2S Enable */
S#define  SPI_I2SCFGR_I2SMOD                  ((uint16_t)0x0800)            /*!< I2S mode selection */
S
S/******************  Bit definition for SPI_I2SPR register  *******************/
S#define  SPI_I2SPR_I2SDIV                    ((uint16_t)0x00FF)            /*!< I2S Linear prescaler */
S#define  SPI_I2SPR_ODD                       ((uint16_t)0x0100)            /*!< Odd factor for the prescaler */
S#define  SPI_I2SPR_MCKOE                     ((uint16_t)0x0200)            /*!< Master Clock Output Enable */
S
S/******************************************************************************/
S/*                                                                            */
S/*                      Inter-integrated Circuit Interface                    */
S/*                                                                            */
S/******************************************************************************/
S
S/*******************  Bit definition for I2C_CR1 register  ********************/
S#define  I2C_CR1_PE                          ((uint16_t)0x0001)            /*!< Peripheral Enable */
S#define  I2C_CR1_SMBUS                       ((uint16_t)0x0002)            /*!< SMBus Mode */
S#define  I2C_CR1_SMBTYPE                     ((uint16_t)0x0008)            /*!< SMBus Type */
S#define  I2C_CR1_ENARP                       ((uint16_t)0x0010)            /*!< ARP Enable */
S#define  I2C_CR1_ENPEC                       ((uint16_t)0x0020)            /*!< PEC Enable */
S#define  I2C_CR1_ENGC                        ((uint16_t)0x0040)            /*!< General Call Enable */
S#define  I2C_CR1_NOSTRETCH                   ((uint16_t)0x0080)            /*!< Clock Stretching Disable (Slave mode) */
S#define  I2C_CR1_START                       ((uint16_t)0x0100)            /*!< Start Generation */
S#define  I2C_CR1_STOP                        ((uint16_t)0x0200)            /*!< Stop Generation */
S#define  I2C_CR1_ACK                         ((uint16_t)0x0400)            /*!< Acknowledge Enable */
S#define  I2C_CR1_POS                         ((uint16_t)0x0800)            /*!< Acknowledge/PEC Position (for data reception) */
S#define  I2C_CR1_PEC                         ((uint16_t)0x1000)            /*!< Packet Error Checking */
S#define  I2C_CR1_ALERT                       ((uint16_t)0x2000)            /*!< SMBus Alert */
S#define  I2C_CR1_SWRST                       ((uint16_t)0x8000)            /*!< Software Reset */
S
S/*******************  Bit definition for I2C_CR2 register  ********************/
S#define  I2C_CR2_FREQ                        ((uint16_t)0x003F)            /*!< FREQ[5:0] bits (Peripheral Clock Frequency) */
S#define  I2C_CR2_FREQ_0                      ((uint16_t)0x0001)            /*!< Bit 0 */
S#define  I2C_CR2_FREQ_1                      ((uint16_t)0x0002)            /*!< Bit 1 */
S#define  I2C_CR2_FREQ_2                      ((uint16_t)0x0004)            /*!< Bit 2 */
S#define  I2C_CR2_FREQ_3                      ((uint16_t)0x0008)            /*!< Bit 3 */
S#define  I2C_CR2_FREQ_4                      ((uint16_t)0x0010)            /*!< Bit 4 */
S#define  I2C_CR2_FREQ_5                      ((uint16_t)0x0020)            /*!< Bit 5 */
S
S#define  I2C_CR2_ITERREN                     ((uint16_t)0x0100)            /*!< Error Interrupt Enable */
S#define  I2C_CR2_ITEVTEN                     ((uint16_t)0x0200)            /*!< Event Interrupt Enable */
S#define  I2C_CR2_ITBUFEN                     ((uint16_t)0x0400)            /*!< Buffer Interrupt Enable */
S#define  I2C_CR2_DMAEN                       ((uint16_t)0x0800)            /*!< DMA Requests Enable */
S#define  I2C_CR2_LAST                        ((uint16_t)0x1000)            /*!< DMA Last Transfer */
S
S/*******************  Bit definition for I2C_OAR1 register  *******************/
S#define  I2C_OAR1_ADD1_7                     ((uint16_t)0x00FE)            /*!< Interface Address */
S#define  I2C_OAR1_ADD8_9                     ((uint16_t)0x0300)            /*!< Interface Address */
S
S#define  I2C_OAR1_ADD0                       ((uint16_t)0x0001)            /*!< Bit 0 */
S#define  I2C_OAR1_ADD1                       ((uint16_t)0x0002)            /*!< Bit 1 */
S#define  I2C_OAR1_ADD2                       ((uint16_t)0x0004)            /*!< Bit 2 */
S#define  I2C_OAR1_ADD3                       ((uint16_t)0x0008)            /*!< Bit 3 */
S#define  I2C_OAR1_ADD4                       ((uint16_t)0x0010)            /*!< Bit 4 */
S#define  I2C_OAR1_ADD5                       ((uint16_t)0x0020)            /*!< Bit 5 */
S#define  I2C_OAR1_ADD6                       ((uint16_t)0x0040)            /*!< Bit 6 */
S#define  I2C_OAR1_ADD7                       ((uint16_t)0x0080)            /*!< Bit 7 */
S#define  I2C_OAR1_ADD8                       ((uint16_t)0x0100)            /*!< Bit 8 */
S#define  I2C_OAR1_ADD9                       ((uint16_t)0x0200)            /*!< Bit 9 */
S
S#define  I2C_OAR1_ADDMODE                    ((uint16_t)0x8000)            /*!< Addressing Mode (Slave mode) */
S
S/*******************  Bit definition for I2C_OAR2 register  *******************/
S#define  I2C_OAR2_ENDUAL                     ((uint8_t)0x01)               /*!< Dual addressing mode enable */
S#define  I2C_OAR2_ADD2                       ((uint8_t)0xFE)               /*!< Interface address */
S
S/********************  Bit definition for I2C_DR register  ********************/
S#define  I2C_DR_DR                           ((uint8_t)0xFF)               /*!< 8-bit Data Register */
S
S/*******************  Bit definition for I2C_SR1 register  ********************/
S#define  I2C_SR1_SB                          ((uint16_t)0x0001)            /*!< Start Bit (Master mode) */
S#define  I2C_SR1_ADDR                        ((uint16_t)0x0002)            /*!< Address sent (master mode)/matched (slave mode) */
S#define  I2C_SR1_BTF                         ((uint16_t)0x0004)            /*!< Byte Transfer Finished */
S#define  I2C_SR1_ADD10                       ((uint16_t)0x0008)            /*!< 10-bit header sent (Master mode) */
S#define  I2C_SR1_STOPF                       ((uint16_t)0x0010)            /*!< Stop detection (Slave mode) */
S#define  I2C_SR1_RXNE                        ((uint16_t)0x0040)            /*!< Data Register not Empty (receivers) */
S#define  I2C_SR1_TXE                         ((uint16_t)0x0080)            /*!< Data Register Empty (transmitters) */
S#define  I2C_SR1_BERR                        ((uint16_t)0x0100)            /*!< Bus Error */
S#define  I2C_SR1_ARLO                        ((uint16_t)0x0200)            /*!< Arbitration Lost (master mode) */
S#define  I2C_SR1_AF                          ((uint16_t)0x0400)            /*!< Acknowledge Failure */
S#define  I2C_SR1_OVR                         ((uint16_t)0x0800)            /*!< Overrun/Underrun */
S#define  I2C_SR1_PECERR                      ((uint16_t)0x1000)            /*!< PEC Error in reception */
S#define  I2C_SR1_TIMEOUT                     ((uint16_t)0x4000)            /*!< Timeout or Tlow Error */
S#define  I2C_SR1_SMBALERT                    ((uint16_t)0x8000)            /*!< SMBus Alert */
S
S/*******************  Bit definition for I2C_SR2 register  ********************/
S#define  I2C_SR2_MSL                         ((uint16_t)0x0001)            /*!< Master/Slave */
S#define  I2C_SR2_BUSY                        ((uint16_t)0x0002)            /*!< Bus Busy */
S#define  I2C_SR2_TRA                         ((uint16_t)0x0004)            /*!< Transmitter/Receiver */
S#define  I2C_SR2_GENCALL                     ((uint16_t)0x0010)            /*!< General Call Address (Slave mode) */
S#define  I2C_SR2_SMBDEFAULT                  ((uint16_t)0x0020)            /*!< SMBus Device Default Address (Slave mode) */
S#define  I2C_SR2_SMBHOST                     ((uint16_t)0x0040)            /*!< SMBus Host Header (Slave mode) */
S#define  I2C_SR2_DUALF                       ((uint16_t)0x0080)            /*!< Dual Flag (Slave mode) */
S#define  I2C_SR2_PEC                         ((uint16_t)0xFF00)            /*!< Packet Error Checking Register */
S
S/*******************  Bit definition for I2C_CCR register  ********************/
S#define  I2C_CCR_CCR                         ((uint16_t)0x0FFF)            /*!< Clock Control Register in Fast/Standard mode (Master mode) */
S#define  I2C_CCR_DUTY                        ((uint16_t)0x4000)            /*!< Fast Mode Duty Cycle */
S#define  I2C_CCR_FS                          ((uint16_t)0x8000)            /*!< I2C Master Mode Selection */
S
S/******************  Bit definition for I2C_TRISE register  *******************/
S#define  I2C_TRISE_TRISE                     ((uint8_t)0x3F)               /*!< Maximum Rise Time in Fast/Standard mode (Master mode) */
S
S/******************************************************************************/
S/*                                                                            */
S/*         Universal Synchronous Asynchronous Receiver Transmitter            */
S/*                                                                            */
S/******************************************************************************/
S
S/*******************  Bit definition for USART_SR register  *******************/
S#define  USART_SR_PE                         ((uint16_t)0x0001)            /*!< Parity Error */
S#define  USART_SR_FE                         ((uint16_t)0x0002)            /*!< Framing Error */
S#define  USART_SR_NE                         ((uint16_t)0x0004)            /*!< Noise Error Flag */
S#define  USART_SR_ORE                        ((uint16_t)0x0008)            /*!< OverRun Error */
S#define  USART_SR_IDLE                       ((uint16_t)0x0010)            /*!< IDLE line detected */
S#define  USART_SR_RXNE                       ((uint16_t)0x0020)            /*!< Read Data Register Not Empty */
S#define  USART_SR_TC                         ((uint16_t)0x0040)            /*!< Transmission Complete */
S#define  USART_SR_TXE                        ((uint16_t)0x0080)            /*!< Transmit Data Register Empty */
S#define  USART_SR_LBD                        ((uint16_t)0x0100)            /*!< LIN Break Detection Flag */
S#define  USART_SR_CTS                        ((uint16_t)0x0200)            /*!< CTS Flag */
S
S/*******************  Bit definition for USART_DR register  *******************/
S#define  USART_DR_DR                         ((uint16_t)0x01FF)            /*!< Data value */
S
S/******************  Bit definition for USART_BRR register  *******************/
S#define  USART_BRR_DIV_Fraction              ((uint16_t)0x000F)            /*!< Fraction of USARTDIV */
S#define  USART_BRR_DIV_Mantissa              ((uint16_t)0xFFF0)            /*!< Mantissa of USARTDIV */
S
S/******************  Bit definition for USART_CR1 register  *******************/
S#define  USART_CR1_SBK                       ((uint16_t)0x0001)            /*!< Send Break */
S#define  USART_CR1_RWU                       ((uint16_t)0x0002)            /*!< Receiver wakeup */
S#define  USART_CR1_RE                        ((uint16_t)0x0004)            /*!< Receiver Enable */
S#define  USART_CR1_TE                        ((uint16_t)0x0008)            /*!< Transmitter Enable */
S#define  USART_CR1_IDLEIE                    ((uint16_t)0x0010)            /*!< IDLE Interrupt Enable */
S#define  USART_CR1_RXNEIE                    ((uint16_t)0x0020)            /*!< RXNE Interrupt Enable */
S#define  USART_CR1_TCIE                      ((uint16_t)0x0040)            /*!< Transmission Complete Interrupt Enable */
S#define  USART_CR1_TXEIE                     ((uint16_t)0x0080)            /*!< PE Interrupt Enable */
S#define  USART_CR1_PEIE                      ((uint16_t)0x0100)            /*!< PE Interrupt Enable */
S#define  USART_CR1_PS                        ((uint16_t)0x0200)            /*!< Parity Selection */
S#define  USART_CR1_PCE                       ((uint16_t)0x0400)            /*!< Parity Control Enable */
S#define  USART_CR1_WAKE                      ((uint16_t)0x0800)            /*!< Wakeup method */
S#define  USART_CR1_M                         ((uint16_t)0x1000)            /*!< Word length */
S#define  USART_CR1_UE                        ((uint16_t)0x2000)            /*!< USART Enable */
S#define  USART_CR1_OVER8                     ((uint16_t)0x8000)            /*!< USART Oversmapling 8-bits */
S
S/******************  Bit definition for USART_CR2 register  *******************/
S#define  USART_CR2_ADD                       ((uint16_t)0x000F)            /*!< Address of the USART node */
S#define  USART_CR2_LBDL                      ((uint16_t)0x0020)            /*!< LIN Break Detection Length */
S#define  USART_CR2_LBDIE                     ((uint16_t)0x0040)            /*!< LIN Break Detection Interrupt Enable */
S#define  USART_CR2_LBCL                      ((uint16_t)0x0100)            /*!< Last Bit Clock pulse */
S#define  USART_CR2_CPHA                      ((uint16_t)0x0200)            /*!< Clock Phase */
S#define  USART_CR2_CPOL                      ((uint16_t)0x0400)            /*!< Clock Polarity */
S#define  USART_CR2_CLKEN                     ((uint16_t)0x0800)            /*!< Clock Enable */
S
S#define  USART_CR2_STOP                      ((uint16_t)0x3000)            /*!< STOP[1:0] bits (STOP bits) */
S#define  USART_CR2_STOP_0                    ((uint16_t)0x1000)            /*!< Bit 0 */
S#define  USART_CR2_STOP_1                    ((uint16_t)0x2000)            /*!< Bit 1 */
S
S#define  USART_CR2_LINEN                     ((uint16_t)0x4000)            /*!< LIN mode enable */
S
S/******************  Bit definition for USART_CR3 register  *******************/
S#define  USART_CR3_EIE                       ((uint16_t)0x0001)            /*!< Error Interrupt Enable */
S#define  USART_CR3_IREN                      ((uint16_t)0x0002)            /*!< IrDA mode Enable */
S#define  USART_CR3_IRLP                      ((uint16_t)0x0004)            /*!< IrDA Low-Power */
S#define  USART_CR3_HDSEL                     ((uint16_t)0x0008)            /*!< Half-Duplex Selection */
S#define  USART_CR3_NACK                      ((uint16_t)0x0010)            /*!< Smartcard NACK enable */
S#define  USART_CR3_SCEN                      ((uint16_t)0x0020)            /*!< Smartcard mode enable */
S#define  USART_CR3_DMAR                      ((uint16_t)0x0040)            /*!< DMA Enable Receiver */
S#define  USART_CR3_DMAT                      ((uint16_t)0x0080)            /*!< DMA Enable Transmitter */
S#define  USART_CR3_RTSE                      ((uint16_t)0x0100)            /*!< RTS Enable */
S#define  USART_CR3_CTSE                      ((uint16_t)0x0200)            /*!< CTS Enable */
S#define  USART_CR3_CTSIE                     ((uint16_t)0x0400)            /*!< CTS Interrupt Enable */
S#define  USART_CR3_ONEBIT                    ((uint16_t)0x0800)            /*!< One Bit method */
S
S/******************  Bit definition for USART_GTPR register  ******************/
S#define  USART_GTPR_PSC                      ((uint16_t)0x00FF)            /*!< PSC[7:0] bits (Prescaler value) */
S#define  USART_GTPR_PSC_0                    ((uint16_t)0x0001)            /*!< Bit 0 */
S#define  USART_GTPR_PSC_1                    ((uint16_t)0x0002)            /*!< Bit 1 */
S#define  USART_GTPR_PSC_2                    ((uint16_t)0x0004)            /*!< Bit 2 */
S#define  USART_GTPR_PSC_3                    ((uint16_t)0x0008)            /*!< Bit 3 */
S#define  USART_GTPR_PSC_4                    ((uint16_t)0x0010)            /*!< Bit 4 */
S#define  USART_GTPR_PSC_5                    ((uint16_t)0x0020)            /*!< Bit 5 */
S#define  USART_GTPR_PSC_6                    ((uint16_t)0x0040)            /*!< Bit 6 */
S#define  USART_GTPR_PSC_7                    ((uint16_t)0x0080)            /*!< Bit 7 */
S
S#define  USART_GTPR_GT                       ((uint16_t)0xFF00)            /*!< Guard time value */
S
S/******************************************************************************/
S/*                                                                            */
S/*                                 Debug MCU                                  */
S/*                                                                            */
S/******************************************************************************/
S
S/****************  Bit definition for DBGMCU_IDCODE register  *****************/
S#define  DBGMCU_IDCODE_DEV_ID                ((uint32_t)0x00000FFF)        /*!< Device Identifier */
S
S#define  DBGMCU_IDCODE_REV_ID                ((uint32_t)0xFFFF0000)        /*!< REV_ID[15:0] bits (Revision Identifier) */
S#define  DBGMCU_IDCODE_REV_ID_0              ((uint32_t)0x00010000)        /*!< Bit 0 */
S#define  DBGMCU_IDCODE_REV_ID_1              ((uint32_t)0x00020000)        /*!< Bit 1 */
S#define  DBGMCU_IDCODE_REV_ID_2              ((uint32_t)0x00040000)        /*!< Bit 2 */
S#define  DBGMCU_IDCODE_REV_ID_3              ((uint32_t)0x00080000)        /*!< Bit 3 */
S#define  DBGMCU_IDCODE_REV_ID_4              ((uint32_t)0x00100000)        /*!< Bit 4 */
S#define  DBGMCU_IDCODE_REV_ID_5              ((uint32_t)0x00200000)        /*!< Bit 5 */
S#define  DBGMCU_IDCODE_REV_ID_6              ((uint32_t)0x00400000)        /*!< Bit 6 */
S#define  DBGMCU_IDCODE_REV_ID_7              ((uint32_t)0x00800000)        /*!< Bit 7 */
S#define  DBGMCU_IDCODE_REV_ID_8              ((uint32_t)0x01000000)        /*!< Bit 8 */
S#define  DBGMCU_IDCODE_REV_ID_9              ((uint32_t)0x02000000)        /*!< Bit 9 */
S#define  DBGMCU_IDCODE_REV_ID_10             ((uint32_t)0x04000000)        /*!< Bit 10 */
S#define  DBGMCU_IDCODE_REV_ID_11             ((uint32_t)0x08000000)        /*!< Bit 11 */
S#define  DBGMCU_IDCODE_REV_ID_12             ((uint32_t)0x10000000)        /*!< Bit 12 */
S#define  DBGMCU_IDCODE_REV_ID_13             ((uint32_t)0x20000000)        /*!< Bit 13 */
S#define  DBGMCU_IDCODE_REV_ID_14             ((uint32_t)0x40000000)        /*!< Bit 14 */
S#define  DBGMCU_IDCODE_REV_ID_15             ((uint32_t)0x80000000)        /*!< Bit 15 */
S
S/******************  Bit definition for DBGMCU_CR register  *******************/
S#define  DBGMCU_CR_DBG_SLEEP                 ((uint32_t)0x00000001)        /*!< Debug Sleep Mode */
S#define  DBGMCU_CR_DBG_STOP                  ((uint32_t)0x00000002)        /*!< Debug Stop Mode */
S#define  DBGMCU_CR_DBG_STANDBY               ((uint32_t)0x00000004)        /*!< Debug Standby mode */
S#define  DBGMCU_CR_TRACE_IOEN                ((uint32_t)0x00000020)        /*!< Trace Pin Assignment Control */
S
S#define  DBGMCU_CR_TRACE_MODE                ((uint32_t)0x000000C0)        /*!< TRACE_MODE[1:0] bits (Trace Pin Assignment Control) */
S#define  DBGMCU_CR_TRACE_MODE_0              ((uint32_t)0x00000040)        /*!< Bit 0 */
S#define  DBGMCU_CR_TRACE_MODE_1              ((uint32_t)0x00000080)        /*!< Bit 1 */
S
S#define  DBGMCU_CR_DBG_IWDG_STOP             ((uint32_t)0x00000100)        /*!< Debug Independent Watchdog stopped when Core is halted */
S#define  DBGMCU_CR_DBG_WWDG_STOP             ((uint32_t)0x00000200)        /*!< Debug Window Watchdog stopped when Core is halted */
S#define  DBGMCU_CR_DBG_TIM1_STOP             ((uint32_t)0x00000400)        /*!< TIM1 counter stopped when core is halted */
S#define  DBGMCU_CR_DBG_TIM2_STOP             ((uint32_t)0x00000800)        /*!< TIM2 counter stopped when core is halted */
S#define  DBGMCU_CR_DBG_TIM3_STOP             ((uint32_t)0x00001000)        /*!< TIM3 counter stopped when core is halted */
S#define  DBGMCU_CR_DBG_TIM4_STOP             ((uint32_t)0x00002000)        /*!< TIM4 counter stopped when core is halted */
S#define  DBGMCU_CR_DBG_CAN1_STOP             ((uint32_t)0x00004000)        /*!< Debug CAN1 stopped when Core is halted */
S#define  DBGMCU_CR_DBG_I2C1_SMBUS_TIMEOUT    ((uint32_t)0x00008000)        /*!< SMBUS timeout mode stopped when Core is halted */
S#define  DBGMCU_CR_DBG_I2C2_SMBUS_TIMEOUT    ((uint32_t)0x00010000)        /*!< SMBUS timeout mode stopped when Core is halted */
S#define  DBGMCU_CR_DBG_TIM8_STOP             ((uint32_t)0x00020000)        /*!< TIM8 counter stopped when core is halted */
S#define  DBGMCU_CR_DBG_TIM5_STOP             ((uint32_t)0x00040000)        /*!< TIM5 counter stopped when core is halted */
S#define  DBGMCU_CR_DBG_TIM6_STOP             ((uint32_t)0x00080000)        /*!< TIM6 counter stopped when core is halted */
S#define  DBGMCU_CR_DBG_TIM7_STOP             ((uint32_t)0x00100000)        /*!< TIM7 counter stopped when core is halted */
S#define  DBGMCU_CR_DBG_CAN2_STOP             ((uint32_t)0x00200000)        /*!< Debug CAN2 stopped when Core is halted */
S#define  DBGMCU_CR_DBG_TIM15_STOP            ((uint32_t)0x00400000)        /*!< Debug TIM15 stopped when Core is halted */
S#define  DBGMCU_CR_DBG_TIM16_STOP            ((uint32_t)0x00800000)        /*!< Debug TIM16 stopped when Core is halted */
S#define  DBGMCU_CR_DBG_TIM17_STOP            ((uint32_t)0x01000000)        /*!< Debug TIM17 stopped when Core is halted */
S#define  DBGMCU_CR_DBG_TIM12_STOP            ((uint32_t)0x02000000)        /*!< Debug TIM12 stopped when Core is halted */
S#define  DBGMCU_CR_DBG_TIM13_STOP            ((uint32_t)0x04000000)        /*!< Debug TIM13 stopped when Core is halted */
S#define  DBGMCU_CR_DBG_TIM14_STOP            ((uint32_t)0x08000000)        /*!< Debug TIM14 stopped when Core is halted */
S#define  DBGMCU_CR_DBG_TIM9_STOP             ((uint32_t)0x10000000)        /*!< Debug TIM9 stopped when Core is halted */
S#define  DBGMCU_CR_DBG_TIM10_STOP            ((uint32_t)0x20000000)        /*!< Debug TIM10 stopped when Core is halted */
S#define  DBGMCU_CR_DBG_TIM11_STOP            ((uint32_t)0x40000000)        /*!< Debug TIM11 stopped when Core is halted */
S
S/******************************************************************************/
S/*                                                                            */
S/*                      FLASH and Option Bytes Registers                      */
S/*                                                                            */
S/******************************************************************************/
S
S/*******************  Bit definition for FLASH_ACR register  ******************/
S#define  FLASH_ACR_LATENCY                   ((uint8_t)0x03)               /*!< LATENCY[2:0] bits (Latency) */
S#define  FLASH_ACR_LATENCY_0                 ((uint8_t)0x00)               /*!< Bit 0 */
S#define  FLASH_ACR_LATENCY_1                 ((uint8_t)0x01)               /*!< Bit 0 */
S#define  FLASH_ACR_LATENCY_2                 ((uint8_t)0x02)               /*!< Bit 1 */
S
S#define  FLASH_ACR_HLFCYA                    ((uint8_t)0x08)               /*!< Flash Half Cycle Access Enable */
S#define  FLASH_ACR_PRFTBE                    ((uint8_t)0x10)               /*!< Prefetch Buffer Enable */
S#define  FLASH_ACR_PRFTBS                    ((uint8_t)0x20)               /*!< Prefetch Buffer Status */
S
S/******************  Bit definition for FLASH_KEYR register  ******************/
S#define  FLASH_KEYR_FKEYR                    ((uint32_t)0xFFFFFFFF)        /*!< FPEC Key */
S
S/*****************  Bit definition for FLASH_OPTKEYR register  ****************/
S#define  FLASH_OPTKEYR_OPTKEYR               ((uint32_t)0xFFFFFFFF)        /*!< Option Byte Key */
S
S/******************  Bit definition for FLASH_SR register  *******************/
S#define  FLASH_SR_BSY                        ((uint8_t)0x01)               /*!< Busy */
S#define  FLASH_SR_PGERR                      ((uint8_t)0x04)               /*!< Programming Error */
S#define  FLASH_SR_WRPRTERR                   ((uint8_t)0x10)               /*!< Write Protection Error */
S#define  FLASH_SR_EOP                        ((uint8_t)0x20)               /*!< End of operation */
S
S/*******************  Bit definition for FLASH_CR register  *******************/
S#define  FLASH_CR_PG                         ((uint16_t)0x0001)            /*!< Programming */
S#define  FLASH_CR_PER                        ((uint16_t)0x0002)            /*!< Page Erase */
S#define  FLASH_CR_MER                        ((uint16_t)0x0004)            /*!< Mass Erase */
S#define  FLASH_CR_OPTPG                      ((uint16_t)0x0010)            /*!< Option Byte Programming */
S#define  FLASH_CR_OPTER                      ((uint16_t)0x0020)            /*!< Option Byte Erase */
S#define  FLASH_CR_STRT                       ((uint16_t)0x0040)            /*!< Start */
S#define  FLASH_CR_LOCK                       ((uint16_t)0x0080)            /*!< Lock */
S#define  FLASH_CR_OPTWRE                     ((uint16_t)0x0200)            /*!< Option Bytes Write Enable */
S#define  FLASH_CR_ERRIE                      ((uint16_t)0x0400)            /*!< Error Interrupt Enable */
S#define  FLASH_CR_EOPIE                      ((uint16_t)0x1000)            /*!< End of operation interrupt enable */
S
S/*******************  Bit definition for FLASH_AR register  *******************/
S#define  FLASH_AR_FAR                        ((uint32_t)0xFFFFFFFF)        /*!< Flash Address */
S
S/******************  Bit definition for FLASH_OBR register  *******************/
S#define  FLASH_OBR_OPTERR                    ((uint16_t)0x0001)            /*!< Option Byte Error */
S#define  FLASH_OBR_RDPRT                     ((uint16_t)0x0002)            /*!< Read protection */
S
S#define  FLASH_OBR_USER                      ((uint16_t)0x03FC)            /*!< User Option Bytes */
S#define  FLASH_OBR_WDG_SW                    ((uint16_t)0x0004)            /*!< WDG_SW */
S#define  FLASH_OBR_nRST_STOP                 ((uint16_t)0x0008)            /*!< nRST_STOP */
S#define  FLASH_OBR_nRST_STDBY                ((uint16_t)0x0010)            /*!< nRST_STDBY */
S#define  FLASH_OBR_BFB2                      ((uint16_t)0x0020)            /*!< BFB2 */
S
S/******************  Bit definition for FLASH_WRPR register  ******************/
S#define  FLASH_WRPR_WRP                        ((uint32_t)0xFFFFFFFF)        /*!< Write Protect */
S
S/*----------------------------------------------------------------------------*/
S
S/******************  Bit definition for FLASH_RDP register  *******************/
S#define  FLASH_RDP_RDP                       ((uint32_t)0x000000FF)        /*!< Read protection option byte */
S#define  FLASH_RDP_nRDP                      ((uint32_t)0x0000FF00)        /*!< Read protection complemented option byte */
S
S/******************  Bit definition for FLASH_USER register  ******************/
S#define  FLASH_USER_USER                     ((uint32_t)0x00FF0000)        /*!< User option byte */
S#define  FLASH_USER_nUSER                    ((uint32_t)0xFF000000)        /*!< User complemented option byte */
S
S/******************  Bit definition for FLASH_Data0 register  *****************/
S#define  FLASH_Data0_Data0                   ((uint32_t)0x000000FF)        /*!< User data storage option byte */
S#define  FLASH_Data0_nData0                  ((uint32_t)0x0000FF00)        /*!< User data storage complemented option byte */
S
S/******************  Bit definition for FLASH_Data1 register  *****************/
S#define  FLASH_Data1_Data1                   ((uint32_t)0x00FF0000)        /*!< User data storage option byte */
S#define  FLASH_Data1_nData1                  ((uint32_t)0xFF000000)        /*!< User data storage complemented option byte */
S
S/******************  Bit definition for FLASH_WRP0 register  ******************/
S#define  FLASH_WRP0_WRP0                     ((uint32_t)0x000000FF)        /*!< Flash memory write protection option bytes */
S#define  FLASH_WRP0_nWRP0                    ((uint32_t)0x0000FF00)        /*!< Flash memory write protection complemented option bytes */
S
S/******************  Bit definition for FLASH_WRP1 register  ******************/
S#define  FLASH_WRP1_WRP1                     ((uint32_t)0x00FF0000)        /*!< Flash memory write protection option bytes */
S#define  FLASH_WRP1_nWRP1                    ((uint32_t)0xFF000000)        /*!< Flash memory write protection complemented option bytes */
S
S/******************  Bit definition for FLASH_WRP2 register  ******************/
S#define  FLASH_WRP2_WRP2                     ((uint32_t)0x000000FF)        /*!< Flash memory write protection option bytes */
S#define  FLASH_WRP2_nWRP2                    ((uint32_t)0x0000FF00)        /*!< Flash memory write protection complemented option bytes */
S
S/******************  Bit definition for FLASH_WRP3 register  ******************/
S#define  FLASH_WRP3_WRP3                     ((uint32_t)0x00FF0000)        /*!< Flash memory write protection option bytes */
S#define  FLASH_WRP3_nWRP3                    ((uint32_t)0xFF000000)        /*!< Flash memory write protection complemented option bytes */
S
S#ifdef STM32F10X_CL
S/******************************************************************************/
S/*                Ethernet MAC Registers bits definitions                     */
S/******************************************************************************/
S/* Bit definition for Ethernet MAC Control Register register */
S#define ETH_MACCR_WD      ((uint32_t)0x00800000)  /* Watchdog disable */
S#define ETH_MACCR_JD      ((uint32_t)0x00400000)  /* Jabber disable */
S#define ETH_MACCR_IFG     ((uint32_t)0x000E0000)  /* Inter-frame gap */
S  #define ETH_MACCR_IFG_96Bit     ((uint32_t)0x00000000)  /* Minimum IFG between frames during transmission is 96Bit */
S  #define ETH_MACCR_IFG_88Bit     ((uint32_t)0x00020000)  /* Minimum IFG between frames during transmission is 88Bit */
S  #define ETH_MACCR_IFG_80Bit     ((uint32_t)0x00040000)  /* Minimum IFG between frames during transmission is 80Bit */
S  #define ETH_MACCR_IFG_72Bit     ((uint32_t)0x00060000)  /* Minimum IFG between frames during transmission is 72Bit */
S  #define ETH_MACCR_IFG_64Bit     ((uint32_t)0x00080000)  /* Minimum IFG between frames during transmission is 64Bit */        
S  #define ETH_MACCR_IFG_56Bit     ((uint32_t)0x000A0000)  /* Minimum IFG between frames during transmission is 56Bit */
S  #define ETH_MACCR_IFG_48Bit     ((uint32_t)0x000C0000)  /* Minimum IFG between frames during transmission is 48Bit */
S  #define ETH_MACCR_IFG_40Bit     ((uint32_t)0x000E0000)  /* Minimum IFG between frames during transmission is 40Bit */              
S#define ETH_MACCR_CSD     ((uint32_t)0x00010000)  /* Carrier sense disable (during transmission) */
S#define ETH_MACCR_FES     ((uint32_t)0x00004000)  /* Fast ethernet speed */
S#define ETH_MACCR_ROD     ((uint32_t)0x00002000)  /* Receive own disable */
S#define ETH_MACCR_LM      ((uint32_t)0x00001000)  /* loopback mode */
S#define ETH_MACCR_DM      ((uint32_t)0x00000800)  /* Duplex mode */
S#define ETH_MACCR_IPCO    ((uint32_t)0x00000400)  /* IP Checksum offload */
S#define ETH_MACCR_RD      ((uint32_t)0x00000200)  /* Retry disable */
S#define ETH_MACCR_APCS    ((uint32_t)0x00000080)  /* Automatic Pad/CRC stripping */
S#define ETH_MACCR_BL      ((uint32_t)0x00000060)  /* Back-off limit: random integer number (r) of slot time delays before rescheduling
S                                                       a transmission attempt during retries after a collision: 0 =< r <2^k */
S  #define ETH_MACCR_BL_10    ((uint32_t)0x00000000)  /* k = min (n, 10) */
S  #define ETH_MACCR_BL_8     ((uint32_t)0x00000020)  /* k = min (n, 8) */
S  #define ETH_MACCR_BL_4     ((uint32_t)0x00000040)  /* k = min (n, 4) */
S  #define ETH_MACCR_BL_1     ((uint32_t)0x00000060)  /* k = min (n, 1) */ 
S#define ETH_MACCR_DC      ((uint32_t)0x00000010)  /* Defferal check */
S#define ETH_MACCR_TE      ((uint32_t)0x00000008)  /* Transmitter enable */
S#define ETH_MACCR_RE      ((uint32_t)0x00000004)  /* Receiver enable */
S
S/* Bit definition for Ethernet MAC Frame Filter Register */
S#define ETH_MACFFR_RA     ((uint32_t)0x80000000)  /* Receive all */ 
S#define ETH_MACFFR_HPF    ((uint32_t)0x00000400)  /* Hash or perfect filter */ 
S#define ETH_MACFFR_SAF    ((uint32_t)0x00000200)  /* Source address filter enable */ 
S#define ETH_MACFFR_SAIF   ((uint32_t)0x00000100)  /* SA inverse filtering */ 
S#define ETH_MACFFR_PCF    ((uint32_t)0x000000C0)  /* Pass control frames: 3 cases */
S  #define ETH_MACFFR_PCF_BlockAll                ((uint32_t)0x00000040)  /* MAC filters all control frames from reaching the application */
S  #define ETH_MACFFR_PCF_ForwardAll              ((uint32_t)0x00000080)  /* MAC forwards all control frames to application even if they fail the Address Filter */
S  #define ETH_MACFFR_PCF_ForwardPassedAddrFilter ((uint32_t)0x000000C0)  /* MAC forwards control frames that pass the Address Filter. */ 
S#define ETH_MACFFR_BFD    ((uint32_t)0x00000020)  /* Broadcast frame disable */ 
S#define ETH_MACFFR_PAM 	  ((uint32_t)0x00000010)  /* Pass all mutlicast */ 
S#define ETH_MACFFR_DAIF   ((uint32_t)0x00000008)  /* DA Inverse filtering */ 
S#define ETH_MACFFR_HM     ((uint32_t)0x00000004)  /* Hash multicast */ 
S#define ETH_MACFFR_HU     ((uint32_t)0x00000002)  /* Hash unicast */
S#define ETH_MACFFR_PM     ((uint32_t)0x00000001)  /* Promiscuous mode */
S
S/* Bit definition for Ethernet MAC Hash Table High Register */
S#define ETH_MACHTHR_HTH   ((uint32_t)0xFFFFFFFF)  /* Hash table high */
S
S/* Bit definition for Ethernet MAC Hash Table Low Register */
S#define ETH_MACHTLR_HTL   ((uint32_t)0xFFFFFFFF)  /* Hash table low */
S
S/* Bit definition for Ethernet MAC MII Address Register */
S#define ETH_MACMIIAR_PA   ((uint32_t)0x0000F800)  /* Physical layer address */ 
S#define ETH_MACMIIAR_MR   ((uint32_t)0x000007C0)  /* MII register in the selected PHY */ 
S#define ETH_MACMIIAR_CR   ((uint32_t)0x0000001C)  /* CR clock range: 6 cases */ 
S  #define ETH_MACMIIAR_CR_Div42   ((uint32_t)0x00000000)  /* HCLK:60-72 MHz; MDC clock= HCLK/42 */
S  #define ETH_MACMIIAR_CR_Div16   ((uint32_t)0x00000008)  /* HCLK:20-35 MHz; MDC clock= HCLK/16 */
S  #define ETH_MACMIIAR_CR_Div26   ((uint32_t)0x0000000C)  /* HCLK:35-60 MHz; MDC clock= HCLK/26 */
S#define ETH_MACMIIAR_MW   ((uint32_t)0x00000002)  /* MII write */ 
S#define ETH_MACMIIAR_MB   ((uint32_t)0x00000001)  /* MII busy */ 
S  
S/* Bit definition for Ethernet MAC MII Data Register */
S#define ETH_MACMIIDR_MD   ((uint32_t)0x0000FFFF)  /* MII data: read/write data from/to PHY */
S
S/* Bit definition for Ethernet MAC Flow Control Register */
S#define ETH_MACFCR_PT     ((uint32_t)0xFFFF0000)  /* Pause time */
S#define ETH_MACFCR_ZQPD   ((uint32_t)0x00000080)  /* Zero-quanta pause disable */
S#define ETH_MACFCR_PLT    ((uint32_t)0x00000030)  /* Pause low threshold: 4 cases */
S  #define ETH_MACFCR_PLT_Minus4   ((uint32_t)0x00000000)  /* Pause time minus 4 slot times */
S  #define ETH_MACFCR_PLT_Minus28  ((uint32_t)0x00000010)  /* Pause time minus 28 slot times */
S  #define ETH_MACFCR_PLT_Minus144 ((uint32_t)0x00000020)  /* Pause time minus 144 slot times */
S  #define ETH_MACFCR_PLT_Minus256 ((uint32_t)0x00000030)  /* Pause time minus 256 slot times */      
S#define ETH_MACFCR_UPFD   ((uint32_t)0x00000008)  /* Unicast pause frame detect */
S#define ETH_MACFCR_RFCE   ((uint32_t)0x00000004)  /* Receive flow control enable */
S#define ETH_MACFCR_TFCE   ((uint32_t)0x00000002)  /* Transmit flow control enable */
S#define ETH_MACFCR_FCBBPA ((uint32_t)0x00000001)  /* Flow control busy/backpressure activate */
S
S/* Bit definition for Ethernet MAC VLAN Tag Register */
S#define ETH_MACVLANTR_VLANTC ((uint32_t)0x00010000)  /* 12-bit VLAN tag comparison */
S#define ETH_MACVLANTR_VLANTI ((uint32_t)0x0000FFFF)  /* VLAN tag identifier (for receive frames) */
S
S/* Bit definition for Ethernet MAC Remote Wake-UpFrame Filter Register */ 
S#define ETH_MACRWUFFR_D   ((uint32_t)0xFFFFFFFF)  /* Wake-up frame filter register data */
S/* Eight sequential Writes to this address (offset 0x28) will write all Wake-UpFrame Filter Registers.
S   Eight sequential Reads from this address (offset 0x28) will read all Wake-UpFrame Filter Registers. */
S/* Wake-UpFrame Filter Reg0 : Filter 0 Byte Mask
S   Wake-UpFrame Filter Reg1 : Filter 1 Byte Mask
S   Wake-UpFrame Filter Reg2 : Filter 2 Byte Mask
S   Wake-UpFrame Filter Reg3 : Filter 3 Byte Mask
S   Wake-UpFrame Filter Reg4 : RSVD - Filter3 Command - RSVD - Filter2 Command - 
S                              RSVD - Filter1 Command - RSVD - Filter0 Command
S   Wake-UpFrame Filter Re5 : Filter3 Offset - Filter2 Offset - Filter1 Offset - Filter0 Offset
S   Wake-UpFrame Filter Re6 : Filter1 CRC16 - Filter0 CRC16
S   Wake-UpFrame Filter Re7 : Filter3 CRC16 - Filter2 CRC16 */
S
S/* Bit definition for Ethernet MAC PMT Control and Status Register */ 
S#define ETH_MACPMTCSR_WFFRPR ((uint32_t)0x80000000)  /* Wake-Up Frame Filter Register Pointer Reset */
S#define ETH_MACPMTCSR_GU     ((uint32_t)0x00000200)  /* Global Unicast */
S#define ETH_MACPMTCSR_WFR    ((uint32_t)0x00000040)  /* Wake-Up Frame Received */
S#define ETH_MACPMTCSR_MPR    ((uint32_t)0x00000020)  /* Magic Packet Received */
S#define ETH_MACPMTCSR_WFE    ((uint32_t)0x00000004)  /* Wake-Up Frame Enable */
S#define ETH_MACPMTCSR_MPE    ((uint32_t)0x00000002)  /* Magic Packet Enable */
S#define ETH_MACPMTCSR_PD     ((uint32_t)0x00000001)  /* Power Down */
S
S/* Bit definition for Ethernet MAC Status Register */
S#define ETH_MACSR_TSTS      ((uint32_t)0x00000200)  /* Time stamp trigger status */
S#define ETH_MACSR_MMCTS     ((uint32_t)0x00000040)  /* MMC transmit status */
S#define ETH_MACSR_MMMCRS    ((uint32_t)0x00000020)  /* MMC receive status */
S#define ETH_MACSR_MMCS      ((uint32_t)0x00000010)  /* MMC status */
S#define ETH_MACSR_PMTS      ((uint32_t)0x00000008)  /* PMT status */
S
S/* Bit definition for Ethernet MAC Interrupt Mask Register */
S#define ETH_MACIMR_TSTIM     ((uint32_t)0x00000200)  /* Time stamp trigger interrupt mask */
S#define ETH_MACIMR_PMTIM     ((uint32_t)0x00000008)  /* PMT interrupt mask */
S
S/* Bit definition for Ethernet MAC Address0 High Register */
S#define ETH_MACA0HR_MACA0H   ((uint32_t)0x0000FFFF)  /* MAC address0 high */
S
S/* Bit definition for Ethernet MAC Address0 Low Register */
S#define ETH_MACA0LR_MACA0L   ((uint32_t)0xFFFFFFFF)  /* MAC address0 low */
S
S/* Bit definition for Ethernet MAC Address1 High Register */
S#define ETH_MACA1HR_AE       ((uint32_t)0x80000000)  /* Address enable */
S#define ETH_MACA1HR_SA       ((uint32_t)0x40000000)  /* Source address */
S#define ETH_MACA1HR_MBC      ((uint32_t)0x3F000000)  /* Mask byte control: bits to mask for comparison of the MAC Address bytes */
S  #define ETH_MACA1HR_MBC_HBits15_8    ((uint32_t)0x20000000)  /* Mask MAC Address high reg bits [15:8] */
S  #define ETH_MACA1HR_MBC_HBits7_0     ((uint32_t)0x10000000)  /* Mask MAC Address high reg bits [7:0] */
S  #define ETH_MACA1HR_MBC_LBits31_24   ((uint32_t)0x08000000)  /* Mask MAC Address low reg bits [31:24] */
S  #define ETH_MACA1HR_MBC_LBits23_16   ((uint32_t)0x04000000)  /* Mask MAC Address low reg bits [23:16] */
S  #define ETH_MACA1HR_MBC_LBits15_8    ((uint32_t)0x02000000)  /* Mask MAC Address low reg bits [15:8] */
S  #define ETH_MACA1HR_MBC_LBits7_0     ((uint32_t)0x01000000)  /* Mask MAC Address low reg bits [7:0] */ 
S#define ETH_MACA1HR_MACA1H   ((uint32_t)0x0000FFFF)  /* MAC address1 high */
S
S/* Bit definition for Ethernet MAC Address1 Low Register */
S#define ETH_MACA1LR_MACA1L   ((uint32_t)0xFFFFFFFF)  /* MAC address1 low */
S
S/* Bit definition for Ethernet MAC Address2 High Register */
S#define ETH_MACA2HR_AE       ((uint32_t)0x80000000)  /* Address enable */
S#define ETH_MACA2HR_SA       ((uint32_t)0x40000000)  /* Source address */
S#define ETH_MACA2HR_MBC      ((uint32_t)0x3F000000)  /* Mask byte control */
S  #define ETH_MACA2HR_MBC_HBits15_8    ((uint32_t)0x20000000)  /* Mask MAC Address high reg bits [15:8] */
S  #define ETH_MACA2HR_MBC_HBits7_0     ((uint32_t)0x10000000)  /* Mask MAC Address high reg bits [7:0] */
S  #define ETH_MACA2HR_MBC_LBits31_24   ((uint32_t)0x08000000)  /* Mask MAC Address low reg bits [31:24] */
S  #define ETH_MACA2HR_MBC_LBits23_16   ((uint32_t)0x04000000)  /* Mask MAC Address low reg bits [23:16] */
S  #define ETH_MACA2HR_MBC_LBits15_8    ((uint32_t)0x02000000)  /* Mask MAC Address low reg bits [15:8] */
S  #define ETH_MACA2HR_MBC_LBits7_0     ((uint32_t)0x01000000)  /* Mask MAC Address low reg bits [70] */
S#define ETH_MACA2HR_MACA2H   ((uint32_t)0x0000FFFF)  /* MAC address1 high */
S
S/* Bit definition for Ethernet MAC Address2 Low Register */
S#define ETH_MACA2LR_MACA2L   ((uint32_t)0xFFFFFFFF)  /* MAC address2 low */
S
S/* Bit definition for Ethernet MAC Address3 High Register */
S#define ETH_MACA3HR_AE       ((uint32_t)0x80000000)  /* Address enable */
S#define ETH_MACA3HR_SA       ((uint32_t)0x40000000)  /* Source address */
S#define ETH_MACA3HR_MBC      ((uint32_t)0x3F000000)  /* Mask byte control */
S  #define ETH_MACA3HR_MBC_HBits15_8    ((uint32_t)0x20000000)  /* Mask MAC Address high reg bits [15:8] */
S  #define ETH_MACA3HR_MBC_HBits7_0     ((uint32_t)0x10000000)  /* Mask MAC Address high reg bits [7:0] */
S  #define ETH_MACA3HR_MBC_LBits31_24   ((uint32_t)0x08000000)  /* Mask MAC Address low reg bits [31:24] */
S  #define ETH_MACA3HR_MBC_LBits23_16   ((uint32_t)0x04000000)  /* Mask MAC Address low reg bits [23:16] */
S  #define ETH_MACA3HR_MBC_LBits15_8    ((uint32_t)0x02000000)  /* Mask MAC Address low reg bits [15:8] */
S  #define ETH_MACA3HR_MBC_LBits7_0     ((uint32_t)0x01000000)  /* Mask MAC Address low reg bits [70] */
S#define ETH_MACA3HR_MACA3H   ((uint32_t)0x0000FFFF)  /* MAC address3 high */
S
S/* Bit definition for Ethernet MAC Address3 Low Register */
S#define ETH_MACA3LR_MACA3L   ((uint32_t)0xFFFFFFFF)  /* MAC address3 low */
S
S/******************************************************************************/
S/*                Ethernet MMC Registers bits definition                      */
S/******************************************************************************/
S
S/* Bit definition for Ethernet MMC Contol Register */
S#define ETH_MMCCR_MCF        ((uint32_t)0x00000008)  /* MMC Counter Freeze */
S#define ETH_MMCCR_ROR        ((uint32_t)0x00000004)  /* Reset on Read */
S#define ETH_MMCCR_CSR        ((uint32_t)0x00000002)  /* Counter Stop Rollover */
S#define ETH_MMCCR_CR         ((uint32_t)0x00000001)  /* Counters Reset */
S
S/* Bit definition for Ethernet MMC Receive Interrupt Register */
S#define ETH_MMCRIR_RGUFS     ((uint32_t)0x00020000)  /* Set when Rx good unicast frames counter reaches half the maximum value */
S#define ETH_MMCRIR_RFAES     ((uint32_t)0x00000040)  /* Set when Rx alignment error counter reaches half the maximum value */
S#define ETH_MMCRIR_RFCES     ((uint32_t)0x00000020)  /* Set when Rx crc error counter reaches half the maximum value */
S
S/* Bit definition for Ethernet MMC Transmit Interrupt Register */
S#define ETH_MMCTIR_TGFS      ((uint32_t)0x00200000)  /* Set when Tx good frame count counter reaches half the maximum value */
S#define ETH_MMCTIR_TGFMSCS   ((uint32_t)0x00008000)  /* Set when Tx good multi col counter reaches half the maximum value */
S#define ETH_MMCTIR_TGFSCS    ((uint32_t)0x00004000)  /* Set when Tx good single col counter reaches half the maximum value */
S
S/* Bit definition for Ethernet MMC Receive Interrupt Mask Register */
S#define ETH_MMCRIMR_RGUFM    ((uint32_t)0x00020000)  /* Mask the interrupt when Rx good unicast frames counter reaches half the maximum value */
S#define ETH_MMCRIMR_RFAEM    ((uint32_t)0x00000040)  /* Mask the interrupt when when Rx alignment error counter reaches half the maximum value */
S#define ETH_MMCRIMR_RFCEM    ((uint32_t)0x00000020)  /* Mask the interrupt when Rx crc error counter reaches half the maximum value */
S
S/* Bit definition for Ethernet MMC Transmit Interrupt Mask Register */
S#define ETH_MMCTIMR_TGFM     ((uint32_t)0x00200000)  /* Mask the interrupt when Tx good frame count counter reaches half the maximum value */
S#define ETH_MMCTIMR_TGFMSCM  ((uint32_t)0x00008000)  /* Mask the interrupt when Tx good multi col counter reaches half the maximum value */
S#define ETH_MMCTIMR_TGFSCM   ((uint32_t)0x00004000)  /* Mask the interrupt when Tx good single col counter reaches half the maximum value */
S
S/* Bit definition for Ethernet MMC Transmitted Good Frames after Single Collision Counter Register */
S#define ETH_MMCTGFSCCR_TGFSCC     ((uint32_t)0xFFFFFFFF)  /* Number of successfully transmitted frames after a single collision in Half-duplex mode. */
S
S/* Bit definition for Ethernet MMC Transmitted Good Frames after More than a Single Collision Counter Register */
S#define ETH_MMCTGFMSCCR_TGFMSCC   ((uint32_t)0xFFFFFFFF)  /* Number of successfully transmitted frames after more than a single collision in Half-duplex mode. */
S
S/* Bit definition for Ethernet MMC Transmitted Good Frames Counter Register */
S#define ETH_MMCTGFCR_TGFC    ((uint32_t)0xFFFFFFFF)  /* Number of good frames transmitted. */
S
S/* Bit definition for Ethernet MMC Received Frames with CRC Error Counter Register */
S#define ETH_MMCRFCECR_RFCEC  ((uint32_t)0xFFFFFFFF)  /* Number of frames received with CRC error. */
S
S/* Bit definition for Ethernet MMC Received Frames with Alignement Error Counter Register */
S#define ETH_MMCRFAECR_RFAEC  ((uint32_t)0xFFFFFFFF)  /* Number of frames received with alignment (dribble) error */
S
S/* Bit definition for Ethernet MMC Received Good Unicast Frames Counter Register */
S#define ETH_MMCRGUFCR_RGUFC  ((uint32_t)0xFFFFFFFF)  /* Number of good unicast frames received. */
S
S/******************************************************************************/
S/*               Ethernet PTP Registers bits definition                       */
S/******************************************************************************/
S
S/* Bit definition for Ethernet PTP Time Stamp Contol Register */
S#define ETH_PTPTSCR_TSARU    ((uint32_t)0x00000020)  /* Addend register update */
S#define ETH_PTPTSCR_TSITE    ((uint32_t)0x00000010)  /* Time stamp interrupt trigger enable */
S#define ETH_PTPTSCR_TSSTU    ((uint32_t)0x00000008)  /* Time stamp update */
S#define ETH_PTPTSCR_TSSTI    ((uint32_t)0x00000004)  /* Time stamp initialize */
S#define ETH_PTPTSCR_TSFCU    ((uint32_t)0x00000002)  /* Time stamp fine or coarse update */
S#define ETH_PTPTSCR_TSE      ((uint32_t)0x00000001)  /* Time stamp enable */
S
S/* Bit definition for Ethernet PTP Sub-Second Increment Register */
S#define ETH_PTPSSIR_STSSI    ((uint32_t)0x000000FF)  /* System time Sub-second increment value */
S
S/* Bit definition for Ethernet PTP Time Stamp High Register */
S#define ETH_PTPTSHR_STS      ((uint32_t)0xFFFFFFFF)  /* System Time second */
S
S/* Bit definition for Ethernet PTP Time Stamp Low Register */
S#define ETH_PTPTSLR_STPNS    ((uint32_t)0x80000000)  /* System Time Positive or negative time */
S#define ETH_PTPTSLR_STSS     ((uint32_t)0x7FFFFFFF)  /* System Time sub-seconds */
S
S/* Bit definition for Ethernet PTP Time Stamp High Update Register */
S#define ETH_PTPTSHUR_TSUS    ((uint32_t)0xFFFFFFFF)  /* Time stamp update seconds */
S
S/* Bit definition for Ethernet PTP Time Stamp Low Update Register */
S#define ETH_PTPTSLUR_TSUPNS  ((uint32_t)0x80000000)  /* Time stamp update Positive or negative time */
S#define ETH_PTPTSLUR_TSUSS   ((uint32_t)0x7FFFFFFF)  /* Time stamp update sub-seconds */
S
S/* Bit definition for Ethernet PTP Time Stamp Addend Register */
S#define ETH_PTPTSAR_TSA      ((uint32_t)0xFFFFFFFF)  /* Time stamp addend */
S
S/* Bit definition for Ethernet PTP Target Time High Register */
S#define ETH_PTPTTHR_TTSH     ((uint32_t)0xFFFFFFFF)  /* Target time stamp high */
S
S/* Bit definition for Ethernet PTP Target Time Low Register */
S#define ETH_PTPTTLR_TTSL     ((uint32_t)0xFFFFFFFF)  /* Target time stamp low */
S
S/******************************************************************************/
S/*                 Ethernet DMA Registers bits definition                     */
S/******************************************************************************/
S
S/* Bit definition for Ethernet DMA Bus Mode Register */
S#define ETH_DMABMR_AAB       ((uint32_t)0x02000000)  /* Address-Aligned beats */
S#define ETH_DMABMR_FPM        ((uint32_t)0x01000000)  /* 4xPBL mode */
S#define ETH_DMABMR_USP       ((uint32_t)0x00800000)  /* Use separate PBL */
S#define ETH_DMABMR_RDP       ((uint32_t)0x007E0000)  /* RxDMA PBL */
S  #define ETH_DMABMR_RDP_1Beat    ((uint32_t)0x00020000)  /* maximum number of beats to be transferred in one RxDMA transaction is 1 */
S  #define ETH_DMABMR_RDP_2Beat    ((uint32_t)0x00040000)  /* maximum number of beats to be transferred in one RxDMA transaction is 2 */
S  #define ETH_DMABMR_RDP_4Beat    ((uint32_t)0x00080000)  /* maximum number of beats to be transferred in one RxDMA transaction is 4 */
S  #define ETH_DMABMR_RDP_8Beat    ((uint32_t)0x00100000)  /* maximum number of beats to be transferred in one RxDMA transaction is 8 */
S  #define ETH_DMABMR_RDP_16Beat   ((uint32_t)0x00200000)  /* maximum number of beats to be transferred in one RxDMA transaction is 16 */
S  #define ETH_DMABMR_RDP_32Beat   ((uint32_t)0x00400000)  /* maximum number of beats to be transferred in one RxDMA transaction is 32 */                
S  #define ETH_DMABMR_RDP_4xPBL_4Beat   ((uint32_t)0x01020000)  /* maximum number of beats to be transferred in one RxDMA transaction is 4 */
S  #define ETH_DMABMR_RDP_4xPBL_8Beat   ((uint32_t)0x01040000)  /* maximum number of beats to be transferred in one RxDMA transaction is 8 */
S  #define ETH_DMABMR_RDP_4xPBL_16Beat  ((uint32_t)0x01080000)  /* maximum number of beats to be transferred in one RxDMA transaction is 16 */
S  #define ETH_DMABMR_RDP_4xPBL_32Beat  ((uint32_t)0x01100000)  /* maximum number of beats to be transferred in one RxDMA transaction is 32 */
S  #define ETH_DMABMR_RDP_4xPBL_64Beat  ((uint32_t)0x01200000)  /* maximum number of beats to be transferred in one RxDMA transaction is 64 */
S  #define ETH_DMABMR_RDP_4xPBL_128Beat ((uint32_t)0x01400000)  /* maximum number of beats to be transferred in one RxDMA transaction is 128 */  
S#define ETH_DMABMR_FB        ((uint32_t)0x00010000)  /* Fixed Burst */
S#define ETH_DMABMR_RTPR      ((uint32_t)0x0000C000)  /* Rx Tx priority ratio */
S  #define ETH_DMABMR_RTPR_1_1     ((uint32_t)0x00000000)  /* Rx Tx priority ratio */
S  #define ETH_DMABMR_RTPR_2_1     ((uint32_t)0x00004000)  /* Rx Tx priority ratio */
S  #define ETH_DMABMR_RTPR_3_1     ((uint32_t)0x00008000)  /* Rx Tx priority ratio */
S  #define ETH_DMABMR_RTPR_4_1     ((uint32_t)0x0000C000)  /* Rx Tx priority ratio */  
S#define ETH_DMABMR_PBL    ((uint32_t)0x00003F00)  /* Programmable burst length */
S  #define ETH_DMABMR_PBL_1Beat    ((uint32_t)0x00000100)  /* maximum number of beats to be transferred in one TxDMA (or both) transaction is 1 */
S  #define ETH_DMABMR_PBL_2Beat    ((uint32_t)0x00000200)  /* maximum number of beats to be transferred in one TxDMA (or both) transaction is 2 */
S  #define ETH_DMABMR_PBL_4Beat    ((uint32_t)0x00000400)  /* maximum number of beats to be transferred in one TxDMA (or both) transaction is 4 */
S  #define ETH_DMABMR_PBL_8Beat    ((uint32_t)0x00000800)  /* maximum number of beats to be transferred in one TxDMA (or both) transaction is 8 */
S  #define ETH_DMABMR_PBL_16Beat   ((uint32_t)0x00001000)  /* maximum number of beats to be transferred in one TxDMA (or both) transaction is 16 */
S  #define ETH_DMABMR_PBL_32Beat   ((uint32_t)0x00002000)  /* maximum number of beats to be transferred in one TxDMA (or both) transaction is 32 */                
S  #define ETH_DMABMR_PBL_4xPBL_4Beat   ((uint32_t)0x01000100)  /* maximum number of beats to be transferred in one TxDMA (or both) transaction is 4 */
S  #define ETH_DMABMR_PBL_4xPBL_8Beat   ((uint32_t)0x01000200)  /* maximum number of beats to be transferred in one TxDMA (or both) transaction is 8 */
S  #define ETH_DMABMR_PBL_4xPBL_16Beat  ((uint32_t)0x01000400)  /* maximum number of beats to be transferred in one TxDMA (or both) transaction is 16 */
S  #define ETH_DMABMR_PBL_4xPBL_32Beat  ((uint32_t)0x01000800)  /* maximum number of beats to be transferred in one TxDMA (or both) transaction is 32 */
S  #define ETH_DMABMR_PBL_4xPBL_64Beat  ((uint32_t)0x01001000)  /* maximum number of beats to be transferred in one TxDMA (or both) transaction is 64 */
S  #define ETH_DMABMR_PBL_4xPBL_128Beat ((uint32_t)0x01002000)  /* maximum number of beats to be transferred in one TxDMA (or both) transaction is 128 */
S#define ETH_DMABMR_DSL       ((uint32_t)0x0000007C)  /* Descriptor Skip Length */
S#define ETH_DMABMR_DA        ((uint32_t)0x00000002)  /* DMA arbitration scheme */
S#define ETH_DMABMR_SR        ((uint32_t)0x00000001)  /* Software reset */
S
S/* Bit definition for Ethernet DMA Transmit Poll Demand Register */
S#define ETH_DMATPDR_TPD      ((uint32_t)0xFFFFFFFF)  /* Transmit poll demand */
S
S/* Bit definition for Ethernet DMA Receive Poll Demand Register */
S#define ETH_DMARPDR_RPD      ((uint32_t)0xFFFFFFFF)  /* Receive poll demand  */
S
S/* Bit definition for Ethernet DMA Receive Descriptor List Address Register */
S#define ETH_DMARDLAR_SRL     ((uint32_t)0xFFFFFFFF)  /* Start of receive list */
S
S/* Bit definition for Ethernet DMA Transmit Descriptor List Address Register */
S#define ETH_DMATDLAR_STL     ((uint32_t)0xFFFFFFFF)  /* Start of transmit list */
S
S/* Bit definition for Ethernet DMA Status Register */
S#define ETH_DMASR_TSTS       ((uint32_t)0x20000000)  /* Time-stamp trigger status */
S#define ETH_DMASR_PMTS       ((uint32_t)0x10000000)  /* PMT status */
S#define ETH_DMASR_MMCS       ((uint32_t)0x08000000)  /* MMC status */
S#define ETH_DMASR_EBS        ((uint32_t)0x03800000)  /* Error bits status */
S  /* combination with EBS[2:0] for GetFlagStatus function */
S  #define ETH_DMASR_EBS_DescAccess      ((uint32_t)0x02000000)  /* Error bits 0-data buffer, 1-desc. access */
S  #define ETH_DMASR_EBS_ReadTransf      ((uint32_t)0x01000000)  /* Error bits 0-write trnsf, 1-read transfr */
S  #define ETH_DMASR_EBS_DataTransfTx    ((uint32_t)0x00800000)  /* Error bits 0-Rx DMA, 1-Tx DMA */
S#define ETH_DMASR_TPS         ((uint32_t)0x00700000)  /* Transmit process state */
S  #define ETH_DMASR_TPS_Stopped         ((uint32_t)0x00000000)  /* Stopped - Reset or Stop Tx Command issued  */
S  #define ETH_DMASR_TPS_Fetching        ((uint32_t)0x00100000)  /* Running - fetching the Tx descriptor */
S  #define ETH_DMASR_TPS_Waiting         ((uint32_t)0x00200000)  /* Running - waiting for status */
S  #define ETH_DMASR_TPS_Reading         ((uint32_t)0x00300000)  /* Running - reading the data from host memory */
S  #define ETH_DMASR_TPS_Suspended       ((uint32_t)0x00600000)  /* Suspended - Tx Descriptor unavailabe */
S  #define ETH_DMASR_TPS_Closing         ((uint32_t)0x00700000)  /* Running - closing Rx descriptor */
S#define ETH_DMASR_RPS         ((uint32_t)0x000E0000)  /* Receive process state */
S  #define ETH_DMASR_RPS_Stopped         ((uint32_t)0x00000000)  /* Stopped - Reset or Stop Rx Command issued */
S  #define ETH_DMASR_RPS_Fetching        ((uint32_t)0x00020000)  /* Running - fetching the Rx descriptor */
S  #define ETH_DMASR_RPS_Waiting         ((uint32_t)0x00060000)  /* Running - waiting for packet */
S  #define ETH_DMASR_RPS_Suspended       ((uint32_t)0x00080000)  /* Suspended - Rx Descriptor unavailable */
S  #define ETH_DMASR_RPS_Closing         ((uint32_t)0x000A0000)  /* Running - closing descriptor */
S  #define ETH_DMASR_RPS_Queuing         ((uint32_t)0x000E0000)  /* Running - queuing the recieve frame into host memory */
S#define ETH_DMASR_NIS        ((uint32_t)0x00010000)  /* Normal interrupt summary */
S#define ETH_DMASR_AIS        ((uint32_t)0x00008000)  /* Abnormal interrupt summary */
S#define ETH_DMASR_ERS        ((uint32_t)0x00004000)  /* Early receive status */
S#define ETH_DMASR_FBES       ((uint32_t)0x00002000)  /* Fatal bus error status */
S#define ETH_DMASR_ETS        ((uint32_t)0x00000400)  /* Early transmit status */
S#define ETH_DMASR_RWTS       ((uint32_t)0x00000200)  /* Receive watchdog timeout status */
S#define ETH_DMASR_RPSS       ((uint32_t)0x00000100)  /* Receive process stopped status */
S#define ETH_DMASR_RBUS       ((uint32_t)0x00000080)  /* Receive buffer unavailable status */
S#define ETH_DMASR_RS         ((uint32_t)0x00000040)  /* Receive status */
S#define ETH_DMASR_TUS        ((uint32_t)0x00000020)  /* Transmit underflow status */
S#define ETH_DMASR_ROS        ((uint32_t)0x00000010)  /* Receive overflow status */
S#define ETH_DMASR_TJTS       ((uint32_t)0x00000008)  /* Transmit jabber timeout status */
S#define ETH_DMASR_TBUS       ((uint32_t)0x00000004)  /* Transmit buffer unavailable status */
S#define ETH_DMASR_TPSS       ((uint32_t)0x00000002)  /* Transmit process stopped status */
S#define ETH_DMASR_TS         ((uint32_t)0x00000001)  /* Transmit status */
S
S/* Bit definition for Ethernet DMA Operation Mode Register */
S#define ETH_DMAOMR_DTCEFD    ((uint32_t)0x04000000)  /* Disable Dropping of TCP/IP checksum error frames */
S#define ETH_DMAOMR_RSF       ((uint32_t)0x02000000)  /* Receive store and forward */
S#define ETH_DMAOMR_DFRF      ((uint32_t)0x01000000)  /* Disable flushing of received frames */
S#define ETH_DMAOMR_TSF       ((uint32_t)0x00200000)  /* Transmit store and forward */
S#define ETH_DMAOMR_FTF       ((uint32_t)0x00100000)  /* Flush transmit FIFO */
S#define ETH_DMAOMR_TTC       ((uint32_t)0x0001C000)  /* Transmit threshold control */
S  #define ETH_DMAOMR_TTC_64Bytes       ((uint32_t)0x00000000)  /* threshold level of the MTL Transmit FIFO is 64 Bytes */
S  #define ETH_DMAOMR_TTC_128Bytes      ((uint32_t)0x00004000)  /* threshold level of the MTL Transmit FIFO is 128 Bytes */
S  #define ETH_DMAOMR_TTC_192Bytes      ((uint32_t)0x00008000)  /* threshold level of the MTL Transmit FIFO is 192 Bytes */
S  #define ETH_DMAOMR_TTC_256Bytes      ((uint32_t)0x0000C000)  /* threshold level of the MTL Transmit FIFO is 256 Bytes */
S  #define ETH_DMAOMR_TTC_40Bytes       ((uint32_t)0x00010000)  /* threshold level of the MTL Transmit FIFO is 40 Bytes */
S  #define ETH_DMAOMR_TTC_32Bytes       ((uint32_t)0x00014000)  /* threshold level of the MTL Transmit FIFO is 32 Bytes */
S  #define ETH_DMAOMR_TTC_24Bytes       ((uint32_t)0x00018000)  /* threshold level of the MTL Transmit FIFO is 24 Bytes */
S  #define ETH_DMAOMR_TTC_16Bytes       ((uint32_t)0x0001C000)  /* threshold level of the MTL Transmit FIFO is 16 Bytes */
S#define ETH_DMAOMR_ST        ((uint32_t)0x00002000)  /* Start/stop transmission command */
S#define ETH_DMAOMR_FEF       ((uint32_t)0x00000080)  /* Forward error frames */
S#define ETH_DMAOMR_FUGF      ((uint32_t)0x00000040)  /* Forward undersized good frames */
S#define ETH_DMAOMR_RTC       ((uint32_t)0x00000018)  /* receive threshold control */
S  #define ETH_DMAOMR_RTC_64Bytes       ((uint32_t)0x00000000)  /* threshold level of the MTL Receive FIFO is 64 Bytes */
S  #define ETH_DMAOMR_RTC_32Bytes       ((uint32_t)0x00000008)  /* threshold level of the MTL Receive FIFO is 32 Bytes */
S  #define ETH_DMAOMR_RTC_96Bytes       ((uint32_t)0x00000010)  /* threshold level of the MTL Receive FIFO is 96 Bytes */
S  #define ETH_DMAOMR_RTC_128Bytes      ((uint32_t)0x00000018)  /* threshold level of the MTL Receive FIFO is 128 Bytes */
S#define ETH_DMAOMR_OSF       ((uint32_t)0x00000004)  /* operate on second frame */
S#define ETH_DMAOMR_SR        ((uint32_t)0x00000002)  /* Start/stop receive */
S
S/* Bit definition for Ethernet DMA Interrupt Enable Register */
S#define ETH_DMAIER_NISE      ((uint32_t)0x00010000)  /* Normal interrupt summary enable */
S#define ETH_DMAIER_AISE      ((uint32_t)0x00008000)  /* Abnormal interrupt summary enable */
S#define ETH_DMAIER_ERIE      ((uint32_t)0x00004000)  /* Early receive interrupt enable */
S#define ETH_DMAIER_FBEIE     ((uint32_t)0x00002000)  /* Fatal bus error interrupt enable */
S#define ETH_DMAIER_ETIE      ((uint32_t)0x00000400)  /* Early transmit interrupt enable */
S#define ETH_DMAIER_RWTIE     ((uint32_t)0x00000200)  /* Receive watchdog timeout interrupt enable */
S#define ETH_DMAIER_RPSIE     ((uint32_t)0x00000100)  /* Receive process stopped interrupt enable */
S#define ETH_DMAIER_RBUIE     ((uint32_t)0x00000080)  /* Receive buffer unavailable interrupt enable */
S#define ETH_DMAIER_RIE       ((uint32_t)0x00000040)  /* Receive interrupt enable */
S#define ETH_DMAIER_TUIE      ((uint32_t)0x00000020)  /* Transmit Underflow interrupt enable */
S#define ETH_DMAIER_ROIE      ((uint32_t)0x00000010)  /* Receive Overflow interrupt enable */
S#define ETH_DMAIER_TJTIE     ((uint32_t)0x00000008)  /* Transmit jabber timeout interrupt enable */
S#define ETH_DMAIER_TBUIE     ((uint32_t)0x00000004)  /* Transmit buffer unavailable interrupt enable */
S#define ETH_DMAIER_TPSIE     ((uint32_t)0x00000002)  /* Transmit process stopped interrupt enable */
S#define ETH_DMAIER_TIE       ((uint32_t)0x00000001)  /* Transmit interrupt enable */
S
S/* Bit definition for Ethernet DMA Missed Frame and Buffer Overflow Counter Register */
S#define ETH_DMAMFBOCR_OFOC   ((uint32_t)0x10000000)  /* Overflow bit for FIFO overflow counter */
S#define ETH_DMAMFBOCR_MFA    ((uint32_t)0x0FFE0000)  /* Number of frames missed by the application */
S#define ETH_DMAMFBOCR_OMFC   ((uint32_t)0x00010000)  /* Overflow bit for missed frame counter */
S#define ETH_DMAMFBOCR_MFC    ((uint32_t)0x0000FFFF)  /* Number of frames missed by the controller */
S
S/* Bit definition for Ethernet DMA Current Host Transmit Descriptor Register */
S#define ETH_DMACHTDR_HTDAP   ((uint32_t)0xFFFFFFFF)  /* Host transmit descriptor address pointer */
S
S/* Bit definition for Ethernet DMA Current Host Receive Descriptor Register */
S#define ETH_DMACHRDR_HRDAP   ((uint32_t)0xFFFFFFFF)  /* Host receive descriptor address pointer */
S
S/* Bit definition for Ethernet DMA Current Host Transmit Buffer Address Register */
S#define ETH_DMACHTBAR_HTBAP  ((uint32_t)0xFFFFFFFF)  /* Host transmit buffer address pointer */
S
S/* Bit definition for Ethernet DMA Current Host Receive Buffer Address Register */
S#define ETH_DMACHRBAR_HRBAP  ((uint32_t)0xFFFFFFFF)  /* Host receive buffer address pointer */
S#endif /* STM32F10X_CL */
S
S/**
S  * @}
S  */
S
S /**
S  * @}
S  */ 
S
S#ifdef USE_STDPERIPH_DRIVER
S  #include "stm32f10x_conf.h"
S#endif
S
S/** @addtogroup Exported_macro
S  * @{
S  */
S
S#define SET_BIT(REG, BIT)     ((REG) |= (BIT))
S
S#define CLEAR_BIT(REG, BIT)   ((REG) &= ~(BIT))
S
S#define READ_BIT(REG, BIT)    ((REG) & (BIT))
S
S#define CLEAR_REG(REG)        ((REG) = (0x0))
S
S#define WRITE_REG(REG, VAL)   ((REG) = (VAL))
S
S#define READ_REG(REG)         ((REG))
S
S#define MODIFY_REG(REG, CLEARMASK, SETMASK)  WRITE_REG((REG), (((READ_REG(REG)) & (~(CLEARMASK))) | (SETMASK)))
S
S/**
S  * @}
S  */
S
S#ifdef __cplusplus
S}
S#endif
S
N#endif /* __STM32F10x_H */
N
N/**
N  * @}
N  */
N
N  /**
N  * @}
N  */
N
N/******************* (C) COPYRIGHT 2011 STMicroelectronics *****END OF FILE****/
L 33 "..\..\Libraries\FWlib\inc\stm32f10x_bkp.h" 2
N
N/** @addtogroup STM32F10x_StdPeriph_Driver
N  * @{
N  */
N
N/** @addtogroup BKP
N  * @{
N  */
N
N/** @defgroup BKP_Exported_Types
N  * @{
N  */
N
N/**
N  * @}
N  */
N
N/** @defgroup BKP_Exported_Constants
N  * @{
N  */
N
N/** @defgroup Tamper_Pin_active_level 
N  * @{
N  */
N
N#define BKP_TamperPinLevel_High           ((uint16_t)0x0000)
N#define BKP_TamperPinLevel_Low            ((uint16_t)0x0001)
N#define IS_BKP_TAMPER_PIN_LEVEL(LEVEL) (((LEVEL) == BKP_TamperPinLevel_High) || \
N                                        ((LEVEL) == BKP_TamperPinLevel_Low))
X#define IS_BKP_TAMPER_PIN_LEVEL(LEVEL) (((LEVEL) == BKP_TamperPinLevel_High) ||                                         ((LEVEL) == BKP_TamperPinLevel_Low))
N/**
N  * @}
N  */
N
N/** @defgroup RTC_output_source_to_output_on_the_Tamper_pin 
N  * @{
N  */
N
N#define BKP_RTCOutputSource_None          ((uint16_t)0x0000)
N#define BKP_RTCOutputSource_CalibClock    ((uint16_t)0x0080)
N#define BKP_RTCOutputSource_Alarm         ((uint16_t)0x0100)
N#define BKP_RTCOutputSource_Second        ((uint16_t)0x0300)
N#define IS_BKP_RTC_OUTPUT_SOURCE(SOURCE) (((SOURCE) == BKP_RTCOutputSource_None) || \
N                                          ((SOURCE) == BKP_RTCOutputSource_CalibClock) || \
N                                          ((SOURCE) == BKP_RTCOutputSource_Alarm) || \
N                                          ((SOURCE) == BKP_RTCOutputSource_Second))
X#define IS_BKP_RTC_OUTPUT_SOURCE(SOURCE) (((SOURCE) == BKP_RTCOutputSource_None) ||                                           ((SOURCE) == BKP_RTCOutputSource_CalibClock) ||                                           ((SOURCE) == BKP_RTCOutputSource_Alarm) ||                                           ((SOURCE) == BKP_RTCOutputSource_Second))
N/**
N  * @}
N  */
N
N/** @defgroup Data_Backup_Register 
N  * @{
N  */
N
N#define BKP_DR1                           ((uint16_t)0x0004)
N#define BKP_DR2                           ((uint16_t)0x0008)
N#define BKP_DR3                           ((uint16_t)0x000C)
N#define BKP_DR4                           ((uint16_t)0x0010)
N#define BKP_DR5                           ((uint16_t)0x0014)
N#define BKP_DR6                           ((uint16_t)0x0018)
N#define BKP_DR7                           ((uint16_t)0x001C)
N#define BKP_DR8                           ((uint16_t)0x0020)
N#define BKP_DR9                           ((uint16_t)0x0024)
N#define BKP_DR10                          ((uint16_t)0x0028)
N#define BKP_DR11                          ((uint16_t)0x0040)
N#define BKP_DR12                          ((uint16_t)0x0044)
N#define BKP_DR13                          ((uint16_t)0x0048)
N#define BKP_DR14                          ((uint16_t)0x004C)
N#define BKP_DR15                          ((uint16_t)0x0050)
N#define BKP_DR16                          ((uint16_t)0x0054)
N#define BKP_DR17                          ((uint16_t)0x0058)
N#define BKP_DR18                          ((uint16_t)0x005C)
N#define BKP_DR19                          ((uint16_t)0x0060)
N#define BKP_DR20                          ((uint16_t)0x0064)
N#define BKP_DR21                          ((uint16_t)0x0068)
N#define BKP_DR22                          ((uint16_t)0x006C)
N#define BKP_DR23                          ((uint16_t)0x0070)
N#define BKP_DR24                          ((uint16_t)0x0074)
N#define BKP_DR25                          ((uint16_t)0x0078)
N#define BKP_DR26                          ((uint16_t)0x007C)
N#define BKP_DR27                          ((uint16_t)0x0080)
N#define BKP_DR28                          ((uint16_t)0x0084)
N#define BKP_DR29                          ((uint16_t)0x0088)
N#define BKP_DR30                          ((uint16_t)0x008C)
N#define BKP_DR31                          ((uint16_t)0x0090)
N#define BKP_DR32                          ((uint16_t)0x0094)
N#define BKP_DR33                          ((uint16_t)0x0098)
N#define BKP_DR34                          ((uint16_t)0x009C)
N#define BKP_DR35                          ((uint16_t)0x00A0)
N#define BKP_DR36                          ((uint16_t)0x00A4)
N#define BKP_DR37                          ((uint16_t)0x00A8)
N#define BKP_DR38                          ((uint16_t)0x00AC)
N#define BKP_DR39                          ((uint16_t)0x00B0)
N#define BKP_DR40                          ((uint16_t)0x00B4)
N#define BKP_DR41                          ((uint16_t)0x00B8)
N#define BKP_DR42                          ((uint16_t)0x00BC)
N
N#define IS_BKP_DR(DR) (((DR) == BKP_DR1)  || ((DR) == BKP_DR2)  || ((DR) == BKP_DR3)  || \
N                       ((DR) == BKP_DR4)  || ((DR) == BKP_DR5)  || ((DR) == BKP_DR6)  || \
N                       ((DR) == BKP_DR7)  || ((DR) == BKP_DR8)  || ((DR) == BKP_DR9)  || \
N                       ((DR) == BKP_DR10) || ((DR) == BKP_DR11) || ((DR) == BKP_DR12) || \
N                       ((DR) == BKP_DR13) || ((DR) == BKP_DR14) || ((DR) == BKP_DR15) || \
N                       ((DR) == BKP_DR16) || ((DR) == BKP_DR17) || ((DR) == BKP_DR18) || \
N                       ((DR) == BKP_DR19) || ((DR) == BKP_DR20) || ((DR) == BKP_DR21) || \
N                       ((DR) == BKP_DR22) || ((DR) == BKP_DR23) || ((DR) == BKP_DR24) || \
N                       ((DR) == BKP_DR25) || ((DR) == BKP_DR26) || ((DR) == BKP_DR27) || \
N                       ((DR) == BKP_DR28) || ((DR) == BKP_DR29) || ((DR) == BKP_DR30) || \
N                       ((DR) == BKP_DR31) || ((DR) == BKP_DR32) || ((DR) == BKP_DR33) || \
N                       ((DR) == BKP_DR34) || ((DR) == BKP_DR35) || ((DR) == BKP_DR36) || \
N                       ((DR) == BKP_DR37) || ((DR) == BKP_DR38) || ((DR) == BKP_DR39) || \
N                       ((DR) == BKP_DR40) || ((DR) == BKP_DR41) || ((DR) == BKP_DR42))
X#define IS_BKP_DR(DR) (((DR) == BKP_DR1)  || ((DR) == BKP_DR2)  || ((DR) == BKP_DR3)  ||                        ((DR) == BKP_DR4)  || ((DR) == BKP_DR5)  || ((DR) == BKP_DR6)  ||                        ((DR) == BKP_DR7)  || ((DR) == BKP_DR8)  || ((DR) == BKP_DR9)  ||                        ((DR) == BKP_DR10) || ((DR) == BKP_DR11) || ((DR) == BKP_DR12) ||                        ((DR) == BKP_DR13) || ((DR) == BKP_DR14) || ((DR) == BKP_DR15) ||                        ((DR) == BKP_DR16) || ((DR) == BKP_DR17) || ((DR) == BKP_DR18) ||                        ((DR) == BKP_DR19) || ((DR) == BKP_DR20) || ((DR) == BKP_DR21) ||                        ((DR) == BKP_DR22) || ((DR) == BKP_DR23) || ((DR) == BKP_DR24) ||                        ((DR) == BKP_DR25) || ((DR) == BKP_DR26) || ((DR) == BKP_DR27) ||                        ((DR) == BKP_DR28) || ((DR) == BKP_DR29) || ((DR) == BKP_DR30) ||                        ((DR) == BKP_DR31) || ((DR) == BKP_DR32) || ((DR) == BKP_DR33) ||                        ((DR) == BKP_DR34) || ((DR) == BKP_DR35) || ((DR) == BKP_DR36) ||                        ((DR) == BKP_DR37) || ((DR) == BKP_DR38) || ((DR) == BKP_DR39) ||                        ((DR) == BKP_DR40) || ((DR) == BKP_DR41) || ((DR) == BKP_DR42))
N
N#define IS_BKP_CALIBRATION_VALUE(VALUE) ((VALUE) <= 0x7F)
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */
N
N/** @defgroup BKP_Exported_Macros
N  * @{
N  */
N
N/**
N  * @}
N  */
N
N/** @defgroup BKP_Exported_Functions
N  * @{
N  */
N
Nvoid BKP_DeInit(void);
Nvoid BKP_TamperPinLevelConfig(uint16_t BKP_TamperPinLevel);
Nvoid BKP_TamperPinCmd(FunctionalState NewState);
Nvoid BKP_ITConfig(FunctionalState NewState);
Nvoid BKP_RTCOutputConfig(uint16_t BKP_RTCOutputSource);
Nvoid BKP_SetRTCCalibrationValue(uint8_t CalibrationValue);
Nvoid BKP_WriteBackupRegister(uint16_t BKP_DR, uint16_t Data);
Nuint16_t BKP_ReadBackupRegister(uint16_t BKP_DR);
NFlagStatus BKP_GetFlagStatus(void);
Nvoid BKP_ClearFlag(void);
NITStatus BKP_GetITStatus(void);
Nvoid BKP_ClearITPendingBit(void);
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif /* __STM32F10x_BKP_H */
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */
N
N/******************* (C) COPYRIGHT 2011 STMicroelectronics *****END OF FILE****/
L 30 "..\..\User\stm32f10x_conf.h" 2
N//#include "stm32f10x_can.h" 
N//#include "stm32f10x_cec.h" 
N//#include "stm32f10x_crc.h" 
N#include "stm32f10x_dac.h" 
L 1 "..\..\Libraries\FWlib\inc\stm32f10x_dac.h" 1
N/**
N  ******************************************************************************
N  * @file    stm32f10x_dac.h
N  * @author  MCD Application Team
N  * @version V3.5.0
N  * @date    11-March-2011
N  * @brief   This file contains all the functions prototypes for the DAC firmware 
N  *          library.
N  ******************************************************************************
N  * @attention
N  *
N  * THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
N  * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE
N  * TIME. AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY
N  * DIRECT, INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING
N  * FROM THE CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE
N  * CODING INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
N  *
N  * <h2><center>&copy; COPYRIGHT 2011 STMicroelectronics</center></h2>
N  ******************************************************************************
N  */
N
N/* Define to prevent recursive inclusion -------------------------------------*/
N#ifndef __STM32F10x_DAC_H
N#define __STM32F10x_DAC_H
N
N#ifdef __cplusplus
S extern "C" {
N#endif
N
N/* Includes ------------------------------------------------------------------*/
N#include "stm32f10x.h"
N
N/** @addtogroup STM32F10x_StdPeriph_Driver
N  * @{
N  */
N
N/** @addtogroup DAC
N  * @{
N  */
N
N/** @defgroup DAC_Exported_Types
N  * @{
N  */
N
N/** 
N  * @brief  DAC Init structure definition
N  */
N
Ntypedef struct
N{
N  uint32_t DAC_Trigger;                      /*!< Specifies the external trigger for the selected DAC channel.
N                                                  This parameter can be a value of @ref DAC_trigger_selection */
N
N  uint32_t DAC_WaveGeneration;               /*!< Specifies whether DAC channel noise waves or triangle waves
N                                                  are generated, or whether no wave is generated.
N                                                  This parameter can be a value of @ref DAC_wave_generation */
N
N  uint32_t DAC_LFSRUnmask_TriangleAmplitude; /*!< Specifies the LFSR mask for noise wave generation or
N                                                  the maximum amplitude triangle generation for the DAC channel. 
N                                                  This parameter can be a value of @ref DAC_lfsrunmask_triangleamplitude */
N
N  uint32_t DAC_OutputBuffer;                 /*!< Specifies whether the DAC channel output buffer is enabled or disabled.
N                                                  This parameter can be a value of @ref DAC_output_buffer */
N}DAC_InitTypeDef;
N
N/**
N  * @}
N  */
N
N/** @defgroup DAC_Exported_Constants
N  * @{
N  */
N
N/** @defgroup DAC_trigger_selection 
N  * @{
N  */
N
N#define DAC_Trigger_None                   ((uint32_t)0x00000000) /*!< Conversion is automatic once the DAC1_DHRxxxx register 
N                                                                       has been loaded, and not by external trigger */
N#define DAC_Trigger_T6_TRGO                ((uint32_t)0x00000004) /*!< TIM6 TRGO selected as external conversion trigger for DAC channel */
N#define DAC_Trigger_T8_TRGO                ((uint32_t)0x0000000C) /*!< TIM8 TRGO selected as external conversion trigger for DAC channel
N                                                                       only in High-density devices*/
N#define DAC_Trigger_T3_TRGO                ((uint32_t)0x0000000C) /*!< TIM8 TRGO selected as external conversion trigger for DAC channel
N                                                                       only in Connectivity line, Medium-density and Low-density Value Line devices */
N#define DAC_Trigger_T7_TRGO                ((uint32_t)0x00000014) /*!< TIM7 TRGO selected as external conversion trigger for DAC channel */
N#define DAC_Trigger_T5_TRGO                ((uint32_t)0x0000001C) /*!< TIM5 TRGO selected as external conversion trigger for DAC channel */
N#define DAC_Trigger_T15_TRGO               ((uint32_t)0x0000001C) /*!< TIM15 TRGO selected as external conversion trigger for DAC channel 
N                                                                       only in Medium-density and Low-density Value Line devices*/
N#define DAC_Trigger_T2_TRGO                ((uint32_t)0x00000024) /*!< TIM2 TRGO selected as external conversion trigger for DAC channel */
N#define DAC_Trigger_T4_TRGO                ((uint32_t)0x0000002C) /*!< TIM4 TRGO selected as external conversion trigger for DAC channel */
N#define DAC_Trigger_Ext_IT9                ((uint32_t)0x00000034) /*!< EXTI Line9 event selected as external conversion trigger for DAC channel */
N#define DAC_Trigger_Software               ((uint32_t)0x0000003C) /*!< Conversion started by software trigger for DAC channel */
N
N#define IS_DAC_TRIGGER(TRIGGER) (((TRIGGER) == DAC_Trigger_None) || \
N                                 ((TRIGGER) == DAC_Trigger_T6_TRGO) || \
N                                 ((TRIGGER) == DAC_Trigger_T8_TRGO) || \
N                                 ((TRIGGER) == DAC_Trigger_T7_TRGO) || \
N                                 ((TRIGGER) == DAC_Trigger_T5_TRGO) || \
N                                 ((TRIGGER) == DAC_Trigger_T2_TRGO) || \
N                                 ((TRIGGER) == DAC_Trigger_T4_TRGO) || \
N                                 ((TRIGGER) == DAC_Trigger_Ext_IT9) || \
N                                 ((TRIGGER) == DAC_Trigger_Software))
X#define IS_DAC_TRIGGER(TRIGGER) (((TRIGGER) == DAC_Trigger_None) ||                                  ((TRIGGER) == DAC_Trigger_T6_TRGO) ||                                  ((TRIGGER) == DAC_Trigger_T8_TRGO) ||                                  ((TRIGGER) == DAC_Trigger_T7_TRGO) ||                                  ((TRIGGER) == DAC_Trigger_T5_TRGO) ||                                  ((TRIGGER) == DAC_Trigger_T2_TRGO) ||                                  ((TRIGGER) == DAC_Trigger_T4_TRGO) ||                                  ((TRIGGER) == DAC_Trigger_Ext_IT9) ||                                  ((TRIGGER) == DAC_Trigger_Software))
N
N/**
N  * @}
N  */
N
N/** @defgroup DAC_wave_generation 
N  * @{
N  */
N
N#define DAC_WaveGeneration_None            ((uint32_t)0x00000000)
N#define DAC_WaveGeneration_Noise           ((uint32_t)0x00000040)
N#define DAC_WaveGeneration_Triangle        ((uint32_t)0x00000080)
N#define IS_DAC_GENERATE_WAVE(WAVE) (((WAVE) == DAC_WaveGeneration_None) || \
N                                    ((WAVE) == DAC_WaveGeneration_Noise) || \
N                                    ((WAVE) == DAC_WaveGeneration_Triangle))
X#define IS_DAC_GENERATE_WAVE(WAVE) (((WAVE) == DAC_WaveGeneration_None) ||                                     ((WAVE) == DAC_WaveGeneration_Noise) ||                                     ((WAVE) == DAC_WaveGeneration_Triangle))
N/**
N  * @}
N  */
N
N/** @defgroup DAC_lfsrunmask_triangleamplitude
N  * @{
N  */
N
N#define DAC_LFSRUnmask_Bit0                ((uint32_t)0x00000000) /*!< Unmask DAC channel LFSR bit0 for noise wave generation */
N#define DAC_LFSRUnmask_Bits1_0             ((uint32_t)0x00000100) /*!< Unmask DAC channel LFSR bit[1:0] for noise wave generation */
N#define DAC_LFSRUnmask_Bits2_0             ((uint32_t)0x00000200) /*!< Unmask DAC channel LFSR bit[2:0] for noise wave generation */
N#define DAC_LFSRUnmask_Bits3_0             ((uint32_t)0x00000300) /*!< Unmask DAC channel LFSR bit[3:0] for noise wave generation */
N#define DAC_LFSRUnmask_Bits4_0             ((uint32_t)0x00000400) /*!< Unmask DAC channel LFSR bit[4:0] for noise wave generation */
N#define DAC_LFSRUnmask_Bits5_0             ((uint32_t)0x00000500) /*!< Unmask DAC channel LFSR bit[5:0] for noise wave generation */
N#define DAC_LFSRUnmask_Bits6_0             ((uint32_t)0x00000600) /*!< Unmask DAC channel LFSR bit[6:0] for noise wave generation */
N#define DAC_LFSRUnmask_Bits7_0             ((uint32_t)0x00000700) /*!< Unmask DAC channel LFSR bit[7:0] for noise wave generation */
N#define DAC_LFSRUnmask_Bits8_0             ((uint32_t)0x00000800) /*!< Unmask DAC channel LFSR bit[8:0] for noise wave generation */
N#define DAC_LFSRUnmask_Bits9_0             ((uint32_t)0x00000900) /*!< Unmask DAC channel LFSR bit[9:0] for noise wave generation */
N#define DAC_LFSRUnmask_Bits10_0            ((uint32_t)0x00000A00) /*!< Unmask DAC channel LFSR bit[10:0] for noise wave generation */
N#define DAC_LFSRUnmask_Bits11_0            ((uint32_t)0x00000B00) /*!< Unmask DAC channel LFSR bit[11:0] for noise wave generation */
N#define DAC_TriangleAmplitude_1            ((uint32_t)0x00000000) /*!< Select max triangle amplitude of 1 */
N#define DAC_TriangleAmplitude_3            ((uint32_t)0x00000100) /*!< Select max triangle amplitude of 3 */
N#define DAC_TriangleAmplitude_7            ((uint32_t)0x00000200) /*!< Select max triangle amplitude of 7 */
N#define DAC_TriangleAmplitude_15           ((uint32_t)0x00000300) /*!< Select max triangle amplitude of 15 */
N#define DAC_TriangleAmplitude_31           ((uint32_t)0x00000400) /*!< Select max triangle amplitude of 31 */
N#define DAC_TriangleAmplitude_63           ((uint32_t)0x00000500) /*!< Select max triangle amplitude of 63 */
N#define DAC_TriangleAmplitude_127          ((uint32_t)0x00000600) /*!< Select max triangle amplitude of 127 */
N#define DAC_TriangleAmplitude_255          ((uint32_t)0x00000700) /*!< Select max triangle amplitude of 255 */
N#define DAC_TriangleAmplitude_511          ((uint32_t)0x00000800) /*!< Select max triangle amplitude of 511 */
N#define DAC_TriangleAmplitude_1023         ((uint32_t)0x00000900) /*!< Select max triangle amplitude of 1023 */
N#define DAC_TriangleAmplitude_2047         ((uint32_t)0x00000A00) /*!< Select max triangle amplitude of 2047 */
N#define DAC_TriangleAmplitude_4095         ((uint32_t)0x00000B00) /*!< Select max triangle amplitude of 4095 */
N
N#define IS_DAC_LFSR_UNMASK_TRIANGLE_AMPLITUDE(VALUE) (((VALUE) == DAC_LFSRUnmask_Bit0) || \
N                                                      ((VALUE) == DAC_LFSRUnmask_Bits1_0) || \
N                                                      ((VALUE) == DAC_LFSRUnmask_Bits2_0) || \
N                                                      ((VALUE) == DAC_LFSRUnmask_Bits3_0) || \
N                                                      ((VALUE) == DAC_LFSRUnmask_Bits4_0) || \
N                                                      ((VALUE) == DAC_LFSRUnmask_Bits5_0) || \
N                                                      ((VALUE) == DAC_LFSRUnmask_Bits6_0) || \
N                                                      ((VALUE) == DAC_LFSRUnmask_Bits7_0) || \
N                                                      ((VALUE) == DAC_LFSRUnmask_Bits8_0) || \
N                                                      ((VALUE) == DAC_LFSRUnmask_Bits9_0) || \
N                                                      ((VALUE) == DAC_LFSRUnmask_Bits10_0) || \
N                                                      ((VALUE) == DAC_LFSRUnmask_Bits11_0) || \
N                                                      ((VALUE) == DAC_TriangleAmplitude_1) || \
N                                                      ((VALUE) == DAC_TriangleAmplitude_3) || \
N                                                      ((VALUE) == DAC_TriangleAmplitude_7) || \
N                                                      ((VALUE) == DAC_TriangleAmplitude_15) || \
N                                                      ((VALUE) == DAC_TriangleAmplitude_31) || \
N                                                      ((VALUE) == DAC_TriangleAmplitude_63) || \
N                                                      ((VALUE) == DAC_TriangleAmplitude_127) || \
N                                                      ((VALUE) == DAC_TriangleAmplitude_255) || \
N                                                      ((VALUE) == DAC_TriangleAmplitude_511) || \
N                                                      ((VALUE) == DAC_TriangleAmplitude_1023) || \
N                                                      ((VALUE) == DAC_TriangleAmplitude_2047) || \
N                                                      ((VALUE) == DAC_TriangleAmplitude_4095))
X#define IS_DAC_LFSR_UNMASK_TRIANGLE_AMPLITUDE(VALUE) (((VALUE) == DAC_LFSRUnmask_Bit0) ||                                                       ((VALUE) == DAC_LFSRUnmask_Bits1_0) ||                                                       ((VALUE) == DAC_LFSRUnmask_Bits2_0) ||                                                       ((VALUE) == DAC_LFSRUnmask_Bits3_0) ||                                                       ((VALUE) == DAC_LFSRUnmask_Bits4_0) ||                                                       ((VALUE) == DAC_LFSRUnmask_Bits5_0) ||                                                       ((VALUE) == DAC_LFSRUnmask_Bits6_0) ||                                                       ((VALUE) == DAC_LFSRUnmask_Bits7_0) ||                                                       ((VALUE) == DAC_LFSRUnmask_Bits8_0) ||                                                       ((VALUE) == DAC_LFSRUnmask_Bits9_0) ||                                                       ((VALUE) == DAC_LFSRUnmask_Bits10_0) ||                                                       ((VALUE) == DAC_LFSRUnmask_Bits11_0) ||                                                       ((VALUE) == DAC_TriangleAmplitude_1) ||                                                       ((VALUE) == DAC_TriangleAmplitude_3) ||                                                       ((VALUE) == DAC_TriangleAmplitude_7) ||                                                       ((VALUE) == DAC_TriangleAmplitude_15) ||                                                       ((VALUE) == DAC_TriangleAmplitude_31) ||                                                       ((VALUE) == DAC_TriangleAmplitude_63) ||                                                       ((VALUE) == DAC_TriangleAmplitude_127) ||                                                       ((VALUE) == DAC_TriangleAmplitude_255) ||                                                       ((VALUE) == DAC_TriangleAmplitude_511) ||                                                       ((VALUE) == DAC_TriangleAmplitude_1023) ||                                                       ((VALUE) == DAC_TriangleAmplitude_2047) ||                                                       ((VALUE) == DAC_TriangleAmplitude_4095))
N/**
N  * @}
N  */
N
N/** @defgroup DAC_output_buffer 
N  * @{
N  */
N
N#define DAC_OutputBuffer_Enable            ((uint32_t)0x00000000)
N#define DAC_OutputBuffer_Disable           ((uint32_t)0x00000002)
N#define IS_DAC_OUTPUT_BUFFER_STATE(STATE) (((STATE) == DAC_OutputBuffer_Enable) || \
N                                           ((STATE) == DAC_OutputBuffer_Disable))
X#define IS_DAC_OUTPUT_BUFFER_STATE(STATE) (((STATE) == DAC_OutputBuffer_Enable) ||                                            ((STATE) == DAC_OutputBuffer_Disable))
N/**
N  * @}
N  */
N
N/** @defgroup DAC_Channel_selection 
N  * @{
N  */
N
N#define DAC_Channel_1                      ((uint32_t)0x00000000)
N#define DAC_Channel_2                      ((uint32_t)0x00000010)
N#define IS_DAC_CHANNEL(CHANNEL) (((CHANNEL) == DAC_Channel_1) || \
N                                 ((CHANNEL) == DAC_Channel_2))
X#define IS_DAC_CHANNEL(CHANNEL) (((CHANNEL) == DAC_Channel_1) ||                                  ((CHANNEL) == DAC_Channel_2))
N/**
N  * @}
N  */
N
N/** @defgroup DAC_data_alignment 
N  * @{
N  */
N
N#define DAC_Align_12b_R                    ((uint32_t)0x00000000)
N#define DAC_Align_12b_L                    ((uint32_t)0x00000004)
N#define DAC_Align_8b_R                     ((uint32_t)0x00000008)
N#define IS_DAC_ALIGN(ALIGN) (((ALIGN) == DAC_Align_12b_R) || \
N                             ((ALIGN) == DAC_Align_12b_L) || \
N                             ((ALIGN) == DAC_Align_8b_R))
X#define IS_DAC_ALIGN(ALIGN) (((ALIGN) == DAC_Align_12b_R) ||                              ((ALIGN) == DAC_Align_12b_L) ||                              ((ALIGN) == DAC_Align_8b_R))
N/**
N  * @}
N  */
N
N/** @defgroup DAC_wave_generation 
N  * @{
N  */
N
N#define DAC_Wave_Noise                     ((uint32_t)0x00000040)
N#define DAC_Wave_Triangle                  ((uint32_t)0x00000080)
N#define IS_DAC_WAVE(WAVE) (((WAVE) == DAC_Wave_Noise) || \
N                           ((WAVE) == DAC_Wave_Triangle))
X#define IS_DAC_WAVE(WAVE) (((WAVE) == DAC_Wave_Noise) ||                            ((WAVE) == DAC_Wave_Triangle))
N/**
N  * @}
N  */
N
N/** @defgroup DAC_data 
N  * @{
N  */
N
N#define IS_DAC_DATA(DATA) ((DATA) <= 0xFFF0) 
N/**
N  * @}
N  */
N#if defined (STM32F10X_LD_VL) || defined (STM32F10X_MD_VL)  || defined (STM32F10X_HD_VL)
X#if 0L || 0L  || 0L
S/** @defgroup DAC_interrupts_definition 
S  * @{
S  */ 
S  
S#define DAC_IT_DMAUDR                      ((uint32_t)0x00002000)  
S#define IS_DAC_IT(IT) (((IT) == DAC_IT_DMAUDR)) 
S
S/**
S  * @}
S  */ 
S
S/** @defgroup DAC_flags_definition 
S  * @{
S  */ 
S  
S#define DAC_FLAG_DMAUDR                    ((uint32_t)0x00002000)  
S#define IS_DAC_FLAG(FLAG) (((FLAG) == DAC_FLAG_DMAUDR))  
S
S/**
S  * @}
S  */
N#endif
N
N/**
N  * @}
N  */
N
N/** @defgroup DAC_Exported_Macros
N  * @{
N  */
N
N/**
N  * @}
N  */
N
N/** @defgroup DAC_Exported_Functions
N  * @{
N  */
N
Nvoid DAC_DeInit(void);
Nvoid DAC_Init(uint32_t DAC_Channel, DAC_InitTypeDef* DAC_InitStruct);
Nvoid DAC_StructInit(DAC_InitTypeDef* DAC_InitStruct);
Nvoid DAC_Cmd(uint32_t DAC_Channel, FunctionalState NewState);
N#if defined (STM32F10X_LD_VL) || defined (STM32F10X_MD_VL) || defined (STM32F10X_HD_VL)
X#if 0L || 0L || 0L
Svoid DAC_ITConfig(uint32_t DAC_Channel, uint32_t DAC_IT, FunctionalState NewState);
N#endif
Nvoid DAC_DMACmd(uint32_t DAC_Channel, FunctionalState NewState);
Nvoid DAC_SoftwareTriggerCmd(uint32_t DAC_Channel, FunctionalState NewState);
Nvoid DAC_DualSoftwareTriggerCmd(FunctionalState NewState);
Nvoid DAC_WaveGenerationCmd(uint32_t DAC_Channel, uint32_t DAC_Wave, FunctionalState NewState);
Nvoid DAC_SetChannel1Data(uint32_t DAC_Align, uint16_t Data);
Nvoid DAC_SetChannel2Data(uint32_t DAC_Align, uint16_t Data);
Nvoid DAC_SetDualChannelData(uint32_t DAC_Align, uint16_t Data2, uint16_t Data1);
Nuint16_t DAC_GetDataOutputValue(uint32_t DAC_Channel);
N#if defined (STM32F10X_LD_VL) || defined (STM32F10X_MD_VL) || defined (STM32F10X_HD_VL) 
X#if 0L || 0L || 0L 
SFlagStatus DAC_GetFlagStatus(uint32_t DAC_Channel, uint32_t DAC_FLAG);
Svoid DAC_ClearFlag(uint32_t DAC_Channel, uint32_t DAC_FLAG);
SITStatus DAC_GetITStatus(uint32_t DAC_Channel, uint32_t DAC_IT);
Svoid DAC_ClearITPendingBit(uint32_t DAC_Channel, uint32_t DAC_IT);
N#endif
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif /*__STM32F10x_DAC_H */
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */
N
N/******************* (C) COPYRIGHT 2011 STMicroelectronics *****END OF FILE****/
L 34 "..\..\User\stm32f10x_conf.h" 2
N#include "stm32f10x_dbgmcu.h"
L 1 "..\..\Libraries\FWlib\inc\stm32f10x_dbgmcu.h" 1
N/**
N  ******************************************************************************
N  * @file    stm32f10x_dbgmcu.h
N  * @author  MCD Application Team
N  * @version V3.5.0
N  * @date    11-March-2011
N  * @brief   This file contains all the functions prototypes for the DBGMCU 
N  *          firmware library.
N  ******************************************************************************
N  * @attention
N  *
N  * THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
N  * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE
N  * TIME. AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY
N  * DIRECT, INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING
N  * FROM THE CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE
N  * CODING INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
N  *
N  * <h2><center>&copy; COPYRIGHT 2011 STMicroelectronics</center></h2>
N  ******************************************************************************
N  */
N
N/* Define to prevent recursive inclusion -------------------------------------*/
N#ifndef __STM32F10x_DBGMCU_H
N#define __STM32F10x_DBGMCU_H
N
N#ifdef __cplusplus
S extern "C" {
N#endif
N
N/* Includes ------------------------------------------------------------------*/
N#include "stm32f10x.h"
N
N/** @addtogroup STM32F10x_StdPeriph_Driver
N  * @{
N  */
N
N/** @addtogroup DBGMCU
N  * @{
N  */
N
N/** @defgroup DBGMCU_Exported_Types
N  * @{
N  */
N
N/**
N  * @}
N  */
N
N/** @defgroup DBGMCU_Exported_Constants
N  * @{
N  */
N
N#define DBGMCU_SLEEP                 ((uint32_t)0x00000001)
N#define DBGMCU_STOP                  ((uint32_t)0x00000002)
N#define DBGMCU_STANDBY               ((uint32_t)0x00000004)
N#define DBGMCU_IWDG_STOP             ((uint32_t)0x00000100)
N#define DBGMCU_WWDG_STOP             ((uint32_t)0x00000200)
N#define DBGMCU_TIM1_STOP             ((uint32_t)0x00000400)
N#define DBGMCU_TIM2_STOP             ((uint32_t)0x00000800)
N#define DBGMCU_TIM3_STOP             ((uint32_t)0x00001000)
N#define DBGMCU_TIM4_STOP             ((uint32_t)0x00002000)
N#define DBGMCU_CAN1_STOP             ((uint32_t)0x00004000)
N#define DBGMCU_I2C1_SMBUS_TIMEOUT    ((uint32_t)0x00008000)
N#define DBGMCU_I2C2_SMBUS_TIMEOUT    ((uint32_t)0x00010000)
N#define DBGMCU_TIM8_STOP             ((uint32_t)0x00020000)
N#define DBGMCU_TIM5_STOP             ((uint32_t)0x00040000)
N#define DBGMCU_TIM6_STOP             ((uint32_t)0x00080000)
N#define DBGMCU_TIM7_STOP             ((uint32_t)0x00100000)
N#define DBGMCU_CAN2_STOP             ((uint32_t)0x00200000)
N#define DBGMCU_TIM15_STOP            ((uint32_t)0x00400000)
N#define DBGMCU_TIM16_STOP            ((uint32_t)0x00800000)
N#define DBGMCU_TIM17_STOP            ((uint32_t)0x01000000)
N#define DBGMCU_TIM12_STOP            ((uint32_t)0x02000000)
N#define DBGMCU_TIM13_STOP            ((uint32_t)0x04000000)
N#define DBGMCU_TIM14_STOP            ((uint32_t)0x08000000)
N#define DBGMCU_TIM9_STOP             ((uint32_t)0x10000000)
N#define DBGMCU_TIM10_STOP            ((uint32_t)0x20000000)
N#define DBGMCU_TIM11_STOP            ((uint32_t)0x40000000)
N                                              
N#define IS_DBGMCU_PERIPH(PERIPH) ((((PERIPH) & 0x800000F8) == 0x00) && ((PERIPH) != 0x00))
N/**
N  * @}
N  */ 
N
N/** @defgroup DBGMCU_Exported_Macros
N  * @{
N  */
N
N/**
N  * @}
N  */
N
N/** @defgroup DBGMCU_Exported_Functions
N  * @{
N  */
N
Nuint32_t DBGMCU_GetREVID(void);
Nuint32_t DBGMCU_GetDEVID(void);
Nvoid DBGMCU_Config(uint32_t DBGMCU_Periph, FunctionalState NewState);
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif /* __STM32F10x_DBGMCU_H */
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */
N
N/******************* (C) COPYRIGHT 2011 STMicroelectronics *****END OF FILE****/
L 35 "..\..\User\stm32f10x_conf.h" 2
N#include "stm32f10x_dma.h"
L 1 "..\..\Libraries\FWlib\inc\stm32f10x_dma.h" 1
N/**
N  ******************************************************************************
N  * @file    stm32f10x_dma.h
N  * @author  MCD Application Team
N  * @version V3.5.0
N  * @date    11-March-2011
N  * @brief   This file contains all the functions prototypes for the DMA firmware 
N  *          library.
N  ******************************************************************************
N  * @attention
N  *
N  * THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
N  * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE
N  * TIME. AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY
N  * DIRECT, INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING
N  * FROM THE CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE
N  * CODING INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
N  *
N  * <h2><center>&copy; COPYRIGHT 2011 STMicroelectronics</center></h2>
N  ******************************************************************************
N  */
N
N/* Define to prevent recursive inclusion -------------------------------------*/
N#ifndef __STM32F10x_DMA_H
N#define __STM32F10x_DMA_H
N
N#ifdef __cplusplus
S extern "C" {
N#endif
N
N/* Includes ------------------------------------------------------------------*/
N#include "stm32f10x.h"
N
N/** @addtogroup STM32F10x_StdPeriph_Driver
N  * @{
N  */
N
N/** @addtogroup DMA
N  * @{
N  */
N
N/** @defgroup DMA_Exported_Types
N  * @{
N  */
N
N/** 
N  * @brief  DMA Init structure definition
N  */
N
Ntypedef struct
N{
N  uint32_t DMA_PeripheralBaseAddr; /*!< Specifies the peripheral base address for DMAy Channelx. */
N
N  uint32_t DMA_MemoryBaseAddr;     /*!< Specifies the memory base address for DMAy Channelx. */
N
N  uint32_t DMA_DIR;                /*!< Specifies if the peripheral is the source or destination.
N                                        This parameter can be a value of @ref DMA_data_transfer_direction */
N
N  uint32_t DMA_BufferSize;         /*!< Specifies the buffer size, in data unit, of the specified Channel. 
N                                        The data unit is equal to the configuration set in DMA_PeripheralDataSize
N                                        or DMA_MemoryDataSize members depending in the transfer direction. */
N
N  uint32_t DMA_PeripheralInc;      /*!< Specifies whether the Peripheral address register is incremented or not.
N                                        This parameter can be a value of @ref DMA_peripheral_incremented_mode */
N
N  uint32_t DMA_MemoryInc;          /*!< Specifies whether the memory address register is incremented or not.
N                                        This parameter can be a value of @ref DMA_memory_incremented_mode */
N
N  uint32_t DMA_PeripheralDataSize; /*!< Specifies the Peripheral data width.
N                                        This parameter can be a value of @ref DMA_peripheral_data_size */
N
N  uint32_t DMA_MemoryDataSize;     /*!< Specifies the Memory data width.
N                                        This parameter can be a value of @ref DMA_memory_data_size */
N
N  uint32_t DMA_Mode;               /*!< Specifies the operation mode of the DMAy Channelx.
N                                        This parameter can be a value of @ref DMA_circular_normal_mode.
N                                        @note: The circular buffer mode cannot be used if the memory-to-memory
N                                              data transfer is configured on the selected Channel */
N
N  uint32_t DMA_Priority;           /*!< Specifies the software priority for the DMAy Channelx.
N                                        This parameter can be a value of @ref DMA_priority_level */
N
N  uint32_t DMA_M2M;                /*!< Specifies if the DMAy Channelx will be used in memory-to-memory transfer.
N                                        This parameter can be a value of @ref DMA_memory_to_memory */
N}DMA_InitTypeDef;
N
N/**
N  * @}
N  */
N
N/** @defgroup DMA_Exported_Constants
N  * @{
N  */
N
N#define IS_DMA_ALL_PERIPH(PERIPH) (((PERIPH) == DMA1_Channel1) || \
N                                   ((PERIPH) == DMA1_Channel2) || \
N                                   ((PERIPH) == DMA1_Channel3) || \
N                                   ((PERIPH) == DMA1_Channel4) || \
N                                   ((PERIPH) == DMA1_Channel5) || \
N                                   ((PERIPH) == DMA1_Channel6) || \
N                                   ((PERIPH) == DMA1_Channel7) || \
N                                   ((PERIPH) == DMA2_Channel1) || \
N                                   ((PERIPH) == DMA2_Channel2) || \
N                                   ((PERIPH) == DMA2_Channel3) || \
N                                   ((PERIPH) == DMA2_Channel4) || \
N                                   ((PERIPH) == DMA2_Channel5))
X#define IS_DMA_ALL_PERIPH(PERIPH) (((PERIPH) == DMA1_Channel1) ||                                    ((PERIPH) == DMA1_Channel2) ||                                    ((PERIPH) == DMA1_Channel3) ||                                    ((PERIPH) == DMA1_Channel4) ||                                    ((PERIPH) == DMA1_Channel5) ||                                    ((PERIPH) == DMA1_Channel6) ||                                    ((PERIPH) == DMA1_Channel7) ||                                    ((PERIPH) == DMA2_Channel1) ||                                    ((PERIPH) == DMA2_Channel2) ||                                    ((PERIPH) == DMA2_Channel3) ||                                    ((PERIPH) == DMA2_Channel4) ||                                    ((PERIPH) == DMA2_Channel5))
N
N/** @defgroup DMA_data_transfer_direction 
N  * @{
N  */
N
N#define DMA_DIR_PeripheralDST              ((uint32_t)0x00000010)
N#define DMA_DIR_PeripheralSRC              ((uint32_t)0x00000000)
N#define IS_DMA_DIR(DIR) (((DIR) == DMA_DIR_PeripheralDST) || \
N                         ((DIR) == DMA_DIR_PeripheralSRC))
X#define IS_DMA_DIR(DIR) (((DIR) == DMA_DIR_PeripheralDST) ||                          ((DIR) == DMA_DIR_PeripheralSRC))
N/**
N  * @}
N  */
N
N/** @defgroup DMA_peripheral_incremented_mode 
N  * @{
N  */
N
N#define DMA_PeripheralInc_Enable           ((uint32_t)0x00000040)
N#define DMA_PeripheralInc_Disable          ((uint32_t)0x00000000)
N#define IS_DMA_PERIPHERAL_INC_STATE(STATE) (((STATE) == DMA_PeripheralInc_Enable) || \
N                                            ((STATE) == DMA_PeripheralInc_Disable))
X#define IS_DMA_PERIPHERAL_INC_STATE(STATE) (((STATE) == DMA_PeripheralInc_Enable) ||                                             ((STATE) == DMA_PeripheralInc_Disable))
N/**
N  * @}
N  */
N
N/** @defgroup DMA_memory_incremented_mode 
N  * @{
N  */
N
N#define DMA_MemoryInc_Enable               ((uint32_t)0x00000080)
N#define DMA_MemoryInc_Disable              ((uint32_t)0x00000000)
N#define IS_DMA_MEMORY_INC_STATE(STATE) (((STATE) == DMA_MemoryInc_Enable) || \
N                                        ((STATE) == DMA_MemoryInc_Disable))
X#define IS_DMA_MEMORY_INC_STATE(STATE) (((STATE) == DMA_MemoryInc_Enable) ||                                         ((STATE) == DMA_MemoryInc_Disable))
N/**
N  * @}
N  */
N
N/** @defgroup DMA_peripheral_data_size 
N  * @{
N  */
N
N#define DMA_PeripheralDataSize_Byte        ((uint32_t)0x00000000)
N#define DMA_PeripheralDataSize_HalfWord    ((uint32_t)0x00000100)
N#define DMA_PeripheralDataSize_Word        ((uint32_t)0x00000200)
N#define IS_DMA_PERIPHERAL_DATA_SIZE(SIZE) (((SIZE) == DMA_PeripheralDataSize_Byte) || \
N                                           ((SIZE) == DMA_PeripheralDataSize_HalfWord) || \
N                                           ((SIZE) == DMA_PeripheralDataSize_Word))
X#define IS_DMA_PERIPHERAL_DATA_SIZE(SIZE) (((SIZE) == DMA_PeripheralDataSize_Byte) ||                                            ((SIZE) == DMA_PeripheralDataSize_HalfWord) ||                                            ((SIZE) == DMA_PeripheralDataSize_Word))
N/**
N  * @}
N  */
N
N/** @defgroup DMA_memory_data_size 
N  * @{
N  */
N
N#define DMA_MemoryDataSize_Byte            ((uint32_t)0x00000000)
N#define DMA_MemoryDataSize_HalfWord        ((uint32_t)0x00000400)
N#define DMA_MemoryDataSize_Word            ((uint32_t)0x00000800)
N#define IS_DMA_MEMORY_DATA_SIZE(SIZE) (((SIZE) == DMA_MemoryDataSize_Byte) || \
N                                       ((SIZE) == DMA_MemoryDataSize_HalfWord) || \
N                                       ((SIZE) == DMA_MemoryDataSize_Word))
X#define IS_DMA_MEMORY_DATA_SIZE(SIZE) (((SIZE) == DMA_MemoryDataSize_Byte) ||                                        ((SIZE) == DMA_MemoryDataSize_HalfWord) ||                                        ((SIZE) == DMA_MemoryDataSize_Word))
N/**
N  * @}
N  */
N
N/** @defgroup DMA_circular_normal_mode 
N  * @{
N  */
N
N#define DMA_Mode_Circular                  ((uint32_t)0x00000020)
N#define DMA_Mode_Normal                    ((uint32_t)0x00000000)
N#define IS_DMA_MODE(MODE) (((MODE) == DMA_Mode_Circular) || ((MODE) == DMA_Mode_Normal))
N/**
N  * @}
N  */
N
N/** @defgroup DMA_priority_level 
N  * @{
N  */
N
N#define DMA_Priority_VeryHigh              ((uint32_t)0x00003000)
N#define DMA_Priority_High                  ((uint32_t)0x00002000)
N#define DMA_Priority_Medium                ((uint32_t)0x00001000)
N#define DMA_Priority_Low                   ((uint32_t)0x00000000)
N#define IS_DMA_PRIORITY(PRIORITY) (((PRIORITY) == DMA_Priority_VeryHigh) || \
N                                   ((PRIORITY) == DMA_Priority_High) || \
N                                   ((PRIORITY) == DMA_Priority_Medium) || \
N                                   ((PRIORITY) == DMA_Priority_Low))
X#define IS_DMA_PRIORITY(PRIORITY) (((PRIORITY) == DMA_Priority_VeryHigh) ||                                    ((PRIORITY) == DMA_Priority_High) ||                                    ((PRIORITY) == DMA_Priority_Medium) ||                                    ((PRIORITY) == DMA_Priority_Low))
N/**
N  * @}
N  */
N
N/** @defgroup DMA_memory_to_memory 
N  * @{
N  */
N
N#define DMA_M2M_Enable                     ((uint32_t)0x00004000)
N#define DMA_M2M_Disable                    ((uint32_t)0x00000000)
N#define IS_DMA_M2M_STATE(STATE) (((STATE) == DMA_M2M_Enable) || ((STATE) == DMA_M2M_Disable))
N
N/**
N  * @}
N  */
N
N/** @defgroup DMA_interrupts_definition 
N  * @{
N  */
N
N#define DMA_IT_TC                          ((uint32_t)0x00000002)
N#define DMA_IT_HT                          ((uint32_t)0x00000004)
N#define DMA_IT_TE                          ((uint32_t)0x00000008)
N#define IS_DMA_CONFIG_IT(IT) ((((IT) & 0xFFFFFFF1) == 0x00) && ((IT) != 0x00))
N
N#define DMA1_IT_GL1                        ((uint32_t)0x00000001)
N#define DMA1_IT_TC1                        ((uint32_t)0x00000002)
N#define DMA1_IT_HT1                        ((uint32_t)0x00000004)
N#define DMA1_IT_TE1                        ((uint32_t)0x00000008)
N#define DMA1_IT_GL2                        ((uint32_t)0x00000010)
N#define DMA1_IT_TC2                        ((uint32_t)0x00000020)
N#define DMA1_IT_HT2                        ((uint32_t)0x00000040)
N#define DMA1_IT_TE2                        ((uint32_t)0x00000080)
N#define DMA1_IT_GL3                        ((uint32_t)0x00000100)
N#define DMA1_IT_TC3                        ((uint32_t)0x00000200)
N#define DMA1_IT_HT3                        ((uint32_t)0x00000400)
N#define DMA1_IT_TE3                        ((uint32_t)0x00000800)
N#define DMA1_IT_GL4                        ((uint32_t)0x00001000)
N#define DMA1_IT_TC4                        ((uint32_t)0x00002000)
N#define DMA1_IT_HT4                        ((uint32_t)0x00004000)
N#define DMA1_IT_TE4                        ((uint32_t)0x00008000)
N#define DMA1_IT_GL5                        ((uint32_t)0x00010000)
N#define DMA1_IT_TC5                        ((uint32_t)0x00020000)
N#define DMA1_IT_HT5                        ((uint32_t)0x00040000)
N#define DMA1_IT_TE5                        ((uint32_t)0x00080000)
N#define DMA1_IT_GL6                        ((uint32_t)0x00100000)
N#define DMA1_IT_TC6                        ((uint32_t)0x00200000)
N#define DMA1_IT_HT6                        ((uint32_t)0x00400000)
N#define DMA1_IT_TE6                        ((uint32_t)0x00800000)
N#define DMA1_IT_GL7                        ((uint32_t)0x01000000)
N#define DMA1_IT_TC7                        ((uint32_t)0x02000000)
N#define DMA1_IT_HT7                        ((uint32_t)0x04000000)
N#define DMA1_IT_TE7                        ((uint32_t)0x08000000)
N
N#define DMA2_IT_GL1                        ((uint32_t)0x10000001)
N#define DMA2_IT_TC1                        ((uint32_t)0x10000002)
N#define DMA2_IT_HT1                        ((uint32_t)0x10000004)
N#define DMA2_IT_TE1                        ((uint32_t)0x10000008)
N#define DMA2_IT_GL2                        ((uint32_t)0x10000010)
N#define DMA2_IT_TC2                        ((uint32_t)0x10000020)
N#define DMA2_IT_HT2                        ((uint32_t)0x10000040)
N#define DMA2_IT_TE2                        ((uint32_t)0x10000080)
N#define DMA2_IT_GL3                        ((uint32_t)0x10000100)
N#define DMA2_IT_TC3                        ((uint32_t)0x10000200)
N#define DMA2_IT_HT3                        ((uint32_t)0x10000400)
N#define DMA2_IT_TE3                        ((uint32_t)0x10000800)
N#define DMA2_IT_GL4                        ((uint32_t)0x10001000)
N#define DMA2_IT_TC4                        ((uint32_t)0x10002000)
N#define DMA2_IT_HT4                        ((uint32_t)0x10004000)
N#define DMA2_IT_TE4                        ((uint32_t)0x10008000)
N#define DMA2_IT_GL5                        ((uint32_t)0x10010000)
N#define DMA2_IT_TC5                        ((uint32_t)0x10020000)
N#define DMA2_IT_HT5                        ((uint32_t)0x10040000)
N#define DMA2_IT_TE5                        ((uint32_t)0x10080000)
N
N#define IS_DMA_CLEAR_IT(IT) (((((IT) & 0xF0000000) == 0x00) || (((IT) & 0xEFF00000) == 0x00)) && ((IT) != 0x00))
N
N#define IS_DMA_GET_IT(IT) (((IT) == DMA1_IT_GL1) || ((IT) == DMA1_IT_TC1) || \
N                           ((IT) == DMA1_IT_HT1) || ((IT) == DMA1_IT_TE1) || \
N                           ((IT) == DMA1_IT_GL2) || ((IT) == DMA1_IT_TC2) || \
N                           ((IT) == DMA1_IT_HT2) || ((IT) == DMA1_IT_TE2) || \
N                           ((IT) == DMA1_IT_GL3) || ((IT) == DMA1_IT_TC3) || \
N                           ((IT) == DMA1_IT_HT3) || ((IT) == DMA1_IT_TE3) || \
N                           ((IT) == DMA1_IT_GL4) || ((IT) == DMA1_IT_TC4) || \
N                           ((IT) == DMA1_IT_HT4) || ((IT) == DMA1_IT_TE4) || \
N                           ((IT) == DMA1_IT_GL5) || ((IT) == DMA1_IT_TC5) || \
N                           ((IT) == DMA1_IT_HT5) || ((IT) == DMA1_IT_TE5) || \
N                           ((IT) == DMA1_IT_GL6) || ((IT) == DMA1_IT_TC6) || \
N                           ((IT) == DMA1_IT_HT6) || ((IT) == DMA1_IT_TE6) || \
N                           ((IT) == DMA1_IT_GL7) || ((IT) == DMA1_IT_TC7) || \
N                           ((IT) == DMA1_IT_HT7) || ((IT) == DMA1_IT_TE7) || \
N                           ((IT) == DMA2_IT_GL1) || ((IT) == DMA2_IT_TC1) || \
N                           ((IT) == DMA2_IT_HT1) || ((IT) == DMA2_IT_TE1) || \
N                           ((IT) == DMA2_IT_GL2) || ((IT) == DMA2_IT_TC2) || \
N                           ((IT) == DMA2_IT_HT2) || ((IT) == DMA2_IT_TE2) || \
N                           ((IT) == DMA2_IT_GL3) || ((IT) == DMA2_IT_TC3) || \
N                           ((IT) == DMA2_IT_HT3) || ((IT) == DMA2_IT_TE3) || \
N                           ((IT) == DMA2_IT_GL4) || ((IT) == DMA2_IT_TC4) || \
N                           ((IT) == DMA2_IT_HT4) || ((IT) == DMA2_IT_TE4) || \
N                           ((IT) == DMA2_IT_GL5) || ((IT) == DMA2_IT_TC5) || \
N                           ((IT) == DMA2_IT_HT5) || ((IT) == DMA2_IT_TE5))
X#define IS_DMA_GET_IT(IT) (((IT) == DMA1_IT_GL1) || ((IT) == DMA1_IT_TC1) ||                            ((IT) == DMA1_IT_HT1) || ((IT) == DMA1_IT_TE1) ||                            ((IT) == DMA1_IT_GL2) || ((IT) == DMA1_IT_TC2) ||                            ((IT) == DMA1_IT_HT2) || ((IT) == DMA1_IT_TE2) ||                            ((IT) == DMA1_IT_GL3) || ((IT) == DMA1_IT_TC3) ||                            ((IT) == DMA1_IT_HT3) || ((IT) == DMA1_IT_TE3) ||                            ((IT) == DMA1_IT_GL4) || ((IT) == DMA1_IT_TC4) ||                            ((IT) == DMA1_IT_HT4) || ((IT) == DMA1_IT_TE4) ||                            ((IT) == DMA1_IT_GL5) || ((IT) == DMA1_IT_TC5) ||                            ((IT) == DMA1_IT_HT5) || ((IT) == DMA1_IT_TE5) ||                            ((IT) == DMA1_IT_GL6) || ((IT) == DMA1_IT_TC6) ||                            ((IT) == DMA1_IT_HT6) || ((IT) == DMA1_IT_TE6) ||                            ((IT) == DMA1_IT_GL7) || ((IT) == DMA1_IT_TC7) ||                            ((IT) == DMA1_IT_HT7) || ((IT) == DMA1_IT_TE7) ||                            ((IT) == DMA2_IT_GL1) || ((IT) == DMA2_IT_TC1) ||                            ((IT) == DMA2_IT_HT1) || ((IT) == DMA2_IT_TE1) ||                            ((IT) == DMA2_IT_GL2) || ((IT) == DMA2_IT_TC2) ||                            ((IT) == DMA2_IT_HT2) || ((IT) == DMA2_IT_TE2) ||                            ((IT) == DMA2_IT_GL3) || ((IT) == DMA2_IT_TC3) ||                            ((IT) == DMA2_IT_HT3) || ((IT) == DMA2_IT_TE3) ||                            ((IT) == DMA2_IT_GL4) || ((IT) == DMA2_IT_TC4) ||                            ((IT) == DMA2_IT_HT4) || ((IT) == DMA2_IT_TE4) ||                            ((IT) == DMA2_IT_GL5) || ((IT) == DMA2_IT_TC5) ||                            ((IT) == DMA2_IT_HT5) || ((IT) == DMA2_IT_TE5))
N
N/**
N  * @}
N  */
N
N/** @defgroup DMA_flags_definition 
N  * @{
N  */
N#define DMA1_FLAG_GL1                      ((uint32_t)0x00000001)
N#define DMA1_FLAG_TC1                      ((uint32_t)0x00000002)
N#define DMA1_FLAG_HT1                      ((uint32_t)0x00000004)
N#define DMA1_FLAG_TE1                      ((uint32_t)0x00000008)
N#define DMA1_FLAG_GL2                      ((uint32_t)0x00000010)
N#define DMA1_FLAG_TC2                      ((uint32_t)0x00000020)
N#define DMA1_FLAG_HT2                      ((uint32_t)0x00000040)
N#define DMA1_FLAG_TE2                      ((uint32_t)0x00000080)
N#define DMA1_FLAG_GL3                      ((uint32_t)0x00000100)
N#define DMA1_FLAG_TC3                      ((uint32_t)0x00000200)
N#define DMA1_FLAG_HT3                      ((uint32_t)0x00000400)
N#define DMA1_FLAG_TE3                      ((uint32_t)0x00000800)
N#define DMA1_FLAG_GL4                      ((uint32_t)0x00001000)
N#define DMA1_FLAG_TC4                      ((uint32_t)0x00002000)
N#define DMA1_FLAG_HT4                      ((uint32_t)0x00004000)
N#define DMA1_FLAG_TE4                      ((uint32_t)0x00008000)
N#define DMA1_FLAG_GL5                      ((uint32_t)0x00010000)
N#define DMA1_FLAG_TC5                      ((uint32_t)0x00020000)
N#define DMA1_FLAG_HT5                      ((uint32_t)0x00040000)
N#define DMA1_FLAG_TE5                      ((uint32_t)0x00080000)
N#define DMA1_FLAG_GL6                      ((uint32_t)0x00100000)
N#define DMA1_FLAG_TC6                      ((uint32_t)0x00200000)
N#define DMA1_FLAG_HT6                      ((uint32_t)0x00400000)
N#define DMA1_FLAG_TE6                      ((uint32_t)0x00800000)
N#define DMA1_FLAG_GL7                      ((uint32_t)0x01000000)
N#define DMA1_FLAG_TC7                      ((uint32_t)0x02000000)
N#define DMA1_FLAG_HT7                      ((uint32_t)0x04000000)
N#define DMA1_FLAG_TE7                      ((uint32_t)0x08000000)
N
N#define DMA2_FLAG_GL1                      ((uint32_t)0x10000001)
N#define DMA2_FLAG_TC1                      ((uint32_t)0x10000002)
N#define DMA2_FLAG_HT1                      ((uint32_t)0x10000004)
N#define DMA2_FLAG_TE1                      ((uint32_t)0x10000008)
N#define DMA2_FLAG_GL2                      ((uint32_t)0x10000010)
N#define DMA2_FLAG_TC2                      ((uint32_t)0x10000020)
N#define DMA2_FLAG_HT2                      ((uint32_t)0x10000040)
N#define DMA2_FLAG_TE2                      ((uint32_t)0x10000080)
N#define DMA2_FLAG_GL3                      ((uint32_t)0x10000100)
N#define DMA2_FLAG_TC3                      ((uint32_t)0x10000200)
N#define DMA2_FLAG_HT3                      ((uint32_t)0x10000400)
N#define DMA2_FLAG_TE3                      ((uint32_t)0x10000800)
N#define DMA2_FLAG_GL4                      ((uint32_t)0x10001000)
N#define DMA2_FLAG_TC4                      ((uint32_t)0x10002000)
N#define DMA2_FLAG_HT4                      ((uint32_t)0x10004000)
N#define DMA2_FLAG_TE4                      ((uint32_t)0x10008000)
N#define DMA2_FLAG_GL5                      ((uint32_t)0x10010000)
N#define DMA2_FLAG_TC5                      ((uint32_t)0x10020000)
N#define DMA2_FLAG_HT5                      ((uint32_t)0x10040000)
N#define DMA2_FLAG_TE5                      ((uint32_t)0x10080000)
N
N#define IS_DMA_CLEAR_FLAG(FLAG) (((((FLAG) & 0xF0000000) == 0x00) || (((FLAG) & 0xEFF00000) == 0x00)) && ((FLAG) != 0x00))
N
N#define IS_DMA_GET_FLAG(FLAG) (((FLAG) == DMA1_FLAG_GL1) || ((FLAG) == DMA1_FLAG_TC1) || \
N                               ((FLAG) == DMA1_FLAG_HT1) || ((FLAG) == DMA1_FLAG_TE1) || \
N                               ((FLAG) == DMA1_FLAG_GL2) || ((FLAG) == DMA1_FLAG_TC2) || \
N                               ((FLAG) == DMA1_FLAG_HT2) || ((FLAG) == DMA1_FLAG_TE2) || \
N                               ((FLAG) == DMA1_FLAG_GL3) || ((FLAG) == DMA1_FLAG_TC3) || \
N                               ((FLAG) == DMA1_FLAG_HT3) || ((FLAG) == DMA1_FLAG_TE3) || \
N                               ((FLAG) == DMA1_FLAG_GL4) || ((FLAG) == DMA1_FLAG_TC4) || \
N                               ((FLAG) == DMA1_FLAG_HT4) || ((FLAG) == DMA1_FLAG_TE4) || \
N                               ((FLAG) == DMA1_FLAG_GL5) || ((FLAG) == DMA1_FLAG_TC5) || \
N                               ((FLAG) == DMA1_FLAG_HT5) || ((FLAG) == DMA1_FLAG_TE5) || \
N                               ((FLAG) == DMA1_FLAG_GL6) || ((FLAG) == DMA1_FLAG_TC6) || \
N                               ((FLAG) == DMA1_FLAG_HT6) || ((FLAG) == DMA1_FLAG_TE6) || \
N                               ((FLAG) == DMA1_FLAG_GL7) || ((FLAG) == DMA1_FLAG_TC7) || \
N                               ((FLAG) == DMA1_FLAG_HT7) || ((FLAG) == DMA1_FLAG_TE7) || \
N                               ((FLAG) == DMA2_FLAG_GL1) || ((FLAG) == DMA2_FLAG_TC1) || \
N                               ((FLAG) == DMA2_FLAG_HT1) || ((FLAG) == DMA2_FLAG_TE1) || \
N                               ((FLAG) == DMA2_FLAG_GL2) || ((FLAG) == DMA2_FLAG_TC2) || \
N                               ((FLAG) == DMA2_FLAG_HT2) || ((FLAG) == DMA2_FLAG_TE2) || \
N                               ((FLAG) == DMA2_FLAG_GL3) || ((FLAG) == DMA2_FLAG_TC3) || \
N                               ((FLAG) == DMA2_FLAG_HT3) || ((FLAG) == DMA2_FLAG_TE3) || \
N                               ((FLAG) == DMA2_FLAG_GL4) || ((FLAG) == DMA2_FLAG_TC4) || \
N                               ((FLAG) == DMA2_FLAG_HT4) || ((FLAG) == DMA2_FLAG_TE4) || \
N                               ((FLAG) == DMA2_FLAG_GL5) || ((FLAG) == DMA2_FLAG_TC5) || \
N                               ((FLAG) == DMA2_FLAG_HT5) || ((FLAG) == DMA2_FLAG_TE5))
X#define IS_DMA_GET_FLAG(FLAG) (((FLAG) == DMA1_FLAG_GL1) || ((FLAG) == DMA1_FLAG_TC1) ||                                ((FLAG) == DMA1_FLAG_HT1) || ((FLAG) == DMA1_FLAG_TE1) ||                                ((FLAG) == DMA1_FLAG_GL2) || ((FLAG) == DMA1_FLAG_TC2) ||                                ((FLAG) == DMA1_FLAG_HT2) || ((FLAG) == DMA1_FLAG_TE2) ||                                ((FLAG) == DMA1_FLAG_GL3) || ((FLAG) == DMA1_FLAG_TC3) ||                                ((FLAG) == DMA1_FLAG_HT3) || ((FLAG) == DMA1_FLAG_TE3) ||                                ((FLAG) == DMA1_FLAG_GL4) || ((FLAG) == DMA1_FLAG_TC4) ||                                ((FLAG) == DMA1_FLAG_HT4) || ((FLAG) == DMA1_FLAG_TE4) ||                                ((FLAG) == DMA1_FLAG_GL5) || ((FLAG) == DMA1_FLAG_TC5) ||                                ((FLAG) == DMA1_FLAG_HT5) || ((FLAG) == DMA1_FLAG_TE5) ||                                ((FLAG) == DMA1_FLAG_GL6) || ((FLAG) == DMA1_FLAG_TC6) ||                                ((FLAG) == DMA1_FLAG_HT6) || ((FLAG) == DMA1_FLAG_TE6) ||                                ((FLAG) == DMA1_FLAG_GL7) || ((FLAG) == DMA1_FLAG_TC7) ||                                ((FLAG) == DMA1_FLAG_HT7) || ((FLAG) == DMA1_FLAG_TE7) ||                                ((FLAG) == DMA2_FLAG_GL1) || ((FLAG) == DMA2_FLAG_TC1) ||                                ((FLAG) == DMA2_FLAG_HT1) || ((FLAG) == DMA2_FLAG_TE1) ||                                ((FLAG) == DMA2_FLAG_GL2) || ((FLAG) == DMA2_FLAG_TC2) ||                                ((FLAG) == DMA2_FLAG_HT2) || ((FLAG) == DMA2_FLAG_TE2) ||                                ((FLAG) == DMA2_FLAG_GL3) || ((FLAG) == DMA2_FLAG_TC3) ||                                ((FLAG) == DMA2_FLAG_HT3) || ((FLAG) == DMA2_FLAG_TE3) ||                                ((FLAG) == DMA2_FLAG_GL4) || ((FLAG) == DMA2_FLAG_TC4) ||                                ((FLAG) == DMA2_FLAG_HT4) || ((FLAG) == DMA2_FLAG_TE4) ||                                ((FLAG) == DMA2_FLAG_GL5) || ((FLAG) == DMA2_FLAG_TC5) ||                                ((FLAG) == DMA2_FLAG_HT5) || ((FLAG) == DMA2_FLAG_TE5))
N/**
N  * @}
N  */
N
N/** @defgroup DMA_Buffer_Size 
N  * @{
N  */
N
N#define IS_DMA_BUFFER_SIZE(SIZE) (((SIZE) >= 0x1) && ((SIZE) < 0x10000))
N
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */
N
N/** @defgroup DMA_Exported_Macros
N  * @{
N  */
N
N/**
N  * @}
N  */
N
N/** @defgroup DMA_Exported_Functions
N  * @{
N  */
N
Nvoid DMA_DeInit(DMA_Channel_TypeDef* DMAy_Channelx);
Nvoid DMA_Init(DMA_Channel_TypeDef* DMAy_Channelx, DMA_InitTypeDef* DMA_InitStruct);
Nvoid DMA_StructInit(DMA_InitTypeDef* DMA_InitStruct);
Nvoid DMA_Cmd(DMA_Channel_TypeDef* DMAy_Channelx, FunctionalState NewState);
Nvoid DMA_ITConfig(DMA_Channel_TypeDef* DMAy_Channelx, uint32_t DMA_IT, FunctionalState NewState);
Nvoid DMA_SetCurrDataCounter(DMA_Channel_TypeDef* DMAy_Channelx, uint16_t DataNumber); 
Nuint16_t DMA_GetCurrDataCounter(DMA_Channel_TypeDef* DMAy_Channelx);
NFlagStatus DMA_GetFlagStatus(uint32_t DMAy_FLAG);
Nvoid DMA_ClearFlag(uint32_t DMAy_FLAG);
NITStatus DMA_GetITStatus(uint32_t DMAy_IT);
Nvoid DMA_ClearITPendingBit(uint32_t DMAy_IT);
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif /*__STM32F10x_DMA_H */
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */
N
N/******************* (C) COPYRIGHT 2011 STMicroelectronics *****END OF FILE****/
L 36 "..\..\User\stm32f10x_conf.h" 2
N#include "stm32f10x_exti.h" 
L 1 "..\..\Libraries\FWlib\inc\stm32f10x_exti.h" 1
N/**
N  ******************************************************************************
N  * @file    stm32f10x_exti.h
N  * @author  MCD Application Team
N  * @version V3.5.0
N  * @date    11-March-2011
N  * @brief   This file contains all the functions prototypes for the EXTI firmware
N  *          library.
N  ******************************************************************************
N  * @attention
N  *
N  * THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
N  * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE
N  * TIME. AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY
N  * DIRECT, INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING
N  * FROM THE CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE
N  * CODING INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
N  *
N  * <h2><center>&copy; COPYRIGHT 2011 STMicroelectronics</center></h2>
N  ******************************************************************************
N  */
N
N/* Define to prevent recursive inclusion -------------------------------------*/
N#ifndef __STM32F10x_EXTI_H
N#define __STM32F10x_EXTI_H
N
N#ifdef __cplusplus
S extern "C" {
N#endif
N
N/* Includes ------------------------------------------------------------------*/
N#include "stm32f10x.h"
N
N/** @addtogroup STM32F10x_StdPeriph_Driver
N  * @{
N  */
N
N/** @addtogroup EXTI
N  * @{
N  */
N
N/** @defgroup EXTI_Exported_Types
N  * @{
N  */
N
N/** 
N  * @brief  EXTI mode enumeration  
N  */
N
Ntypedef enum
N{
N  EXTI_Mode_Interrupt = 0x00,
N  EXTI_Mode_Event = 0x04
N}EXTIMode_TypeDef;
N
N#define IS_EXTI_MODE(MODE) (((MODE) == EXTI_Mode_Interrupt) || ((MODE) == EXTI_Mode_Event))
N
N/** 
N  * @brief  EXTI Trigger enumeration  
N  */
N
Ntypedef enum
N{
N  EXTI_Trigger_Rising = 0x08,
N  EXTI_Trigger_Falling = 0x0C,  
N  EXTI_Trigger_Rising_Falling = 0x10
N}EXTITrigger_TypeDef;
N
N#define IS_EXTI_TRIGGER(TRIGGER) (((TRIGGER) == EXTI_Trigger_Rising) || \
N                                  ((TRIGGER) == EXTI_Trigger_Falling) || \
N                                  ((TRIGGER) == EXTI_Trigger_Rising_Falling))
X#define IS_EXTI_TRIGGER(TRIGGER) (((TRIGGER) == EXTI_Trigger_Rising) ||                                   ((TRIGGER) == EXTI_Trigger_Falling) ||                                   ((TRIGGER) == EXTI_Trigger_Rising_Falling))
N/** 
N  * @brief  EXTI Init Structure definition  
N  */
N
Ntypedef struct
N{
N  uint32_t EXTI_Line;               /*!< Specifies the EXTI lines to be enabled or disabled.
N                                         This parameter can be any combination of @ref EXTI_Lines */
N   
N  EXTIMode_TypeDef EXTI_Mode;       /*!< Specifies the mode for the EXTI lines.
N                                         This parameter can be a value of @ref EXTIMode_TypeDef */
N
N  EXTITrigger_TypeDef EXTI_Trigger; /*!< Specifies the trigger signal active edge for the EXTI lines.
N                                         This parameter can be a value of @ref EXTIMode_TypeDef */
N
N  FunctionalState EXTI_LineCmd;     /*!< Specifies the new state of the selected EXTI lines.
N                                         This parameter can be set either to ENABLE or DISABLE */ 
N}EXTI_InitTypeDef;
N
N/**
N  * @}
N  */
N
N/** @defgroup EXTI_Exported_Constants
N  * @{
N  */
N
N/** @defgroup EXTI_Lines 
N  * @{
N  */
N
N#define EXTI_Line0       ((uint32_t)0x00001)  /*!< External interrupt line 0 */
N#define EXTI_Line1       ((uint32_t)0x00002)  /*!< External interrupt line 1 */
N#define EXTI_Line2       ((uint32_t)0x00004)  /*!< External interrupt line 2 */
N#define EXTI_Line3       ((uint32_t)0x00008)  /*!< External interrupt line 3 */
N#define EXTI_Line4       ((uint32_t)0x00010)  /*!< External interrupt line 4 */
N#define EXTI_Line5       ((uint32_t)0x00020)  /*!< External interrupt line 5 */
N#define EXTI_Line6       ((uint32_t)0x00040)  /*!< External interrupt line 6 */
N#define EXTI_Line7       ((uint32_t)0x00080)  /*!< External interrupt line 7 */
N#define EXTI_Line8       ((uint32_t)0x00100)  /*!< External interrupt line 8 */
N#define EXTI_Line9       ((uint32_t)0x00200)  /*!< External interrupt line 9 */
N#define EXTI_Line10      ((uint32_t)0x00400)  /*!< External interrupt line 10 */
N#define EXTI_Line11      ((uint32_t)0x00800)  /*!< External interrupt line 11 */
N#define EXTI_Line12      ((uint32_t)0x01000)  /*!< External interrupt line 12 */
N#define EXTI_Line13      ((uint32_t)0x02000)  /*!< External interrupt line 13 */
N#define EXTI_Line14      ((uint32_t)0x04000)  /*!< External interrupt line 14 */
N#define EXTI_Line15      ((uint32_t)0x08000)  /*!< External interrupt line 15 */
N#define EXTI_Line16      ((uint32_t)0x10000)  /*!< External interrupt line 16 Connected to the PVD Output */
N#define EXTI_Line17      ((uint32_t)0x20000)  /*!< External interrupt line 17 Connected to the RTC Alarm event */
N#define EXTI_Line18      ((uint32_t)0x40000)  /*!< External interrupt line 18 Connected to the USB Device/USB OTG FS
N                                                   Wakeup from suspend event */                                    
N#define EXTI_Line19      ((uint32_t)0x80000)  /*!< External interrupt line 19 Connected to the Ethernet Wakeup event */
N                                          
N#define IS_EXTI_LINE(LINE) ((((LINE) & (uint32_t)0xFFF00000) == 0x00) && ((LINE) != (uint16_t)0x00))
N#define IS_GET_EXTI_LINE(LINE) (((LINE) == EXTI_Line0) || ((LINE) == EXTI_Line1) || \
N                            ((LINE) == EXTI_Line2) || ((LINE) == EXTI_Line3) || \
N                            ((LINE) == EXTI_Line4) || ((LINE) == EXTI_Line5) || \
N                            ((LINE) == EXTI_Line6) || ((LINE) == EXTI_Line7) || \
N                            ((LINE) == EXTI_Line8) || ((LINE) == EXTI_Line9) || \
N                            ((LINE) == EXTI_Line10) || ((LINE) == EXTI_Line11) || \
N                            ((LINE) == EXTI_Line12) || ((LINE) == EXTI_Line13) || \
N                            ((LINE) == EXTI_Line14) || ((LINE) == EXTI_Line15) || \
N                            ((LINE) == EXTI_Line16) || ((LINE) == EXTI_Line17) || \
N                            ((LINE) == EXTI_Line18) || ((LINE) == EXTI_Line19))
X#define IS_GET_EXTI_LINE(LINE) (((LINE) == EXTI_Line0) || ((LINE) == EXTI_Line1) ||                             ((LINE) == EXTI_Line2) || ((LINE) == EXTI_Line3) ||                             ((LINE) == EXTI_Line4) || ((LINE) == EXTI_Line5) ||                             ((LINE) == EXTI_Line6) || ((LINE) == EXTI_Line7) ||                             ((LINE) == EXTI_Line8) || ((LINE) == EXTI_Line9) ||                             ((LINE) == EXTI_Line10) || ((LINE) == EXTI_Line11) ||                             ((LINE) == EXTI_Line12) || ((LINE) == EXTI_Line13) ||                             ((LINE) == EXTI_Line14) || ((LINE) == EXTI_Line15) ||                             ((LINE) == EXTI_Line16) || ((LINE) == EXTI_Line17) ||                             ((LINE) == EXTI_Line18) || ((LINE) == EXTI_Line19))
N
N                    
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */
N
N/** @defgroup EXTI_Exported_Macros
N  * @{
N  */
N
N/**
N  * @}
N  */
N
N/** @defgroup EXTI_Exported_Functions
N  * @{
N  */
N
Nvoid EXTI_DeInit(void);
Nvoid EXTI_Init(EXTI_InitTypeDef* EXTI_InitStruct);
Nvoid EXTI_StructInit(EXTI_InitTypeDef* EXTI_InitStruct);
Nvoid EXTI_GenerateSWInterrupt(uint32_t EXTI_Line);
NFlagStatus EXTI_GetFlagStatus(uint32_t EXTI_Line);
Nvoid EXTI_ClearFlag(uint32_t EXTI_Line);
NITStatus EXTI_GetITStatus(uint32_t EXTI_Line);
Nvoid EXTI_ClearITPendingBit(uint32_t EXTI_Line);
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif /* __STM32F10x_EXTI_H */
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */
N
N/******************* (C) COPYRIGHT 2011 STMicroelectronics *****END OF FILE****/
L 37 "..\..\User\stm32f10x_conf.h" 2
N#include "stm32f10x_flash.h"
L 1 "..\..\Libraries\FWlib\inc\stm32f10x_flash.h" 1
N/**
N  ******************************************************************************
N  * @file    stm32f10x_flash.h
N  * @author  MCD Application Team
N  * @version V3.5.0
N  * @date    11-March-2011
N  * @brief   This file contains all the functions prototypes for the FLASH 
N  *          firmware library.
N  ******************************************************************************
N  * @attention
N  *
N  * THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
N  * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE
N  * TIME. AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY
N  * DIRECT, INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING
N  * FROM THE CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE
N  * CODING INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
N  *
N  * <h2><center>&copy; COPYRIGHT 2011 STMicroelectronics</center></h2>
N  ******************************************************************************
N  */
N
N/* Define to prevent recursive inclusion -------------------------------------*/
N#ifndef __STM32F10x_FLASH_H
N#define __STM32F10x_FLASH_H
N
N#ifdef __cplusplus
S extern "C" {
N#endif
N
N/* Includes ------------------------------------------------------------------*/
N#include "stm32f10x.h"
N
N/** @addtogroup STM32F10x_StdPeriph_Driver
N  * @{
N  */
N
N/** @addtogroup FLASH
N  * @{
N  */
N
N/** @defgroup FLASH_Exported_Types
N  * @{
N  */
N
N/** 
N  * @brief  FLASH Status  
N  */
N
Ntypedef enum
N{ 
N  FLASH_BUSY = 1,
N  FLASH_ERROR_PG,
N  FLASH_ERROR_WRP,
N  FLASH_COMPLETE,
N  FLASH_TIMEOUT
N}FLASH_Status;
N
N/**
N  * @}
N  */
N
N/** @defgroup FLASH_Exported_Constants
N  * @{
N  */
N
N/** @defgroup Flash_Latency 
N  * @{
N  */
N
N#define FLASH_Latency_0                ((uint32_t)0x00000000)  /*!< FLASH Zero Latency cycle */
N#define FLASH_Latency_1                ((uint32_t)0x00000001)  /*!< FLASH One Latency cycle */
N#define FLASH_Latency_2                ((uint32_t)0x00000002)  /*!< FLASH Two Latency cycles */
N#define IS_FLASH_LATENCY(LATENCY) (((LATENCY) == FLASH_Latency_0) || \
N                                   ((LATENCY) == FLASH_Latency_1) || \
N                                   ((LATENCY) == FLASH_Latency_2))
X#define IS_FLASH_LATENCY(LATENCY) (((LATENCY) == FLASH_Latency_0) ||                                    ((LATENCY) == FLASH_Latency_1) ||                                    ((LATENCY) == FLASH_Latency_2))
N/**
N  * @}
N  */
N
N/** @defgroup Half_Cycle_Enable_Disable 
N  * @{
N  */
N
N#define FLASH_HalfCycleAccess_Enable   ((uint32_t)0x00000008)  /*!< FLASH Half Cycle Enable */
N#define FLASH_HalfCycleAccess_Disable  ((uint32_t)0x00000000)  /*!< FLASH Half Cycle Disable */
N#define IS_FLASH_HALFCYCLEACCESS_STATE(STATE) (((STATE) == FLASH_HalfCycleAccess_Enable) || \
N                                               ((STATE) == FLASH_HalfCycleAccess_Disable)) 
X#define IS_FLASH_HALFCYCLEACCESS_STATE(STATE) (((STATE) == FLASH_HalfCycleAccess_Enable) ||                                                ((STATE) == FLASH_HalfCycleAccess_Disable)) 
N/**
N  * @}
N  */
N
N/** @defgroup Prefetch_Buffer_Enable_Disable 
N  * @{
N  */
N
N#define FLASH_PrefetchBuffer_Enable    ((uint32_t)0x00000010)  /*!< FLASH Prefetch Buffer Enable */
N#define FLASH_PrefetchBuffer_Disable   ((uint32_t)0x00000000)  /*!< FLASH Prefetch Buffer Disable */
N#define IS_FLASH_PREFETCHBUFFER_STATE(STATE) (((STATE) == FLASH_PrefetchBuffer_Enable) || \
N                                              ((STATE) == FLASH_PrefetchBuffer_Disable)) 
X#define IS_FLASH_PREFETCHBUFFER_STATE(STATE) (((STATE) == FLASH_PrefetchBuffer_Enable) ||                                               ((STATE) == FLASH_PrefetchBuffer_Disable)) 
N/**
N  * @}
N  */
N
N/** @defgroup Option_Bytes_Write_Protection 
N  * @{
N  */
N
N/* Values to be used with STM32 Low and Medium density devices */
N#define FLASH_WRProt_Pages0to3         ((uint32_t)0x00000001) /*!< STM32 Low and Medium density devices: Write protection of page 0 to 3 */
N#define FLASH_WRProt_Pages4to7         ((uint32_t)0x00000002) /*!< STM32 Low and Medium density devices: Write protection of page 4 to 7 */
N#define FLASH_WRProt_Pages8to11        ((uint32_t)0x00000004) /*!< STM32 Low and Medium density devices: Write protection of page 8 to 11 */
N#define FLASH_WRProt_Pages12to15       ((uint32_t)0x00000008) /*!< STM32 Low and Medium density devices: Write protection of page 12 to 15 */
N#define FLASH_WRProt_Pages16to19       ((uint32_t)0x00000010) /*!< STM32 Low and Medium density devices: Write protection of page 16 to 19 */
N#define FLASH_WRProt_Pages20to23       ((uint32_t)0x00000020) /*!< STM32 Low and Medium density devices: Write protection of page 20 to 23 */
N#define FLASH_WRProt_Pages24to27       ((uint32_t)0x00000040) /*!< STM32 Low and Medium density devices: Write protection of page 24 to 27 */
N#define FLASH_WRProt_Pages28to31       ((uint32_t)0x00000080) /*!< STM32 Low and Medium density devices: Write protection of page 28 to 31 */
N
N/* Values to be used with STM32 Medium-density devices */
N#define FLASH_WRProt_Pages32to35       ((uint32_t)0x00000100) /*!< STM32 Medium-density devices: Write protection of page 32 to 35 */
N#define FLASH_WRProt_Pages36to39       ((uint32_t)0x00000200) /*!< STM32 Medium-density devices: Write protection of page 36 to 39 */
N#define FLASH_WRProt_Pages40to43       ((uint32_t)0x00000400) /*!< STM32 Medium-density devices: Write protection of page 40 to 43 */
N#define FLASH_WRProt_Pages44to47       ((uint32_t)0x00000800) /*!< STM32 Medium-density devices: Write protection of page 44 to 47 */
N#define FLASH_WRProt_Pages48to51       ((uint32_t)0x00001000) /*!< STM32 Medium-density devices: Write protection of page 48 to 51 */
N#define FLASH_WRProt_Pages52to55       ((uint32_t)0x00002000) /*!< STM32 Medium-density devices: Write protection of page 52 to 55 */
N#define FLASH_WRProt_Pages56to59       ((uint32_t)0x00004000) /*!< STM32 Medium-density devices: Write protection of page 56 to 59 */
N#define FLASH_WRProt_Pages60to63       ((uint32_t)0x00008000) /*!< STM32 Medium-density devices: Write protection of page 60 to 63 */
N#define FLASH_WRProt_Pages64to67       ((uint32_t)0x00010000) /*!< STM32 Medium-density devices: Write protection of page 64 to 67 */
N#define FLASH_WRProt_Pages68to71       ((uint32_t)0x00020000) /*!< STM32 Medium-density devices: Write protection of page 68 to 71 */
N#define FLASH_WRProt_Pages72to75       ((uint32_t)0x00040000) /*!< STM32 Medium-density devices: Write protection of page 72 to 75 */
N#define FLASH_WRProt_Pages76to79       ((uint32_t)0x00080000) /*!< STM32 Medium-density devices: Write protection of page 76 to 79 */
N#define FLASH_WRProt_Pages80to83       ((uint32_t)0x00100000) /*!< STM32 Medium-density devices: Write protection of page 80 to 83 */
N#define FLASH_WRProt_Pages84to87       ((uint32_t)0x00200000) /*!< STM32 Medium-density devices: Write protection of page 84 to 87 */
N#define FLASH_WRProt_Pages88to91       ((uint32_t)0x00400000) /*!< STM32 Medium-density devices: Write protection of page 88 to 91 */
N#define FLASH_WRProt_Pages92to95       ((uint32_t)0x00800000) /*!< STM32 Medium-density devices: Write protection of page 92 to 95 */
N#define FLASH_WRProt_Pages96to99       ((uint32_t)0x01000000) /*!< STM32 Medium-density devices: Write protection of page 96 to 99 */
N#define FLASH_WRProt_Pages100to103     ((uint32_t)0x02000000) /*!< STM32 Medium-density devices: Write protection of page 100 to 103 */
N#define FLASH_WRProt_Pages104to107     ((uint32_t)0x04000000) /*!< STM32 Medium-density devices: Write protection of page 104 to 107 */
N#define FLASH_WRProt_Pages108to111     ((uint32_t)0x08000000) /*!< STM32 Medium-density devices: Write protection of page 108 to 111 */
N#define FLASH_WRProt_Pages112to115     ((uint32_t)0x10000000) /*!< STM32 Medium-density devices: Write protection of page 112 to 115 */
N#define FLASH_WRProt_Pages116to119     ((uint32_t)0x20000000) /*!< STM32 Medium-density devices: Write protection of page 115 to 119 */
N#define FLASH_WRProt_Pages120to123     ((uint32_t)0x40000000) /*!< STM32 Medium-density devices: Write protection of page 120 to 123 */
N#define FLASH_WRProt_Pages124to127     ((uint32_t)0x80000000) /*!< STM32 Medium-density devices: Write protection of page 124 to 127 */
N
N/* Values to be used with STM32 High-density and STM32F10X Connectivity line devices */
N#define FLASH_WRProt_Pages0to1         ((uint32_t)0x00000001) /*!< STM32 High-density, XL-density and Connectivity line devices:
N                                                                   Write protection of page 0 to 1 */
N#define FLASH_WRProt_Pages2to3         ((uint32_t)0x00000002) /*!< STM32 High-density, XL-density and Connectivity line devices:
N                                                                   Write protection of page 2 to 3 */
N#define FLASH_WRProt_Pages4to5         ((uint32_t)0x00000004) /*!< STM32 High-density, XL-density and Connectivity line devices:
N                                                                   Write protection of page 4 to 5 */
N#define FLASH_WRProt_Pages6to7         ((uint32_t)0x00000008) /*!< STM32 High-density, XL-density and Connectivity line devices:
N                                                                   Write protection of page 6 to 7 */
N#define FLASH_WRProt_Pages8to9         ((uint32_t)0x00000010) /*!< STM32 High-density, XL-density and Connectivity line devices:
N                                                                   Write protection of page 8 to 9 */
N#define FLASH_WRProt_Pages10to11       ((uint32_t)0x00000020) /*!< STM32 High-density, XL-density and Connectivity line devices:
N                                                                   Write protection of page 10 to 11 */
N#define FLASH_WRProt_Pages12to13       ((uint32_t)0x00000040) /*!< STM32 High-density, XL-density and Connectivity line devices:
N                                                                   Write protection of page 12 to 13 */
N#define FLASH_WRProt_Pages14to15       ((uint32_t)0x00000080) /*!< STM32 High-density, XL-density and Connectivity line devices:
N                                                                   Write protection of page 14 to 15 */
N#define FLASH_WRProt_Pages16to17       ((uint32_t)0x00000100) /*!< STM32 High-density, XL-density and Connectivity line devices:
N                                                                   Write protection of page 16 to 17 */
N#define FLASH_WRProt_Pages18to19       ((uint32_t)0x00000200) /*!< STM32 High-density, XL-density and Connectivity line devices:
N                                                                   Write protection of page 18 to 19 */
N#define FLASH_WRProt_Pages20to21       ((uint32_t)0x00000400) /*!< STM32 High-density, XL-density and Connectivity line devices:
N                                                                   Write protection of page 20 to 21 */
N#define FLASH_WRProt_Pages22to23       ((uint32_t)0x00000800) /*!< STM32 High-density, XL-density and Connectivity line devices:
N                                                                   Write protection of page 22 to 23 */
N#define FLASH_WRProt_Pages24to25       ((uint32_t)0x00001000) /*!< STM32 High-density, XL-density and Connectivity line devices:
N                                                                   Write protection of page 24 to 25 */
N#define FLASH_WRProt_Pages26to27       ((uint32_t)0x00002000) /*!< STM32 High-density, XL-density and Connectivity line devices:
N                                                                   Write protection of page 26 to 27 */
N#define FLASH_WRProt_Pages28to29       ((uint32_t)0x00004000) /*!< STM32 High-density, XL-density and Connectivity line devices:
N                                                                   Write protection of page 28 to 29 */
N#define FLASH_WRProt_Pages30to31       ((uint32_t)0x00008000) /*!< STM32 High-density, XL-density and Connectivity line devices:
N                                                                   Write protection of page 30 to 31 */
N#define FLASH_WRProt_Pages32to33       ((uint32_t)0x00010000) /*!< STM32 High-density, XL-density and Connectivity line devices:
N                                                                   Write protection of page 32 to 33 */
N#define FLASH_WRProt_Pages34to35       ((uint32_t)0x00020000) /*!< STM32 High-density, XL-density and Connectivity line devices:
N                                                                   Write protection of page 34 to 35 */
N#define FLASH_WRProt_Pages36to37       ((uint32_t)0x00040000) /*!< STM32 High-density, XL-density and Connectivity line devices:
N                                                                   Write protection of page 36 to 37 */
N#define FLASH_WRProt_Pages38to39       ((uint32_t)0x00080000) /*!< STM32 High-density, XL-density and Connectivity line devices:
N                                                                   Write protection of page 38 to 39 */
N#define FLASH_WRProt_Pages40to41       ((uint32_t)0x00100000) /*!< STM32 High-density, XL-density and Connectivity line devices:
N                                                                   Write protection of page 40 to 41 */
N#define FLASH_WRProt_Pages42to43       ((uint32_t)0x00200000) /*!< STM32 High-density, XL-density and Connectivity line devices:
N                                                                   Write protection of page 42 to 43 */
N#define FLASH_WRProt_Pages44to45       ((uint32_t)0x00400000) /*!< STM32 High-density, XL-density and Connectivity line devices:
N                                                                   Write protection of page 44 to 45 */
N#define FLASH_WRProt_Pages46to47       ((uint32_t)0x00800000) /*!< STM32 High-density, XL-density and Connectivity line devices:
N                                                                   Write protection of page 46 to 47 */
N#define FLASH_WRProt_Pages48to49       ((uint32_t)0x01000000) /*!< STM32 High-density, XL-density and Connectivity line devices:
N                                                                   Write protection of page 48 to 49 */
N#define FLASH_WRProt_Pages50to51       ((uint32_t)0x02000000) /*!< STM32 High-density, XL-density and Connectivity line devices:
N                                                                   Write protection of page 50 to 51 */
N#define FLASH_WRProt_Pages52to53       ((uint32_t)0x04000000) /*!< STM32 High-density, XL-density and Connectivity line devices:
N                                                                   Write protection of page 52 to 53 */
N#define FLASH_WRProt_Pages54to55       ((uint32_t)0x08000000) /*!< STM32 High-density, XL-density and Connectivity line devices:
N                                                                   Write protection of page 54 to 55 */
N#define FLASH_WRProt_Pages56to57       ((uint32_t)0x10000000) /*!< STM32 High-density, XL-density and Connectivity line devices:
N                                                                   Write protection of page 56 to 57 */
N#define FLASH_WRProt_Pages58to59       ((uint32_t)0x20000000) /*!< STM32 High-density, XL-density and Connectivity line devices:
N                                                                   Write protection of page 58 to 59 */
N#define FLASH_WRProt_Pages60to61       ((uint32_t)0x40000000) /*!< STM32 High-density, XL-density and Connectivity line devices:
N                                                                   Write protection of page 60 to 61 */
N#define FLASH_WRProt_Pages62to127      ((uint32_t)0x80000000) /*!< STM32 Connectivity line devices: Write protection of page 62 to 127 */
N#define FLASH_WRProt_Pages62to255      ((uint32_t)0x80000000) /*!< STM32 Medium-density devices: Write protection of page 62 to 255 */
N#define FLASH_WRProt_Pages62to511      ((uint32_t)0x80000000) /*!< STM32 XL-density devices: Write protection of page 62 to 511 */
N
N#define FLASH_WRProt_AllPages          ((uint32_t)0xFFFFFFFF) /*!< Write protection of all Pages */
N
N#define IS_FLASH_WRPROT_PAGE(PAGE) (((PAGE) != 0x00000000))
N
N#define IS_FLASH_ADDRESS(ADDRESS) (((ADDRESS) >= 0x08000000) && ((ADDRESS) < 0x080FFFFF))
N
N#define IS_OB_DATA_ADDRESS(ADDRESS) (((ADDRESS) == 0x1FFFF804) || ((ADDRESS) == 0x1FFFF806))
N
N/**
N  * @}
N  */
N
N/** @defgroup Option_Bytes_IWatchdog 
N  * @{
N  */
N
N#define OB_IWDG_SW                     ((uint16_t)0x0001)  /*!< Software IWDG selected */
N#define OB_IWDG_HW                     ((uint16_t)0x0000)  /*!< Hardware IWDG selected */
N#define IS_OB_IWDG_SOURCE(SOURCE) (((SOURCE) == OB_IWDG_SW) || ((SOURCE) == OB_IWDG_HW))
N
N/**
N  * @}
N  */
N
N/** @defgroup Option_Bytes_nRST_STOP 
N  * @{
N  */
N
N#define OB_STOP_NoRST                  ((uint16_t)0x0002) /*!< No reset generated when entering in STOP */
N#define OB_STOP_RST                    ((uint16_t)0x0000) /*!< Reset generated when entering in STOP */
N#define IS_OB_STOP_SOURCE(SOURCE) (((SOURCE) == OB_STOP_NoRST) || ((SOURCE) == OB_STOP_RST))
N
N/**
N  * @}
N  */
N
N/** @defgroup Option_Bytes_nRST_STDBY 
N  * @{
N  */
N
N#define OB_STDBY_NoRST                 ((uint16_t)0x0004) /*!< No reset generated when entering in STANDBY */
N#define OB_STDBY_RST                   ((uint16_t)0x0000) /*!< Reset generated when entering in STANDBY */
N#define IS_OB_STDBY_SOURCE(SOURCE) (((SOURCE) == OB_STDBY_NoRST) || ((SOURCE) == OB_STDBY_RST))
N
N#ifdef STM32F10X_XL
S/**
S  * @}
S  */
S/** @defgroup FLASH_Boot
S  * @{
S  */
S#define FLASH_BOOT_Bank1  ((uint16_t)0x0000) /*!< At startup, if boot pins are set in boot from user Flash position
S                                                  and this parameter is selected the device will boot from Bank1(Default) */
S#define FLASH_BOOT_Bank2  ((uint16_t)0x0001) /*!< At startup, if boot pins are set in boot from user Flash position
S                                                  and this parameter is selected the device will boot from Bank 2 or Bank 1,
S                                                  depending on the activation of the bank */
S#define IS_FLASH_BOOT(BOOT) (((BOOT) == FLASH_BOOT_Bank1) || ((BOOT) == FLASH_BOOT_Bank2))
N#endif
N/**
N  * @}
N  */
N/** @defgroup FLASH_Interrupts 
N  * @{
N  */
N#ifdef STM32F10X_XL
S#define FLASH_IT_BANK2_ERROR                 ((uint32_t)0x80000400)  /*!< FPEC BANK2 error interrupt source */
S#define FLASH_IT_BANK2_EOP                   ((uint32_t)0x80001000)  /*!< End of FLASH BANK2 Operation Interrupt source */
S
S#define FLASH_IT_BANK1_ERROR                 FLASH_IT_ERROR          /*!< FPEC BANK1 error interrupt source */
S#define FLASH_IT_BANK1_EOP                   FLASH_IT_EOP            /*!< End of FLASH BANK1 Operation Interrupt source */
S
S#define FLASH_IT_ERROR                 ((uint32_t)0x00000400)  /*!< FPEC BANK1 error interrupt source */
S#define FLASH_IT_EOP                   ((uint32_t)0x00001000)  /*!< End of FLASH BANK1 Operation Interrupt source */
S#define IS_FLASH_IT(IT) ((((IT) & (uint32_t)0x7FFFEBFF) == 0x00000000) && (((IT) != 0x00000000)))
N#else
N#define FLASH_IT_ERROR                 ((uint32_t)0x00000400)  /*!< FPEC error interrupt source */
N#define FLASH_IT_EOP                   ((uint32_t)0x00001000)  /*!< End of FLASH Operation Interrupt source */
N#define FLASH_IT_BANK1_ERROR           FLASH_IT_ERROR          /*!< FPEC BANK1 error interrupt source */
N#define FLASH_IT_BANK1_EOP             FLASH_IT_EOP            /*!< End of FLASH BANK1 Operation Interrupt source */
N
N#define IS_FLASH_IT(IT) ((((IT) & (uint32_t)0xFFFFEBFF) == 0x00000000) && (((IT) != 0x00000000)))
N#endif
N
N/**
N  * @}
N  */
N
N/** @defgroup FLASH_Flags 
N  * @{
N  */
N#ifdef STM32F10X_XL
S#define FLASH_FLAG_BANK2_BSY                 ((uint32_t)0x80000001)  /*!< FLASH BANK2 Busy flag */
S#define FLASH_FLAG_BANK2_EOP                 ((uint32_t)0x80000020)  /*!< FLASH BANK2 End of Operation flag */
S#define FLASH_FLAG_BANK2_PGERR               ((uint32_t)0x80000004)  /*!< FLASH BANK2 Program error flag */
S#define FLASH_FLAG_BANK2_WRPRTERR            ((uint32_t)0x80000010)  /*!< FLASH BANK2 Write protected error flag */
S
S#define FLASH_FLAG_BANK1_BSY                 FLASH_FLAG_BSY       /*!< FLASH BANK1 Busy flag*/
S#define FLASH_FLAG_BANK1_EOP                 FLASH_FLAG_EOP       /*!< FLASH BANK1 End of Operation flag */
S#define FLASH_FLAG_BANK1_PGERR               FLASH_FLAG_PGERR     /*!< FLASH BANK1 Program error flag */
S#define FLASH_FLAG_BANK1_WRPRTERR            FLASH_FLAG_WRPRTERR  /*!< FLASH BANK1 Write protected error flag */
S
S#define FLASH_FLAG_BSY                 ((uint32_t)0x00000001)  /*!< FLASH Busy flag */
S#define FLASH_FLAG_EOP                 ((uint32_t)0x00000020)  /*!< FLASH End of Operation flag */
S#define FLASH_FLAG_PGERR               ((uint32_t)0x00000004)  /*!< FLASH Program error flag */
S#define FLASH_FLAG_WRPRTERR            ((uint32_t)0x00000010)  /*!< FLASH Write protected error flag */
S#define FLASH_FLAG_OPTERR              ((uint32_t)0x00000001)  /*!< FLASH Option Byte error flag */
S 
S#define IS_FLASH_CLEAR_FLAG(FLAG) ((((FLAG) & (uint32_t)0x7FFFFFCA) == 0x00000000) && ((FLAG) != 0x00000000))
S#define IS_FLASH_GET_FLAG(FLAG)  (((FLAG) == FLASH_FLAG_BSY) || ((FLAG) == FLASH_FLAG_EOP) || \
S                                  ((FLAG) == FLASH_FLAG_PGERR) || ((FLAG) == FLASH_FLAG_WRPRTERR) || \
S                                  ((FLAG) == FLASH_FLAG_OPTERR)|| \
S                                  ((FLAG) == FLASH_FLAG_BANK1_BSY) || ((FLAG) == FLASH_FLAG_BANK1_EOP) || \
S                                  ((FLAG) == FLASH_FLAG_BANK1_PGERR) || ((FLAG) == FLASH_FLAG_BANK1_WRPRTERR) || \
S                                  ((FLAG) == FLASH_FLAG_BANK2_BSY) || ((FLAG) == FLASH_FLAG_BANK2_EOP) || \
S                                  ((FLAG) == FLASH_FLAG_BANK2_PGERR) || ((FLAG) == FLASH_FLAG_BANK2_WRPRTERR))
X#define IS_FLASH_GET_FLAG(FLAG)  (((FLAG) == FLASH_FLAG_BSY) || ((FLAG) == FLASH_FLAG_EOP) ||                                   ((FLAG) == FLASH_FLAG_PGERR) || ((FLAG) == FLASH_FLAG_WRPRTERR) ||                                   ((FLAG) == FLASH_FLAG_OPTERR)||                                   ((FLAG) == FLASH_FLAG_BANK1_BSY) || ((FLAG) == FLASH_FLAG_BANK1_EOP) ||                                   ((FLAG) == FLASH_FLAG_BANK1_PGERR) || ((FLAG) == FLASH_FLAG_BANK1_WRPRTERR) ||                                   ((FLAG) == FLASH_FLAG_BANK2_BSY) || ((FLAG) == FLASH_FLAG_BANK2_EOP) ||                                   ((FLAG) == FLASH_FLAG_BANK2_PGERR) || ((FLAG) == FLASH_FLAG_BANK2_WRPRTERR))
N#else
N#define FLASH_FLAG_BSY                 ((uint32_t)0x00000001)  /*!< FLASH Busy flag */
N#define FLASH_FLAG_EOP                 ((uint32_t)0x00000020)  /*!< FLASH End of Operation flag */
N#define FLASH_FLAG_PGERR               ((uint32_t)0x00000004)  /*!< FLASH Program error flag */
N#define FLASH_FLAG_WRPRTERR            ((uint32_t)0x00000010)  /*!< FLASH Write protected error flag */
N#define FLASH_FLAG_OPTERR              ((uint32_t)0x00000001)  /*!< FLASH Option Byte error flag */
N
N#define FLASH_FLAG_BANK1_BSY                 FLASH_FLAG_BSY       /*!< FLASH BANK1 Busy flag*/
N#define FLASH_FLAG_BANK1_EOP                 FLASH_FLAG_EOP       /*!< FLASH BANK1 End of Operation flag */
N#define FLASH_FLAG_BANK1_PGERR               FLASH_FLAG_PGERR     /*!< FLASH BANK1 Program error flag */
N#define FLASH_FLAG_BANK1_WRPRTERR            FLASH_FLAG_WRPRTERR  /*!< FLASH BANK1 Write protected error flag */
N 
N#define IS_FLASH_CLEAR_FLAG(FLAG) ((((FLAG) & (uint32_t)0xFFFFFFCA) == 0x00000000) && ((FLAG) != 0x00000000))
N#define IS_FLASH_GET_FLAG(FLAG)  (((FLAG) == FLASH_FLAG_BSY) || ((FLAG) == FLASH_FLAG_EOP) || \
N                                  ((FLAG) == FLASH_FLAG_PGERR) || ((FLAG) == FLASH_FLAG_WRPRTERR) || \
N								  ((FLAG) == FLASH_FLAG_BANK1_BSY) || ((FLAG) == FLASH_FLAG_BANK1_EOP) || \
N                                  ((FLAG) == FLASH_FLAG_BANK1_PGERR) || ((FLAG) == FLASH_FLAG_BANK1_WRPRTERR) || \
N                                  ((FLAG) == FLASH_FLAG_OPTERR))
X#define IS_FLASH_GET_FLAG(FLAG)  (((FLAG) == FLASH_FLAG_BSY) || ((FLAG) == FLASH_FLAG_EOP) ||                                   ((FLAG) == FLASH_FLAG_PGERR) || ((FLAG) == FLASH_FLAG_WRPRTERR) || 								  ((FLAG) == FLASH_FLAG_BANK1_BSY) || ((FLAG) == FLASH_FLAG_BANK1_EOP) ||                                   ((FLAG) == FLASH_FLAG_BANK1_PGERR) || ((FLAG) == FLASH_FLAG_BANK1_WRPRTERR) ||                                   ((FLAG) == FLASH_FLAG_OPTERR))
N#endif
N
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */
N
N/** @defgroup FLASH_Exported_Macros
N  * @{
N  */
N
N/**
N  * @}
N  */
N
N/** @defgroup FLASH_Exported_Functions
N  * @{
N  */
N
N/*------------ Functions used for all STM32F10x devices -----*/
Nvoid FLASH_SetLatency(uint32_t FLASH_Latency);
Nvoid FLASH_HalfCycleAccessCmd(uint32_t FLASH_HalfCycleAccess);
Nvoid FLASH_PrefetchBufferCmd(uint32_t FLASH_PrefetchBuffer);
Nvoid FLASH_Unlock(void);
Nvoid FLASH_Lock(void);
NFLASH_Status FLASH_ErasePage(uint32_t Page_Address);
NFLASH_Status FLASH_EraseAllPages(void);
NFLASH_Status FLASH_EraseOptionBytes(void);
NFLASH_Status FLASH_ProgramWord(uint32_t Address, uint32_t Data);
NFLASH_Status FLASH_ProgramHalfWord(uint32_t Address, uint16_t Data);
NFLASH_Status FLASH_ProgramOptionByteData(uint32_t Address, uint8_t Data);
NFLASH_Status FLASH_EnableWriteProtection(uint32_t FLASH_Pages);
NFLASH_Status FLASH_ReadOutProtection(FunctionalState NewState);
NFLASH_Status FLASH_UserOptionByteConfig(uint16_t OB_IWDG, uint16_t OB_STOP, uint16_t OB_STDBY);
Nuint32_t FLASH_GetUserOptionByte(void);
Nuint32_t FLASH_GetWriteProtectionOptionByte(void);
NFlagStatus FLASH_GetReadOutProtectionStatus(void);
NFlagStatus FLASH_GetPrefetchBufferStatus(void);
Nvoid FLASH_ITConfig(uint32_t FLASH_IT, FunctionalState NewState);
NFlagStatus FLASH_GetFlagStatus(uint32_t FLASH_FLAG);
Nvoid FLASH_ClearFlag(uint32_t FLASH_FLAG);
NFLASH_Status FLASH_GetStatus(void);
NFLASH_Status FLASH_WaitForLastOperation(uint32_t Timeout);
N
N/*------------ New function used for all STM32F10x devices -----*/
Nvoid FLASH_UnlockBank1(void);
Nvoid FLASH_LockBank1(void);
NFLASH_Status FLASH_EraseAllBank1Pages(void);
NFLASH_Status FLASH_GetBank1Status(void);
NFLASH_Status FLASH_WaitForLastBank1Operation(uint32_t Timeout);
N
N#ifdef STM32F10X_XL
S/*---- New Functions used only with STM32F10x_XL density devices -----*/
Svoid FLASH_UnlockBank2(void);
Svoid FLASH_LockBank2(void);
SFLASH_Status FLASH_EraseAllBank2Pages(void);
SFLASH_Status FLASH_GetBank2Status(void);
SFLASH_Status FLASH_WaitForLastBank2Operation(uint32_t Timeout);
SFLASH_Status FLASH_BootConfig(uint16_t FLASH_BOOT);
N#endif
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif /* __STM32F10x_FLASH_H */
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */
N
N/******************* (C) COPYRIGHT 2011 STMicroelectronics *****END OF FILE****/
L 38 "..\..\User\stm32f10x_conf.h" 2
N#include "stm32f10x_fsmc.h" 
L 1 "..\..\Libraries\FWlib\inc\stm32f10x_fsmc.h" 1
N/**
N  ******************************************************************************
N  * @file    stm32f10x_fsmc.h
N  * @author  MCD Application Team
N  * @version V3.5.0
N  * @date    11-March-2011
N  * @brief   This file contains all the functions prototypes for the FSMC firmware 
N  *          library.
N  ******************************************************************************
N  * @attention
N  *
N  * THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
N  * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE
N  * TIME. AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY
N  * DIRECT, INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING
N  * FROM THE CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE
N  * CODING INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
N  *
N  * <h2><center>&copy; COPYRIGHT 2011 STMicroelectronics</center></h2>
N  ******************************************************************************
N  */
N
N/* Define to prevent recursive inclusion -------------------------------------*/
N#ifndef __STM32F10x_FSMC_H
N#define __STM32F10x_FSMC_H
N
N#ifdef __cplusplus
S extern "C" {
N#endif
N
N/* Includes ------------------------------------------------------------------*/
N#include "stm32f10x.h"
N
N/** @addtogroup STM32F10x_StdPeriph_Driver
N  * @{
N  */
N
N/** @addtogroup FSMC
N  * @{
N  */
N
N/** @defgroup FSMC_Exported_Types
N  * @{
N  */
N
N/** 
N  * @brief  Timing parameters For NOR/SRAM Banks  
N  */
N
Ntypedef struct
N{
N  uint32_t FSMC_AddressSetupTime;       /*!< Defines the number of HCLK cycles to configure
N                                             the duration of the address setup time. 
N                                             This parameter can be a value between 0 and 0xF.
N                                             @note: It is not used with synchronous NOR Flash memories. */
N
N  uint32_t FSMC_AddressHoldTime;        /*!< Defines the number of HCLK cycles to configure
N                                             the duration of the address hold time.
N                                             This parameter can be a value between 0 and 0xF. 
N                                             @note: It is not used with synchronous NOR Flash memories.*/
N
N  uint32_t FSMC_DataSetupTime;          /*!< Defines the number of HCLK cycles to configure
N                                             the duration of the data setup time.
N                                             This parameter can be a value between 0 and 0xFF.
N                                             @note: It is used for SRAMs, ROMs and asynchronous multiplexed NOR Flash memories. */
N
N  uint32_t FSMC_BusTurnAroundDuration;  /*!< Defines the number of HCLK cycles to configure
N                                             the duration of the bus turnaround.
N                                             This parameter can be a value between 0 and 0xF.
N                                             @note: It is only used for multiplexed NOR Flash memories. */
N
N  uint32_t FSMC_CLKDivision;            /*!< Defines the period of CLK clock output signal, expressed in number of HCLK cycles.
N                                             This parameter can be a value between 1 and 0xF.
N                                             @note: This parameter is not used for asynchronous NOR Flash, SRAM or ROM accesses. */
N
N  uint32_t FSMC_DataLatency;            /*!< Defines the number of memory clock cycles to issue
N                                             to the memory before getting the first data.
N                                             The value of this parameter depends on the memory type as shown below:
N                                              - It must be set to 0 in case of a CRAM
N                                              - It is don't care in asynchronous NOR, SRAM or ROM accesses
N                                              - It may assume a value between 0 and 0xF in NOR Flash memories
N                                                with synchronous burst mode enable */
N
N  uint32_t FSMC_AccessMode;             /*!< Specifies the asynchronous access mode. 
N                                             This parameter can be a value of @ref FSMC_Access_Mode */
N}FSMC_NORSRAMTimingInitTypeDef;
N
N/** 
N  * @brief  FSMC NOR/SRAM Init structure definition
N  */
N
Ntypedef struct
N{
N  uint32_t FSMC_Bank;                /*!< Specifies the NOR/SRAM memory bank that will be used.
N                                          This parameter can be a value of @ref FSMC_NORSRAM_Bank */
N
N  uint32_t FSMC_DataAddressMux;      /*!< Specifies whether the address and data values are
N                                          multiplexed on the databus or not. 
N                                          This parameter can be a value of @ref FSMC_Data_Address_Bus_Multiplexing */
N
N  uint32_t FSMC_MemoryType;          /*!< Specifies the type of external memory attached to
N                                          the corresponding memory bank.
N                                          This parameter can be a value of @ref FSMC_Memory_Type */
N
N  uint32_t FSMC_MemoryDataWidth;     /*!< Specifies the external memory device width.
N                                          This parameter can be a value of @ref FSMC_Data_Width */
N
N  uint32_t FSMC_BurstAccessMode;     /*!< Enables or disables the burst access mode for Flash memory,
N                                          valid only with synchronous burst Flash memories.
N                                          This parameter can be a value of @ref FSMC_Burst_Access_Mode */
N                                       
N  uint32_t FSMC_AsynchronousWait;     /*!< Enables or disables wait signal during asynchronous transfers,
N                                          valid only with asynchronous Flash memories.
N                                          This parameter can be a value of @ref FSMC_AsynchronousWait */
N
N  uint32_t FSMC_WaitSignalPolarity;  /*!< Specifies the wait signal polarity, valid only when accessing
N                                          the Flash memory in burst mode.
N                                          This parameter can be a value of @ref FSMC_Wait_Signal_Polarity */
N
N  uint32_t FSMC_WrapMode;            /*!< Enables or disables the Wrapped burst access mode for Flash
N                                          memory, valid only when accessing Flash memories in burst mode.
N                                          This parameter can be a value of @ref FSMC_Wrap_Mode */
N
N  uint32_t FSMC_WaitSignalActive;    /*!< Specifies if the wait signal is asserted by the memory one
N                                          clock cycle before the wait state or during the wait state,
N                                          valid only when accessing memories in burst mode. 
N                                          This parameter can be a value of @ref FSMC_Wait_Timing */
N
N  uint32_t FSMC_WriteOperation;      /*!< Enables or disables the write operation in the selected bank by the FSMC. 
N                                          This parameter can be a value of @ref FSMC_Write_Operation */
N
N  uint32_t FSMC_WaitSignal;          /*!< Enables or disables the wait-state insertion via wait
N                                          signal, valid for Flash memory access in burst mode. 
N                                          This parameter can be a value of @ref FSMC_Wait_Signal */
N
N  uint32_t FSMC_ExtendedMode;        /*!< Enables or disables the extended mode.
N                                          This parameter can be a value of @ref FSMC_Extended_Mode */
N
N  uint32_t FSMC_WriteBurst;          /*!< Enables or disables the write burst operation.
N                                          This parameter can be a value of @ref FSMC_Write_Burst */ 
N
N  FSMC_NORSRAMTimingInitTypeDef* FSMC_ReadWriteTimingStruct; /*!< Timing Parameters for write and read access if the  ExtendedMode is not used*/  
N
N  FSMC_NORSRAMTimingInitTypeDef* FSMC_WriteTimingStruct;     /*!< Timing Parameters for write access if the  ExtendedMode is used*/      
N}FSMC_NORSRAMInitTypeDef;
N
N/** 
N  * @brief  Timing parameters For FSMC NAND and PCCARD Banks
N  */
N
Ntypedef struct
N{
N  uint32_t FSMC_SetupTime;      /*!< Defines the number of HCLK cycles to setup address before
N                                     the command assertion for NAND-Flash read or write access
N                                     to common/Attribute or I/O memory space (depending on
N                                     the memory space timing to be configured).
N                                     This parameter can be a value between 0 and 0xFF.*/
N
N  uint32_t FSMC_WaitSetupTime;  /*!< Defines the minimum number of HCLK cycles to assert the
N                                     command for NAND-Flash read or write access to
N                                     common/Attribute or I/O memory space (depending on the
N                                     memory space timing to be configured). 
N                                     This parameter can be a number between 0x00 and 0xFF */
N
N  uint32_t FSMC_HoldSetupTime;  /*!< Defines the number of HCLK clock cycles to hold address
N                                     (and data for write access) after the command deassertion
N                                     for NAND-Flash read or write access to common/Attribute
N                                     or I/O memory space (depending on the memory space timing
N                                     to be configured).
N                                     This parameter can be a number between 0x00 and 0xFF */
N
N  uint32_t FSMC_HiZSetupTime;   /*!< Defines the number of HCLK clock cycles during which the
N                                     databus is kept in HiZ after the start of a NAND-Flash
N                                     write access to common/Attribute or I/O memory space (depending
N                                     on the memory space timing to be configured).
N                                     This parameter can be a number between 0x00 and 0xFF */
N}FSMC_NAND_PCCARDTimingInitTypeDef;
N
N/** 
N  * @brief  FSMC NAND Init structure definition
N  */
N
Ntypedef struct
N{
N  uint32_t FSMC_Bank;              /*!< Specifies the NAND memory bank that will be used.
N                                      This parameter can be a value of @ref FSMC_NAND_Bank */
N
N  uint32_t FSMC_Waitfeature;      /*!< Enables or disables the Wait feature for the NAND Memory Bank.
N                                       This parameter can be any value of @ref FSMC_Wait_feature */
N
N  uint32_t FSMC_MemoryDataWidth;  /*!< Specifies the external memory device width.
N                                       This parameter can be any value of @ref FSMC_Data_Width */
N
N  uint32_t FSMC_ECC;              /*!< Enables or disables the ECC computation.
N                                       This parameter can be any value of @ref FSMC_ECC */
N
N  uint32_t FSMC_ECCPageSize;      /*!< Defines the page size for the extended ECC.
N                                       This parameter can be any value of @ref FSMC_ECC_Page_Size */
N
N  uint32_t FSMC_TCLRSetupTime;    /*!< Defines the number of HCLK cycles to configure the
N                                       delay between CLE low and RE low.
N                                       This parameter can be a value between 0 and 0xFF. */
N
N  uint32_t FSMC_TARSetupTime;     /*!< Defines the number of HCLK cycles to configure the
N                                       delay between ALE low and RE low.
N                                       This parameter can be a number between 0x0 and 0xFF */ 
N
N  FSMC_NAND_PCCARDTimingInitTypeDef*  FSMC_CommonSpaceTimingStruct;   /*!< FSMC Common Space Timing */ 
N
N  FSMC_NAND_PCCARDTimingInitTypeDef*  FSMC_AttributeSpaceTimingStruct; /*!< FSMC Attribute Space Timing */
N}FSMC_NANDInitTypeDef;
N
N/** 
N  * @brief  FSMC PCCARD Init structure definition
N  */
N
Ntypedef struct
N{
N  uint32_t FSMC_Waitfeature;    /*!< Enables or disables the Wait feature for the Memory Bank.
N                                    This parameter can be any value of @ref FSMC_Wait_feature */
N
N  uint32_t FSMC_TCLRSetupTime;  /*!< Defines the number of HCLK cycles to configure the
N                                     delay between CLE low and RE low.
N                                     This parameter can be a value between 0 and 0xFF. */
N
N  uint32_t FSMC_TARSetupTime;   /*!< Defines the number of HCLK cycles to configure the
N                                     delay between ALE low and RE low.
N                                     This parameter can be a number between 0x0 and 0xFF */ 
N
N  
N  FSMC_NAND_PCCARDTimingInitTypeDef*  FSMC_CommonSpaceTimingStruct; /*!< FSMC Common Space Timing */
N
N  FSMC_NAND_PCCARDTimingInitTypeDef*  FSMC_AttributeSpaceTimingStruct;  /*!< FSMC Attribute Space Timing */ 
N  
N  FSMC_NAND_PCCARDTimingInitTypeDef*  FSMC_IOSpaceTimingStruct; /*!< FSMC IO Space Timing */  
N}FSMC_PCCARDInitTypeDef;
N
N/**
N  * @}
N  */
N
N/** @defgroup FSMC_Exported_Constants
N  * @{
N  */
N
N/** @defgroup FSMC_NORSRAM_Bank 
N  * @{
N  */
N#define FSMC_Bank1_NORSRAM1                             ((uint32_t)0x00000000)
N#define FSMC_Bank1_NORSRAM2                             ((uint32_t)0x00000002)
N#define FSMC_Bank1_NORSRAM3                             ((uint32_t)0x00000004)
N#define FSMC_Bank1_NORSRAM4                             ((uint32_t)0x00000006)
N/**
N  * @}
N  */
N
N/** @defgroup FSMC_NAND_Bank 
N  * @{
N  */  
N#define FSMC_Bank2_NAND                                 ((uint32_t)0x00000010)
N#define FSMC_Bank3_NAND                                 ((uint32_t)0x00000100)
N/**
N  * @}
N  */
N
N/** @defgroup FSMC_PCCARD_Bank 
N  * @{
N  */    
N#define FSMC_Bank4_PCCARD                               ((uint32_t)0x00001000)
N/**
N  * @}
N  */
N
N#define IS_FSMC_NORSRAM_BANK(BANK) (((BANK) == FSMC_Bank1_NORSRAM1) || \
N                                    ((BANK) == FSMC_Bank1_NORSRAM2) || \
N                                    ((BANK) == FSMC_Bank1_NORSRAM3) || \
N                                    ((BANK) == FSMC_Bank1_NORSRAM4))
X#define IS_FSMC_NORSRAM_BANK(BANK) (((BANK) == FSMC_Bank1_NORSRAM1) ||                                     ((BANK) == FSMC_Bank1_NORSRAM2) ||                                     ((BANK) == FSMC_Bank1_NORSRAM3) ||                                     ((BANK) == FSMC_Bank1_NORSRAM4))
N
N#define IS_FSMC_NAND_BANK(BANK) (((BANK) == FSMC_Bank2_NAND) || \
N                                 ((BANK) == FSMC_Bank3_NAND))
X#define IS_FSMC_NAND_BANK(BANK) (((BANK) == FSMC_Bank2_NAND) ||                                  ((BANK) == FSMC_Bank3_NAND))
N
N#define IS_FSMC_GETFLAG_BANK(BANK) (((BANK) == FSMC_Bank2_NAND) || \
N                                    ((BANK) == FSMC_Bank3_NAND) || \
N                                    ((BANK) == FSMC_Bank4_PCCARD))
X#define IS_FSMC_GETFLAG_BANK(BANK) (((BANK) == FSMC_Bank2_NAND) ||                                     ((BANK) == FSMC_Bank3_NAND) ||                                     ((BANK) == FSMC_Bank4_PCCARD))
N
N#define IS_FSMC_IT_BANK(BANK) (((BANK) == FSMC_Bank2_NAND) || \
N                               ((BANK) == FSMC_Bank3_NAND) || \
N                               ((BANK) == FSMC_Bank4_PCCARD))
X#define IS_FSMC_IT_BANK(BANK) (((BANK) == FSMC_Bank2_NAND) ||                                ((BANK) == FSMC_Bank3_NAND) ||                                ((BANK) == FSMC_Bank4_PCCARD))
N
N/** @defgroup NOR_SRAM_Controller 
N  * @{
N  */
N
N/** @defgroup FSMC_Data_Address_Bus_Multiplexing 
N  * @{
N  */
N
N#define FSMC_DataAddressMux_Disable                       ((uint32_t)0x00000000)
N#define FSMC_DataAddressMux_Enable                        ((uint32_t)0x00000002)
N#define IS_FSMC_MUX(MUX) (((MUX) == FSMC_DataAddressMux_Disable) || \
N                          ((MUX) == FSMC_DataAddressMux_Enable))
X#define IS_FSMC_MUX(MUX) (((MUX) == FSMC_DataAddressMux_Disable) ||                           ((MUX) == FSMC_DataAddressMux_Enable))
N
N/**
N  * @}
N  */
N
N/** @defgroup FSMC_Memory_Type 
N  * @{
N  */
N
N#define FSMC_MemoryType_SRAM                            ((uint32_t)0x00000000)
N#define FSMC_MemoryType_PSRAM                           ((uint32_t)0x00000004)
N#define FSMC_MemoryType_NOR                             ((uint32_t)0x00000008)
N#define IS_FSMC_MEMORY(MEMORY) (((MEMORY) == FSMC_MemoryType_SRAM) || \
N                                ((MEMORY) == FSMC_MemoryType_PSRAM)|| \
N                                ((MEMORY) == FSMC_MemoryType_NOR))
X#define IS_FSMC_MEMORY(MEMORY) (((MEMORY) == FSMC_MemoryType_SRAM) ||                                 ((MEMORY) == FSMC_MemoryType_PSRAM)||                                 ((MEMORY) == FSMC_MemoryType_NOR))
N
N/**
N  * @}
N  */
N
N/** @defgroup FSMC_Data_Width 
N  * @{
N  */
N
N#define FSMC_MemoryDataWidth_8b                         ((uint32_t)0x00000000)
N#define FSMC_MemoryDataWidth_16b                        ((uint32_t)0x00000010)
N#define IS_FSMC_MEMORY_WIDTH(WIDTH) (((WIDTH) == FSMC_MemoryDataWidth_8b) || \
N                                     ((WIDTH) == FSMC_MemoryDataWidth_16b))
X#define IS_FSMC_MEMORY_WIDTH(WIDTH) (((WIDTH) == FSMC_MemoryDataWidth_8b) ||                                      ((WIDTH) == FSMC_MemoryDataWidth_16b))
N
N/**
N  * @}
N  */
N
N/** @defgroup FSMC_Burst_Access_Mode 
N  * @{
N  */
N
N#define FSMC_BurstAccessMode_Disable                    ((uint32_t)0x00000000) 
N#define FSMC_BurstAccessMode_Enable                     ((uint32_t)0x00000100)
N#define IS_FSMC_BURSTMODE(STATE) (((STATE) == FSMC_BurstAccessMode_Disable) || \
N                                  ((STATE) == FSMC_BurstAccessMode_Enable))
X#define IS_FSMC_BURSTMODE(STATE) (((STATE) == FSMC_BurstAccessMode_Disable) ||                                   ((STATE) == FSMC_BurstAccessMode_Enable))
N/**
N  * @}
N  */
N  
N/** @defgroup FSMC_AsynchronousWait 
N  * @{
N  */
N#define FSMC_AsynchronousWait_Disable                   ((uint32_t)0x00000000)
N#define FSMC_AsynchronousWait_Enable                    ((uint32_t)0x00008000)
N#define IS_FSMC_ASYNWAIT(STATE) (((STATE) == FSMC_AsynchronousWait_Disable) || \
N                                 ((STATE) == FSMC_AsynchronousWait_Enable))
X#define IS_FSMC_ASYNWAIT(STATE) (((STATE) == FSMC_AsynchronousWait_Disable) ||                                  ((STATE) == FSMC_AsynchronousWait_Enable))
N
N/**
N  * @}
N  */
N  
N/** @defgroup FSMC_Wait_Signal_Polarity 
N  * @{
N  */
N
N#define FSMC_WaitSignalPolarity_Low                     ((uint32_t)0x00000000)
N#define FSMC_WaitSignalPolarity_High                    ((uint32_t)0x00000200)
N#define IS_FSMC_WAIT_POLARITY(POLARITY) (((POLARITY) == FSMC_WaitSignalPolarity_Low) || \
N                                         ((POLARITY) == FSMC_WaitSignalPolarity_High)) 
X#define IS_FSMC_WAIT_POLARITY(POLARITY) (((POLARITY) == FSMC_WaitSignalPolarity_Low) ||                                          ((POLARITY) == FSMC_WaitSignalPolarity_High)) 
N
N/**
N  * @}
N  */
N
N/** @defgroup FSMC_Wrap_Mode 
N  * @{
N  */
N
N#define FSMC_WrapMode_Disable                           ((uint32_t)0x00000000)
N#define FSMC_WrapMode_Enable                            ((uint32_t)0x00000400) 
N#define IS_FSMC_WRAP_MODE(MODE) (((MODE) == FSMC_WrapMode_Disable) || \
N                                 ((MODE) == FSMC_WrapMode_Enable))
X#define IS_FSMC_WRAP_MODE(MODE) (((MODE) == FSMC_WrapMode_Disable) ||                                  ((MODE) == FSMC_WrapMode_Enable))
N
N/**
N  * @}
N  */
N
N/** @defgroup FSMC_Wait_Timing 
N  * @{
N  */
N
N#define FSMC_WaitSignalActive_BeforeWaitState           ((uint32_t)0x00000000)
N#define FSMC_WaitSignalActive_DuringWaitState           ((uint32_t)0x00000800) 
N#define IS_FSMC_WAIT_SIGNAL_ACTIVE(ACTIVE) (((ACTIVE) == FSMC_WaitSignalActive_BeforeWaitState) || \
N                                            ((ACTIVE) == FSMC_WaitSignalActive_DuringWaitState))
X#define IS_FSMC_WAIT_SIGNAL_ACTIVE(ACTIVE) (((ACTIVE) == FSMC_WaitSignalActive_BeforeWaitState) ||                                             ((ACTIVE) == FSMC_WaitSignalActive_DuringWaitState))
N
N/**
N  * @}
N  */
N
N/** @defgroup FSMC_Write_Operation 
N  * @{
N  */
N
N#define FSMC_WriteOperation_Disable                     ((uint32_t)0x00000000)
N#define FSMC_WriteOperation_Enable                      ((uint32_t)0x00001000)
N#define IS_FSMC_WRITE_OPERATION(OPERATION) (((OPERATION) == FSMC_WriteOperation_Disable) || \
N                                            ((OPERATION) == FSMC_WriteOperation_Enable))
X#define IS_FSMC_WRITE_OPERATION(OPERATION) (((OPERATION) == FSMC_WriteOperation_Disable) ||                                             ((OPERATION) == FSMC_WriteOperation_Enable))
N                              
N/**
N  * @}
N  */
N
N/** @defgroup FSMC_Wait_Signal 
N  * @{
N  */
N
N#define FSMC_WaitSignal_Disable                         ((uint32_t)0x00000000)
N#define FSMC_WaitSignal_Enable                          ((uint32_t)0x00002000) 
N#define IS_FSMC_WAITE_SIGNAL(SIGNAL) (((SIGNAL) == FSMC_WaitSignal_Disable) || \
N                                      ((SIGNAL) == FSMC_WaitSignal_Enable))
X#define IS_FSMC_WAITE_SIGNAL(SIGNAL) (((SIGNAL) == FSMC_WaitSignal_Disable) ||                                       ((SIGNAL) == FSMC_WaitSignal_Enable))
N/**
N  * @}
N  */
N
N/** @defgroup FSMC_Extended_Mode 
N  * @{
N  */
N
N#define FSMC_ExtendedMode_Disable                       ((uint32_t)0x00000000)
N#define FSMC_ExtendedMode_Enable                        ((uint32_t)0x00004000)
N
N#define IS_FSMC_EXTENDED_MODE(MODE) (((MODE) == FSMC_ExtendedMode_Disable) || \
N                                     ((MODE) == FSMC_ExtendedMode_Enable)) 
X#define IS_FSMC_EXTENDED_MODE(MODE) (((MODE) == FSMC_ExtendedMode_Disable) ||                                      ((MODE) == FSMC_ExtendedMode_Enable)) 
N
N/**
N  * @}
N  */
N
N/** @defgroup FSMC_Write_Burst 
N  * @{
N  */
N
N#define FSMC_WriteBurst_Disable                         ((uint32_t)0x00000000)
N#define FSMC_WriteBurst_Enable                          ((uint32_t)0x00080000) 
N#define IS_FSMC_WRITE_BURST(BURST) (((BURST) == FSMC_WriteBurst_Disable) || \
N                                    ((BURST) == FSMC_WriteBurst_Enable))
X#define IS_FSMC_WRITE_BURST(BURST) (((BURST) == FSMC_WriteBurst_Disable) ||                                     ((BURST) == FSMC_WriteBurst_Enable))
N/**
N  * @}
N  */
N
N/** @defgroup FSMC_Address_Setup_Time 
N  * @{
N  */
N
N#define IS_FSMC_ADDRESS_SETUP_TIME(TIME) ((TIME) <= 0xF)
N
N/**
N  * @}
N  */
N
N/** @defgroup FSMC_Address_Hold_Time 
N  * @{
N  */
N
N#define IS_FSMC_ADDRESS_HOLD_TIME(TIME) ((TIME) <= 0xF)
N
N/**
N  * @}
N  */
N
N/** @defgroup FSMC_Data_Setup_Time 
N  * @{
N  */
N
N#define IS_FSMC_DATASETUP_TIME(TIME) (((TIME) > 0) && ((TIME) <= 0xFF))
N
N/**
N  * @}
N  */
N
N/** @defgroup FSMC_Bus_Turn_around_Duration 
N  * @{
N  */
N
N#define IS_FSMC_TURNAROUND_TIME(TIME) ((TIME) <= 0xF)
N
N/**
N  * @}
N  */
N
N/** @defgroup FSMC_CLK_Division 
N  * @{
N  */
N
N#define IS_FSMC_CLK_DIV(DIV) ((DIV) <= 0xF)
N
N/**
N  * @}
N  */
N
N/** @defgroup FSMC_Data_Latency 
N  * @{
N  */
N
N#define IS_FSMC_DATA_LATENCY(LATENCY) ((LATENCY) <= 0xF)
N
N/**
N  * @}
N  */
N
N/** @defgroup FSMC_Access_Mode 
N  * @{
N  */
N
N#define FSMC_AccessMode_A                               ((uint32_t)0x00000000)
N#define FSMC_AccessMode_B                               ((uint32_t)0x10000000) 
N#define FSMC_AccessMode_C                               ((uint32_t)0x20000000)
N#define FSMC_AccessMode_D                               ((uint32_t)0x30000000)
N#define IS_FSMC_ACCESS_MODE(MODE) (((MODE) == FSMC_AccessMode_A) || \
N                                   ((MODE) == FSMC_AccessMode_B) || \
N                                   ((MODE) == FSMC_AccessMode_C) || \
N                                   ((MODE) == FSMC_AccessMode_D)) 
X#define IS_FSMC_ACCESS_MODE(MODE) (((MODE) == FSMC_AccessMode_A) ||                                    ((MODE) == FSMC_AccessMode_B) ||                                    ((MODE) == FSMC_AccessMode_C) ||                                    ((MODE) == FSMC_AccessMode_D)) 
N
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */
N  
N/** @defgroup NAND_PCCARD_Controller 
N  * @{
N  */
N
N/** @defgroup FSMC_Wait_feature 
N  * @{
N  */
N
N#define FSMC_Waitfeature_Disable                        ((uint32_t)0x00000000)
N#define FSMC_Waitfeature_Enable                         ((uint32_t)0x00000002)
N#define IS_FSMC_WAIT_FEATURE(FEATURE) (((FEATURE) == FSMC_Waitfeature_Disable) || \
N                                       ((FEATURE) == FSMC_Waitfeature_Enable))
X#define IS_FSMC_WAIT_FEATURE(FEATURE) (((FEATURE) == FSMC_Waitfeature_Disable) ||                                        ((FEATURE) == FSMC_Waitfeature_Enable))
N
N/**
N  * @}
N  */
N
N
N/** @defgroup FSMC_ECC 
N  * @{
N  */
N
N#define FSMC_ECC_Disable                                ((uint32_t)0x00000000)
N#define FSMC_ECC_Enable                                 ((uint32_t)0x00000040)
N#define IS_FSMC_ECC_STATE(STATE) (((STATE) == FSMC_ECC_Disable) || \
N                                  ((STATE) == FSMC_ECC_Enable))
X#define IS_FSMC_ECC_STATE(STATE) (((STATE) == FSMC_ECC_Disable) ||                                   ((STATE) == FSMC_ECC_Enable))
N
N/**
N  * @}
N  */
N
N/** @defgroup FSMC_ECC_Page_Size 
N  * @{
N  */
N
N#define FSMC_ECCPageSize_256Bytes                       ((uint32_t)0x00000000)
N#define FSMC_ECCPageSize_512Bytes                       ((uint32_t)0x00020000)
N#define FSMC_ECCPageSize_1024Bytes                      ((uint32_t)0x00040000)
N#define FSMC_ECCPageSize_2048Bytes                      ((uint32_t)0x00060000)
N#define FSMC_ECCPageSize_4096Bytes                      ((uint32_t)0x00080000)
N#define FSMC_ECCPageSize_8192Bytes                      ((uint32_t)0x000A0000)
N#define IS_FSMC_ECCPAGE_SIZE(SIZE) (((SIZE) == FSMC_ECCPageSize_256Bytes) || \
N                                    ((SIZE) == FSMC_ECCPageSize_512Bytes) || \
N                                    ((SIZE) == FSMC_ECCPageSize_1024Bytes) || \
N                                    ((SIZE) == FSMC_ECCPageSize_2048Bytes) || \
N                                    ((SIZE) == FSMC_ECCPageSize_4096Bytes) || \
N                                    ((SIZE) == FSMC_ECCPageSize_8192Bytes))
X#define IS_FSMC_ECCPAGE_SIZE(SIZE) (((SIZE) == FSMC_ECCPageSize_256Bytes) ||                                     ((SIZE) == FSMC_ECCPageSize_512Bytes) ||                                     ((SIZE) == FSMC_ECCPageSize_1024Bytes) ||                                     ((SIZE) == FSMC_ECCPageSize_2048Bytes) ||                                     ((SIZE) == FSMC_ECCPageSize_4096Bytes) ||                                     ((SIZE) == FSMC_ECCPageSize_8192Bytes))
N
N/**
N  * @}
N  */
N
N/** @defgroup FSMC_TCLR_Setup_Time 
N  * @{
N  */
N
N#define IS_FSMC_TCLR_TIME(TIME) ((TIME) <= 0xFF)
N
N/**
N  * @}
N  */
N
N/** @defgroup FSMC_TAR_Setup_Time 
N  * @{
N  */
N
N#define IS_FSMC_TAR_TIME(TIME) ((TIME) <= 0xFF)
N
N/**
N  * @}
N  */
N
N/** @defgroup FSMC_Setup_Time 
N  * @{
N  */
N
N#define IS_FSMC_SETUP_TIME(TIME) ((TIME) <= 0xFF)
N
N/**
N  * @}
N  */
N
N/** @defgroup FSMC_Wait_Setup_Time 
N  * @{
N  */
N
N#define IS_FSMC_WAIT_TIME(TIME) ((TIME) <= 0xFF)
N
N/**
N  * @}
N  */
N
N/** @defgroup FSMC_Hold_Setup_Time 
N  * @{
N  */
N
N#define IS_FSMC_HOLD_TIME(TIME) ((TIME) <= 0xFF)
N
N/**
N  * @}
N  */
N
N/** @defgroup FSMC_HiZ_Setup_Time 
N  * @{
N  */
N
N#define IS_FSMC_HIZ_TIME(TIME) ((TIME) <= 0xFF)
N
N/**
N  * @}
N  */
N
N/** @defgroup FSMC_Interrupt_sources 
N  * @{
N  */
N
N#define FSMC_IT_RisingEdge                              ((uint32_t)0x00000008)
N#define FSMC_IT_Level                                   ((uint32_t)0x00000010)
N#define FSMC_IT_FallingEdge                             ((uint32_t)0x00000020)
N#define IS_FSMC_IT(IT) ((((IT) & (uint32_t)0xFFFFFFC7) == 0x00000000) && ((IT) != 0x00000000))
N#define IS_FSMC_GET_IT(IT) (((IT) == FSMC_IT_RisingEdge) || \
N                            ((IT) == FSMC_IT_Level) || \
N                            ((IT) == FSMC_IT_FallingEdge)) 
X#define IS_FSMC_GET_IT(IT) (((IT) == FSMC_IT_RisingEdge) ||                             ((IT) == FSMC_IT_Level) ||                             ((IT) == FSMC_IT_FallingEdge)) 
N/**
N  * @}
N  */
N
N/** @defgroup FSMC_Flags 
N  * @{
N  */
N
N#define FSMC_FLAG_RisingEdge                            ((uint32_t)0x00000001)
N#define FSMC_FLAG_Level                                 ((uint32_t)0x00000002)
N#define FSMC_FLAG_FallingEdge                           ((uint32_t)0x00000004)
N#define FSMC_FLAG_FEMPT                                 ((uint32_t)0x00000040)
N#define IS_FSMC_GET_FLAG(FLAG) (((FLAG) == FSMC_FLAG_RisingEdge) || \
N                                ((FLAG) == FSMC_FLAG_Level) || \
N                                ((FLAG) == FSMC_FLAG_FallingEdge) || \
N                                ((FLAG) == FSMC_FLAG_FEMPT))
X#define IS_FSMC_GET_FLAG(FLAG) (((FLAG) == FSMC_FLAG_RisingEdge) ||                                 ((FLAG) == FSMC_FLAG_Level) ||                                 ((FLAG) == FSMC_FLAG_FallingEdge) ||                                 ((FLAG) == FSMC_FLAG_FEMPT))
N
N#define IS_FSMC_CLEAR_FLAG(FLAG) ((((FLAG) & (uint32_t)0xFFFFFFF8) == 0x00000000) && ((FLAG) != 0x00000000))
N
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */
N
N/** @defgroup FSMC_Exported_Macros
N  * @{
N  */
N
N/**
N  * @}
N  */
N
N/** @defgroup FSMC_Exported_Functions
N  * @{
N  */
N
Nvoid FSMC_NORSRAMDeInit(uint32_t FSMC_Bank);
Nvoid FSMC_NANDDeInit(uint32_t FSMC_Bank);
Nvoid FSMC_PCCARDDeInit(void);
Nvoid FSMC_NORSRAMInit(FSMC_NORSRAMInitTypeDef* FSMC_NORSRAMInitStruct);
Nvoid FSMC_NANDInit(FSMC_NANDInitTypeDef* FSMC_NANDInitStruct);
Nvoid FSMC_PCCARDInit(FSMC_PCCARDInitTypeDef* FSMC_PCCARDInitStruct);
Nvoid FSMC_NORSRAMStructInit(FSMC_NORSRAMInitTypeDef* FSMC_NORSRAMInitStruct);
Nvoid FSMC_NANDStructInit(FSMC_NANDInitTypeDef* FSMC_NANDInitStruct);
Nvoid FSMC_PCCARDStructInit(FSMC_PCCARDInitTypeDef* FSMC_PCCARDInitStruct);
Nvoid FSMC_NORSRAMCmd(uint32_t FSMC_Bank, FunctionalState NewState);
Nvoid FSMC_NANDCmd(uint32_t FSMC_Bank, FunctionalState NewState);
Nvoid FSMC_PCCARDCmd(FunctionalState NewState);
Nvoid FSMC_NANDECCCmd(uint32_t FSMC_Bank, FunctionalState NewState);
Nuint32_t FSMC_GetECC(uint32_t FSMC_Bank);
Nvoid FSMC_ITConfig(uint32_t FSMC_Bank, uint32_t FSMC_IT, FunctionalState NewState);
NFlagStatus FSMC_GetFlagStatus(uint32_t FSMC_Bank, uint32_t FSMC_FLAG);
Nvoid FSMC_ClearFlag(uint32_t FSMC_Bank, uint32_t FSMC_FLAG);
NITStatus FSMC_GetITStatus(uint32_t FSMC_Bank, uint32_t FSMC_IT);
Nvoid FSMC_ClearITPendingBit(uint32_t FSMC_Bank, uint32_t FSMC_IT);
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif /*__STM32F10x_FSMC_H */
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */ 
N
N/******************* (C) COPYRIGHT 2011 STMicroelectronics *****END OF FILE****/
L 39 "..\..\User\stm32f10x_conf.h" 2
N#include "stm32f10x_gpio.h"
L 1 "..\..\Libraries\FWlib\inc\stm32f10x_gpio.h" 1
N/**
N  ******************************************************************************
N  * @file    stm32f10x_gpio.h
N  * @author  MCD Application Team
N  * @version V3.5.0
N  * @date    11-March-2011
N  * @brief   This file contains all the functions prototypes for the GPIO 
N  *          firmware library.
N  ******************************************************************************
N  * @attention
N  *
N  * THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
N  * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE
N  * TIME. AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY
N  * DIRECT, INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING
N  * FROM THE CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE
N  * CODING INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
N  *
N  * <h2><center>&copy; COPYRIGHT 2011 STMicroelectronics</center></h2>
N  ******************************************************************************
N  */
N
N/* Define to prevent recursive inclusion -------------------------------------*/
N#ifndef __STM32F10x_GPIO_H
N#define __STM32F10x_GPIO_H
N
N#ifdef __cplusplus
S extern "C" {
N#endif
N
N/* Includes ------------------------------------------------------------------*/
N#include "stm32f10x.h"
N
N/** @addtogroup STM32F10x_StdPeriph_Driver
N  * @{
N  */
N
N/** @addtogroup GPIO
N  * @{
N  */
N
N/** @defgroup GPIO_Exported_Types
N  * @{
N  */
N
N#define IS_GPIO_ALL_PERIPH(PERIPH) (((PERIPH) == GPIOA) || \
N                                    ((PERIPH) == GPIOB) || \
N                                    ((PERIPH) == GPIOC) || \
N                                    ((PERIPH) == GPIOD) || \
N                                    ((PERIPH) == GPIOE) || \
N                                    ((PERIPH) == GPIOF) || \
N                                    ((PERIPH) == GPIOG))
X#define IS_GPIO_ALL_PERIPH(PERIPH) (((PERIPH) == GPIOA) ||                                     ((PERIPH) == GPIOB) ||                                     ((PERIPH) == GPIOC) ||                                     ((PERIPH) == GPIOD) ||                                     ((PERIPH) == GPIOE) ||                                     ((PERIPH) == GPIOF) ||                                     ((PERIPH) == GPIOG))
N                                     
N/** 
N  * @brief  Output Maximum frequency selection  
N  */
N
Ntypedef enum
N{ 
N  GPIO_Speed_10MHz = 1,
N  GPIO_Speed_2MHz, 
N  GPIO_Speed_50MHz
N}GPIOSpeed_TypeDef;
N#define IS_GPIO_SPEED(SPEED) (((SPEED) == GPIO_Speed_10MHz) || ((SPEED) == GPIO_Speed_2MHz) || \
N                              ((SPEED) == GPIO_Speed_50MHz))
X#define IS_GPIO_SPEED(SPEED) (((SPEED) == GPIO_Speed_10MHz) || ((SPEED) == GPIO_Speed_2MHz) ||                               ((SPEED) == GPIO_Speed_50MHz))
N
N/** 
N  * @brief  Configuration Mode enumeration  
N  */
N
Ntypedef enum
N{ GPIO_Mode_AIN = 0x0,
N  GPIO_Mode_IN_FLOATING = 0x04,
N  GPIO_Mode_IPD = 0x28,
N  GPIO_Mode_IPU = 0x48,
N  GPIO_Mode_Out_OD = 0x14,
N  GPIO_Mode_Out_PP = 0x10,
N  GPIO_Mode_AF_OD = 0x1C,
N  GPIO_Mode_AF_PP = 0x18
N}GPIOMode_TypeDef;
N
N#define IS_GPIO_MODE(MODE) (((MODE) == GPIO_Mode_AIN) || ((MODE) == GPIO_Mode_IN_FLOATING) || \
N                            ((MODE) == GPIO_Mode_IPD) || ((MODE) == GPIO_Mode_IPU) || \
N                            ((MODE) == GPIO_Mode_Out_OD) || ((MODE) == GPIO_Mode_Out_PP) || \
N                            ((MODE) == GPIO_Mode_AF_OD) || ((MODE) == GPIO_Mode_AF_PP))
X#define IS_GPIO_MODE(MODE) (((MODE) == GPIO_Mode_AIN) || ((MODE) == GPIO_Mode_IN_FLOATING) ||                             ((MODE) == GPIO_Mode_IPD) || ((MODE) == GPIO_Mode_IPU) ||                             ((MODE) == GPIO_Mode_Out_OD) || ((MODE) == GPIO_Mode_Out_PP) ||                             ((MODE) == GPIO_Mode_AF_OD) || ((MODE) == GPIO_Mode_AF_PP))
N
N/** 
N  * @brief  GPIO Init structure definition  
N  */
N
Ntypedef struct
N{
N  uint16_t GPIO_Pin;             /*!< Specifies the GPIO pins to be configured.
N                                      This parameter can be any value of @ref GPIO_pins_define */
N
N  GPIOSpeed_TypeDef GPIO_Speed;  /*!< Specifies the speed for the selected pins.
N                                      This parameter can be a value of @ref GPIOSpeed_TypeDef */
N
N  GPIOMode_TypeDef GPIO_Mode;    /*!< Specifies the operating mode for the selected pins.
N                                      This parameter can be a value of @ref GPIOMode_TypeDef */
N}GPIO_InitTypeDef;
N
N
N/** 
N  * @brief  Bit_SET and Bit_RESET enumeration  
N  */
N
Ntypedef enum
N{ Bit_RESET = 0,
N  Bit_SET
N}BitAction;
N
N#define IS_GPIO_BIT_ACTION(ACTION) (((ACTION) == Bit_RESET) || ((ACTION) == Bit_SET))
N
N/**
N  * @}
N  */
N
N/** @defgroup GPIO_Exported_Constants
N  * @{
N  */
N
N/** @defgroup GPIO_pins_define 
N  * @{
N  */
N
N#define GPIO_Pin_0                 ((uint16_t)0x0001)  /*!< Pin 0 selected */
N#define GPIO_Pin_1                 ((uint16_t)0x0002)  /*!< Pin 1 selected */
N#define GPIO_Pin_2                 ((uint16_t)0x0004)  /*!< Pin 2 selected */
N#define GPIO_Pin_3                 ((uint16_t)0x0008)  /*!< Pin 3 selected */
N#define GPIO_Pin_4                 ((uint16_t)0x0010)  /*!< Pin 4 selected */
N#define GPIO_Pin_5                 ((uint16_t)0x0020)  /*!< Pin 5 selected */
N#define GPIO_Pin_6                 ((uint16_t)0x0040)  /*!< Pin 6 selected */
N#define GPIO_Pin_7                 ((uint16_t)0x0080)  /*!< Pin 7 selected */
N#define GPIO_Pin_8                 ((uint16_t)0x0100)  /*!< Pin 8 selected */
N#define GPIO_Pin_9                 ((uint16_t)0x0200)  /*!< Pin 9 selected */
N#define GPIO_Pin_10                ((uint16_t)0x0400)  /*!< Pin 10 selected */
N#define GPIO_Pin_11                ((uint16_t)0x0800)  /*!< Pin 11 selected */
N#define GPIO_Pin_12                ((uint16_t)0x1000)  /*!< Pin 12 selected */
N#define GPIO_Pin_13                ((uint16_t)0x2000)  /*!< Pin 13 selected */
N#define GPIO_Pin_14                ((uint16_t)0x4000)  /*!< Pin 14 selected */
N#define GPIO_Pin_15                ((uint16_t)0x8000)  /*!< Pin 15 selected */
N#define GPIO_Pin_All               ((uint16_t)0xFFFF)  /*!< All pins selected */
N
N#define IS_GPIO_PIN(PIN) ((((PIN) & (uint16_t)0x00) == 0x00) && ((PIN) != (uint16_t)0x00))
N
N#define IS_GET_GPIO_PIN(PIN) (((PIN) == GPIO_Pin_0) || \
N                              ((PIN) == GPIO_Pin_1) || \
N                              ((PIN) == GPIO_Pin_2) || \
N                              ((PIN) == GPIO_Pin_3) || \
N                              ((PIN) == GPIO_Pin_4) || \
N                              ((PIN) == GPIO_Pin_5) || \
N                              ((PIN) == GPIO_Pin_6) || \
N                              ((PIN) == GPIO_Pin_7) || \
N                              ((PIN) == GPIO_Pin_8) || \
N                              ((PIN) == GPIO_Pin_9) || \
N                              ((PIN) == GPIO_Pin_10) || \
N                              ((PIN) == GPIO_Pin_11) || \
N                              ((PIN) == GPIO_Pin_12) || \
N                              ((PIN) == GPIO_Pin_13) || \
N                              ((PIN) == GPIO_Pin_14) || \
N                              ((PIN) == GPIO_Pin_15))
X#define IS_GET_GPIO_PIN(PIN) (((PIN) == GPIO_Pin_0) ||                               ((PIN) == GPIO_Pin_1) ||                               ((PIN) == GPIO_Pin_2) ||                               ((PIN) == GPIO_Pin_3) ||                               ((PIN) == GPIO_Pin_4) ||                               ((PIN) == GPIO_Pin_5) ||                               ((PIN) == GPIO_Pin_6) ||                               ((PIN) == GPIO_Pin_7) ||                               ((PIN) == GPIO_Pin_8) ||                               ((PIN) == GPIO_Pin_9) ||                               ((PIN) == GPIO_Pin_10) ||                               ((PIN) == GPIO_Pin_11) ||                               ((PIN) == GPIO_Pin_12) ||                               ((PIN) == GPIO_Pin_13) ||                               ((PIN) == GPIO_Pin_14) ||                               ((PIN) == GPIO_Pin_15))
N
N/**
N  * @}
N  */
N
N/** @defgroup GPIO_Remap_define 
N  * @{
N  */
N
N#define GPIO_Remap_SPI1             ((uint32_t)0x00000001)  /*!< SPI1 Alternate Function mapping */
N#define GPIO_Remap_I2C1             ((uint32_t)0x00000002)  /*!< I2C1 Alternate Function mapping */
N#define GPIO_Remap_USART1           ((uint32_t)0x00000004)  /*!< USART1 Alternate Function mapping */
N#define GPIO_Remap_USART2           ((uint32_t)0x00000008)  /*!< USART2 Alternate Function mapping */
N#define GPIO_PartialRemap_USART3    ((uint32_t)0x00140010)  /*!< USART3 Partial Alternate Function mapping */
N#define GPIO_FullRemap_USART3       ((uint32_t)0x00140030)  /*!< USART3 Full Alternate Function mapping */
N#define GPIO_PartialRemap_TIM1      ((uint32_t)0x00160040)  /*!< TIM1 Partial Alternate Function mapping */
N#define GPIO_FullRemap_TIM1         ((uint32_t)0x001600C0)  /*!< TIM1 Full Alternate Function mapping */
N#define GPIO_PartialRemap1_TIM2     ((uint32_t)0x00180100)  /*!< TIM2 Partial1 Alternate Function mapping */
N#define GPIO_PartialRemap2_TIM2     ((uint32_t)0x00180200)  /*!< TIM2 Partial2 Alternate Function mapping */
N#define GPIO_FullRemap_TIM2         ((uint32_t)0x00180300)  /*!< TIM2 Full Alternate Function mapping */
N#define GPIO_PartialRemap_TIM3      ((uint32_t)0x001A0800)  /*!< TIM3 Partial Alternate Function mapping */
N#define GPIO_FullRemap_TIM3         ((uint32_t)0x001A0C00)  /*!< TIM3 Full Alternate Function mapping */
N#define GPIO_Remap_TIM4             ((uint32_t)0x00001000)  /*!< TIM4 Alternate Function mapping */
N#define GPIO_Remap1_CAN1            ((uint32_t)0x001D4000)  /*!< CAN1 Alternate Function mapping */
N#define GPIO_Remap2_CAN1            ((uint32_t)0x001D6000)  /*!< CAN1 Alternate Function mapping */
N#define GPIO_Remap_PD01             ((uint32_t)0x00008000)  /*!< PD01 Alternate Function mapping */
N#define GPIO_Remap_TIM5CH4_LSI      ((uint32_t)0x00200001)  /*!< LSI connected to TIM5 Channel4 input capture for calibration */
N#define GPIO_Remap_ADC1_ETRGINJ     ((uint32_t)0x00200002)  /*!< ADC1 External Trigger Injected Conversion remapping */
N#define GPIO_Remap_ADC1_ETRGREG     ((uint32_t)0x00200004)  /*!< ADC1 External Trigger Regular Conversion remapping */
N#define GPIO_Remap_ADC2_ETRGINJ     ((uint32_t)0x00200008)  /*!< ADC2 External Trigger Injected Conversion remapping */
N#define GPIO_Remap_ADC2_ETRGREG     ((uint32_t)0x00200010)  /*!< ADC2 External Trigger Regular Conversion remapping */
N#define GPIO_Remap_ETH              ((uint32_t)0x00200020)  /*!< Ethernet remapping (only for Connectivity line devices) */
N#define GPIO_Remap_CAN2             ((uint32_t)0x00200040)  /*!< CAN2 remapping (only for Connectivity line devices) */
N#define GPIO_Remap_SWJ_NoJTRST      ((uint32_t)0x00300100)  /*!< Full SWJ Enabled (JTAG-DP + SW-DP) but without JTRST */
N#define GPIO_Remap_SWJ_JTAGDisable  ((uint32_t)0x00300200)  /*!< JTAG-DP Disabled and SW-DP Enabled */
N#define GPIO_Remap_SWJ_Disable      ((uint32_t)0x00300400)  /*!< Full SWJ Disabled (JTAG-DP + SW-DP) */
N#define GPIO_Remap_SPI3             ((uint32_t)0x00201100)  /*!< SPI3/I2S3 Alternate Function mapping (only for Connectivity line devices) */
N#define GPIO_Remap_TIM2ITR1_PTP_SOF ((uint32_t)0x00202000)  /*!< Ethernet PTP output or USB OTG SOF (Start of Frame) connected
N                                                                 to TIM2 Internal Trigger 1 for calibration
N                                                                 (only for Connectivity line devices) */
N#define GPIO_Remap_PTP_PPS          ((uint32_t)0x00204000)  /*!< Ethernet MAC PPS_PTS output on PB05 (only for Connectivity line devices) */
N
N#define GPIO_Remap_TIM15            ((uint32_t)0x80000001)  /*!< TIM15 Alternate Function mapping (only for Value line devices) */
N#define GPIO_Remap_TIM16            ((uint32_t)0x80000002)  /*!< TIM16 Alternate Function mapping (only for Value line devices) */
N#define GPIO_Remap_TIM17            ((uint32_t)0x80000004)  /*!< TIM17 Alternate Function mapping (only for Value line devices) */
N#define GPIO_Remap_CEC              ((uint32_t)0x80000008)  /*!< CEC Alternate Function mapping (only for Value line devices) */
N#define GPIO_Remap_TIM1_DMA         ((uint32_t)0x80000010)  /*!< TIM1 DMA requests mapping (only for Value line devices) */
N
N#define GPIO_Remap_TIM9             ((uint32_t)0x80000020)  /*!< TIM9 Alternate Function mapping (only for XL-density devices) */
N#define GPIO_Remap_TIM10            ((uint32_t)0x80000040)  /*!< TIM10 Alternate Function mapping (only for XL-density devices) */
N#define GPIO_Remap_TIM11            ((uint32_t)0x80000080)  /*!< TIM11 Alternate Function mapping (only for XL-density devices) */
N#define GPIO_Remap_TIM13            ((uint32_t)0x80000100)  /*!< TIM13 Alternate Function mapping (only for High density Value line and XL-density devices) */
N#define GPIO_Remap_TIM14            ((uint32_t)0x80000200)  /*!< TIM14 Alternate Function mapping (only for High density Value line and XL-density devices) */
N#define GPIO_Remap_FSMC_NADV        ((uint32_t)0x80000400)  /*!< FSMC_NADV Alternate Function mapping (only for High density Value line and XL-density devices) */
N
N#define GPIO_Remap_TIM67_DAC_DMA    ((uint32_t)0x80000800)  /*!< TIM6/TIM7 and DAC DMA requests remapping (only for High density Value line devices) */
N#define GPIO_Remap_TIM12            ((uint32_t)0x80001000)  /*!< TIM12 Alternate Function mapping (only for High density Value line devices) */
N#define GPIO_Remap_MISC             ((uint32_t)0x80002000)  /*!< Miscellaneous Remap (DMA2 Channel5 Position and DAC Trigger remapping, 
N                                                                 only for High density Value line devices) */                                                       
N
N#define IS_GPIO_REMAP(REMAP) (((REMAP) == GPIO_Remap_SPI1) || ((REMAP) == GPIO_Remap_I2C1) || \
N                              ((REMAP) == GPIO_Remap_USART1) || ((REMAP) == GPIO_Remap_USART2) || \
N                              ((REMAP) == GPIO_PartialRemap_USART3) || ((REMAP) == GPIO_FullRemap_USART3) || \
N                              ((REMAP) == GPIO_PartialRemap_TIM1) || ((REMAP) == GPIO_FullRemap_TIM1) || \
N                              ((REMAP) == GPIO_PartialRemap1_TIM2) || ((REMAP) == GPIO_PartialRemap2_TIM2) || \
N                              ((REMAP) == GPIO_FullRemap_TIM2) || ((REMAP) == GPIO_PartialRemap_TIM3) || \
N                              ((REMAP) == GPIO_FullRemap_TIM3) || ((REMAP) == GPIO_Remap_TIM4) || \
N                              ((REMAP) == GPIO_Remap1_CAN1) || ((REMAP) == GPIO_Remap2_CAN1) || \
N                              ((REMAP) == GPIO_Remap_PD01) || ((REMAP) == GPIO_Remap_TIM5CH4_LSI) || \
N                              ((REMAP) == GPIO_Remap_ADC1_ETRGINJ) ||((REMAP) == GPIO_Remap_ADC1_ETRGREG) || \
N                              ((REMAP) == GPIO_Remap_ADC2_ETRGINJ) ||((REMAP) == GPIO_Remap_ADC2_ETRGREG) || \
N                              ((REMAP) == GPIO_Remap_ETH) ||((REMAP) == GPIO_Remap_CAN2) || \
N                              ((REMAP) == GPIO_Remap_SWJ_NoJTRST) || ((REMAP) == GPIO_Remap_SWJ_JTAGDisable) || \
N                              ((REMAP) == GPIO_Remap_SWJ_Disable)|| ((REMAP) == GPIO_Remap_SPI3) || \
N                              ((REMAP) == GPIO_Remap_TIM2ITR1_PTP_SOF) || ((REMAP) == GPIO_Remap_PTP_PPS) || \
N                              ((REMAP) == GPIO_Remap_TIM15) || ((REMAP) == GPIO_Remap_TIM16) || \
N                              ((REMAP) == GPIO_Remap_TIM17) || ((REMAP) == GPIO_Remap_CEC) || \
N                              ((REMAP) == GPIO_Remap_TIM1_DMA) || ((REMAP) == GPIO_Remap_TIM9) || \
N                              ((REMAP) == GPIO_Remap_TIM10) || ((REMAP) == GPIO_Remap_TIM11) || \
N                              ((REMAP) == GPIO_Remap_TIM13) || ((REMAP) == GPIO_Remap_TIM14) || \
N                              ((REMAP) == GPIO_Remap_FSMC_NADV) || ((REMAP) == GPIO_Remap_TIM67_DAC_DMA) || \
N                              ((REMAP) == GPIO_Remap_TIM12) || ((REMAP) == GPIO_Remap_MISC))
X#define IS_GPIO_REMAP(REMAP) (((REMAP) == GPIO_Remap_SPI1) || ((REMAP) == GPIO_Remap_I2C1) ||                               ((REMAP) == GPIO_Remap_USART1) || ((REMAP) == GPIO_Remap_USART2) ||                               ((REMAP) == GPIO_PartialRemap_USART3) || ((REMAP) == GPIO_FullRemap_USART3) ||                               ((REMAP) == GPIO_PartialRemap_TIM1) || ((REMAP) == GPIO_FullRemap_TIM1) ||                               ((REMAP) == GPIO_PartialRemap1_TIM2) || ((REMAP) == GPIO_PartialRemap2_TIM2) ||                               ((REMAP) == GPIO_FullRemap_TIM2) || ((REMAP) == GPIO_PartialRemap_TIM3) ||                               ((REMAP) == GPIO_FullRemap_TIM3) || ((REMAP) == GPIO_Remap_TIM4) ||                               ((REMAP) == GPIO_Remap1_CAN1) || ((REMAP) == GPIO_Remap2_CAN1) ||                               ((REMAP) == GPIO_Remap_PD01) || ((REMAP) == GPIO_Remap_TIM5CH4_LSI) ||                               ((REMAP) == GPIO_Remap_ADC1_ETRGINJ) ||((REMAP) == GPIO_Remap_ADC1_ETRGREG) ||                               ((REMAP) == GPIO_Remap_ADC2_ETRGINJ) ||((REMAP) == GPIO_Remap_ADC2_ETRGREG) ||                               ((REMAP) == GPIO_Remap_ETH) ||((REMAP) == GPIO_Remap_CAN2) ||                               ((REMAP) == GPIO_Remap_SWJ_NoJTRST) || ((REMAP) == GPIO_Remap_SWJ_JTAGDisable) ||                               ((REMAP) == GPIO_Remap_SWJ_Disable)|| ((REMAP) == GPIO_Remap_SPI3) ||                               ((REMAP) == GPIO_Remap_TIM2ITR1_PTP_SOF) || ((REMAP) == GPIO_Remap_PTP_PPS) ||                               ((REMAP) == GPIO_Remap_TIM15) || ((REMAP) == GPIO_Remap_TIM16) ||                               ((REMAP) == GPIO_Remap_TIM17) || ((REMAP) == GPIO_Remap_CEC) ||                               ((REMAP) == GPIO_Remap_TIM1_DMA) || ((REMAP) == GPIO_Remap_TIM9) ||                               ((REMAP) == GPIO_Remap_TIM10) || ((REMAP) == GPIO_Remap_TIM11) ||                               ((REMAP) == GPIO_Remap_TIM13) || ((REMAP) == GPIO_Remap_TIM14) ||                               ((REMAP) == GPIO_Remap_FSMC_NADV) || ((REMAP) == GPIO_Remap_TIM67_DAC_DMA) ||                               ((REMAP) == GPIO_Remap_TIM12) || ((REMAP) == GPIO_Remap_MISC))
N                              
N/**
N  * @}
N  */ 
N
N/** @defgroup GPIO_Port_Sources 
N  * @{
N  */
N
N#define GPIO_PortSourceGPIOA       ((uint8_t)0x00)
N#define GPIO_PortSourceGPIOB       ((uint8_t)0x01)
N#define GPIO_PortSourceGPIOC       ((uint8_t)0x02)
N#define GPIO_PortSourceGPIOD       ((uint8_t)0x03)
N#define GPIO_PortSourceGPIOE       ((uint8_t)0x04)
N#define GPIO_PortSourceGPIOF       ((uint8_t)0x05)
N#define GPIO_PortSourceGPIOG       ((uint8_t)0x06)
N#define IS_GPIO_EVENTOUT_PORT_SOURCE(PORTSOURCE) (((PORTSOURCE) == GPIO_PortSourceGPIOA) || \
N                                                  ((PORTSOURCE) == GPIO_PortSourceGPIOB) || \
N                                                  ((PORTSOURCE) == GPIO_PortSourceGPIOC) || \
N                                                  ((PORTSOURCE) == GPIO_PortSourceGPIOD) || \
N                                                  ((PORTSOURCE) == GPIO_PortSourceGPIOE))
X#define IS_GPIO_EVENTOUT_PORT_SOURCE(PORTSOURCE) (((PORTSOURCE) == GPIO_PortSourceGPIOA) ||                                                   ((PORTSOURCE) == GPIO_PortSourceGPIOB) ||                                                   ((PORTSOURCE) == GPIO_PortSourceGPIOC) ||                                                   ((PORTSOURCE) == GPIO_PortSourceGPIOD) ||                                                   ((PORTSOURCE) == GPIO_PortSourceGPIOE))
N
N#define IS_GPIO_EXTI_PORT_SOURCE(PORTSOURCE) (((PORTSOURCE) == GPIO_PortSourceGPIOA) || \
N                                              ((PORTSOURCE) == GPIO_PortSourceGPIOB) || \
N                                              ((PORTSOURCE) == GPIO_PortSourceGPIOC) || \
N                                              ((PORTSOURCE) == GPIO_PortSourceGPIOD) || \
N                                              ((PORTSOURCE) == GPIO_PortSourceGPIOE) || \
N                                              ((PORTSOURCE) == GPIO_PortSourceGPIOF) || \
N                                              ((PORTSOURCE) == GPIO_PortSourceGPIOG))
X#define IS_GPIO_EXTI_PORT_SOURCE(PORTSOURCE) (((PORTSOURCE) == GPIO_PortSourceGPIOA) ||                                               ((PORTSOURCE) == GPIO_PortSourceGPIOB) ||                                               ((PORTSOURCE) == GPIO_PortSourceGPIOC) ||                                               ((PORTSOURCE) == GPIO_PortSourceGPIOD) ||                                               ((PORTSOURCE) == GPIO_PortSourceGPIOE) ||                                               ((PORTSOURCE) == GPIO_PortSourceGPIOF) ||                                               ((PORTSOURCE) == GPIO_PortSourceGPIOG))
N
N/**
N  * @}
N  */
N
N/** @defgroup GPIO_Pin_sources 
N  * @{
N  */
N
N#define GPIO_PinSource0            ((uint8_t)0x00)
N#define GPIO_PinSource1            ((uint8_t)0x01)
N#define GPIO_PinSource2            ((uint8_t)0x02)
N#define GPIO_PinSource3            ((uint8_t)0x03)
N#define GPIO_PinSource4            ((uint8_t)0x04)
N#define GPIO_PinSource5            ((uint8_t)0x05)
N#define GPIO_PinSource6            ((uint8_t)0x06)
N#define GPIO_PinSource7            ((uint8_t)0x07)
N#define GPIO_PinSource8            ((uint8_t)0x08)
N#define GPIO_PinSource9            ((uint8_t)0x09)
N#define GPIO_PinSource10           ((uint8_t)0x0A)
N#define GPIO_PinSource11           ((uint8_t)0x0B)
N#define GPIO_PinSource12           ((uint8_t)0x0C)
N#define GPIO_PinSource13           ((uint8_t)0x0D)
N#define GPIO_PinSource14           ((uint8_t)0x0E)
N#define GPIO_PinSource15           ((uint8_t)0x0F)
N
N#define IS_GPIO_PIN_SOURCE(PINSOURCE) (((PINSOURCE) == GPIO_PinSource0) || \
N                                       ((PINSOURCE) == GPIO_PinSource1) || \
N                                       ((PINSOURCE) == GPIO_PinSource2) || \
N                                       ((PINSOURCE) == GPIO_PinSource3) || \
N                                       ((PINSOURCE) == GPIO_PinSource4) || \
N                                       ((PINSOURCE) == GPIO_PinSource5) || \
N                                       ((PINSOURCE) == GPIO_PinSource6) || \
N                                       ((PINSOURCE) == GPIO_PinSource7) || \
N                                       ((PINSOURCE) == GPIO_PinSource8) || \
N                                       ((PINSOURCE) == GPIO_PinSource9) || \
N                                       ((PINSOURCE) == GPIO_PinSource10) || \
N                                       ((PINSOURCE) == GPIO_PinSource11) || \
N                                       ((PINSOURCE) == GPIO_PinSource12) || \
N                                       ((PINSOURCE) == GPIO_PinSource13) || \
N                                       ((PINSOURCE) == GPIO_PinSource14) || \
N                                       ((PINSOURCE) == GPIO_PinSource15))
X#define IS_GPIO_PIN_SOURCE(PINSOURCE) (((PINSOURCE) == GPIO_PinSource0) ||                                        ((PINSOURCE) == GPIO_PinSource1) ||                                        ((PINSOURCE) == GPIO_PinSource2) ||                                        ((PINSOURCE) == GPIO_PinSource3) ||                                        ((PINSOURCE) == GPIO_PinSource4) ||                                        ((PINSOURCE) == GPIO_PinSource5) ||                                        ((PINSOURCE) == GPIO_PinSource6) ||                                        ((PINSOURCE) == GPIO_PinSource7) ||                                        ((PINSOURCE) == GPIO_PinSource8) ||                                        ((PINSOURCE) == GPIO_PinSource9) ||                                        ((PINSOURCE) == GPIO_PinSource10) ||                                        ((PINSOURCE) == GPIO_PinSource11) ||                                        ((PINSOURCE) == GPIO_PinSource12) ||                                        ((PINSOURCE) == GPIO_PinSource13) ||                                        ((PINSOURCE) == GPIO_PinSource14) ||                                        ((PINSOURCE) == GPIO_PinSource15))
N
N/**
N  * @}
N  */
N
N/** @defgroup Ethernet_Media_Interface 
N  * @{
N  */ 
N#define GPIO_ETH_MediaInterface_MII    ((u32)0x00000000) 
N#define GPIO_ETH_MediaInterface_RMII   ((u32)0x00000001)                                       
N
N#define IS_GPIO_ETH_MEDIA_INTERFACE(INTERFACE) (((INTERFACE) == GPIO_ETH_MediaInterface_MII) || \
N                                                ((INTERFACE) == GPIO_ETH_MediaInterface_RMII))
X#define IS_GPIO_ETH_MEDIA_INTERFACE(INTERFACE) (((INTERFACE) == GPIO_ETH_MediaInterface_MII) ||                                                 ((INTERFACE) == GPIO_ETH_MediaInterface_RMII))
N
N/**
N  * @}
N  */                                                
N/**
N  * @}
N  */
N
N/** @defgroup GPIO_Exported_Macros
N  * @{
N  */
N
N/**
N  * @}
N  */
N
N/** @defgroup GPIO_Exported_Functions
N  * @{
N  */
N
Nvoid GPIO_DeInit(GPIO_TypeDef* GPIOx);
Nvoid GPIO_AFIODeInit(void);
Nvoid GPIO_Init(GPIO_TypeDef* GPIOx, GPIO_InitTypeDef* GPIO_InitStruct);
Nvoid GPIO_StructInit(GPIO_InitTypeDef* GPIO_InitStruct);
Nuint8_t GPIO_ReadInputDataBit(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin);
Nuint16_t GPIO_ReadInputData(GPIO_TypeDef* GPIOx);
Nuint8_t GPIO_ReadOutputDataBit(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin);
Nuint16_t GPIO_ReadOutputData(GPIO_TypeDef* GPIOx);
Nvoid GPIO_SetBits(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin);
Nvoid GPIO_ResetBits(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin);
Nvoid GPIO_WriteBit(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin, BitAction BitVal);
Nvoid GPIO_Write(GPIO_TypeDef* GPIOx, uint16_t PortVal);
Nvoid GPIO_PinLockConfig(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin);
Nvoid GPIO_EventOutputConfig(uint8_t GPIO_PortSource, uint8_t GPIO_PinSource);
Nvoid GPIO_EventOutputCmd(FunctionalState NewState);
Nvoid GPIO_PinRemapConfig(uint32_t GPIO_Remap, FunctionalState NewState);
Nvoid GPIO_EXTILineConfig(uint8_t GPIO_PortSource, uint8_t GPIO_PinSource);
Nvoid GPIO_ETH_MediaInterfaceConfig(uint32_t GPIO_ETH_MediaInterface);
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif /* __STM32F10x_GPIO_H */
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */
N
N/******************* (C) COPYRIGHT 2011 STMicroelectronics *****END OF FILE****/
L 40 "..\..\User\stm32f10x_conf.h" 2
N#include "stm32f10x_i2c.h" 
L 1 "..\..\Libraries\FWlib\inc\stm32f10x_i2c.h" 1
N/**
N  ******************************************************************************
N  * @file    stm32f10x_i2c.h
N  * @author  MCD Application Team
N  * @version V3.5.0
N  * @date    11-March-2011
N  * @brief   This file contains all the functions prototypes for the I2C firmware 
N  *          library.
N  ******************************************************************************
N  * @attention
N  *
N  * THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
N  * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE
N  * TIME. AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY
N  * DIRECT, INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING
N  * FROM THE CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE
N  * CODING INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
N  *
N  * <h2><center>&copy; COPYRIGHT 2011 STMicroelectronics</center></h2>
N  ******************************************************************************
N  */
N
N/* Define to prevent recursive inclusion -------------------------------------*/
N#ifndef __STM32F10x_I2C_H
N#define __STM32F10x_I2C_H
N
N#ifdef __cplusplus
S extern "C" {
N#endif
N
N/* Includes ------------------------------------------------------------------*/
N#include "stm32f10x.h"
N
N/** @addtogroup STM32F10x_StdPeriph_Driver
N  * @{
N  */
N
N/** @addtogroup I2C
N  * @{
N  */
N
N/** @defgroup I2C_Exported_Types
N  * @{
N  */
N
N/** 
N  * @brief  I2C Init structure definition  
N  */
N
Ntypedef struct
N{
N  uint32_t I2C_ClockSpeed;          /*!< Specifies the clock frequency.
N                                         This parameter must be set to a value lower than 400kHz */
N
N  uint16_t I2C_Mode;                /*!< Specifies the I2C mode.
N                                         This parameter can be a value of @ref I2C_mode */
N
N  uint16_t I2C_DutyCycle;           /*!< Specifies the I2C fast mode duty cycle.
N                                         This parameter can be a value of @ref I2C_duty_cycle_in_fast_mode */
N
N  uint16_t I2C_OwnAddress1;         /*!< Specifies the first device own address.
N                                         This parameter can be a 7-bit or 10-bit address. */
N
N  uint16_t I2C_Ack;                 /*!< Enables or disables the acknowledgement.
N                                         This parameter can be a value of @ref I2C_acknowledgement */
N
N  uint16_t I2C_AcknowledgedAddress; /*!< Specifies if 7-bit or 10-bit address is acknowledged.
N                                         This parameter can be a value of @ref I2C_acknowledged_address */
N}I2C_InitTypeDef;
N
N/**
N  * @}
N  */ 
N
N
N/** @defgroup I2C_Exported_Constants
N  * @{
N  */
N
N#define IS_I2C_ALL_PERIPH(PERIPH) (((PERIPH) == I2C1) || \
N                                   ((PERIPH) == I2C2))
X#define IS_I2C_ALL_PERIPH(PERIPH) (((PERIPH) == I2C1) ||                                    ((PERIPH) == I2C2))
N/** @defgroup I2C_mode 
N  * @{
N  */
N
N#define I2C_Mode_I2C                    ((uint16_t)0x0000)
N#define I2C_Mode_SMBusDevice            ((uint16_t)0x0002)  
N#define I2C_Mode_SMBusHost              ((uint16_t)0x000A)
N#define IS_I2C_MODE(MODE) (((MODE) == I2C_Mode_I2C) || \
N                           ((MODE) == I2C_Mode_SMBusDevice) || \
N                           ((MODE) == I2C_Mode_SMBusHost))
X#define IS_I2C_MODE(MODE) (((MODE) == I2C_Mode_I2C) ||                            ((MODE) == I2C_Mode_SMBusDevice) ||                            ((MODE) == I2C_Mode_SMBusHost))
N/**
N  * @}
N  */
N
N/** @defgroup I2C_duty_cycle_in_fast_mode 
N  * @{
N  */
N
N#define I2C_DutyCycle_16_9              ((uint16_t)0x4000) /*!< I2C fast mode Tlow/Thigh = 16/9 */
N#define I2C_DutyCycle_2                 ((uint16_t)0xBFFF) /*!< I2C fast mode Tlow/Thigh = 2 */
N#define IS_I2C_DUTY_CYCLE(CYCLE) (((CYCLE) == I2C_DutyCycle_16_9) || \
N                                  ((CYCLE) == I2C_DutyCycle_2))
X#define IS_I2C_DUTY_CYCLE(CYCLE) (((CYCLE) == I2C_DutyCycle_16_9) ||                                   ((CYCLE) == I2C_DutyCycle_2))
N/**
N  * @}
N  */ 
N
N/** @defgroup I2C_acknowledgement
N  * @{
N  */
N
N#define I2C_Ack_Enable                  ((uint16_t)0x0400)
N#define I2C_Ack_Disable                 ((uint16_t)0x0000)
N#define IS_I2C_ACK_STATE(STATE) (((STATE) == I2C_Ack_Enable) || \
N                                 ((STATE) == I2C_Ack_Disable))
X#define IS_I2C_ACK_STATE(STATE) (((STATE) == I2C_Ack_Enable) ||                                  ((STATE) == I2C_Ack_Disable))
N/**
N  * @}
N  */
N
N/** @defgroup I2C_transfer_direction 
N  * @{
N  */
N
N#define  I2C_Direction_Transmitter      ((uint8_t)0x00)
N#define  I2C_Direction_Receiver         ((uint8_t)0x01)
N#define IS_I2C_DIRECTION(DIRECTION) (((DIRECTION) == I2C_Direction_Transmitter) || \
N                                     ((DIRECTION) == I2C_Direction_Receiver))
X#define IS_I2C_DIRECTION(DIRECTION) (((DIRECTION) == I2C_Direction_Transmitter) ||                                      ((DIRECTION) == I2C_Direction_Receiver))
N/**
N  * @}
N  */
N
N/** @defgroup I2C_acknowledged_address 
N  * @{
N  */
N
N#define I2C_AcknowledgedAddress_7bit    ((uint16_t)0x4000)
N#define I2C_AcknowledgedAddress_10bit   ((uint16_t)0xC000)
N#define IS_I2C_ACKNOWLEDGE_ADDRESS(ADDRESS) (((ADDRESS) == I2C_AcknowledgedAddress_7bit) || \
N                                             ((ADDRESS) == I2C_AcknowledgedAddress_10bit))
X#define IS_I2C_ACKNOWLEDGE_ADDRESS(ADDRESS) (((ADDRESS) == I2C_AcknowledgedAddress_7bit) ||                                              ((ADDRESS) == I2C_AcknowledgedAddress_10bit))
N/**
N  * @}
N  */ 
N
N/** @defgroup I2C_registers 
N  * @{
N  */
N
N#define I2C_Register_CR1                ((uint8_t)0x00)
N#define I2C_Register_CR2                ((uint8_t)0x04)
N#define I2C_Register_OAR1               ((uint8_t)0x08)
N#define I2C_Register_OAR2               ((uint8_t)0x0C)
N#define I2C_Register_DR                 ((uint8_t)0x10)
N#define I2C_Register_SR1                ((uint8_t)0x14)
N#define I2C_Register_SR2                ((uint8_t)0x18)
N#define I2C_Register_CCR                ((uint8_t)0x1C)
N#define I2C_Register_TRISE              ((uint8_t)0x20)
N#define IS_I2C_REGISTER(REGISTER) (((REGISTER) == I2C_Register_CR1) || \
N                                   ((REGISTER) == I2C_Register_CR2) || \
N                                   ((REGISTER) == I2C_Register_OAR1) || \
N                                   ((REGISTER) == I2C_Register_OAR2) || \
N                                   ((REGISTER) == I2C_Register_DR) || \
N                                   ((REGISTER) == I2C_Register_SR1) || \
N                                   ((REGISTER) == I2C_Register_SR2) || \
N                                   ((REGISTER) == I2C_Register_CCR) || \
N                                   ((REGISTER) == I2C_Register_TRISE))
X#define IS_I2C_REGISTER(REGISTER) (((REGISTER) == I2C_Register_CR1) ||                                    ((REGISTER) == I2C_Register_CR2) ||                                    ((REGISTER) == I2C_Register_OAR1) ||                                    ((REGISTER) == I2C_Register_OAR2) ||                                    ((REGISTER) == I2C_Register_DR) ||                                    ((REGISTER) == I2C_Register_SR1) ||                                    ((REGISTER) == I2C_Register_SR2) ||                                    ((REGISTER) == I2C_Register_CCR) ||                                    ((REGISTER) == I2C_Register_TRISE))
N/**
N  * @}
N  */
N
N/** @defgroup I2C_SMBus_alert_pin_level 
N  * @{
N  */
N
N#define I2C_SMBusAlert_Low              ((uint16_t)0x2000)
N#define I2C_SMBusAlert_High             ((uint16_t)0xDFFF)
N#define IS_I2C_SMBUS_ALERT(ALERT) (((ALERT) == I2C_SMBusAlert_Low) || \
N                                   ((ALERT) == I2C_SMBusAlert_High))
X#define IS_I2C_SMBUS_ALERT(ALERT) (((ALERT) == I2C_SMBusAlert_Low) ||                                    ((ALERT) == I2C_SMBusAlert_High))
N/**
N  * @}
N  */
N
N/** @defgroup I2C_PEC_position 
N  * @{
N  */
N
N#define I2C_PECPosition_Next            ((uint16_t)0x0800)
N#define I2C_PECPosition_Current         ((uint16_t)0xF7FF)
N#define IS_I2C_PEC_POSITION(POSITION) (((POSITION) == I2C_PECPosition_Next) || \
N                                       ((POSITION) == I2C_PECPosition_Current))
X#define IS_I2C_PEC_POSITION(POSITION) (((POSITION) == I2C_PECPosition_Next) ||                                        ((POSITION) == I2C_PECPosition_Current))
N/**
N  * @}
N  */ 
N
N/** @defgroup I2C_NCAK_position 
N  * @{
N  */
N
N#define I2C_NACKPosition_Next           ((uint16_t)0x0800)
N#define I2C_NACKPosition_Current        ((uint16_t)0xF7FF)
N#define IS_I2C_NACK_POSITION(POSITION)  (((POSITION) == I2C_NACKPosition_Next) || \
N                                         ((POSITION) == I2C_NACKPosition_Current))
X#define IS_I2C_NACK_POSITION(POSITION)  (((POSITION) == I2C_NACKPosition_Next) ||                                          ((POSITION) == I2C_NACKPosition_Current))
N/**
N  * @}
N  */ 
N
N/** @defgroup I2C_interrupts_definition 
N  * @{
N  */
N
N#define I2C_IT_BUF                      ((uint16_t)0x0400)
N#define I2C_IT_EVT                      ((uint16_t)0x0200)
N#define I2C_IT_ERR                      ((uint16_t)0x0100)
N#define IS_I2C_CONFIG_IT(IT) ((((IT) & (uint16_t)0xF8FF) == 0x00) && ((IT) != 0x00))
N/**
N  * @}
N  */ 
N
N/** @defgroup I2C_interrupts_definition 
N  * @{
N  */
N
N#define I2C_IT_SMBALERT                 ((uint32_t)0x01008000)
N#define I2C_IT_TIMEOUT                  ((uint32_t)0x01004000)
N#define I2C_IT_PECERR                   ((uint32_t)0x01001000)
N#define I2C_IT_OVR                      ((uint32_t)0x01000800)
N#define I2C_IT_AF                       ((uint32_t)0x01000400)
N#define I2C_IT_ARLO                     ((uint32_t)0x01000200)
N#define I2C_IT_BERR                     ((uint32_t)0x01000100)
N#define I2C_IT_TXE                      ((uint32_t)0x06000080)
N#define I2C_IT_RXNE                     ((uint32_t)0x06000040)
N#define I2C_IT_STOPF                    ((uint32_t)0x02000010)
N#define I2C_IT_ADD10                    ((uint32_t)0x02000008)
N#define I2C_IT_BTF                      ((uint32_t)0x02000004)
N#define I2C_IT_ADDR                     ((uint32_t)0x02000002)
N#define I2C_IT_SB                       ((uint32_t)0x02000001)
N
N#define IS_I2C_CLEAR_IT(IT) ((((IT) & (uint16_t)0x20FF) == 0x00) && ((IT) != (uint16_t)0x00))
N
N#define IS_I2C_GET_IT(IT) (((IT) == I2C_IT_SMBALERT) || ((IT) == I2C_IT_TIMEOUT) || \
N                           ((IT) == I2C_IT_PECERR) || ((IT) == I2C_IT_OVR) || \
N                           ((IT) == I2C_IT_AF) || ((IT) == I2C_IT_ARLO) || \
N                           ((IT) == I2C_IT_BERR) || ((IT) == I2C_IT_TXE) || \
N                           ((IT) == I2C_IT_RXNE) || ((IT) == I2C_IT_STOPF) || \
N                           ((IT) == I2C_IT_ADD10) || ((IT) == I2C_IT_BTF) || \
N                           ((IT) == I2C_IT_ADDR) || ((IT) == I2C_IT_SB))
X#define IS_I2C_GET_IT(IT) (((IT) == I2C_IT_SMBALERT) || ((IT) == I2C_IT_TIMEOUT) ||                            ((IT) == I2C_IT_PECERR) || ((IT) == I2C_IT_OVR) ||                            ((IT) == I2C_IT_AF) || ((IT) == I2C_IT_ARLO) ||                            ((IT) == I2C_IT_BERR) || ((IT) == I2C_IT_TXE) ||                            ((IT) == I2C_IT_RXNE) || ((IT) == I2C_IT_STOPF) ||                            ((IT) == I2C_IT_ADD10) || ((IT) == I2C_IT_BTF) ||                            ((IT) == I2C_IT_ADDR) || ((IT) == I2C_IT_SB))
N/**
N  * @}
N  */
N
N/** @defgroup I2C_flags_definition 
N  * @{
N  */
N
N/** 
N  * @brief  SR2 register flags  
N  */
N
N#define I2C_FLAG_DUALF                  ((uint32_t)0x00800000)
N#define I2C_FLAG_SMBHOST                ((uint32_t)0x00400000)
N#define I2C_FLAG_SMBDEFAULT             ((uint32_t)0x00200000)
N#define I2C_FLAG_GENCALL                ((uint32_t)0x00100000)
N#define I2C_FLAG_TRA                    ((uint32_t)0x00040000)
N#define I2C_FLAG_BUSY                   ((uint32_t)0x00020000)
N#define I2C_FLAG_MSL                    ((uint32_t)0x00010000)
N
N/** 
N  * @brief  SR1 register flags  
N  */
N
N#define I2C_FLAG_SMBALERT               ((uint32_t)0x10008000)
N#define I2C_FLAG_TIMEOUT                ((uint32_t)0x10004000)
N#define I2C_FLAG_PECERR                 ((uint32_t)0x10001000)
N#define I2C_FLAG_OVR                    ((uint32_t)0x10000800)
N#define I2C_FLAG_AF                     ((uint32_t)0x10000400)
N#define I2C_FLAG_ARLO                   ((uint32_t)0x10000200)
N#define I2C_FLAG_BERR                   ((uint32_t)0x10000100)
N#define I2C_FLAG_TXE                    ((uint32_t)0x10000080)
N#define I2C_FLAG_RXNE                   ((uint32_t)0x10000040)
N#define I2C_FLAG_STOPF                  ((uint32_t)0x10000010)
N#define I2C_FLAG_ADD10                  ((uint32_t)0x10000008)
N#define I2C_FLAG_BTF                    ((uint32_t)0x10000004)
N#define I2C_FLAG_ADDR                   ((uint32_t)0x10000002)
N#define I2C_FLAG_SB                     ((uint32_t)0x10000001)
N
N#define IS_I2C_CLEAR_FLAG(FLAG) ((((FLAG) & (uint16_t)0x20FF) == 0x00) && ((FLAG) != (uint16_t)0x00))
N
N#define IS_I2C_GET_FLAG(FLAG) (((FLAG) == I2C_FLAG_DUALF) || ((FLAG) == I2C_FLAG_SMBHOST) || \
N                               ((FLAG) == I2C_FLAG_SMBDEFAULT) || ((FLAG) == I2C_FLAG_GENCALL) || \
N                               ((FLAG) == I2C_FLAG_TRA) || ((FLAG) == I2C_FLAG_BUSY) || \
N                               ((FLAG) == I2C_FLAG_MSL) || ((FLAG) == I2C_FLAG_SMBALERT) || \
N                               ((FLAG) == I2C_FLAG_TIMEOUT) || ((FLAG) == I2C_FLAG_PECERR) || \
N                               ((FLAG) == I2C_FLAG_OVR) || ((FLAG) == I2C_FLAG_AF) || \
N                               ((FLAG) == I2C_FLAG_ARLO) || ((FLAG) == I2C_FLAG_BERR) || \
N                               ((FLAG) == I2C_FLAG_TXE) || ((FLAG) == I2C_FLAG_RXNE) || \
N                               ((FLAG) == I2C_FLAG_STOPF) || ((FLAG) == I2C_FLAG_ADD10) || \
N                               ((FLAG) == I2C_FLAG_BTF) || ((FLAG) == I2C_FLAG_ADDR) || \
N                               ((FLAG) == I2C_FLAG_SB))
X#define IS_I2C_GET_FLAG(FLAG) (((FLAG) == I2C_FLAG_DUALF) || ((FLAG) == I2C_FLAG_SMBHOST) ||                                ((FLAG) == I2C_FLAG_SMBDEFAULT) || ((FLAG) == I2C_FLAG_GENCALL) ||                                ((FLAG) == I2C_FLAG_TRA) || ((FLAG) == I2C_FLAG_BUSY) ||                                ((FLAG) == I2C_FLAG_MSL) || ((FLAG) == I2C_FLAG_SMBALERT) ||                                ((FLAG) == I2C_FLAG_TIMEOUT) || ((FLAG) == I2C_FLAG_PECERR) ||                                ((FLAG) == I2C_FLAG_OVR) || ((FLAG) == I2C_FLAG_AF) ||                                ((FLAG) == I2C_FLAG_ARLO) || ((FLAG) == I2C_FLAG_BERR) ||                                ((FLAG) == I2C_FLAG_TXE) || ((FLAG) == I2C_FLAG_RXNE) ||                                ((FLAG) == I2C_FLAG_STOPF) || ((FLAG) == I2C_FLAG_ADD10) ||                                ((FLAG) == I2C_FLAG_BTF) || ((FLAG) == I2C_FLAG_ADDR) ||                                ((FLAG) == I2C_FLAG_SB))
N/**
N  * @}
N  */
N
N/** @defgroup I2C_Events 
N  * @{
N  */
N
N/*========================================
N     
N                     I2C Master Events (Events grouped in order of communication)
N                                                        ==========================================*/
N/** 
N  * @brief  Communication start
N  * 
N  * After sending the START condition (I2C_GenerateSTART() function) the master 
N  * has to wait for this event. It means that the Start condition has been correctly 
N  * released on the I2C bus (the bus is free, no other devices is communicating).
N  * 
N  */
N/* --EV5 */
N#define  I2C_EVENT_MASTER_MODE_SELECT                      ((uint32_t)0x00030001)  /* BUSY, MSL and SB flag */
N
N/** 
N  * @brief  Address Acknowledge
N  * 
N  * After checking on EV5 (start condition correctly released on the bus), the 
N  * master sends the address of the slave(s) with which it will communicate 
N  * (I2C_Send7bitAddress() function, it also determines the direction of the communication: 
N  * Master transmitter or Receiver). Then the master has to wait that a slave acknowledges 
N  * his address. If an acknowledge is sent on the bus, one of the following events will 
N  * be set:
N  * 
N  *  1) In case of Master Receiver (7-bit addressing): the I2C_EVENT_MASTER_RECEIVER_MODE_SELECTED 
N  *     event is set.
N  *  
N  *  2) In case of Master Transmitter (7-bit addressing): the I2C_EVENT_MASTER_TRANSMITTER_MODE_SELECTED 
N  *     is set
N  *  
N  *  3) In case of 10-Bit addressing mode, the master (just after generating the START 
N  *  and checking on EV5) has to send the header of 10-bit addressing mode (I2C_SendData() 
N  *  function). Then master should wait on EV9. It means that the 10-bit addressing 
N  *  header has been correctly sent on the bus. Then master should send the second part of 
N  *  the 10-bit address (LSB) using the function I2C_Send7bitAddress(). Then master 
N  *  should wait for event EV6. 
N  *     
N  */
N
N/* --EV6 */
N#define  I2C_EVENT_MASTER_TRANSMITTER_MODE_SELECTED        ((uint32_t)0x00070082)  /* BUSY, MSL, ADDR, TXE and TRA flags */
N#define  I2C_EVENT_MASTER_RECEIVER_MODE_SELECTED           ((uint32_t)0x00030002)  /* BUSY, MSL and ADDR flags */
N/* --EV9 */
N#define  I2C_EVENT_MASTER_MODE_ADDRESS10                   ((uint32_t)0x00030008)  /* BUSY, MSL and ADD10 flags */
N
N/** 
N  * @brief Communication events
N  * 
N  * If a communication is established (START condition generated and slave address 
N  * acknowledged) then the master has to check on one of the following events for 
N  * communication procedures:
N  *  
N  * 1) Master Receiver mode: The master has to wait on the event EV7 then to read 
N  *    the data received from the slave (I2C_ReceiveData() function).
N  * 
N  * 2) Master Transmitter mode: The master has to send data (I2C_SendData() 
N  *    function) then to wait on event EV8 or EV8_2.
N  *    These two events are similar: 
N  *     - EV8 means that the data has been written in the data register and is 
N  *       being shifted out.
N  *     - EV8_2 means that the data has been physically shifted out and output 
N  *       on the bus.
N  *     In most cases, using EV8 is sufficient for the application.
N  *     Using EV8_2 leads to a slower communication but ensure more reliable test.
N  *     EV8_2 is also more suitable than EV8 for testing on the last data transmission 
N  *     (before Stop condition generation).
N  *     
N  *  @note In case the  user software does not guarantee that this event EV7 is 
N  *  managed before the current byte end of transfer, then user may check on EV7 
N  *  and BTF flag at the same time (ie. (I2C_EVENT_MASTER_BYTE_RECEIVED | I2C_FLAG_BTF)).
N  *  In this case the communication may be slower.
N  * 
N  */
N
N/* Master RECEIVER mode -----------------------------*/ 
N/* --EV7 */
N#define  I2C_EVENT_MASTER_BYTE_RECEIVED                    ((uint32_t)0x00030040)  /* BUSY, MSL and RXNE flags */
N
N/* Master TRANSMITTER mode --------------------------*/
N/* --EV8 */
N#define I2C_EVENT_MASTER_BYTE_TRANSMITTING                 ((uint32_t)0x00070080) /* TRA, BUSY, MSL, TXE flags */
N/* --EV8_2 */
N#define  I2C_EVENT_MASTER_BYTE_TRANSMITTED                 ((uint32_t)0x00070084)  /* TRA, BUSY, MSL, TXE and BTF flags */
N
N
N/*========================================
N     
N                     I2C Slave Events (Events grouped in order of communication)
N                                                        ==========================================*/
N
N/** 
N  * @brief  Communication start events
N  * 
N  * Wait on one of these events at the start of the communication. It means that 
N  * the I2C peripheral detected a Start condition on the bus (generated by master 
N  * device) followed by the peripheral address. The peripheral generates an ACK 
N  * condition on the bus (if the acknowledge feature is enabled through function 
N  * I2C_AcknowledgeConfig()) and the events listed above are set :
N  *  
N  * 1) In normal case (only one address managed by the slave), when the address 
N  *   sent by the master matches the own address of the peripheral (configured by 
N  *   I2C_OwnAddress1 field) the I2C_EVENT_SLAVE_XXX_ADDRESS_MATCHED event is set 
N  *   (where XXX could be TRANSMITTER or RECEIVER).
N  *    
N  * 2) In case the address sent by the master matches the second address of the 
N  *   peripheral (configured by the function I2C_OwnAddress2Config() and enabled 
N  *   by the function I2C_DualAddressCmd()) the events I2C_EVENT_SLAVE_XXX_SECONDADDRESS_MATCHED 
N  *   (where XXX could be TRANSMITTER or RECEIVER) are set.
N  *   
N  * 3) In case the address sent by the master is General Call (address 0x00) and 
N  *   if the General Call is enabled for the peripheral (using function I2C_GeneralCallCmd()) 
N  *   the following event is set I2C_EVENT_SLAVE_GENERALCALLADDRESS_MATCHED.   
N  * 
N  */
N
N/* --EV1  (all the events below are variants of EV1) */   
N/* 1) Case of One Single Address managed by the slave */
N#define  I2C_EVENT_SLAVE_RECEIVER_ADDRESS_MATCHED          ((uint32_t)0x00020002) /* BUSY and ADDR flags */
N#define  I2C_EVENT_SLAVE_TRANSMITTER_ADDRESS_MATCHED       ((uint32_t)0x00060082) /* TRA, BUSY, TXE and ADDR flags */
N
N/* 2) Case of Dual address managed by the slave */
N#define  I2C_EVENT_SLAVE_RECEIVER_SECONDADDRESS_MATCHED    ((uint32_t)0x00820000)  /* DUALF and BUSY flags */
N#define  I2C_EVENT_SLAVE_TRANSMITTER_SECONDADDRESS_MATCHED ((uint32_t)0x00860080)  /* DUALF, TRA, BUSY and TXE flags */
N
N/* 3) Case of General Call enabled for the slave */
N#define  I2C_EVENT_SLAVE_GENERALCALLADDRESS_MATCHED        ((uint32_t)0x00120000)  /* GENCALL and BUSY flags */
N
N/** 
N  * @brief  Communication events
N  * 
N  * Wait on one of these events when EV1 has already been checked and: 
N  * 
N  * - Slave RECEIVER mode:
N  *     - EV2: When the application is expecting a data byte to be received. 
N  *     - EV4: When the application is expecting the end of the communication: master 
N  *       sends a stop condition and data transmission is stopped.
N  *    
N  * - Slave Transmitter mode:
N  *    - EV3: When a byte has been transmitted by the slave and the application is expecting 
N  *      the end of the byte transmission. The two events I2C_EVENT_SLAVE_BYTE_TRANSMITTED and
N  *      I2C_EVENT_SLAVE_BYTE_TRANSMITTING are similar. The second one can optionally be 
N  *      used when the user software doesn't guarantee the EV3 is managed before the
N  *      current byte end of transfer.
N  *    - EV3_2: When the master sends a NACK in order to tell slave that data transmission 
N  *      shall end (before sending the STOP condition). In this case slave has to stop sending 
N  *      data bytes and expect a Stop condition on the bus.
N  *      
N  *  @note In case the  user software does not guarantee that the event EV2 is 
N  *  managed before the current byte end of transfer, then user may check on EV2 
N  *  and BTF flag at the same time (ie. (I2C_EVENT_SLAVE_BYTE_RECEIVED | I2C_FLAG_BTF)).
N  * In this case the communication may be slower.
N  *
N  */
N
N/* Slave RECEIVER mode --------------------------*/ 
N/* --EV2 */
N#define  I2C_EVENT_SLAVE_BYTE_RECEIVED                     ((uint32_t)0x00020040)  /* BUSY and RXNE flags */
N/* --EV4  */
N#define  I2C_EVENT_SLAVE_STOP_DETECTED                     ((uint32_t)0x00000010)  /* STOPF flag */
N
N/* Slave TRANSMITTER mode -----------------------*/
N/* --EV3 */
N#define  I2C_EVENT_SLAVE_BYTE_TRANSMITTED                  ((uint32_t)0x00060084)  /* TRA, BUSY, TXE and BTF flags */
N#define  I2C_EVENT_SLAVE_BYTE_TRANSMITTING                 ((uint32_t)0x00060080)  /* TRA, BUSY and TXE flags */
N/* --EV3_2 */
N#define  I2C_EVENT_SLAVE_ACK_FAILURE                       ((uint32_t)0x00000400)  /* AF flag */
N
N/*===========================      End of Events Description           ==========================================*/
N
N#define IS_I2C_EVENT(EVENT) (((EVENT) == I2C_EVENT_SLAVE_TRANSMITTER_ADDRESS_MATCHED) || \
N                             ((EVENT) == I2C_EVENT_SLAVE_RECEIVER_ADDRESS_MATCHED) || \
N                             ((EVENT) == I2C_EVENT_SLAVE_TRANSMITTER_SECONDADDRESS_MATCHED) || \
N                             ((EVENT) == I2C_EVENT_SLAVE_RECEIVER_SECONDADDRESS_MATCHED) || \
N                             ((EVENT) == I2C_EVENT_SLAVE_GENERALCALLADDRESS_MATCHED) || \
N                             ((EVENT) == I2C_EVENT_SLAVE_BYTE_RECEIVED) || \
N                             ((EVENT) == (I2C_EVENT_SLAVE_BYTE_RECEIVED | I2C_FLAG_DUALF)) || \
N                             ((EVENT) == (I2C_EVENT_SLAVE_BYTE_RECEIVED | I2C_FLAG_GENCALL)) || \
N                             ((EVENT) == I2C_EVENT_SLAVE_BYTE_TRANSMITTED) || \
N                             ((EVENT) == (I2C_EVENT_SLAVE_BYTE_TRANSMITTED | I2C_FLAG_DUALF)) || \
N                             ((EVENT) == (I2C_EVENT_SLAVE_BYTE_TRANSMITTED | I2C_FLAG_GENCALL)) || \
N                             ((EVENT) == I2C_EVENT_SLAVE_STOP_DETECTED) || \
N                             ((EVENT) == I2C_EVENT_MASTER_MODE_SELECT) || \
N                             ((EVENT) == I2C_EVENT_MASTER_TRANSMITTER_MODE_SELECTED) || \
N                             ((EVENT) == I2C_EVENT_MASTER_RECEIVER_MODE_SELECTED) || \
N                             ((EVENT) == I2C_EVENT_MASTER_BYTE_RECEIVED) || \
N                             ((EVENT) == I2C_EVENT_MASTER_BYTE_TRANSMITTED) || \
N                             ((EVENT) == I2C_EVENT_MASTER_BYTE_TRANSMITTING) || \
N                             ((EVENT) == I2C_EVENT_MASTER_MODE_ADDRESS10) || \
N                             ((EVENT) == I2C_EVENT_SLAVE_ACK_FAILURE))
X#define IS_I2C_EVENT(EVENT) (((EVENT) == I2C_EVENT_SLAVE_TRANSMITTER_ADDRESS_MATCHED) ||                              ((EVENT) == I2C_EVENT_SLAVE_RECEIVER_ADDRESS_MATCHED) ||                              ((EVENT) == I2C_EVENT_SLAVE_TRANSMITTER_SECONDADDRESS_MATCHED) ||                              ((EVENT) == I2C_EVENT_SLAVE_RECEIVER_SECONDADDRESS_MATCHED) ||                              ((EVENT) == I2C_EVENT_SLAVE_GENERALCALLADDRESS_MATCHED) ||                              ((EVENT) == I2C_EVENT_SLAVE_BYTE_RECEIVED) ||                              ((EVENT) == (I2C_EVENT_SLAVE_BYTE_RECEIVED | I2C_FLAG_DUALF)) ||                              ((EVENT) == (I2C_EVENT_SLAVE_BYTE_RECEIVED | I2C_FLAG_GENCALL)) ||                              ((EVENT) == I2C_EVENT_SLAVE_BYTE_TRANSMITTED) ||                              ((EVENT) == (I2C_EVENT_SLAVE_BYTE_TRANSMITTED | I2C_FLAG_DUALF)) ||                              ((EVENT) == (I2C_EVENT_SLAVE_BYTE_TRANSMITTED | I2C_FLAG_GENCALL)) ||                              ((EVENT) == I2C_EVENT_SLAVE_STOP_DETECTED) ||                              ((EVENT) == I2C_EVENT_MASTER_MODE_SELECT) ||                              ((EVENT) == I2C_EVENT_MASTER_TRANSMITTER_MODE_SELECTED) ||                              ((EVENT) == I2C_EVENT_MASTER_RECEIVER_MODE_SELECTED) ||                              ((EVENT) == I2C_EVENT_MASTER_BYTE_RECEIVED) ||                              ((EVENT) == I2C_EVENT_MASTER_BYTE_TRANSMITTED) ||                              ((EVENT) == I2C_EVENT_MASTER_BYTE_TRANSMITTING) ||                              ((EVENT) == I2C_EVENT_MASTER_MODE_ADDRESS10) ||                              ((EVENT) == I2C_EVENT_SLAVE_ACK_FAILURE))
N/**
N  * @}
N  */
N
N/** @defgroup I2C_own_address1 
N  * @{
N  */
N
N#define IS_I2C_OWN_ADDRESS1(ADDRESS1) ((ADDRESS1) <= 0x3FF)
N/**
N  * @}
N  */
N
N/** @defgroup I2C_clock_speed 
N  * @{
N  */
N
N#define IS_I2C_CLOCK_SPEED(SPEED) (((SPEED) >= 0x1) && ((SPEED) <= 400000))
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */
N
N/** @defgroup I2C_Exported_Macros
N  * @{
N  */
N
N/**
N  * @}
N  */
N
N/** @defgroup I2C_Exported_Functions
N  * @{
N  */
N
Nvoid I2C_DeInit(I2C_TypeDef* I2Cx);
Nvoid I2C_Init(I2C_TypeDef* I2Cx, I2C_InitTypeDef* I2C_InitStruct);
Nvoid I2C_StructInit(I2C_InitTypeDef* I2C_InitStruct);
Nvoid I2C_Cmd(I2C_TypeDef* I2Cx, FunctionalState NewState);
Nvoid I2C_DMACmd(I2C_TypeDef* I2Cx, FunctionalState NewState);
Nvoid I2C_DMALastTransferCmd(I2C_TypeDef* I2Cx, FunctionalState NewState);
Nvoid I2C_GenerateSTART(I2C_TypeDef* I2Cx, FunctionalState NewState);
Nvoid I2C_GenerateSTOP(I2C_TypeDef* I2Cx, FunctionalState NewState);
Nvoid I2C_AcknowledgeConfig(I2C_TypeDef* I2Cx, FunctionalState NewState);
Nvoid I2C_OwnAddress2Config(I2C_TypeDef* I2Cx, uint8_t Address);
Nvoid I2C_DualAddressCmd(I2C_TypeDef* I2Cx, FunctionalState NewState);
Nvoid I2C_GeneralCallCmd(I2C_TypeDef* I2Cx, FunctionalState NewState);
Nvoid I2C_ITConfig(I2C_TypeDef* I2Cx, uint16_t I2C_IT, FunctionalState NewState);
Nvoid I2C_SendData(I2C_TypeDef* I2Cx, uint8_t Data);
Nuint8_t I2C_ReceiveData(I2C_TypeDef* I2Cx);
Nvoid I2C_Send7bitAddress(I2C_TypeDef* I2Cx, uint8_t Address, uint8_t I2C_Direction);
Nuint16_t I2C_ReadRegister(I2C_TypeDef* I2Cx, uint8_t I2C_Register);
Nvoid I2C_SoftwareResetCmd(I2C_TypeDef* I2Cx, FunctionalState NewState);
Nvoid I2C_NACKPositionConfig(I2C_TypeDef* I2Cx, uint16_t I2C_NACKPosition);
Nvoid I2C_SMBusAlertConfig(I2C_TypeDef* I2Cx, uint16_t I2C_SMBusAlert);
Nvoid I2C_TransmitPEC(I2C_TypeDef* I2Cx, FunctionalState NewState);
Nvoid I2C_PECPositionConfig(I2C_TypeDef* I2Cx, uint16_t I2C_PECPosition);
Nvoid I2C_CalculatePEC(I2C_TypeDef* I2Cx, FunctionalState NewState);
Nuint8_t I2C_GetPEC(I2C_TypeDef* I2Cx);
Nvoid I2C_ARPCmd(I2C_TypeDef* I2Cx, FunctionalState NewState);
Nvoid I2C_StretchClockCmd(I2C_TypeDef* I2Cx, FunctionalState NewState);
Nvoid I2C_FastModeDutyCycleConfig(I2C_TypeDef* I2Cx, uint16_t I2C_DutyCycle);
N
N/**
N * @brief
N ****************************************************************************************
N *
N *                         I2C State Monitoring Functions
N *                       
N ****************************************************************************************   
N * This I2C driver provides three different ways for I2C state monitoring
N *  depending on the application requirements and constraints:
N *        
N *  
N * 1) Basic state monitoring:
N *    Using I2C_CheckEvent() function:
N *    It compares the status registers (SR1 and SR2) content to a given event
N *    (can be the combination of one or more flags).
N *    It returns SUCCESS if the current status includes the given flags 
N *    and returns ERROR if one or more flags are missing in the current status.
N *    - When to use:
N *      - This function is suitable for most applications as well as for startup 
N *      activity since the events are fully described in the product reference manual 
N *      (RM0008).
N *      - It is also suitable for users who need to define their own events.
N *    - Limitations:
N *      - If an error occurs (ie. error flags are set besides to the monitored flags),
N *        the I2C_CheckEvent() function may return SUCCESS despite the communication
N *        hold or corrupted real state. 
N *        In this case, it is advised to use error interrupts to monitor the error
N *        events and handle them in the interrupt IRQ handler.
N *        
N *        @note 
N *        For error management, it is advised to use the following functions:
N *          - I2C_ITConfig() to configure and enable the error interrupts (I2C_IT_ERR).
N *          - I2Cx_ER_IRQHandler() which is called when the error interrupt occurs.
N *            Where x is the peripheral instance (I2C1, I2C2 ...)
N *          - I2C_GetFlagStatus() or I2C_GetITStatus() to be called into I2Cx_ER_IRQHandler()
N *            in order to determine which error occurred.
N *          - I2C_ClearFlag() or I2C_ClearITPendingBit() and/or I2C_SoftwareResetCmd()
N *            and/or I2C_GenerateStop() in order to clear the error flag and source,
N *            and return to correct communication status.
N *            
N *
N *  2) Advanced state monitoring:
N *     Using the function I2C_GetLastEvent() which returns the image of both status 
N *     registers in a single word (uint32_t) (Status Register 2 value is shifted left 
N *     by 16 bits and concatenated to Status Register 1).
N *     - When to use:
N *       - This function is suitable for the same applications above but it allows to
N *         overcome the limitations of I2C_GetFlagStatus() function (see below).
N *         The returned value could be compared to events already defined in the 
N *         library (stm32f10x_i2c.h) or to custom values defined by user.
N *       - This function is suitable when multiple flags are monitored at the same time.
N *       - At the opposite of I2C_CheckEvent() function, this function allows user to
N *         choose when an event is accepted (when all events flags are set and no 
N *         other flags are set or just when the needed flags are set like 
N *         I2C_CheckEvent() function).
N *     - Limitations:
N *       - User may need to define his own events.
N *       - Same remark concerning the error management is applicable for this 
N *         function if user decides to check only regular communication flags (and 
N *         ignores error flags).
N *     
N *
N *  3) Flag-based state monitoring:
N *     Using the function I2C_GetFlagStatus() which simply returns the status of 
N *     one single flag (ie. I2C_FLAG_RXNE ...). 
N *     - When to use:
N *        - This function could be used for specific applications or in debug phase.
N *        - It is suitable when only one flag checking is needed (most I2C events 
N *          are monitored through multiple flags).
N *     - Limitations: 
N *        - When calling this function, the Status register is accessed. Some flags are
N *          cleared when the status register is accessed. So checking the status
N *          of one Flag, may clear other ones.
N *        - Function may need to be called twice or more in order to monitor one 
N *          single event.
N *            
N */
N
N/**
N * 
N *  1) Basic state monitoring
N *******************************************************************************
N */
NErrorStatus I2C_CheckEvent(I2C_TypeDef* I2Cx, uint32_t I2C_EVENT);
N/**
N * 
N *  2) Advanced state monitoring
N *******************************************************************************
N */
Nuint32_t I2C_GetLastEvent(I2C_TypeDef* I2Cx);
N/**
N * 
N *  3) Flag-based state monitoring
N *******************************************************************************
N */
NFlagStatus I2C_GetFlagStatus(I2C_TypeDef* I2Cx, uint32_t I2C_FLAG);
N/**
N *
N *******************************************************************************
N */
N
Nvoid I2C_ClearFlag(I2C_TypeDef* I2Cx, uint32_t I2C_FLAG);
NITStatus I2C_GetITStatus(I2C_TypeDef* I2Cx, uint32_t I2C_IT);
Nvoid I2C_ClearITPendingBit(I2C_TypeDef* I2Cx, uint32_t I2C_IT);
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif /*__STM32F10x_I2C_H */
N/**
N  * @}
N  */ 
N
N/**
N  * @}
N  */ 
N
N/**
N  * @}
N  */ 
N
N/******************* (C) COPYRIGHT 2011 STMicroelectronics *****END OF FILE****/
L 41 "..\..\User\stm32f10x_conf.h" 2
N#include "stm32f10x_iwdg.h" 
L 1 "..\..\Libraries\FWlib\inc\stm32f10x_iwdg.h" 1
N/**
N  ******************************************************************************
N  * @file    stm32f10x_iwdg.h
N  * @author  MCD Application Team
N  * @version V3.5.0
N  * @date    11-March-2011
N  * @brief   This file contains all the functions prototypes for the IWDG 
N  *          firmware library.
N  ******************************************************************************
N  * @attention
N  *
N  * THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
N  * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE
N  * TIME. AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY
N  * DIRECT, INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING
N  * FROM THE CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE
N  * CODING INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
N  *
N  * <h2><center>&copy; COPYRIGHT 2011 STMicroelectronics</center></h2>
N  ******************************************************************************
N  */
N
N/* Define to prevent recursive inclusion -------------------------------------*/
N#ifndef __STM32F10x_IWDG_H
N#define __STM32F10x_IWDG_H
N
N#ifdef __cplusplus
S extern "C" {
N#endif
N
N/* Includes ------------------------------------------------------------------*/
N#include "stm32f10x.h"
N
N/** @addtogroup STM32F10x_StdPeriph_Driver
N  * @{
N  */
N
N/** @addtogroup IWDG
N  * @{
N  */
N
N/** @defgroup IWDG_Exported_Types
N  * @{
N  */
N
N/**
N  * @}
N  */
N
N/** @defgroup IWDG_Exported_Constants
N  * @{
N  */
N
N/** @defgroup IWDG_WriteAccess
N  * @{
N  */
N
N#define IWDG_WriteAccess_Enable     ((uint16_t)0x5555)
N#define IWDG_WriteAccess_Disable    ((uint16_t)0x0000)
N#define IS_IWDG_WRITE_ACCESS(ACCESS) (((ACCESS) == IWDG_WriteAccess_Enable) || \
N                                      ((ACCESS) == IWDG_WriteAccess_Disable))
X#define IS_IWDG_WRITE_ACCESS(ACCESS) (((ACCESS) == IWDG_WriteAccess_Enable) ||                                       ((ACCESS) == IWDG_WriteAccess_Disable))
N/**
N  * @}
N  */
N
N/** @defgroup IWDG_prescaler 
N  * @{
N  */
N
N#define IWDG_Prescaler_4            ((uint8_t)0x00)
N#define IWDG_Prescaler_8            ((uint8_t)0x01)
N#define IWDG_Prescaler_16           ((uint8_t)0x02)
N#define IWDG_Prescaler_32           ((uint8_t)0x03)
N#define IWDG_Prescaler_64           ((uint8_t)0x04)
N#define IWDG_Prescaler_128          ((uint8_t)0x05)
N#define IWDG_Prescaler_256          ((uint8_t)0x06)
N#define IS_IWDG_PRESCALER(PRESCALER) (((PRESCALER) == IWDG_Prescaler_4)  || \
N                                      ((PRESCALER) == IWDG_Prescaler_8)  || \
N                                      ((PRESCALER) == IWDG_Prescaler_16) || \
N                                      ((PRESCALER) == IWDG_Prescaler_32) || \
N                                      ((PRESCALER) == IWDG_Prescaler_64) || \
N                                      ((PRESCALER) == IWDG_Prescaler_128)|| \
N                                      ((PRESCALER) == IWDG_Prescaler_256))
X#define IS_IWDG_PRESCALER(PRESCALER) (((PRESCALER) == IWDG_Prescaler_4)  ||                                       ((PRESCALER) == IWDG_Prescaler_8)  ||                                       ((PRESCALER) == IWDG_Prescaler_16) ||                                       ((PRESCALER) == IWDG_Prescaler_32) ||                                       ((PRESCALER) == IWDG_Prescaler_64) ||                                       ((PRESCALER) == IWDG_Prescaler_128)||                                       ((PRESCALER) == IWDG_Prescaler_256))
N/**
N  * @}
N  */
N
N/** @defgroup IWDG_Flag 
N  * @{
N  */
N
N#define IWDG_FLAG_PVU               ((uint16_t)0x0001)
N#define IWDG_FLAG_RVU               ((uint16_t)0x0002)
N#define IS_IWDG_FLAG(FLAG) (((FLAG) == IWDG_FLAG_PVU) || ((FLAG) == IWDG_FLAG_RVU))
N#define IS_IWDG_RELOAD(RELOAD) ((RELOAD) <= 0xFFF)
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */
N
N/** @defgroup IWDG_Exported_Macros
N  * @{
N  */
N
N/**
N  * @}
N  */
N
N/** @defgroup IWDG_Exported_Functions
N  * @{
N  */
N
Nvoid IWDG_WriteAccessCmd(uint16_t IWDG_WriteAccess);
Nvoid IWDG_SetPrescaler(uint8_t IWDG_Prescaler);
Nvoid IWDG_SetReload(uint16_t Reload);
Nvoid IWDG_ReloadCounter(void);
Nvoid IWDG_Enable(void);
NFlagStatus IWDG_GetFlagStatus(uint16_t IWDG_FLAG);
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif /* __STM32F10x_IWDG_H */
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */
N
N/******************* (C) COPYRIGHT 2011 STMicroelectronics *****END OF FILE****/
L 42 "..\..\User\stm32f10x_conf.h" 2
N#include "stm32f10x_pwr.h" 
L 1 "..\..\Libraries\FWlib\inc\stm32f10x_pwr.h" 1
N/**
N  ******************************************************************************
N  * @file    stm32f10x_pwr.h
N  * @author  MCD Application Team
N  * @version V3.5.0
N  * @date    11-March-2011
N  * @brief   This file contains all the functions prototypes for the PWR firmware 
N  *          library.
N  ******************************************************************************
N  * @attention
N  *
N  * THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
N  * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE
N  * TIME. AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY
N  * DIRECT, INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING
N  * FROM THE CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE
N  * CODING INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
N  *
N  * <h2><center>&copy; COPYRIGHT 2011 STMicroelectronics</center></h2>
N  ******************************************************************************
N  */
N
N/* Define to prevent recursive inclusion -------------------------------------*/
N#ifndef __STM32F10x_PWR_H
N#define __STM32F10x_PWR_H
N
N#ifdef __cplusplus
S extern "C" {
N#endif
N
N/* Includes ------------------------------------------------------------------*/
N#include "stm32f10x.h"
N
N/** @addtogroup STM32F10x_StdPeriph_Driver
N  * @{
N  */
N
N/** @addtogroup PWR
N  * @{
N  */ 
N
N/** @defgroup PWR_Exported_Types
N  * @{
N  */ 
N
N/**
N  * @}
N  */ 
N
N/** @defgroup PWR_Exported_Constants
N  * @{
N  */ 
N
N/** @defgroup PVD_detection_level 
N  * @{
N  */ 
N
N#define PWR_PVDLevel_2V2          ((uint32_t)0x00000000)
N#define PWR_PVDLevel_2V3          ((uint32_t)0x00000020)
N#define PWR_PVDLevel_2V4          ((uint32_t)0x00000040)
N#define PWR_PVDLevel_2V5          ((uint32_t)0x00000060)
N#define PWR_PVDLevel_2V6          ((uint32_t)0x00000080)
N#define PWR_PVDLevel_2V7          ((uint32_t)0x000000A0)
N#define PWR_PVDLevel_2V8          ((uint32_t)0x000000C0)
N#define PWR_PVDLevel_2V9          ((uint32_t)0x000000E0)
N#define IS_PWR_PVD_LEVEL(LEVEL) (((LEVEL) == PWR_PVDLevel_2V2) || ((LEVEL) == PWR_PVDLevel_2V3)|| \
N                                 ((LEVEL) == PWR_PVDLevel_2V4) || ((LEVEL) == PWR_PVDLevel_2V5)|| \
N                                 ((LEVEL) == PWR_PVDLevel_2V6) || ((LEVEL) == PWR_PVDLevel_2V7)|| \
N                                 ((LEVEL) == PWR_PVDLevel_2V8) || ((LEVEL) == PWR_PVDLevel_2V9))
X#define IS_PWR_PVD_LEVEL(LEVEL) (((LEVEL) == PWR_PVDLevel_2V2) || ((LEVEL) == PWR_PVDLevel_2V3)||                                  ((LEVEL) == PWR_PVDLevel_2V4) || ((LEVEL) == PWR_PVDLevel_2V5)||                                  ((LEVEL) == PWR_PVDLevel_2V6) || ((LEVEL) == PWR_PVDLevel_2V7)||                                  ((LEVEL) == PWR_PVDLevel_2V8) || ((LEVEL) == PWR_PVDLevel_2V9))
N/**
N  * @}
N  */
N
N/** @defgroup Regulator_state_is_STOP_mode 
N  * @{
N  */
N
N#define PWR_Regulator_ON          ((uint32_t)0x00000000)
N#define PWR_Regulator_LowPower    ((uint32_t)0x00000001)
N#define IS_PWR_REGULATOR(REGULATOR) (((REGULATOR) == PWR_Regulator_ON) || \
N                                     ((REGULATOR) == PWR_Regulator_LowPower))
X#define IS_PWR_REGULATOR(REGULATOR) (((REGULATOR) == PWR_Regulator_ON) ||                                      ((REGULATOR) == PWR_Regulator_LowPower))
N/**
N  * @}
N  */
N
N/** @defgroup STOP_mode_entry 
N  * @{
N  */
N
N#define PWR_STOPEntry_WFI         ((uint8_t)0x01)
N#define PWR_STOPEntry_WFE         ((uint8_t)0x02)
N#define IS_PWR_STOP_ENTRY(ENTRY) (((ENTRY) == PWR_STOPEntry_WFI) || ((ENTRY) == PWR_STOPEntry_WFE))
N 
N/**
N  * @}
N  */
N
N/** @defgroup PWR_Flag 
N  * @{
N  */
N
N#define PWR_FLAG_WU               ((uint32_t)0x00000001)
N#define PWR_FLAG_SB               ((uint32_t)0x00000002)
N#define PWR_FLAG_PVDO             ((uint32_t)0x00000004)
N#define IS_PWR_GET_FLAG(FLAG) (((FLAG) == PWR_FLAG_WU) || ((FLAG) == PWR_FLAG_SB) || \
N                               ((FLAG) == PWR_FLAG_PVDO))
X#define IS_PWR_GET_FLAG(FLAG) (((FLAG) == PWR_FLAG_WU) || ((FLAG) == PWR_FLAG_SB) ||                                ((FLAG) == PWR_FLAG_PVDO))
N
N#define IS_PWR_CLEAR_FLAG(FLAG) (((FLAG) == PWR_FLAG_WU) || ((FLAG) == PWR_FLAG_SB))
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */
N
N/** @defgroup PWR_Exported_Macros
N  * @{
N  */
N
N/**
N  * @}
N  */
N
N/** @defgroup PWR_Exported_Functions
N  * @{
N  */
N
Nvoid PWR_DeInit(void);
Nvoid PWR_BackupAccessCmd(FunctionalState NewState);
Nvoid PWR_PVDCmd(FunctionalState NewState);
Nvoid PWR_PVDLevelConfig(uint32_t PWR_PVDLevel);
Nvoid PWR_WakeUpPinCmd(FunctionalState NewState);
Nvoid PWR_EnterSTOPMode(uint32_t PWR_Regulator, uint8_t PWR_STOPEntry);
Nvoid PWR_EnterSTANDBYMode(void);
NFlagStatus PWR_GetFlagStatus(uint32_t PWR_FLAG);
Nvoid PWR_ClearFlag(uint32_t PWR_FLAG);
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif /* __STM32F10x_PWR_H */
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */
N
N/******************* (C) COPYRIGHT 2011 STMicroelectronics *****END OF FILE****/
L 43 "..\..\User\stm32f10x_conf.h" 2
N#include "stm32f10x_rcc.h" 
L 1 "..\..\Libraries\FWlib\inc\stm32f10x_rcc.h" 1
N/**
N  ******************************************************************************
N  * @file    stm32f10x_rcc.h
N  * @author  MCD Application Team
N  * @version V3.5.0
N  * @date    11-March-2011
N  * @brief   This file contains all the functions prototypes for the RCC firmware 
N  *          library.
N  ******************************************************************************
N  * @attention
N  *
N  * THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
N  * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE
N  * TIME. AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY
N  * DIRECT, INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING
N  * FROM THE CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE
N  * CODING INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
N  *
N  * <h2><center>&copy; COPYRIGHT 2011 STMicroelectronics</center></h2>
N  ******************************************************************************
N  */
N
N/* Define to prevent recursive inclusion -------------------------------------*/
N#ifndef __STM32F10x_RCC_H
N#define __STM32F10x_RCC_H
N
N#ifdef __cplusplus
S extern "C" {
N#endif
N
N/* Includes ------------------------------------------------------------------*/
N#include "stm32f10x.h"
N
N/** @addtogroup STM32F10x_StdPeriph_Driver
N  * @{
N  */
N
N/** @addtogroup RCC
N  * @{
N  */
N
N/** @defgroup RCC_Exported_Types
N  * @{
N  */
N
Ntypedef struct
N{
N  uint32_t SYSCLK_Frequency;  /*!< returns SYSCLK clock frequency expressed in Hz */
N  uint32_t HCLK_Frequency;    /*!< returns HCLK clock frequency expressed in Hz */
N  uint32_t PCLK1_Frequency;   /*!< returns PCLK1 clock frequency expressed in Hz */
N  uint32_t PCLK2_Frequency;   /*!< returns PCLK2 clock frequency expressed in Hz */
N  uint32_t ADCCLK_Frequency;  /*!< returns ADCCLK clock frequency expressed in Hz */
N}RCC_ClocksTypeDef;
N
N/**
N  * @}
N  */
N
N/** @defgroup RCC_Exported_Constants
N  * @{
N  */
N
N/** @defgroup HSE_configuration 
N  * @{
N  */
N
N#define RCC_HSE_OFF                      ((uint32_t)0x00000000)
N#define RCC_HSE_ON                       ((uint32_t)0x00010000)
N#define RCC_HSE_Bypass                   ((uint32_t)0x00040000)
N#define IS_RCC_HSE(HSE) (((HSE) == RCC_HSE_OFF) || ((HSE) == RCC_HSE_ON) || \
N                         ((HSE) == RCC_HSE_Bypass))
X#define IS_RCC_HSE(HSE) (((HSE) == RCC_HSE_OFF) || ((HSE) == RCC_HSE_ON) ||                          ((HSE) == RCC_HSE_Bypass))
N
N/**
N  * @}
N  */ 
N
N/** @defgroup PLL_entry_clock_source 
N  * @{
N  */
N
N#define RCC_PLLSource_HSI_Div2           ((uint32_t)0x00000000)
N
N#if !defined (STM32F10X_LD_VL) && !defined (STM32F10X_MD_VL) && !defined (STM32F10X_HD_VL) && !defined (STM32F10X_CL)
X#if !0L && !0L && !0L && !0L
N #define RCC_PLLSource_HSE_Div1           ((uint32_t)0x00010000)
N #define RCC_PLLSource_HSE_Div2           ((uint32_t)0x00030000)
N #define IS_RCC_PLL_SOURCE(SOURCE) (((SOURCE) == RCC_PLLSource_HSI_Div2) || \
N                                   ((SOURCE) == RCC_PLLSource_HSE_Div1) || \
N                                   ((SOURCE) == RCC_PLLSource_HSE_Div2))
X #define IS_RCC_PLL_SOURCE(SOURCE) (((SOURCE) == RCC_PLLSource_HSI_Div2) ||                                    ((SOURCE) == RCC_PLLSource_HSE_Div1) ||                                    ((SOURCE) == RCC_PLLSource_HSE_Div2))
N#else
S #define RCC_PLLSource_PREDIV1            ((uint32_t)0x00010000)
S #define IS_RCC_PLL_SOURCE(SOURCE) (((SOURCE) == RCC_PLLSource_HSI_Div2) || \
S                                   ((SOURCE) == RCC_PLLSource_PREDIV1))
X #define IS_RCC_PLL_SOURCE(SOURCE) (((SOURCE) == RCC_PLLSource_HSI_Div2) ||                                    ((SOURCE) == RCC_PLLSource_PREDIV1))
N#endif /* STM32F10X_CL */ 
N
N/**
N  * @}
N  */ 
N
N/** @defgroup PLL_multiplication_factor 
N  * @{
N  */
N#ifndef STM32F10X_CL
N #define RCC_PLLMul_2                    ((uint32_t)0x00000000)
N #define RCC_PLLMul_3                    ((uint32_t)0x00040000)
N #define RCC_PLLMul_4                    ((uint32_t)0x00080000)
N #define RCC_PLLMul_5                    ((uint32_t)0x000C0000)
N #define RCC_PLLMul_6                    ((uint32_t)0x00100000)
N #define RCC_PLLMul_7                    ((uint32_t)0x00140000)
N #define RCC_PLLMul_8                    ((uint32_t)0x00180000)
N #define RCC_PLLMul_9                    ((uint32_t)0x001C0000)
N #define RCC_PLLMul_10                   ((uint32_t)0x00200000)
N #define RCC_PLLMul_11                   ((uint32_t)0x00240000)
N #define RCC_PLLMul_12                   ((uint32_t)0x00280000)
N #define RCC_PLLMul_13                   ((uint32_t)0x002C0000)
N #define RCC_PLLMul_14                   ((uint32_t)0x00300000)
N #define RCC_PLLMul_15                   ((uint32_t)0x00340000)
N #define RCC_PLLMul_16                   ((uint32_t)0x00380000)
N #define IS_RCC_PLL_MUL(MUL) (((MUL) == RCC_PLLMul_2) || ((MUL) == RCC_PLLMul_3)   || \
N                              ((MUL) == RCC_PLLMul_4) || ((MUL) == RCC_PLLMul_5)   || \
N                              ((MUL) == RCC_PLLMul_6) || ((MUL) == RCC_PLLMul_7)   || \
N                              ((MUL) == RCC_PLLMul_8) || ((MUL) == RCC_PLLMul_9)   || \
N                              ((MUL) == RCC_PLLMul_10) || ((MUL) == RCC_PLLMul_11) || \
N                              ((MUL) == RCC_PLLMul_12) || ((MUL) == RCC_PLLMul_13) || \
N                              ((MUL) == RCC_PLLMul_14) || ((MUL) == RCC_PLLMul_15) || \
N                              ((MUL) == RCC_PLLMul_16))
X #define IS_RCC_PLL_MUL(MUL) (((MUL) == RCC_PLLMul_2) || ((MUL) == RCC_PLLMul_3)   ||                               ((MUL) == RCC_PLLMul_4) || ((MUL) == RCC_PLLMul_5)   ||                               ((MUL) == RCC_PLLMul_6) || ((MUL) == RCC_PLLMul_7)   ||                               ((MUL) == RCC_PLLMul_8) || ((MUL) == RCC_PLLMul_9)   ||                               ((MUL) == RCC_PLLMul_10) || ((MUL) == RCC_PLLMul_11) ||                               ((MUL) == RCC_PLLMul_12) || ((MUL) == RCC_PLLMul_13) ||                               ((MUL) == RCC_PLLMul_14) || ((MUL) == RCC_PLLMul_15) ||                               ((MUL) == RCC_PLLMul_16))
N
N#else
S #define RCC_PLLMul_4                    ((uint32_t)0x00080000)
S #define RCC_PLLMul_5                    ((uint32_t)0x000C0000)
S #define RCC_PLLMul_6                    ((uint32_t)0x00100000)
S #define RCC_PLLMul_7                    ((uint32_t)0x00140000)
S #define RCC_PLLMul_8                    ((uint32_t)0x00180000)
S #define RCC_PLLMul_9                    ((uint32_t)0x001C0000)
S #define RCC_PLLMul_6_5                  ((uint32_t)0x00340000)
S
S #define IS_RCC_PLL_MUL(MUL) (((MUL) == RCC_PLLMul_4) || ((MUL) == RCC_PLLMul_5) || \
S                              ((MUL) == RCC_PLLMul_6) || ((MUL) == RCC_PLLMul_7) || \
S                              ((MUL) == RCC_PLLMul_8) || ((MUL) == RCC_PLLMul_9) || \
S                              ((MUL) == RCC_PLLMul_6_5))
X #define IS_RCC_PLL_MUL(MUL) (((MUL) == RCC_PLLMul_4) || ((MUL) == RCC_PLLMul_5) ||                               ((MUL) == RCC_PLLMul_6) || ((MUL) == RCC_PLLMul_7) ||                               ((MUL) == RCC_PLLMul_8) || ((MUL) == RCC_PLLMul_9) ||                               ((MUL) == RCC_PLLMul_6_5))
N#endif /* STM32F10X_CL */                              
N/**
N  * @}
N  */
N
N/** @defgroup PREDIV1_division_factor
N  * @{
N  */
N#if defined (STM32F10X_LD_VL) || defined (STM32F10X_MD_VL) || defined (STM32F10X_HD_VL) || defined (STM32F10X_CL)
X#if 0L || 0L || 0L || 0L
S #define  RCC_PREDIV1_Div1               ((uint32_t)0x00000000)
S #define  RCC_PREDIV1_Div2               ((uint32_t)0x00000001)
S #define  RCC_PREDIV1_Div3               ((uint32_t)0x00000002)
S #define  RCC_PREDIV1_Div4               ((uint32_t)0x00000003)
S #define  RCC_PREDIV1_Div5               ((uint32_t)0x00000004)
S #define  RCC_PREDIV1_Div6               ((uint32_t)0x00000005)
S #define  RCC_PREDIV1_Div7               ((uint32_t)0x00000006)
S #define  RCC_PREDIV1_Div8               ((uint32_t)0x00000007)
S #define  RCC_PREDIV1_Div9               ((uint32_t)0x00000008)
S #define  RCC_PREDIV1_Div10              ((uint32_t)0x00000009)
S #define  RCC_PREDIV1_Div11              ((uint32_t)0x0000000A)
S #define  RCC_PREDIV1_Div12              ((uint32_t)0x0000000B)
S #define  RCC_PREDIV1_Div13              ((uint32_t)0x0000000C)
S #define  RCC_PREDIV1_Div14              ((uint32_t)0x0000000D)
S #define  RCC_PREDIV1_Div15              ((uint32_t)0x0000000E)
S #define  RCC_PREDIV1_Div16              ((uint32_t)0x0000000F)
S
S #define IS_RCC_PREDIV1(PREDIV1) (((PREDIV1) == RCC_PREDIV1_Div1) || ((PREDIV1) == RCC_PREDIV1_Div2) || \
S                                  ((PREDIV1) == RCC_PREDIV1_Div3) || ((PREDIV1) == RCC_PREDIV1_Div4) || \
S                                  ((PREDIV1) == RCC_PREDIV1_Div5) || ((PREDIV1) == RCC_PREDIV1_Div6) || \
S                                  ((PREDIV1) == RCC_PREDIV1_Div7) || ((PREDIV1) == RCC_PREDIV1_Div8) || \
S                                  ((PREDIV1) == RCC_PREDIV1_Div9) || ((PREDIV1) == RCC_PREDIV1_Div10) || \
S                                  ((PREDIV1) == RCC_PREDIV1_Div11) || ((PREDIV1) == RCC_PREDIV1_Div12) || \
S                                  ((PREDIV1) == RCC_PREDIV1_Div13) || ((PREDIV1) == RCC_PREDIV1_Div14) || \
S                                  ((PREDIV1) == RCC_PREDIV1_Div15) || ((PREDIV1) == RCC_PREDIV1_Div16))
X #define IS_RCC_PREDIV1(PREDIV1) (((PREDIV1) == RCC_PREDIV1_Div1) || ((PREDIV1) == RCC_PREDIV1_Div2) ||                                   ((PREDIV1) == RCC_PREDIV1_Div3) || ((PREDIV1) == RCC_PREDIV1_Div4) ||                                   ((PREDIV1) == RCC_PREDIV1_Div5) || ((PREDIV1) == RCC_PREDIV1_Div6) ||                                   ((PREDIV1) == RCC_PREDIV1_Div7) || ((PREDIV1) == RCC_PREDIV1_Div8) ||                                   ((PREDIV1) == RCC_PREDIV1_Div9) || ((PREDIV1) == RCC_PREDIV1_Div10) ||                                   ((PREDIV1) == RCC_PREDIV1_Div11) || ((PREDIV1) == RCC_PREDIV1_Div12) ||                                   ((PREDIV1) == RCC_PREDIV1_Div13) || ((PREDIV1) == RCC_PREDIV1_Div14) ||                                   ((PREDIV1) == RCC_PREDIV1_Div15) || ((PREDIV1) == RCC_PREDIV1_Div16))
N#endif
N/**
N  * @}
N  */
N
N
N/** @defgroup PREDIV1_clock_source
N  * @{
N  */
N#ifdef STM32F10X_CL
S/* PREDIV1 clock source (for STM32 connectivity line devices) */
S #define  RCC_PREDIV1_Source_HSE         ((uint32_t)0x00000000) 
S #define  RCC_PREDIV1_Source_PLL2        ((uint32_t)0x00010000) 
S
S #define IS_RCC_PREDIV1_SOURCE(SOURCE) (((SOURCE) == RCC_PREDIV1_Source_HSE) || \
S                                        ((SOURCE) == RCC_PREDIV1_Source_PLL2)) 
X #define IS_RCC_PREDIV1_SOURCE(SOURCE) (((SOURCE) == RCC_PREDIV1_Source_HSE) ||                                         ((SOURCE) == RCC_PREDIV1_Source_PLL2)) 
S#elif defined (STM32F10X_LD_VL) || defined (STM32F10X_MD_VL) || defined (STM32F10X_HD_VL)
X#elif 0L || 0L || 0L
S/* PREDIV1 clock source (for STM32 Value line devices) */
S #define  RCC_PREDIV1_Source_HSE         ((uint32_t)0x00000000) 
S
S #define IS_RCC_PREDIV1_SOURCE(SOURCE) (((SOURCE) == RCC_PREDIV1_Source_HSE)) 
N#endif
N/**
N  * @}
N  */
N
N#ifdef STM32F10X_CL
S/** @defgroup PREDIV2_division_factor
S  * @{
S  */
S  
S #define  RCC_PREDIV2_Div1               ((uint32_t)0x00000000)
S #define  RCC_PREDIV2_Div2               ((uint32_t)0x00000010)
S #define  RCC_PREDIV2_Div3               ((uint32_t)0x00000020)
S #define  RCC_PREDIV2_Div4               ((uint32_t)0x00000030)
S #define  RCC_PREDIV2_Div5               ((uint32_t)0x00000040)
S #define  RCC_PREDIV2_Div6               ((uint32_t)0x00000050)
S #define  RCC_PREDIV2_Div7               ((uint32_t)0x00000060)
S #define  RCC_PREDIV2_Div8               ((uint32_t)0x00000070)
S #define  RCC_PREDIV2_Div9               ((uint32_t)0x00000080)
S #define  RCC_PREDIV2_Div10              ((uint32_t)0x00000090)
S #define  RCC_PREDIV2_Div11              ((uint32_t)0x000000A0)
S #define  RCC_PREDIV2_Div12              ((uint32_t)0x000000B0)
S #define  RCC_PREDIV2_Div13              ((uint32_t)0x000000C0)
S #define  RCC_PREDIV2_Div14              ((uint32_t)0x000000D0)
S #define  RCC_PREDIV2_Div15              ((uint32_t)0x000000E0)
S #define  RCC_PREDIV2_Div16              ((uint32_t)0x000000F0)
S
S #define IS_RCC_PREDIV2(PREDIV2) (((PREDIV2) == RCC_PREDIV2_Div1) || ((PREDIV2) == RCC_PREDIV2_Div2) || \
S                                  ((PREDIV2) == RCC_PREDIV2_Div3) || ((PREDIV2) == RCC_PREDIV2_Div4) || \
S                                  ((PREDIV2) == RCC_PREDIV2_Div5) || ((PREDIV2) == RCC_PREDIV2_Div6) || \
S                                  ((PREDIV2) == RCC_PREDIV2_Div7) || ((PREDIV2) == RCC_PREDIV2_Div8) || \
S                                  ((PREDIV2) == RCC_PREDIV2_Div9) || ((PREDIV2) == RCC_PREDIV2_Div10) || \
S                                  ((PREDIV2) == RCC_PREDIV2_Div11) || ((PREDIV2) == RCC_PREDIV2_Div12) || \
S                                  ((PREDIV2) == RCC_PREDIV2_Div13) || ((PREDIV2) == RCC_PREDIV2_Div14) || \
S                                  ((PREDIV2) == RCC_PREDIV2_Div15) || ((PREDIV2) == RCC_PREDIV2_Div16))
X #define IS_RCC_PREDIV2(PREDIV2) (((PREDIV2) == RCC_PREDIV2_Div1) || ((PREDIV2) == RCC_PREDIV2_Div2) ||                                   ((PREDIV2) == RCC_PREDIV2_Div3) || ((PREDIV2) == RCC_PREDIV2_Div4) ||                                   ((PREDIV2) == RCC_PREDIV2_Div5) || ((PREDIV2) == RCC_PREDIV2_Div6) ||                                   ((PREDIV2) == RCC_PREDIV2_Div7) || ((PREDIV2) == RCC_PREDIV2_Div8) ||                                   ((PREDIV2) == RCC_PREDIV2_Div9) || ((PREDIV2) == RCC_PREDIV2_Div10) ||                                   ((PREDIV2) == RCC_PREDIV2_Div11) || ((PREDIV2) == RCC_PREDIV2_Div12) ||                                   ((PREDIV2) == RCC_PREDIV2_Div13) || ((PREDIV2) == RCC_PREDIV2_Div14) ||                                   ((PREDIV2) == RCC_PREDIV2_Div15) || ((PREDIV2) == RCC_PREDIV2_Div16))
S/**
S  * @}
S  */
S
S
S/** @defgroup PLL2_multiplication_factor
S  * @{
S  */
S  
S #define  RCC_PLL2Mul_8                  ((uint32_t)0x00000600)
S #define  RCC_PLL2Mul_9                  ((uint32_t)0x00000700)
S #define  RCC_PLL2Mul_10                 ((uint32_t)0x00000800)
S #define  RCC_PLL2Mul_11                 ((uint32_t)0x00000900)
S #define  RCC_PLL2Mul_12                 ((uint32_t)0x00000A00)
S #define  RCC_PLL2Mul_13                 ((uint32_t)0x00000B00)
S #define  RCC_PLL2Mul_14                 ((uint32_t)0x00000C00)
S #define  RCC_PLL2Mul_16                 ((uint32_t)0x00000E00)
S #define  RCC_PLL2Mul_20                 ((uint32_t)0x00000F00)
S
S #define IS_RCC_PLL2_MUL(MUL) (((MUL) == RCC_PLL2Mul_8) || ((MUL) == RCC_PLL2Mul_9)  || \
S                               ((MUL) == RCC_PLL2Mul_10) || ((MUL) == RCC_PLL2Mul_11) || \
S                               ((MUL) == RCC_PLL2Mul_12) || ((MUL) == RCC_PLL2Mul_13) || \
S                               ((MUL) == RCC_PLL2Mul_14) || ((MUL) == RCC_PLL2Mul_16) || \
S                               ((MUL) == RCC_PLL2Mul_20))
X #define IS_RCC_PLL2_MUL(MUL) (((MUL) == RCC_PLL2Mul_8) || ((MUL) == RCC_PLL2Mul_9)  ||                                ((MUL) == RCC_PLL2Mul_10) || ((MUL) == RCC_PLL2Mul_11) ||                                ((MUL) == RCC_PLL2Mul_12) || ((MUL) == RCC_PLL2Mul_13) ||                                ((MUL) == RCC_PLL2Mul_14) || ((MUL) == RCC_PLL2Mul_16) ||                                ((MUL) == RCC_PLL2Mul_20))
S/**
S  * @}
S  */
S
S
S/** @defgroup PLL3_multiplication_factor
S  * @{
S  */
S
S #define  RCC_PLL3Mul_8                  ((uint32_t)0x00006000)
S #define  RCC_PLL3Mul_9                  ((uint32_t)0x00007000)
S #define  RCC_PLL3Mul_10                 ((uint32_t)0x00008000)
S #define  RCC_PLL3Mul_11                 ((uint32_t)0x00009000)
S #define  RCC_PLL3Mul_12                 ((uint32_t)0x0000A000)
S #define  RCC_PLL3Mul_13                 ((uint32_t)0x0000B000)
S #define  RCC_PLL3Mul_14                 ((uint32_t)0x0000C000)
S #define  RCC_PLL3Mul_16                 ((uint32_t)0x0000E000)
S #define  RCC_PLL3Mul_20                 ((uint32_t)0x0000F000)
S
S #define IS_RCC_PLL3_MUL(MUL) (((MUL) == RCC_PLL3Mul_8) || ((MUL) == RCC_PLL3Mul_9)  || \
S                               ((MUL) == RCC_PLL3Mul_10) || ((MUL) == RCC_PLL3Mul_11) || \
S                               ((MUL) == RCC_PLL3Mul_12) || ((MUL) == RCC_PLL3Mul_13) || \
S                               ((MUL) == RCC_PLL3Mul_14) || ((MUL) == RCC_PLL3Mul_16) || \
S                               ((MUL) == RCC_PLL3Mul_20))
X #define IS_RCC_PLL3_MUL(MUL) (((MUL) == RCC_PLL3Mul_8) || ((MUL) == RCC_PLL3Mul_9)  ||                                ((MUL) == RCC_PLL3Mul_10) || ((MUL) == RCC_PLL3Mul_11) ||                                ((MUL) == RCC_PLL3Mul_12) || ((MUL) == RCC_PLL3Mul_13) ||                                ((MUL) == RCC_PLL3Mul_14) || ((MUL) == RCC_PLL3Mul_16) ||                                ((MUL) == RCC_PLL3Mul_20))
S/**
S  * @}
S  */
S
N#endif /* STM32F10X_CL */
N
N
N/** @defgroup System_clock_source 
N  * @{
N  */
N
N#define RCC_SYSCLKSource_HSI             ((uint32_t)0x00000000)
N#define RCC_SYSCLKSource_HSE             ((uint32_t)0x00000001)
N#define RCC_SYSCLKSource_PLLCLK          ((uint32_t)0x00000002)
N#define IS_RCC_SYSCLK_SOURCE(SOURCE) (((SOURCE) == RCC_SYSCLKSource_HSI) || \
N                                      ((SOURCE) == RCC_SYSCLKSource_HSE) || \
N                                      ((SOURCE) == RCC_SYSCLKSource_PLLCLK))
X#define IS_RCC_SYSCLK_SOURCE(SOURCE) (((SOURCE) == RCC_SYSCLKSource_HSI) ||                                       ((SOURCE) == RCC_SYSCLKSource_HSE) ||                                       ((SOURCE) == RCC_SYSCLKSource_PLLCLK))
N/**
N  * @}
N  */
N
N/** @defgroup AHB_clock_source 
N  * @{
N  */
N
N#define RCC_SYSCLK_Div1                  ((uint32_t)0x00000000)
N#define RCC_SYSCLK_Div2                  ((uint32_t)0x00000080)
N#define RCC_SYSCLK_Div4                  ((uint32_t)0x00000090)
N#define RCC_SYSCLK_Div8                  ((uint32_t)0x000000A0)
N#define RCC_SYSCLK_Div16                 ((uint32_t)0x000000B0)
N#define RCC_SYSCLK_Div64                 ((uint32_t)0x000000C0)
N#define RCC_SYSCLK_Div128                ((uint32_t)0x000000D0)
N#define RCC_SYSCLK_Div256                ((uint32_t)0x000000E0)
N#define RCC_SYSCLK_Div512                ((uint32_t)0x000000F0)
N#define IS_RCC_HCLK(HCLK) (((HCLK) == RCC_SYSCLK_Div1) || ((HCLK) == RCC_SYSCLK_Div2) || \
N                           ((HCLK) == RCC_SYSCLK_Div4) || ((HCLK) == RCC_SYSCLK_Div8) || \
N                           ((HCLK) == RCC_SYSCLK_Div16) || ((HCLK) == RCC_SYSCLK_Div64) || \
N                           ((HCLK) == RCC_SYSCLK_Div128) || ((HCLK) == RCC_SYSCLK_Div256) || \
N                           ((HCLK) == RCC_SYSCLK_Div512))
X#define IS_RCC_HCLK(HCLK) (((HCLK) == RCC_SYSCLK_Div1) || ((HCLK) == RCC_SYSCLK_Div2) ||                            ((HCLK) == RCC_SYSCLK_Div4) || ((HCLK) == RCC_SYSCLK_Div8) ||                            ((HCLK) == RCC_SYSCLK_Div16) || ((HCLK) == RCC_SYSCLK_Div64) ||                            ((HCLK) == RCC_SYSCLK_Div128) || ((HCLK) == RCC_SYSCLK_Div256) ||                            ((HCLK) == RCC_SYSCLK_Div512))
N/**
N  * @}
N  */ 
N
N/** @defgroup APB1_APB2_clock_source 
N  * @{
N  */
N
N#define RCC_HCLK_Div1                    ((uint32_t)0x00000000)
N#define RCC_HCLK_Div2                    ((uint32_t)0x00000400)
N#define RCC_HCLK_Div4                    ((uint32_t)0x00000500)
N#define RCC_HCLK_Div8                    ((uint32_t)0x00000600)
N#define RCC_HCLK_Div16                   ((uint32_t)0x00000700)
N#define IS_RCC_PCLK(PCLK) (((PCLK) == RCC_HCLK_Div1) || ((PCLK) == RCC_HCLK_Div2) || \
N                           ((PCLK) == RCC_HCLK_Div4) || ((PCLK) == RCC_HCLK_Div8) || \
N                           ((PCLK) == RCC_HCLK_Div16))
X#define IS_RCC_PCLK(PCLK) (((PCLK) == RCC_HCLK_Div1) || ((PCLK) == RCC_HCLK_Div2) ||                            ((PCLK) == RCC_HCLK_Div4) || ((PCLK) == RCC_HCLK_Div8) ||                            ((PCLK) == RCC_HCLK_Div16))
N/**
N  * @}
N  */
N
N/** @defgroup RCC_Interrupt_source 
N  * @{
N  */
N
N#define RCC_IT_LSIRDY                    ((uint8_t)0x01)
N#define RCC_IT_LSERDY                    ((uint8_t)0x02)
N#define RCC_IT_HSIRDY                    ((uint8_t)0x04)
N#define RCC_IT_HSERDY                    ((uint8_t)0x08)
N#define RCC_IT_PLLRDY                    ((uint8_t)0x10)
N#define RCC_IT_CSS                       ((uint8_t)0x80)
N
N#ifndef STM32F10X_CL
N #define IS_RCC_IT(IT) ((((IT) & (uint8_t)0xE0) == 0x00) && ((IT) != 0x00))
N #define IS_RCC_GET_IT(IT) (((IT) == RCC_IT_LSIRDY) || ((IT) == RCC_IT_LSERDY) || \
N                            ((IT) == RCC_IT_HSIRDY) || ((IT) == RCC_IT_HSERDY) || \
N                            ((IT) == RCC_IT_PLLRDY) || ((IT) == RCC_IT_CSS))
X #define IS_RCC_GET_IT(IT) (((IT) == RCC_IT_LSIRDY) || ((IT) == RCC_IT_LSERDY) ||                             ((IT) == RCC_IT_HSIRDY) || ((IT) == RCC_IT_HSERDY) ||                             ((IT) == RCC_IT_PLLRDY) || ((IT) == RCC_IT_CSS))
N #define IS_RCC_CLEAR_IT(IT) ((((IT) & (uint8_t)0x60) == 0x00) && ((IT) != 0x00))
N#else
S #define RCC_IT_PLL2RDY                  ((uint8_t)0x20)
S #define RCC_IT_PLL3RDY                  ((uint8_t)0x40)
S #define IS_RCC_IT(IT) ((((IT) & (uint8_t)0x80) == 0x00) && ((IT) != 0x00))
S #define IS_RCC_GET_IT(IT) (((IT) == RCC_IT_LSIRDY) || ((IT) == RCC_IT_LSERDY) || \
S                            ((IT) == RCC_IT_HSIRDY) || ((IT) == RCC_IT_HSERDY) || \
S                            ((IT) == RCC_IT_PLLRDY) || ((IT) == RCC_IT_CSS) || \
S                            ((IT) == RCC_IT_PLL2RDY) || ((IT) == RCC_IT_PLL3RDY))
X #define IS_RCC_GET_IT(IT) (((IT) == RCC_IT_LSIRDY) || ((IT) == RCC_IT_LSERDY) ||                             ((IT) == RCC_IT_HSIRDY) || ((IT) == RCC_IT_HSERDY) ||                             ((IT) == RCC_IT_PLLRDY) || ((IT) == RCC_IT_CSS) ||                             ((IT) == RCC_IT_PLL2RDY) || ((IT) == RCC_IT_PLL3RDY))
S #define IS_RCC_CLEAR_IT(IT) ((IT) != 0x00)
N#endif /* STM32F10X_CL */ 
N
N
N/**
N  * @}
N  */
N
N#ifndef STM32F10X_CL
N/** @defgroup USB_Device_clock_source 
N  * @{
N  */
N
N #define RCC_USBCLKSource_PLLCLK_1Div5   ((uint8_t)0x00)
N #define RCC_USBCLKSource_PLLCLK_Div1    ((uint8_t)0x01)
N
N #define IS_RCC_USBCLK_SOURCE(SOURCE) (((SOURCE) == RCC_USBCLKSource_PLLCLK_1Div5) || \
N                                      ((SOURCE) == RCC_USBCLKSource_PLLCLK_Div1))
X #define IS_RCC_USBCLK_SOURCE(SOURCE) (((SOURCE) == RCC_USBCLKSource_PLLCLK_1Div5) ||                                       ((SOURCE) == RCC_USBCLKSource_PLLCLK_Div1))
N/**
N  * @}
N  */
N#else
S/** @defgroup USB_OTG_FS_clock_source 
S  * @{
S  */
S #define RCC_OTGFSCLKSource_PLLVCO_Div3    ((uint8_t)0x00)
S #define RCC_OTGFSCLKSource_PLLVCO_Div2    ((uint8_t)0x01)
S
S #define IS_RCC_OTGFSCLK_SOURCE(SOURCE) (((SOURCE) == RCC_OTGFSCLKSource_PLLVCO_Div3) || \
S                                         ((SOURCE) == RCC_OTGFSCLKSource_PLLVCO_Div2))
X #define IS_RCC_OTGFSCLK_SOURCE(SOURCE) (((SOURCE) == RCC_OTGFSCLKSource_PLLVCO_Div3) ||                                          ((SOURCE) == RCC_OTGFSCLKSource_PLLVCO_Div2))
S/**
S  * @}
S  */
N#endif /* STM32F10X_CL */ 
N
N
N#ifdef STM32F10X_CL
S/** @defgroup I2S2_clock_source 
S  * @{
S  */
S #define RCC_I2S2CLKSource_SYSCLK        ((uint8_t)0x00)
S #define RCC_I2S2CLKSource_PLL3_VCO      ((uint8_t)0x01)
S
S #define IS_RCC_I2S2CLK_SOURCE(SOURCE) (((SOURCE) == RCC_I2S2CLKSource_SYSCLK) || \
S                                        ((SOURCE) == RCC_I2S2CLKSource_PLL3_VCO))
X #define IS_RCC_I2S2CLK_SOURCE(SOURCE) (((SOURCE) == RCC_I2S2CLKSource_SYSCLK) ||                                         ((SOURCE) == RCC_I2S2CLKSource_PLL3_VCO))
S/**
S  * @}
S  */
S
S/** @defgroup I2S3_clock_source 
S  * @{
S  */
S #define RCC_I2S3CLKSource_SYSCLK        ((uint8_t)0x00)
S #define RCC_I2S3CLKSource_PLL3_VCO      ((uint8_t)0x01)
S
S #define IS_RCC_I2S3CLK_SOURCE(SOURCE) (((SOURCE) == RCC_I2S3CLKSource_SYSCLK) || \
S                                        ((SOURCE) == RCC_I2S3CLKSource_PLL3_VCO))    
X #define IS_RCC_I2S3CLK_SOURCE(SOURCE) (((SOURCE) == RCC_I2S3CLKSource_SYSCLK) ||                                         ((SOURCE) == RCC_I2S3CLKSource_PLL3_VCO))    
S/**
S  * @}
S  */
N#endif /* STM32F10X_CL */  
N  
N
N/** @defgroup ADC_clock_source 
N  * @{
N  */
N
N#define RCC_PCLK2_Div2                   ((uint32_t)0x00000000)
N#define RCC_PCLK2_Div4                   ((uint32_t)0x00004000)
N#define RCC_PCLK2_Div6                   ((uint32_t)0x00008000)
N#define RCC_PCLK2_Div8                   ((uint32_t)0x0000C000)
N#define IS_RCC_ADCCLK(ADCCLK) (((ADCCLK) == RCC_PCLK2_Div2) || ((ADCCLK) == RCC_PCLK2_Div4) || \
N                               ((ADCCLK) == RCC_PCLK2_Div6) || ((ADCCLK) == RCC_PCLK2_Div8))
X#define IS_RCC_ADCCLK(ADCCLK) (((ADCCLK) == RCC_PCLK2_Div2) || ((ADCCLK) == RCC_PCLK2_Div4) ||                                ((ADCCLK) == RCC_PCLK2_Div6) || ((ADCCLK) == RCC_PCLK2_Div8))
N/**
N  * @}
N  */
N
N/** @defgroup LSE_configuration 
N  * @{
N  */
N
N#define RCC_LSE_OFF                      ((uint8_t)0x00)
N#define RCC_LSE_ON                       ((uint8_t)0x01)
N#define RCC_LSE_Bypass                   ((uint8_t)0x04)
N#define IS_RCC_LSE(LSE) (((LSE) == RCC_LSE_OFF) || ((LSE) == RCC_LSE_ON) || \
N                         ((LSE) == RCC_LSE_Bypass))
X#define IS_RCC_LSE(LSE) (((LSE) == RCC_LSE_OFF) || ((LSE) == RCC_LSE_ON) ||                          ((LSE) == RCC_LSE_Bypass))
N/**
N  * @}
N  */
N
N/** @defgroup RTC_clock_source 
N  * @{
N  */
N
N#define RCC_RTCCLKSource_LSE             ((uint32_t)0x00000100)
N#define RCC_RTCCLKSource_LSI             ((uint32_t)0x00000200)
N#define RCC_RTCCLKSource_HSE_Div128      ((uint32_t)0x00000300)
N#define IS_RCC_RTCCLK_SOURCE(SOURCE) (((SOURCE) == RCC_RTCCLKSource_LSE) || \
N                                      ((SOURCE) == RCC_RTCCLKSource_LSI) || \
N                                      ((SOURCE) == RCC_RTCCLKSource_HSE_Div128))
X#define IS_RCC_RTCCLK_SOURCE(SOURCE) (((SOURCE) == RCC_RTCCLKSource_LSE) ||                                       ((SOURCE) == RCC_RTCCLKSource_LSI) ||                                       ((SOURCE) == RCC_RTCCLKSource_HSE_Div128))
N/**
N  * @}
N  */
N
N/** @defgroup AHB_peripheral 
N  * @{
N  */
N
N#define RCC_AHBPeriph_DMA1               ((uint32_t)0x00000001)
N#define RCC_AHBPeriph_DMA2               ((uint32_t)0x00000002)
N#define RCC_AHBPeriph_SRAM               ((uint32_t)0x00000004)
N#define RCC_AHBPeriph_FLITF              ((uint32_t)0x00000010)
N#define RCC_AHBPeriph_CRC                ((uint32_t)0x00000040)
N
N#ifndef STM32F10X_CL
N #define RCC_AHBPeriph_FSMC              ((uint32_t)0x00000100)
N #define RCC_AHBPeriph_SDIO              ((uint32_t)0x00000400)
N #define IS_RCC_AHB_PERIPH(PERIPH) ((((PERIPH) & 0xFFFFFAA8) == 0x00) && ((PERIPH) != 0x00))
N#else
S #define RCC_AHBPeriph_OTG_FS            ((uint32_t)0x00001000)
S #define RCC_AHBPeriph_ETH_MAC           ((uint32_t)0x00004000)
S #define RCC_AHBPeriph_ETH_MAC_Tx        ((uint32_t)0x00008000)
S #define RCC_AHBPeriph_ETH_MAC_Rx        ((uint32_t)0x00010000)
S
S #define IS_RCC_AHB_PERIPH(PERIPH) ((((PERIPH) & 0xFFFE2FA8) == 0x00) && ((PERIPH) != 0x00))
S #define IS_RCC_AHB_PERIPH_RESET(PERIPH) ((((PERIPH) & 0xFFFFAFFF) == 0x00) && ((PERIPH) != 0x00))
N#endif /* STM32F10X_CL */
N/**
N  * @}
N  */
N
N/** @defgroup APB2_peripheral 
N  * @{
N  */
N
N#define RCC_APB2Periph_AFIO              ((uint32_t)0x00000001)
N#define RCC_APB2Periph_GPIOA             ((uint32_t)0x00000004)
N#define RCC_APB2Periph_GPIOB             ((uint32_t)0x00000008)
N#define RCC_APB2Periph_GPIOC             ((uint32_t)0x00000010)
N#define RCC_APB2Periph_GPIOD             ((uint32_t)0x00000020)
N#define RCC_APB2Periph_GPIOE             ((uint32_t)0x00000040)
N#define RCC_APB2Periph_GPIOF             ((uint32_t)0x00000080)
N#define RCC_APB2Periph_GPIOG             ((uint32_t)0x00000100)
N#define RCC_APB2Periph_ADC1              ((uint32_t)0x00000200)
N#define RCC_APB2Periph_ADC2              ((uint32_t)0x00000400)
N#define RCC_APB2Periph_TIM1              ((uint32_t)0x00000800)
N#define RCC_APB2Periph_SPI1              ((uint32_t)0x00001000)
N#define RCC_APB2Periph_TIM8              ((uint32_t)0x00002000)
N#define RCC_APB2Periph_USART1            ((uint32_t)0x00004000)
N#define RCC_APB2Periph_ADC3              ((uint32_t)0x00008000)
N#define RCC_APB2Periph_TIM15             ((uint32_t)0x00010000)
N#define RCC_APB2Periph_TIM16             ((uint32_t)0x00020000)
N#define RCC_APB2Periph_TIM17             ((uint32_t)0x00040000)
N#define RCC_APB2Periph_TIM9              ((uint32_t)0x00080000)
N#define RCC_APB2Periph_TIM10             ((uint32_t)0x00100000)
N#define RCC_APB2Periph_TIM11             ((uint32_t)0x00200000)
N
N#define IS_RCC_APB2_PERIPH(PERIPH) ((((PERIPH) & 0xFFC00002) == 0x00) && ((PERIPH) != 0x00))
N/**
N  * @}
N  */ 
N
N/** @defgroup APB1_peripheral 
N  * @{
N  */
N
N#define RCC_APB1Periph_TIM2              ((uint32_t)0x00000001)
N#define RCC_APB1Periph_TIM3              ((uint32_t)0x00000002)
N#define RCC_APB1Periph_TIM4              ((uint32_t)0x00000004)
N#define RCC_APB1Periph_TIM5              ((uint32_t)0x00000008)
N#define RCC_APB1Periph_TIM6              ((uint32_t)0x00000010)
N#define RCC_APB1Periph_TIM7              ((uint32_t)0x00000020)
N#define RCC_APB1Periph_TIM12             ((uint32_t)0x00000040)
N#define RCC_APB1Periph_TIM13             ((uint32_t)0x00000080)
N#define RCC_APB1Periph_TIM14             ((uint32_t)0x00000100)
N#define RCC_APB1Periph_WWDG              ((uint32_t)0x00000800)
N#define RCC_APB1Periph_SPI2              ((uint32_t)0x00004000)
N#define RCC_APB1Periph_SPI3              ((uint32_t)0x00008000)
N#define RCC_APB1Periph_USART2            ((uint32_t)0x00020000)
N#define RCC_APB1Periph_USART3            ((uint32_t)0x00040000)
N#define RCC_APB1Periph_UART4             ((uint32_t)0x00080000)
N#define RCC_APB1Periph_UART5             ((uint32_t)0x00100000)
N#define RCC_APB1Periph_I2C1              ((uint32_t)0x00200000)
N#define RCC_APB1Periph_I2C2              ((uint32_t)0x00400000)
N#define RCC_APB1Periph_USB               ((uint32_t)0x00800000)
N#define RCC_APB1Periph_CAN1              ((uint32_t)0x02000000)
N#define RCC_APB1Periph_CAN2              ((uint32_t)0x04000000)
N#define RCC_APB1Periph_BKP               ((uint32_t)0x08000000)
N#define RCC_APB1Periph_PWR               ((uint32_t)0x10000000)
N#define RCC_APB1Periph_DAC               ((uint32_t)0x20000000)
N#define RCC_APB1Periph_CEC               ((uint32_t)0x40000000)
N 
N#define IS_RCC_APB1_PERIPH(PERIPH) ((((PERIPH) & 0x81013600) == 0x00) && ((PERIPH) != 0x00))
N
N/**
N  * @}
N  */
N
N/** @defgroup Clock_source_to_output_on_MCO_pin 
N  * @{
N  */
N
N#define RCC_MCO_NoClock                  ((uint8_t)0x00)
N#define RCC_MCO_SYSCLK                   ((uint8_t)0x04)
N#define RCC_MCO_HSI                      ((uint8_t)0x05)
N#define RCC_MCO_HSE                      ((uint8_t)0x06)
N#define RCC_MCO_PLLCLK_Div2              ((uint8_t)0x07)
N
N#ifndef STM32F10X_CL
N #define IS_RCC_MCO(MCO) (((MCO) == RCC_MCO_NoClock) || ((MCO) == RCC_MCO_HSI) || \
N                          ((MCO) == RCC_MCO_SYSCLK)  || ((MCO) == RCC_MCO_HSE) || \
N                          ((MCO) == RCC_MCO_PLLCLK_Div2))
X #define IS_RCC_MCO(MCO) (((MCO) == RCC_MCO_NoClock) || ((MCO) == RCC_MCO_HSI) ||                           ((MCO) == RCC_MCO_SYSCLK)  || ((MCO) == RCC_MCO_HSE) ||                           ((MCO) == RCC_MCO_PLLCLK_Div2))
N#else
S #define RCC_MCO_PLL2CLK                 ((uint8_t)0x08)
S #define RCC_MCO_PLL3CLK_Div2            ((uint8_t)0x09)
S #define RCC_MCO_XT1                     ((uint8_t)0x0A)
S #define RCC_MCO_PLL3CLK                 ((uint8_t)0x0B)
S
S #define IS_RCC_MCO(MCO) (((MCO) == RCC_MCO_NoClock) || ((MCO) == RCC_MCO_HSI) || \
S                          ((MCO) == RCC_MCO_SYSCLK)  || ((MCO) == RCC_MCO_HSE) || \
S                          ((MCO) == RCC_MCO_PLLCLK_Div2) || ((MCO) == RCC_MCO_PLL2CLK) || \
S                          ((MCO) == RCC_MCO_PLL3CLK_Div2) || ((MCO) == RCC_MCO_XT1) || \
S                          ((MCO) == RCC_MCO_PLL3CLK))
X #define IS_RCC_MCO(MCO) (((MCO) == RCC_MCO_NoClock) || ((MCO) == RCC_MCO_HSI) ||                           ((MCO) == RCC_MCO_SYSCLK)  || ((MCO) == RCC_MCO_HSE) ||                           ((MCO) == RCC_MCO_PLLCLK_Div2) || ((MCO) == RCC_MCO_PLL2CLK) ||                           ((MCO) == RCC_MCO_PLL3CLK_Div2) || ((MCO) == RCC_MCO_XT1) ||                           ((MCO) == RCC_MCO_PLL3CLK))
N#endif /* STM32F10X_CL */ 
N
N/**
N  * @}
N  */
N
N/** @defgroup RCC_Flag 
N  * @{
N  */
N
N#define RCC_FLAG_HSIRDY                  ((uint8_t)0x21)
N#define RCC_FLAG_HSERDY                  ((uint8_t)0x31)
N#define RCC_FLAG_PLLRDY                  ((uint8_t)0x39)
N#define RCC_FLAG_LSERDY                  ((uint8_t)0x41)
N#define RCC_FLAG_LSIRDY                  ((uint8_t)0x61)
N#define RCC_FLAG_PINRST                  ((uint8_t)0x7A)
N#define RCC_FLAG_PORRST                  ((uint8_t)0x7B)
N#define RCC_FLAG_SFTRST                  ((uint8_t)0x7C)
N#define RCC_FLAG_IWDGRST                 ((uint8_t)0x7D)
N#define RCC_FLAG_WWDGRST                 ((uint8_t)0x7E)
N#define RCC_FLAG_LPWRRST                 ((uint8_t)0x7F)
N
N#ifndef STM32F10X_CL
N #define IS_RCC_FLAG(FLAG) (((FLAG) == RCC_FLAG_HSIRDY) || ((FLAG) == RCC_FLAG_HSERDY) || \
N                            ((FLAG) == RCC_FLAG_PLLRDY) || ((FLAG) == RCC_FLAG_LSERDY) || \
N                            ((FLAG) == RCC_FLAG_LSIRDY) || ((FLAG) == RCC_FLAG_PINRST) || \
N                            ((FLAG) == RCC_FLAG_PORRST) || ((FLAG) == RCC_FLAG_SFTRST) || \
N                            ((FLAG) == RCC_FLAG_IWDGRST)|| ((FLAG) == RCC_FLAG_WWDGRST)|| \
N                            ((FLAG) == RCC_FLAG_LPWRRST))
X #define IS_RCC_FLAG(FLAG) (((FLAG) == RCC_FLAG_HSIRDY) || ((FLAG) == RCC_FLAG_HSERDY) ||                             ((FLAG) == RCC_FLAG_PLLRDY) || ((FLAG) == RCC_FLAG_LSERDY) ||                             ((FLAG) == RCC_FLAG_LSIRDY) || ((FLAG) == RCC_FLAG_PINRST) ||                             ((FLAG) == RCC_FLAG_PORRST) || ((FLAG) == RCC_FLAG_SFTRST) ||                             ((FLAG) == RCC_FLAG_IWDGRST)|| ((FLAG) == RCC_FLAG_WWDGRST)||                             ((FLAG) == RCC_FLAG_LPWRRST))
N#else
S #define RCC_FLAG_PLL2RDY                ((uint8_t)0x3B) 
S #define RCC_FLAG_PLL3RDY                ((uint8_t)0x3D) 
S #define IS_RCC_FLAG(FLAG) (((FLAG) == RCC_FLAG_HSIRDY) || ((FLAG) == RCC_FLAG_HSERDY) || \
S                            ((FLAG) == RCC_FLAG_PLLRDY) || ((FLAG) == RCC_FLAG_LSERDY) || \
S                            ((FLAG) == RCC_FLAG_PLL2RDY) || ((FLAG) == RCC_FLAG_PLL3RDY) || \
S                            ((FLAG) == RCC_FLAG_LSIRDY) || ((FLAG) == RCC_FLAG_PINRST) || \
S                            ((FLAG) == RCC_FLAG_PORRST) || ((FLAG) == RCC_FLAG_SFTRST) || \
S                            ((FLAG) == RCC_FLAG_IWDGRST)|| ((FLAG) == RCC_FLAG_WWDGRST)|| \
S                            ((FLAG) == RCC_FLAG_LPWRRST))
X #define IS_RCC_FLAG(FLAG) (((FLAG) == RCC_FLAG_HSIRDY) || ((FLAG) == RCC_FLAG_HSERDY) ||                             ((FLAG) == RCC_FLAG_PLLRDY) || ((FLAG) == RCC_FLAG_LSERDY) ||                             ((FLAG) == RCC_FLAG_PLL2RDY) || ((FLAG) == RCC_FLAG_PLL3RDY) ||                             ((FLAG) == RCC_FLAG_LSIRDY) || ((FLAG) == RCC_FLAG_PINRST) ||                             ((FLAG) == RCC_FLAG_PORRST) || ((FLAG) == RCC_FLAG_SFTRST) ||                             ((FLAG) == RCC_FLAG_IWDGRST)|| ((FLAG) == RCC_FLAG_WWDGRST)||                             ((FLAG) == RCC_FLAG_LPWRRST))
N#endif /* STM32F10X_CL */ 
N
N#define IS_RCC_CALIBRATION_VALUE(VALUE) ((VALUE) <= 0x1F)
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */
N
N/** @defgroup RCC_Exported_Macros
N  * @{
N  */
N
N/**
N  * @}
N  */
N
N/** @defgroup RCC_Exported_Functions
N  * @{
N  */
N
Nvoid RCC_DeInit(void);
Nvoid RCC_HSEConfig(uint32_t RCC_HSE);
NErrorStatus RCC_WaitForHSEStartUp(void);
Nvoid RCC_AdjustHSICalibrationValue(uint8_t HSICalibrationValue);
Nvoid RCC_HSICmd(FunctionalState NewState);
Nvoid RCC_PLLConfig(uint32_t RCC_PLLSource, uint32_t RCC_PLLMul);
Nvoid RCC_PLLCmd(FunctionalState NewState);
N
N#if defined (STM32F10X_LD_VL) || defined (STM32F10X_MD_VL) || defined (STM32F10X_HD_VL) || defined (STM32F10X_CL)
X#if 0L || 0L || 0L || 0L
S void RCC_PREDIV1Config(uint32_t RCC_PREDIV1_Source, uint32_t RCC_PREDIV1_Div);
N#endif
N
N#ifdef  STM32F10X_CL
S void RCC_PREDIV2Config(uint32_t RCC_PREDIV2_Div);
S void RCC_PLL2Config(uint32_t RCC_PLL2Mul);
S void RCC_PLL2Cmd(FunctionalState NewState);
S void RCC_PLL3Config(uint32_t RCC_PLL3Mul);
S void RCC_PLL3Cmd(FunctionalState NewState);
N#endif /* STM32F10X_CL */ 
N
Nvoid RCC_SYSCLKConfig(uint32_t RCC_SYSCLKSource);
Nuint8_t RCC_GetSYSCLKSource(void);
Nvoid RCC_HCLKConfig(uint32_t RCC_SYSCLK);
Nvoid RCC_PCLK1Config(uint32_t RCC_HCLK);
Nvoid RCC_PCLK2Config(uint32_t RCC_HCLK);
Nvoid RCC_ITConfig(uint8_t RCC_IT, FunctionalState NewState);
N
N#ifndef STM32F10X_CL
N void RCC_USBCLKConfig(uint32_t RCC_USBCLKSource);
N#else
S void RCC_OTGFSCLKConfig(uint32_t RCC_OTGFSCLKSource);
N#endif /* STM32F10X_CL */ 
N
Nvoid RCC_ADCCLKConfig(uint32_t RCC_PCLK2);
N
N#ifdef STM32F10X_CL
S void RCC_I2S2CLKConfig(uint32_t RCC_I2S2CLKSource);                                  
S void RCC_I2S3CLKConfig(uint32_t RCC_I2S3CLKSource);
N#endif /* STM32F10X_CL */ 
N
Nvoid RCC_LSEConfig(uint8_t RCC_LSE);
Nvoid RCC_LSICmd(FunctionalState NewState);
Nvoid RCC_RTCCLKConfig(uint32_t RCC_RTCCLKSource);
Nvoid RCC_RTCCLKCmd(FunctionalState NewState);
Nvoid RCC_GetClocksFreq(RCC_ClocksTypeDef* RCC_Clocks);
Nvoid RCC_AHBPeriphClockCmd(uint32_t RCC_AHBPeriph, FunctionalState NewState);
Nvoid RCC_APB2PeriphClockCmd(uint32_t RCC_APB2Periph, FunctionalState NewState);
Nvoid RCC_APB1PeriphClockCmd(uint32_t RCC_APB1Periph, FunctionalState NewState);
N
N#ifdef STM32F10X_CL
Svoid RCC_AHBPeriphResetCmd(uint32_t RCC_AHBPeriph, FunctionalState NewState);
N#endif /* STM32F10X_CL */ 
N
Nvoid RCC_APB2PeriphResetCmd(uint32_t RCC_APB2Periph, FunctionalState NewState);
Nvoid RCC_APB1PeriphResetCmd(uint32_t RCC_APB1Periph, FunctionalState NewState);
Nvoid RCC_BackupResetCmd(FunctionalState NewState);
Nvoid RCC_ClockSecuritySystemCmd(FunctionalState NewState);
Nvoid RCC_MCOConfig(uint8_t RCC_MCO);
NFlagStatus RCC_GetFlagStatus(uint8_t RCC_FLAG);
Nvoid RCC_ClearFlag(void);
NITStatus RCC_GetITStatus(uint8_t RCC_IT);
Nvoid RCC_ClearITPendingBit(uint8_t RCC_IT);
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif /* __STM32F10x_RCC_H */
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */ 
N
N/******************* (C) COPYRIGHT 2011 STMicroelectronics *****END OF FILE****/
L 44 "..\..\User\stm32f10x_conf.h" 2
N#include "stm32f10x_rtc.h" 
L 1 "..\..\Libraries\FWlib\inc\stm32f10x_rtc.h" 1
N/**
N  ******************************************************************************
N  * @file    stm32f10x_rtc.h
N  * @author  MCD Application Team
N  * @version V3.5.0
N  * @date    11-March-2011
N  * @brief   This file contains all the functions prototypes for the RTC firmware 
N  *          library.
N  ******************************************************************************
N  * @attention
N  *
N  * THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
N  * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE
N  * TIME. AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY
N  * DIRECT, INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING
N  * FROM THE CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE
N  * CODING INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
N  *
N  * <h2><center>&copy; COPYRIGHT 2011 STMicroelectronics</center></h2>
N  ******************************************************************************
N  */
N
N/* Define to prevent recursive inclusion -------------------------------------*/
N#ifndef __STM32F10x_RTC_H
N#define __STM32F10x_RTC_H
N
N#ifdef __cplusplus
S extern "C" {
N#endif
N
N/* Includes ------------------------------------------------------------------*/
N#include "stm32f10x.h"
N
N/** @addtogroup STM32F10x_StdPeriph_Driver
N  * @{
N  */
N
N/** @addtogroup RTC
N  * @{
N  */ 
N
N/** @defgroup RTC_Exported_Types
N  * @{
N  */ 
N
N/**
N  * @}
N  */ 
N
N/** @defgroup RTC_Exported_Constants
N  * @{
N  */
N
N/** @defgroup RTC_interrupts_define 
N  * @{
N  */
N
N#define RTC_IT_OW            ((uint16_t)0x0004)  /*!< Overflow interrupt */
N#define RTC_IT_ALR           ((uint16_t)0x0002)  /*!< Alarm interrupt */
N#define RTC_IT_SEC           ((uint16_t)0x0001)  /*!< Second interrupt */
N#define IS_RTC_IT(IT) ((((IT) & (uint16_t)0xFFF8) == 0x00) && ((IT) != 0x00))
N#define IS_RTC_GET_IT(IT) (((IT) == RTC_IT_OW) || ((IT) == RTC_IT_ALR) || \
N                           ((IT) == RTC_IT_SEC))
X#define IS_RTC_GET_IT(IT) (((IT) == RTC_IT_OW) || ((IT) == RTC_IT_ALR) ||                            ((IT) == RTC_IT_SEC))
N/**
N  * @}
N  */ 
N
N/** @defgroup RTC_interrupts_flags 
N  * @{
N  */
N
N#define RTC_FLAG_RTOFF       ((uint16_t)0x0020)  /*!< RTC Operation OFF flag */
N#define RTC_FLAG_RSF         ((uint16_t)0x0008)  /*!< Registers Synchronized flag */
N#define RTC_FLAG_OW          ((uint16_t)0x0004)  /*!< Overflow flag */
N#define RTC_FLAG_ALR         ((uint16_t)0x0002)  /*!< Alarm flag */
N#define RTC_FLAG_SEC         ((uint16_t)0x0001)  /*!< Second flag */
N#define IS_RTC_CLEAR_FLAG(FLAG) ((((FLAG) & (uint16_t)0xFFF0) == 0x00) && ((FLAG) != 0x00))
N#define IS_RTC_GET_FLAG(FLAG) (((FLAG) == RTC_FLAG_RTOFF) || ((FLAG) == RTC_FLAG_RSF) || \
N                               ((FLAG) == RTC_FLAG_OW) || ((FLAG) == RTC_FLAG_ALR) || \
N                               ((FLAG) == RTC_FLAG_SEC))
X#define IS_RTC_GET_FLAG(FLAG) (((FLAG) == RTC_FLAG_RTOFF) || ((FLAG) == RTC_FLAG_RSF) ||                                ((FLAG) == RTC_FLAG_OW) || ((FLAG) == RTC_FLAG_ALR) ||                                ((FLAG) == RTC_FLAG_SEC))
N#define IS_RTC_PRESCALER(PRESCALER) ((PRESCALER) <= 0xFFFFF)
N
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */
N
N/** @defgroup RTC_Exported_Macros
N  * @{
N  */
N
N/**
N  * @}
N  */
N
N/** @defgroup RTC_Exported_Functions
N  * @{
N  */
N
Nvoid RTC_ITConfig(uint16_t RTC_IT, FunctionalState NewState);
Nvoid RTC_EnterConfigMode(void);
Nvoid RTC_ExitConfigMode(void);
Nuint32_t  RTC_GetCounter(void);
Nvoid RTC_SetCounter(uint32_t CounterValue);
Nvoid RTC_SetPrescaler(uint32_t PrescalerValue);
Nvoid RTC_SetAlarm(uint32_t AlarmValue);
Nuint32_t  RTC_GetDivider(void);
Nvoid RTC_WaitForLastTask(void);
Nvoid RTC_WaitForSynchro(void);
NFlagStatus RTC_GetFlagStatus(uint16_t RTC_FLAG);
Nvoid RTC_ClearFlag(uint16_t RTC_FLAG);
NITStatus RTC_GetITStatus(uint16_t RTC_IT);
Nvoid RTC_ClearITPendingBit(uint16_t RTC_IT);
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif /* __STM32F10x_RTC_H */
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */
N
N/******************* (C) COPYRIGHT 2011 STMicroelectronics *****END OF FILE****/
L 45 "..\..\User\stm32f10x_conf.h" 2
N#include "stm32f10x_sdio.h" 
L 1 "..\..\Libraries\FWlib\inc\stm32f10x_sdio.h" 1
N/**
N  ******************************************************************************
N  * @file    stm32f10x_sdio.h
N  * @author  MCD Application Team
N  * @version V3.5.0
N  * @date    11-March-2011
N  * @brief   This file contains all the functions prototypes for the SDIO firmware
N  *          library.
N  ******************************************************************************
N  * @attention
N  *
N  * THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
N  * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE
N  * TIME. AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY
N  * DIRECT, INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING
N  * FROM THE CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE
N  * CODING INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
N  *
N  * <h2><center>&copy; COPYRIGHT 2011 STMicroelectronics</center></h2>
N  ******************************************************************************
N  */
N
N/* Define to prevent recursive inclusion -------------------------------------*/
N#ifndef __STM32F10x_SDIO_H
N#define __STM32F10x_SDIO_H
N
N#ifdef __cplusplus
S extern "C" {
N#endif
N
N/* Includes ------------------------------------------------------------------*/
N#include "stm32f10x.h"
N
N/** @addtogroup STM32F10x_StdPeriph_Driver
N  * @{
N  */
N
N/** @addtogroup SDIO
N  * @{
N  */
N
N/** @defgroup SDIO_Exported_Types
N  * @{
N  */
N
Ntypedef struct
N{
N  uint32_t SDIO_ClockEdge;            /*!< Specifies the clock transition on which the bit capture is made.
N                                           This parameter can be a value of @ref SDIO_Clock_Edge */
N
N  uint32_t SDIO_ClockBypass;          /*!< Specifies whether the SDIO Clock divider bypass is
N                                           enabled or disabled.
N                                           This parameter can be a value of @ref SDIO_Clock_Bypass */
N
N  uint32_t SDIO_ClockPowerSave;       /*!< Specifies whether SDIO Clock output is enabled or
N                                           disabled when the bus is idle.
N                                           This parameter can be a value of @ref SDIO_Clock_Power_Save */
N
N  uint32_t SDIO_BusWide;              /*!< Specifies the SDIO bus width.
N                                           This parameter can be a value of @ref SDIO_Bus_Wide */
N
N  uint32_t SDIO_HardwareFlowControl;  /*!< Specifies whether the SDIO hardware flow control is enabled or disabled.
N                                           This parameter can be a value of @ref SDIO_Hardware_Flow_Control */
N
N  uint8_t SDIO_ClockDiv;              /*!< Specifies the clock frequency of the SDIO controller.
N                                           This parameter can be a value between 0x00 and 0xFF. */
N                                           
N} SDIO_InitTypeDef;
N
Ntypedef struct
N{
N  uint32_t SDIO_Argument;  /*!< Specifies the SDIO command argument which is sent
N                                to a card as part of a command message. If a command
N                                contains an argument, it must be loaded into this register
N                                before writing the command to the command register */
N
N  uint32_t SDIO_CmdIndex;  /*!< Specifies the SDIO command index. It must be lower than 0x40. */
N
N  uint32_t SDIO_Response;  /*!< Specifies the SDIO response type.
N                                This parameter can be a value of @ref SDIO_Response_Type */
N
N  uint32_t SDIO_Wait;      /*!< Specifies whether SDIO wait-for-interrupt request is enabled or disabled.
N                                This parameter can be a value of @ref SDIO_Wait_Interrupt_State */
N
N  uint32_t SDIO_CPSM;      /*!< Specifies whether SDIO Command path state machine (CPSM)
N                                is enabled or disabled.
N                                This parameter can be a value of @ref SDIO_CPSM_State */
N} SDIO_CmdInitTypeDef;
N
Ntypedef struct
N{
N  uint32_t SDIO_DataTimeOut;    /*!< Specifies the data timeout period in card bus clock periods. */
N
N  uint32_t SDIO_DataLength;     /*!< Specifies the number of data bytes to be transferred. */
N 
N  uint32_t SDIO_DataBlockSize;  /*!< Specifies the data block size for block transfer.
N                                     This parameter can be a value of @ref SDIO_Data_Block_Size */
N 
N  uint32_t SDIO_TransferDir;    /*!< Specifies the data transfer direction, whether the transfer
N                                     is a read or write.
N                                     This parameter can be a value of @ref SDIO_Transfer_Direction */
N 
N  uint32_t SDIO_TransferMode;   /*!< Specifies whether data transfer is in stream or block mode.
N                                     This parameter can be a value of @ref SDIO_Transfer_Type */
N 
N  uint32_t SDIO_DPSM;           /*!< Specifies whether SDIO Data path state machine (DPSM)
N                                     is enabled or disabled.
N                                     This parameter can be a value of @ref SDIO_DPSM_State */
N} SDIO_DataInitTypeDef;
N
N/**
N  * @}
N  */ 
N
N/** @defgroup SDIO_Exported_Constants
N  * @{
N  */
N
N/** @defgroup SDIO_Clock_Edge 
N  * @{
N  */
N
N#define SDIO_ClockEdge_Rising               ((uint32_t)0x00000000)
N#define SDIO_ClockEdge_Falling              ((uint32_t)0x00002000)
N#define IS_SDIO_CLOCK_EDGE(EDGE) (((EDGE) == SDIO_ClockEdge_Rising) || \
N                                  ((EDGE) == SDIO_ClockEdge_Falling))
X#define IS_SDIO_CLOCK_EDGE(EDGE) (((EDGE) == SDIO_ClockEdge_Rising) ||                                   ((EDGE) == SDIO_ClockEdge_Falling))
N/**
N  * @}
N  */
N
N/** @defgroup SDIO_Clock_Bypass 
N  * @{
N  */
N
N#define SDIO_ClockBypass_Disable             ((uint32_t)0x00000000)
N#define SDIO_ClockBypass_Enable              ((uint32_t)0x00000400)    
N#define IS_SDIO_CLOCK_BYPASS(BYPASS) (((BYPASS) == SDIO_ClockBypass_Disable) || \
N                                     ((BYPASS) == SDIO_ClockBypass_Enable))
X#define IS_SDIO_CLOCK_BYPASS(BYPASS) (((BYPASS) == SDIO_ClockBypass_Disable) ||                                      ((BYPASS) == SDIO_ClockBypass_Enable))
N/**
N  * @}
N  */ 
N
N/** @defgroup SDIO_Clock_Power_Save 
N  * @{
N  */
N
N#define SDIO_ClockPowerSave_Disable         ((uint32_t)0x00000000)
N#define SDIO_ClockPowerSave_Enable          ((uint32_t)0x00000200) 
N#define IS_SDIO_CLOCK_POWER_SAVE(SAVE) (((SAVE) == SDIO_ClockPowerSave_Disable) || \
N                                        ((SAVE) == SDIO_ClockPowerSave_Enable))
X#define IS_SDIO_CLOCK_POWER_SAVE(SAVE) (((SAVE) == SDIO_ClockPowerSave_Disable) ||                                         ((SAVE) == SDIO_ClockPowerSave_Enable))
N/**
N  * @}
N  */
N
N/** @defgroup SDIO_Bus_Wide 
N  * @{
N  */
N
N#define SDIO_BusWide_1b                     ((uint32_t)0x00000000)
N#define SDIO_BusWide_4b                     ((uint32_t)0x00000800)
N#define SDIO_BusWide_8b                     ((uint32_t)0x00001000)
N#define IS_SDIO_BUS_WIDE(WIDE) (((WIDE) == SDIO_BusWide_1b) || ((WIDE) == SDIO_BusWide_4b) || \
N                                ((WIDE) == SDIO_BusWide_8b))
X#define IS_SDIO_BUS_WIDE(WIDE) (((WIDE) == SDIO_BusWide_1b) || ((WIDE) == SDIO_BusWide_4b) ||                                 ((WIDE) == SDIO_BusWide_8b))
N
N/**
N  * @}
N  */
N
N/** @defgroup SDIO_Hardware_Flow_Control 
N  * @{
N  */
N
N#define SDIO_HardwareFlowControl_Disable    ((uint32_t)0x00000000)
N#define SDIO_HardwareFlowControl_Enable     ((uint32_t)0x00004000)
N#define IS_SDIO_HARDWARE_FLOW_CONTROL(CONTROL) (((CONTROL) == SDIO_HardwareFlowControl_Disable) || \
N                                                ((CONTROL) == SDIO_HardwareFlowControl_Enable))
X#define IS_SDIO_HARDWARE_FLOW_CONTROL(CONTROL) (((CONTROL) == SDIO_HardwareFlowControl_Disable) ||                                                 ((CONTROL) == SDIO_HardwareFlowControl_Enable))
N/**
N  * @}
N  */
N
N/** @defgroup SDIO_Power_State 
N  * @{
N  */
N
N#define SDIO_PowerState_OFF                 ((uint32_t)0x00000000)
N#define SDIO_PowerState_ON                  ((uint32_t)0x00000003)
N#define IS_SDIO_POWER_STATE(STATE) (((STATE) == SDIO_PowerState_OFF) || ((STATE) == SDIO_PowerState_ON)) 
N/**
N  * @}
N  */ 
N
N
N/** @defgroup SDIO_Interrupt_sources 
N  * @{
N  */
N
N#define SDIO_IT_CCRCFAIL                    ((uint32_t)0x00000001)
N#define SDIO_IT_DCRCFAIL                    ((uint32_t)0x00000002)
N#define SDIO_IT_CTIMEOUT                    ((uint32_t)0x00000004)
N#define SDIO_IT_DTIMEOUT                    ((uint32_t)0x00000008)
N#define SDIO_IT_TXUNDERR                    ((uint32_t)0x00000010)
N#define SDIO_IT_RXOVERR                     ((uint32_t)0x00000020)
N#define SDIO_IT_CMDREND                     ((uint32_t)0x00000040)
N#define SDIO_IT_CMDSENT                     ((uint32_t)0x00000080)
N#define SDIO_IT_DATAEND                     ((uint32_t)0x00000100)
N#define SDIO_IT_STBITERR                    ((uint32_t)0x00000200)
N#define SDIO_IT_DBCKEND                     ((uint32_t)0x00000400)
N#define SDIO_IT_CMDACT                      ((uint32_t)0x00000800)
N#define SDIO_IT_TXACT                       ((uint32_t)0x00001000)
N#define SDIO_IT_RXACT                       ((uint32_t)0x00002000)
N#define SDIO_IT_TXFIFOHE                    ((uint32_t)0x00004000)
N#define SDIO_IT_RXFIFOHF                    ((uint32_t)0x00008000)
N#define SDIO_IT_TXFIFOF                     ((uint32_t)0x00010000)
N#define SDIO_IT_RXFIFOF                     ((uint32_t)0x00020000)
N#define SDIO_IT_TXFIFOE                     ((uint32_t)0x00040000)
N#define SDIO_IT_RXFIFOE                     ((uint32_t)0x00080000)
N#define SDIO_IT_TXDAVL                      ((uint32_t)0x00100000)
N#define SDIO_IT_RXDAVL                      ((uint32_t)0x00200000)
N#define SDIO_IT_SDIOIT                      ((uint32_t)0x00400000)
N#define SDIO_IT_CEATAEND                    ((uint32_t)0x00800000)
N#define IS_SDIO_IT(IT) ((((IT) & (uint32_t)0xFF000000) == 0x00) && ((IT) != (uint32_t)0x00))
N/**
N  * @}
N  */ 
N
N/** @defgroup SDIO_Command_Index
N  * @{
N  */
N
N#define IS_SDIO_CMD_INDEX(INDEX)            ((INDEX) < 0x40)
N/**
N  * @}
N  */
N
N/** @defgroup SDIO_Response_Type 
N  * @{
N  */
N
N#define SDIO_Response_No                    ((uint32_t)0x00000000)
N#define SDIO_Response_Short                 ((uint32_t)0x00000040)
N#define SDIO_Response_Long                  ((uint32_t)0x000000C0)
N#define IS_SDIO_RESPONSE(RESPONSE) (((RESPONSE) == SDIO_Response_No) || \
N                                    ((RESPONSE) == SDIO_Response_Short) || \
N                                    ((RESPONSE) == SDIO_Response_Long))
X#define IS_SDIO_RESPONSE(RESPONSE) (((RESPONSE) == SDIO_Response_No) ||                                     ((RESPONSE) == SDIO_Response_Short) ||                                     ((RESPONSE) == SDIO_Response_Long))
N/**
N  * @}
N  */
N
N/** @defgroup SDIO_Wait_Interrupt_State 
N  * @{
N  */
N
N#define SDIO_Wait_No                        ((uint32_t)0x00000000) /*!< SDIO No Wait, TimeOut is enabled */
N#define SDIO_Wait_IT                        ((uint32_t)0x00000100) /*!< SDIO Wait Interrupt Request */
N#define SDIO_Wait_Pend                      ((uint32_t)0x00000200) /*!< SDIO Wait End of transfer */
N#define IS_SDIO_WAIT(WAIT) (((WAIT) == SDIO_Wait_No) || ((WAIT) == SDIO_Wait_IT) || \
N                            ((WAIT) == SDIO_Wait_Pend))
X#define IS_SDIO_WAIT(WAIT) (((WAIT) == SDIO_Wait_No) || ((WAIT) == SDIO_Wait_IT) ||                             ((WAIT) == SDIO_Wait_Pend))
N/**
N  * @}
N  */
N
N/** @defgroup SDIO_CPSM_State 
N  * @{
N  */
N
N#define SDIO_CPSM_Disable                    ((uint32_t)0x00000000)
N#define SDIO_CPSM_Enable                     ((uint32_t)0x00000400)
N#define IS_SDIO_CPSM(CPSM) (((CPSM) == SDIO_CPSM_Enable) || ((CPSM) == SDIO_CPSM_Disable))
N/**
N  * @}
N  */ 
N
N/** @defgroup SDIO_Response_Registers 
N  * @{
N  */
N
N#define SDIO_RESP1                          ((uint32_t)0x00000000)
N#define SDIO_RESP2                          ((uint32_t)0x00000004)
N#define SDIO_RESP3                          ((uint32_t)0x00000008)
N#define SDIO_RESP4                          ((uint32_t)0x0000000C)
N#define IS_SDIO_RESP(RESP) (((RESP) == SDIO_RESP1) || ((RESP) == SDIO_RESP2) || \
N                            ((RESP) == SDIO_RESP3) || ((RESP) == SDIO_RESP4))
X#define IS_SDIO_RESP(RESP) (((RESP) == SDIO_RESP1) || ((RESP) == SDIO_RESP2) ||                             ((RESP) == SDIO_RESP3) || ((RESP) == SDIO_RESP4))
N/**
N  * @}
N  */
N
N/** @defgroup SDIO_Data_Length 
N  * @{
N  */
N
N#define IS_SDIO_DATA_LENGTH(LENGTH) ((LENGTH) <= 0x01FFFFFF)
N/**
N  * @}
N  */
N
N/** @defgroup SDIO_Data_Block_Size 
N  * @{
N  */
N
N#define SDIO_DataBlockSize_1b               ((uint32_t)0x00000000)
N#define SDIO_DataBlockSize_2b               ((uint32_t)0x00000010)
N#define SDIO_DataBlockSize_4b               ((uint32_t)0x00000020)
N#define SDIO_DataBlockSize_8b               ((uint32_t)0x00000030)
N#define SDIO_DataBlockSize_16b              ((uint32_t)0x00000040)
N#define SDIO_DataBlockSize_32b              ((uint32_t)0x00000050)
N#define SDIO_DataBlockSize_64b              ((uint32_t)0x00000060)
N#define SDIO_DataBlockSize_128b             ((uint32_t)0x00000070)
N#define SDIO_DataBlockSize_256b             ((uint32_t)0x00000080)
N#define SDIO_DataBlockSize_512b             ((uint32_t)0x00000090)
N#define SDIO_DataBlockSize_1024b            ((uint32_t)0x000000A0)
N#define SDIO_DataBlockSize_2048b            ((uint32_t)0x000000B0)
N#define SDIO_DataBlockSize_4096b            ((uint32_t)0x000000C0)
N#define SDIO_DataBlockSize_8192b            ((uint32_t)0x000000D0)
N#define SDIO_DataBlockSize_16384b           ((uint32_t)0x000000E0)
N#define IS_SDIO_BLOCK_SIZE(SIZE) (((SIZE) == SDIO_DataBlockSize_1b) || \
N                                  ((SIZE) == SDIO_DataBlockSize_2b) || \
N                                  ((SIZE) == SDIO_DataBlockSize_4b) || \
N                                  ((SIZE) == SDIO_DataBlockSize_8b) || \
N                                  ((SIZE) == SDIO_DataBlockSize_16b) || \
N                                  ((SIZE) == SDIO_DataBlockSize_32b) || \
N                                  ((SIZE) == SDIO_DataBlockSize_64b) || \
N                                  ((SIZE) == SDIO_DataBlockSize_128b) || \
N                                  ((SIZE) == SDIO_DataBlockSize_256b) || \
N                                  ((SIZE) == SDIO_DataBlockSize_512b) || \
N                                  ((SIZE) == SDIO_DataBlockSize_1024b) || \
N                                  ((SIZE) == SDIO_DataBlockSize_2048b) || \
N                                  ((SIZE) == SDIO_DataBlockSize_4096b) || \
N                                  ((SIZE) == SDIO_DataBlockSize_8192b) || \
N                                  ((SIZE) == SDIO_DataBlockSize_16384b)) 
X#define IS_SDIO_BLOCK_SIZE(SIZE) (((SIZE) == SDIO_DataBlockSize_1b) ||                                   ((SIZE) == SDIO_DataBlockSize_2b) ||                                   ((SIZE) == SDIO_DataBlockSize_4b) ||                                   ((SIZE) == SDIO_DataBlockSize_8b) ||                                   ((SIZE) == SDIO_DataBlockSize_16b) ||                                   ((SIZE) == SDIO_DataBlockSize_32b) ||                                   ((SIZE) == SDIO_DataBlockSize_64b) ||                                   ((SIZE) == SDIO_DataBlockSize_128b) ||                                   ((SIZE) == SDIO_DataBlockSize_256b) ||                                   ((SIZE) == SDIO_DataBlockSize_512b) ||                                   ((SIZE) == SDIO_DataBlockSize_1024b) ||                                   ((SIZE) == SDIO_DataBlockSize_2048b) ||                                   ((SIZE) == SDIO_DataBlockSize_4096b) ||                                   ((SIZE) == SDIO_DataBlockSize_8192b) ||                                   ((SIZE) == SDIO_DataBlockSize_16384b)) 
N/**
N  * @}
N  */
N
N/** @defgroup SDIO_Transfer_Direction 
N  * @{
N  */
N
N#define SDIO_TransferDir_ToCard             ((uint32_t)0x00000000)
N#define SDIO_TransferDir_ToSDIO             ((uint32_t)0x00000002)
N#define IS_SDIO_TRANSFER_DIR(DIR) (((DIR) == SDIO_TransferDir_ToCard) || \
N                                   ((DIR) == SDIO_TransferDir_ToSDIO))
X#define IS_SDIO_TRANSFER_DIR(DIR) (((DIR) == SDIO_TransferDir_ToCard) ||                                    ((DIR) == SDIO_TransferDir_ToSDIO))
N/**
N  * @}
N  */
N
N/** @defgroup SDIO_Transfer_Type 
N  * @{
N  */
N
N#define SDIO_TransferMode_Block             ((uint32_t)0x00000000)
N#define SDIO_TransferMode_Stream            ((uint32_t)0x00000004)
N#define IS_SDIO_TRANSFER_MODE(MODE) (((MODE) == SDIO_TransferMode_Stream) || \
N                                     ((MODE) == SDIO_TransferMode_Block))
X#define IS_SDIO_TRANSFER_MODE(MODE) (((MODE) == SDIO_TransferMode_Stream) ||                                      ((MODE) == SDIO_TransferMode_Block))
N/**
N  * @}
N  */
N
N/** @defgroup SDIO_DPSM_State 
N  * @{
N  */
N
N#define SDIO_DPSM_Disable                    ((uint32_t)0x00000000)
N#define SDIO_DPSM_Enable                     ((uint32_t)0x00000001)
N#define IS_SDIO_DPSM(DPSM) (((DPSM) == SDIO_DPSM_Enable) || ((DPSM) == SDIO_DPSM_Disable))
N/**
N  * @}
N  */
N
N/** @defgroup SDIO_Flags 
N  * @{
N  */
N
N#define SDIO_FLAG_CCRCFAIL                  ((uint32_t)0x00000001)
N#define SDIO_FLAG_DCRCFAIL                  ((uint32_t)0x00000002)
N#define SDIO_FLAG_CTIMEOUT                  ((uint32_t)0x00000004)
N#define SDIO_FLAG_DTIMEOUT                  ((uint32_t)0x00000008)
N#define SDIO_FLAG_TXUNDERR                  ((uint32_t)0x00000010)
N#define SDIO_FLAG_RXOVERR                   ((uint32_t)0x00000020)
N#define SDIO_FLAG_CMDREND                   ((uint32_t)0x00000040)
N#define SDIO_FLAG_CMDSENT                   ((uint32_t)0x00000080)
N#define SDIO_FLAG_DATAEND                   ((uint32_t)0x00000100)
N#define SDIO_FLAG_STBITERR                  ((uint32_t)0x00000200)
N#define SDIO_FLAG_DBCKEND                   ((uint32_t)0x00000400)
N#define SDIO_FLAG_CMDACT                    ((uint32_t)0x00000800)
N#define SDIO_FLAG_TXACT                     ((uint32_t)0x00001000)
N#define SDIO_FLAG_RXACT                     ((uint32_t)0x00002000)
N#define SDIO_FLAG_TXFIFOHE                  ((uint32_t)0x00004000)
N#define SDIO_FLAG_RXFIFOHF                  ((uint32_t)0x00008000)
N#define SDIO_FLAG_TXFIFOF                   ((uint32_t)0x00010000)
N#define SDIO_FLAG_RXFIFOF                   ((uint32_t)0x00020000)
N#define SDIO_FLAG_TXFIFOE                   ((uint32_t)0x00040000)
N#define SDIO_FLAG_RXFIFOE                   ((uint32_t)0x00080000)
N#define SDIO_FLAG_TXDAVL                    ((uint32_t)0x00100000)
N#define SDIO_FLAG_RXDAVL                    ((uint32_t)0x00200000)
N#define SDIO_FLAG_SDIOIT                    ((uint32_t)0x00400000)
N#define SDIO_FLAG_CEATAEND                  ((uint32_t)0x00800000)
N#define IS_SDIO_FLAG(FLAG) (((FLAG)  == SDIO_FLAG_CCRCFAIL) || \
N                            ((FLAG)  == SDIO_FLAG_DCRCFAIL) || \
N                            ((FLAG)  == SDIO_FLAG_CTIMEOUT) || \
N                            ((FLAG)  == SDIO_FLAG_DTIMEOUT) || \
N                            ((FLAG)  == SDIO_FLAG_TXUNDERR) || \
N                            ((FLAG)  == SDIO_FLAG_RXOVERR) || \
N                            ((FLAG)  == SDIO_FLAG_CMDREND) || \
N                            ((FLAG)  == SDIO_FLAG_CMDSENT) || \
N                            ((FLAG)  == SDIO_FLAG_DATAEND) || \
N                            ((FLAG)  == SDIO_FLAG_STBITERR) || \
N                            ((FLAG)  == SDIO_FLAG_DBCKEND) || \
N                            ((FLAG)  == SDIO_FLAG_CMDACT) || \
N                            ((FLAG)  == SDIO_FLAG_TXACT) || \
N                            ((FLAG)  == SDIO_FLAG_RXACT) || \
N                            ((FLAG)  == SDIO_FLAG_TXFIFOHE) || \
N                            ((FLAG)  == SDIO_FLAG_RXFIFOHF) || \
N                            ((FLAG)  == SDIO_FLAG_TXFIFOF) || \
N                            ((FLAG)  == SDIO_FLAG_RXFIFOF) || \
N                            ((FLAG)  == SDIO_FLAG_TXFIFOE) || \
N                            ((FLAG)  == SDIO_FLAG_RXFIFOE) || \
N                            ((FLAG)  == SDIO_FLAG_TXDAVL) || \
N                            ((FLAG)  == SDIO_FLAG_RXDAVL) || \
N                            ((FLAG)  == SDIO_FLAG_SDIOIT) || \
N                            ((FLAG)  == SDIO_FLAG_CEATAEND))
X#define IS_SDIO_FLAG(FLAG) (((FLAG)  == SDIO_FLAG_CCRCFAIL) ||                             ((FLAG)  == SDIO_FLAG_DCRCFAIL) ||                             ((FLAG)  == SDIO_FLAG_CTIMEOUT) ||                             ((FLAG)  == SDIO_FLAG_DTIMEOUT) ||                             ((FLAG)  == SDIO_FLAG_TXUNDERR) ||                             ((FLAG)  == SDIO_FLAG_RXOVERR) ||                             ((FLAG)  == SDIO_FLAG_CMDREND) ||                             ((FLAG)  == SDIO_FLAG_CMDSENT) ||                             ((FLAG)  == SDIO_FLAG_DATAEND) ||                             ((FLAG)  == SDIO_FLAG_STBITERR) ||                             ((FLAG)  == SDIO_FLAG_DBCKEND) ||                             ((FLAG)  == SDIO_FLAG_CMDACT) ||                             ((FLAG)  == SDIO_FLAG_TXACT) ||                             ((FLAG)  == SDIO_FLAG_RXACT) ||                             ((FLAG)  == SDIO_FLAG_TXFIFOHE) ||                             ((FLAG)  == SDIO_FLAG_RXFIFOHF) ||                             ((FLAG)  == SDIO_FLAG_TXFIFOF) ||                             ((FLAG)  == SDIO_FLAG_RXFIFOF) ||                             ((FLAG)  == SDIO_FLAG_TXFIFOE) ||                             ((FLAG)  == SDIO_FLAG_RXFIFOE) ||                             ((FLAG)  == SDIO_FLAG_TXDAVL) ||                             ((FLAG)  == SDIO_FLAG_RXDAVL) ||                             ((FLAG)  == SDIO_FLAG_SDIOIT) ||                             ((FLAG)  == SDIO_FLAG_CEATAEND))
N
N#define IS_SDIO_CLEAR_FLAG(FLAG) ((((FLAG) & (uint32_t)0xFF3FF800) == 0x00) && ((FLAG) != (uint32_t)0x00))
N
N#define IS_SDIO_GET_IT(IT) (((IT)  == SDIO_IT_CCRCFAIL) || \
N                            ((IT)  == SDIO_IT_DCRCFAIL) || \
N                            ((IT)  == SDIO_IT_CTIMEOUT) || \
N                            ((IT)  == SDIO_IT_DTIMEOUT) || \
N                            ((IT)  == SDIO_IT_TXUNDERR) || \
N                            ((IT)  == SDIO_IT_RXOVERR) || \
N                            ((IT)  == SDIO_IT_CMDREND) || \
N                            ((IT)  == SDIO_IT_CMDSENT) || \
N                            ((IT)  == SDIO_IT_DATAEND) || \
N                            ((IT)  == SDIO_IT_STBITERR) || \
N                            ((IT)  == SDIO_IT_DBCKEND) || \
N                            ((IT)  == SDIO_IT_CMDACT) || \
N                            ((IT)  == SDIO_IT_TXACT) || \
N                            ((IT)  == SDIO_IT_RXACT) || \
N                            ((IT)  == SDIO_IT_TXFIFOHE) || \
N                            ((IT)  == SDIO_IT_RXFIFOHF) || \
N                            ((IT)  == SDIO_IT_TXFIFOF) || \
N                            ((IT)  == SDIO_IT_RXFIFOF) || \
N                            ((IT)  == SDIO_IT_TXFIFOE) || \
N                            ((IT)  == SDIO_IT_RXFIFOE) || \
N                            ((IT)  == SDIO_IT_TXDAVL) || \
N                            ((IT)  == SDIO_IT_RXDAVL) || \
N                            ((IT)  == SDIO_IT_SDIOIT) || \
N                            ((IT)  == SDIO_IT_CEATAEND))
X#define IS_SDIO_GET_IT(IT) (((IT)  == SDIO_IT_CCRCFAIL) ||                             ((IT)  == SDIO_IT_DCRCFAIL) ||                             ((IT)  == SDIO_IT_CTIMEOUT) ||                             ((IT)  == SDIO_IT_DTIMEOUT) ||                             ((IT)  == SDIO_IT_TXUNDERR) ||                             ((IT)  == SDIO_IT_RXOVERR) ||                             ((IT)  == SDIO_IT_CMDREND) ||                             ((IT)  == SDIO_IT_CMDSENT) ||                             ((IT)  == SDIO_IT_DATAEND) ||                             ((IT)  == SDIO_IT_STBITERR) ||                             ((IT)  == SDIO_IT_DBCKEND) ||                             ((IT)  == SDIO_IT_CMDACT) ||                             ((IT)  == SDIO_IT_TXACT) ||                             ((IT)  == SDIO_IT_RXACT) ||                             ((IT)  == SDIO_IT_TXFIFOHE) ||                             ((IT)  == SDIO_IT_RXFIFOHF) ||                             ((IT)  == SDIO_IT_TXFIFOF) ||                             ((IT)  == SDIO_IT_RXFIFOF) ||                             ((IT)  == SDIO_IT_TXFIFOE) ||                             ((IT)  == SDIO_IT_RXFIFOE) ||                             ((IT)  == SDIO_IT_TXDAVL) ||                             ((IT)  == SDIO_IT_RXDAVL) ||                             ((IT)  == SDIO_IT_SDIOIT) ||                             ((IT)  == SDIO_IT_CEATAEND))
N
N#define IS_SDIO_CLEAR_IT(IT) ((((IT) & (uint32_t)0xFF3FF800) == 0x00) && ((IT) != (uint32_t)0x00))
N
N/**
N  * @}
N  */
N
N/** @defgroup SDIO_Read_Wait_Mode 
N  * @{
N  */
N
N#define SDIO_ReadWaitMode_CLK               ((uint32_t)0x00000001)
N#define SDIO_ReadWaitMode_DATA2             ((uint32_t)0x00000000)
N#define IS_SDIO_READWAIT_MODE(MODE) (((MODE) == SDIO_ReadWaitMode_CLK) || \
N                                     ((MODE) == SDIO_ReadWaitMode_DATA2))
X#define IS_SDIO_READWAIT_MODE(MODE) (((MODE) == SDIO_ReadWaitMode_CLK) ||                                      ((MODE) == SDIO_ReadWaitMode_DATA2))
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */
N
N/** @defgroup SDIO_Exported_Macros
N  * @{
N  */
N
N/**
N  * @}
N  */
N
N/** @defgroup SDIO_Exported_Functions
N  * @{
N  */
N
Nvoid SDIO_DeInit(void);
Nvoid SDIO_Init(SDIO_InitTypeDef* SDIO_InitStruct);
Nvoid SDIO_StructInit(SDIO_InitTypeDef* SDIO_InitStruct);
Nvoid SDIO_ClockCmd(FunctionalState NewState);
Nvoid SDIO_SetPowerState(uint32_t SDIO_PowerState);
Nuint32_t SDIO_GetPowerState(void);
Nvoid SDIO_ITConfig(uint32_t SDIO_IT, FunctionalState NewState);
Nvoid SDIO_DMACmd(FunctionalState NewState);
Nvoid SDIO_SendCommand(SDIO_CmdInitTypeDef *SDIO_CmdInitStruct);
Nvoid SDIO_CmdStructInit(SDIO_CmdInitTypeDef* SDIO_CmdInitStruct);
Nuint8_t SDIO_GetCommandResponse(void);
Nuint32_t SDIO_GetResponse(uint32_t SDIO_RESP);
Nvoid SDIO_DataConfig(SDIO_DataInitTypeDef* SDIO_DataInitStruct);
Nvoid SDIO_DataStructInit(SDIO_DataInitTypeDef* SDIO_DataInitStruct);
Nuint32_t SDIO_GetDataCounter(void);
Nuint32_t SDIO_ReadData(void);
Nvoid SDIO_WriteData(uint32_t Data);
Nuint32_t SDIO_GetFIFOCount(void);
Nvoid SDIO_StartSDIOReadWait(FunctionalState NewState);
Nvoid SDIO_StopSDIOReadWait(FunctionalState NewState);
Nvoid SDIO_SetSDIOReadWaitMode(uint32_t SDIO_ReadWaitMode);
Nvoid SDIO_SetSDIOOperation(FunctionalState NewState);
Nvoid SDIO_SendSDIOSuspendCmd(FunctionalState NewState);
Nvoid SDIO_CommandCompletionCmd(FunctionalState NewState);
Nvoid SDIO_CEATAITCmd(FunctionalState NewState);
Nvoid SDIO_SendCEATACmd(FunctionalState NewState);
NFlagStatus SDIO_GetFlagStatus(uint32_t SDIO_FLAG);
Nvoid SDIO_ClearFlag(uint32_t SDIO_FLAG);
NITStatus SDIO_GetITStatus(uint32_t SDIO_IT);
Nvoid SDIO_ClearITPendingBit(uint32_t SDIO_IT);
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif /* __STM32F10x_SDIO_H */
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */
N
N/******************* (C) COPYRIGHT 2011 STMicroelectronics *****END OF FILE****/
L 46 "..\..\User\stm32f10x_conf.h" 2
N#include "stm32f10x_spi.h" 
L 1 "..\..\Libraries\FWlib\inc\stm32f10x_spi.h" 1
N/**
N  ******************************************************************************
N  * @file    stm32f10x_spi.h
N  * @author  MCD Application Team
N  * @version V3.5.0
N  * @date    11-March-2011
N  * @brief   This file contains all the functions prototypes for the SPI firmware 
N  *          library.
N  ******************************************************************************
N  * @attention
N  *
N  * THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
N  * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE
N  * TIME. AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY
N  * DIRECT, INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING
N  * FROM THE CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE
N  * CODING INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
N  *
N  * <h2><center>&copy; COPYRIGHT 2011 STMicroelectronics</center></h2>
N  ******************************************************************************
N  */
N
N/* Define to prevent recursive inclusion -------------------------------------*/
N#ifndef __STM32F10x_SPI_H
N#define __STM32F10x_SPI_H
N
N#ifdef __cplusplus
S extern "C" {
N#endif
N
N/* Includes ------------------------------------------------------------------*/
N#include "stm32f10x.h"
N
N/** @addtogroup STM32F10x_StdPeriph_Driver
N  * @{
N  */
N
N/** @addtogroup SPI
N  * @{
N  */ 
N
N/** @defgroup SPI_Exported_Types
N  * @{
N  */
N
N/** 
N  * @brief  SPI Init structure definition  
N  */
N
Ntypedef struct
N{
N  uint16_t SPI_Direction;           /*!< Specifies the SPI unidirectional or bidirectional data mode.
N                                         This parameter can be a value of @ref SPI_data_direction */
N
N  uint16_t SPI_Mode;                /*!< Specifies the SPI operating mode.
N                                         This parameter can be a value of @ref SPI_mode */
N
N  uint16_t SPI_DataSize;            /*!< Specifies the SPI data size.
N                                         This parameter can be a value of @ref SPI_data_size */
N
N  uint16_t SPI_CPOL;                /*!< Specifies the serial clock steady state.
N                                         This parameter can be a value of @ref SPI_Clock_Polarity */
N
N  uint16_t SPI_CPHA;                /*!< Specifies the clock active edge for the bit capture.
N                                         This parameter can be a value of @ref SPI_Clock_Phase */
N
N  uint16_t SPI_NSS;                 /*!< Specifies whether the NSS signal is managed by
N                                         hardware (NSS pin) or by software using the SSI bit.
N                                         This parameter can be a value of @ref SPI_Slave_Select_management */
N 
N  uint16_t SPI_BaudRatePrescaler;   /*!< Specifies the Baud Rate prescaler value which will be
N                                         used to configure the transmit and receive SCK clock.
N                                         This parameter can be a value of @ref SPI_BaudRate_Prescaler.
N                                         @note The communication clock is derived from the master
N                                               clock. The slave clock does not need to be set. */
N
N  uint16_t SPI_FirstBit;            /*!< Specifies whether data transfers start from MSB or LSB bit.
N                                         This parameter can be a value of @ref SPI_MSB_LSB_transmission */
N
N  uint16_t SPI_CRCPolynomial;       /*!< Specifies the polynomial used for the CRC calculation. */
N}SPI_InitTypeDef;
N
N/** 
N  * @brief  I2S Init structure definition  
N  */
N
Ntypedef struct
N{
N
N  uint16_t I2S_Mode;         /*!< Specifies the I2S operating mode.
N                                  This parameter can be a value of @ref I2S_Mode */
N
N  uint16_t I2S_Standard;     /*!< Specifies the standard used for the I2S communication.
N                                  This parameter can be a value of @ref I2S_Standard */
N
N  uint16_t I2S_DataFormat;   /*!< Specifies the data format for the I2S communication.
N                                  This parameter can be a value of @ref I2S_Data_Format */
N
N  uint16_t I2S_MCLKOutput;   /*!< Specifies whether the I2S MCLK output is enabled or not.
N                                  This parameter can be a value of @ref I2S_MCLK_Output */
N
N  uint32_t I2S_AudioFreq;    /*!< Specifies the frequency selected for the I2S communication.
N                                  This parameter can be a value of @ref I2S_Audio_Frequency */
N
N  uint16_t I2S_CPOL;         /*!< Specifies the idle state of the I2S clock.
N                                  This parameter can be a value of @ref I2S_Clock_Polarity */
N}I2S_InitTypeDef;
N
N/**
N  * @}
N  */
N
N/** @defgroup SPI_Exported_Constants
N  * @{
N  */
N
N#define IS_SPI_ALL_PERIPH(PERIPH) (((PERIPH) == SPI1) || \
N                                   ((PERIPH) == SPI2) || \
N                                   ((PERIPH) == SPI3))
X#define IS_SPI_ALL_PERIPH(PERIPH) (((PERIPH) == SPI1) ||                                    ((PERIPH) == SPI2) ||                                    ((PERIPH) == SPI3))
N
N#define IS_SPI_23_PERIPH(PERIPH) (((PERIPH) == SPI2) || \
N                                  ((PERIPH) == SPI3))
X#define IS_SPI_23_PERIPH(PERIPH) (((PERIPH) == SPI2) ||                                   ((PERIPH) == SPI3))
N
N/** @defgroup SPI_data_direction 
N  * @{
N  */
N  
N#define SPI_Direction_2Lines_FullDuplex ((uint16_t)0x0000)
N#define SPI_Direction_2Lines_RxOnly     ((uint16_t)0x0400)
N#define SPI_Direction_1Line_Rx          ((uint16_t)0x8000)
N#define SPI_Direction_1Line_Tx          ((uint16_t)0xC000)
N#define IS_SPI_DIRECTION_MODE(MODE) (((MODE) == SPI_Direction_2Lines_FullDuplex) || \
N                                     ((MODE) == SPI_Direction_2Lines_RxOnly) || \
N                                     ((MODE) == SPI_Direction_1Line_Rx) || \
N                                     ((MODE) == SPI_Direction_1Line_Tx))
X#define IS_SPI_DIRECTION_MODE(MODE) (((MODE) == SPI_Direction_2Lines_FullDuplex) ||                                      ((MODE) == SPI_Direction_2Lines_RxOnly) ||                                      ((MODE) == SPI_Direction_1Line_Rx) ||                                      ((MODE) == SPI_Direction_1Line_Tx))
N/**
N  * @}
N  */
N
N/** @defgroup SPI_mode 
N  * @{
N  */
N
N#define SPI_Mode_Master                 ((uint16_t)0x0104)
N#define SPI_Mode_Slave                  ((uint16_t)0x0000)
N#define IS_SPI_MODE(MODE) (((MODE) == SPI_Mode_Master) || \
N                           ((MODE) == SPI_Mode_Slave))
X#define IS_SPI_MODE(MODE) (((MODE) == SPI_Mode_Master) ||                            ((MODE) == SPI_Mode_Slave))
N/**
N  * @}
N  */
N
N/** @defgroup SPI_data_size 
N  * @{
N  */
N
N#define SPI_DataSize_16b                ((uint16_t)0x0800)
N#define SPI_DataSize_8b                 ((uint16_t)0x0000)
N#define IS_SPI_DATASIZE(DATASIZE) (((DATASIZE) == SPI_DataSize_16b) || \
N                                   ((DATASIZE) == SPI_DataSize_8b))
X#define IS_SPI_DATASIZE(DATASIZE) (((DATASIZE) == SPI_DataSize_16b) ||                                    ((DATASIZE) == SPI_DataSize_8b))
N/**
N  * @}
N  */ 
N
N/** @defgroup SPI_Clock_Polarity 
N  * @{
N  */
N
N#define SPI_CPOL_Low                    ((uint16_t)0x0000)
N#define SPI_CPOL_High                   ((uint16_t)0x0002)
N#define IS_SPI_CPOL(CPOL) (((CPOL) == SPI_CPOL_Low) || \
N                           ((CPOL) == SPI_CPOL_High))
X#define IS_SPI_CPOL(CPOL) (((CPOL) == SPI_CPOL_Low) ||                            ((CPOL) == SPI_CPOL_High))
N/**
N  * @}
N  */
N
N/** @defgroup SPI_Clock_Phase 
N  * @{
N  */
N
N#define SPI_CPHA_1Edge                  ((uint16_t)0x0000)
N#define SPI_CPHA_2Edge                  ((uint16_t)0x0001)
N#define IS_SPI_CPHA(CPHA) (((CPHA) == SPI_CPHA_1Edge) || \
N                           ((CPHA) == SPI_CPHA_2Edge))
X#define IS_SPI_CPHA(CPHA) (((CPHA) == SPI_CPHA_1Edge) ||                            ((CPHA) == SPI_CPHA_2Edge))
N/**
N  * @}
N  */
N
N/** @defgroup SPI_Slave_Select_management 
N  * @{
N  */
N
N#define SPI_NSS_Soft                    ((uint16_t)0x0200)
N#define SPI_NSS_Hard                    ((uint16_t)0x0000)
N#define IS_SPI_NSS(NSS) (((NSS) == SPI_NSS_Soft) || \
N                         ((NSS) == SPI_NSS_Hard))
X#define IS_SPI_NSS(NSS) (((NSS) == SPI_NSS_Soft) ||                          ((NSS) == SPI_NSS_Hard))
N/**
N  * @}
N  */ 
N
N/** @defgroup SPI_BaudRate_Prescaler 
N  * @{
N  */
N
N#define SPI_BaudRatePrescaler_2         ((uint16_t)0x0000)
N#define SPI_BaudRatePrescaler_4         ((uint16_t)0x0008)
N#define SPI_BaudRatePrescaler_8         ((uint16_t)0x0010)
N#define SPI_BaudRatePrescaler_16        ((uint16_t)0x0018)
N#define SPI_BaudRatePrescaler_32        ((uint16_t)0x0020)
N#define SPI_BaudRatePrescaler_64        ((uint16_t)0x0028)
N#define SPI_BaudRatePrescaler_128       ((uint16_t)0x0030)
N#define SPI_BaudRatePrescaler_256       ((uint16_t)0x0038)
N#define IS_SPI_BAUDRATE_PRESCALER(PRESCALER) (((PRESCALER) == SPI_BaudRatePrescaler_2) || \
N                                              ((PRESCALER) == SPI_BaudRatePrescaler_4) || \
N                                              ((PRESCALER) == SPI_BaudRatePrescaler_8) || \
N                                              ((PRESCALER) == SPI_BaudRatePrescaler_16) || \
N                                              ((PRESCALER) == SPI_BaudRatePrescaler_32) || \
N                                              ((PRESCALER) == SPI_BaudRatePrescaler_64) || \
N                                              ((PRESCALER) == SPI_BaudRatePrescaler_128) || \
N                                              ((PRESCALER) == SPI_BaudRatePrescaler_256))
X#define IS_SPI_BAUDRATE_PRESCALER(PRESCALER) (((PRESCALER) == SPI_BaudRatePrescaler_2) ||                                               ((PRESCALER) == SPI_BaudRatePrescaler_4) ||                                               ((PRESCALER) == SPI_BaudRatePrescaler_8) ||                                               ((PRESCALER) == SPI_BaudRatePrescaler_16) ||                                               ((PRESCALER) == SPI_BaudRatePrescaler_32) ||                                               ((PRESCALER) == SPI_BaudRatePrescaler_64) ||                                               ((PRESCALER) == SPI_BaudRatePrescaler_128) ||                                               ((PRESCALER) == SPI_BaudRatePrescaler_256))
N/**
N  * @}
N  */ 
N
N/** @defgroup SPI_MSB_LSB_transmission 
N  * @{
N  */
N
N#define SPI_FirstBit_MSB                ((uint16_t)0x0000)
N#define SPI_FirstBit_LSB                ((uint16_t)0x0080)
N#define IS_SPI_FIRST_BIT(BIT) (((BIT) == SPI_FirstBit_MSB) || \
N                               ((BIT) == SPI_FirstBit_LSB))
X#define IS_SPI_FIRST_BIT(BIT) (((BIT) == SPI_FirstBit_MSB) ||                                ((BIT) == SPI_FirstBit_LSB))
N/**
N  * @}
N  */
N
N/** @defgroup I2S_Mode 
N  * @{
N  */
N
N#define I2S_Mode_SlaveTx                ((uint16_t)0x0000)
N#define I2S_Mode_SlaveRx                ((uint16_t)0x0100)
N#define I2S_Mode_MasterTx               ((uint16_t)0x0200)
N#define I2S_Mode_MasterRx               ((uint16_t)0x0300)
N#define IS_I2S_MODE(MODE) (((MODE) == I2S_Mode_SlaveTx) || \
N                           ((MODE) == I2S_Mode_SlaveRx) || \
N                           ((MODE) == I2S_Mode_MasterTx) || \
N                           ((MODE) == I2S_Mode_MasterRx) )
X#define IS_I2S_MODE(MODE) (((MODE) == I2S_Mode_SlaveTx) ||                            ((MODE) == I2S_Mode_SlaveRx) ||                            ((MODE) == I2S_Mode_MasterTx) ||                            ((MODE) == I2S_Mode_MasterRx) )
N/**
N  * @}
N  */
N
N/** @defgroup I2S_Standard 
N  * @{
N  */
N
N#define I2S_Standard_Phillips           ((uint16_t)0x0000)
N#define I2S_Standard_MSB                ((uint16_t)0x0010)
N#define I2S_Standard_LSB                ((uint16_t)0x0020)
N#define I2S_Standard_PCMShort           ((uint16_t)0x0030)
N#define I2S_Standard_PCMLong            ((uint16_t)0x00B0)
N#define IS_I2S_STANDARD(STANDARD) (((STANDARD) == I2S_Standard_Phillips) || \
N                                   ((STANDARD) == I2S_Standard_MSB) || \
N                                   ((STANDARD) == I2S_Standard_LSB) || \
N                                   ((STANDARD) == I2S_Standard_PCMShort) || \
N                                   ((STANDARD) == I2S_Standard_PCMLong))
X#define IS_I2S_STANDARD(STANDARD) (((STANDARD) == I2S_Standard_Phillips) ||                                    ((STANDARD) == I2S_Standard_MSB) ||                                    ((STANDARD) == I2S_Standard_LSB) ||                                    ((STANDARD) == I2S_Standard_PCMShort) ||                                    ((STANDARD) == I2S_Standard_PCMLong))
N/**
N  * @}
N  */
N
N/** @defgroup I2S_Data_Format 
N  * @{
N  */
N
N#define I2S_DataFormat_16b              ((uint16_t)0x0000)
N#define I2S_DataFormat_16bextended      ((uint16_t)0x0001)
N#define I2S_DataFormat_24b              ((uint16_t)0x0003)
N#define I2S_DataFormat_32b              ((uint16_t)0x0005)
N#define IS_I2S_DATA_FORMAT(FORMAT) (((FORMAT) == I2S_DataFormat_16b) || \
N                                    ((FORMAT) == I2S_DataFormat_16bextended) || \
N                                    ((FORMAT) == I2S_DataFormat_24b) || \
N                                    ((FORMAT) == I2S_DataFormat_32b))
X#define IS_I2S_DATA_FORMAT(FORMAT) (((FORMAT) == I2S_DataFormat_16b) ||                                     ((FORMAT) == I2S_DataFormat_16bextended) ||                                     ((FORMAT) == I2S_DataFormat_24b) ||                                     ((FORMAT) == I2S_DataFormat_32b))
N/**
N  * @}
N  */ 
N
N/** @defgroup I2S_MCLK_Output 
N  * @{
N  */
N
N#define I2S_MCLKOutput_Enable           ((uint16_t)0x0200)
N#define I2S_MCLKOutput_Disable          ((uint16_t)0x0000)
N#define IS_I2S_MCLK_OUTPUT(OUTPUT) (((OUTPUT) == I2S_MCLKOutput_Enable) || \
N                                    ((OUTPUT) == I2S_MCLKOutput_Disable))
X#define IS_I2S_MCLK_OUTPUT(OUTPUT) (((OUTPUT) == I2S_MCLKOutput_Enable) ||                                     ((OUTPUT) == I2S_MCLKOutput_Disable))
N/**
N  * @}
N  */
N
N/** @defgroup I2S_Audio_Frequency 
N  * @{
N  */
N
N#define I2S_AudioFreq_192k               ((uint32_t)192000)
N#define I2S_AudioFreq_96k                ((uint32_t)96000)
N#define I2S_AudioFreq_48k                ((uint32_t)48000)
N#define I2S_AudioFreq_44k                ((uint32_t)44100)
N#define I2S_AudioFreq_32k                ((uint32_t)32000)
N#define I2S_AudioFreq_22k                ((uint32_t)22050)
N#define I2S_AudioFreq_16k                ((uint32_t)16000)
N#define I2S_AudioFreq_11k                ((uint32_t)11025)
N#define I2S_AudioFreq_8k                 ((uint32_t)8000)
N#define I2S_AudioFreq_Default            ((uint32_t)2)
N
N#define IS_I2S_AUDIO_FREQ(FREQ) ((((FREQ) >= I2S_AudioFreq_8k) && \
N                                  ((FREQ) <= I2S_AudioFreq_192k)) || \
N                                 ((FREQ) == I2S_AudioFreq_Default))
X#define IS_I2S_AUDIO_FREQ(FREQ) ((((FREQ) >= I2S_AudioFreq_8k) &&                                   ((FREQ) <= I2S_AudioFreq_192k)) ||                                  ((FREQ) == I2S_AudioFreq_Default))
N/**
N  * @}
N  */ 
N
N/** @defgroup I2S_Clock_Polarity 
N  * @{
N  */
N
N#define I2S_CPOL_Low                    ((uint16_t)0x0000)
N#define I2S_CPOL_High                   ((uint16_t)0x0008)
N#define IS_I2S_CPOL(CPOL) (((CPOL) == I2S_CPOL_Low) || \
N                           ((CPOL) == I2S_CPOL_High))
X#define IS_I2S_CPOL(CPOL) (((CPOL) == I2S_CPOL_Low) ||                            ((CPOL) == I2S_CPOL_High))
N/**
N  * @}
N  */
N
N/** @defgroup SPI_I2S_DMA_transfer_requests 
N  * @{
N  */
N
N#define SPI_I2S_DMAReq_Tx               ((uint16_t)0x0002)
N#define SPI_I2S_DMAReq_Rx               ((uint16_t)0x0001)
N#define IS_SPI_I2S_DMAREQ(DMAREQ) ((((DMAREQ) & (uint16_t)0xFFFC) == 0x00) && ((DMAREQ) != 0x00))
N/**
N  * @}
N  */
N
N/** @defgroup SPI_NSS_internal_software_management 
N  * @{
N  */
N
N#define SPI_NSSInternalSoft_Set         ((uint16_t)0x0100)
N#define SPI_NSSInternalSoft_Reset       ((uint16_t)0xFEFF)
N#define IS_SPI_NSS_INTERNAL(INTERNAL) (((INTERNAL) == SPI_NSSInternalSoft_Set) || \
N                                       ((INTERNAL) == SPI_NSSInternalSoft_Reset))
X#define IS_SPI_NSS_INTERNAL(INTERNAL) (((INTERNAL) == SPI_NSSInternalSoft_Set) ||                                        ((INTERNAL) == SPI_NSSInternalSoft_Reset))
N/**
N  * @}
N  */
N
N/** @defgroup SPI_CRC_Transmit_Receive 
N  * @{
N  */
N
N#define SPI_CRC_Tx                      ((uint8_t)0x00)
N#define SPI_CRC_Rx                      ((uint8_t)0x01)
N#define IS_SPI_CRC(CRC) (((CRC) == SPI_CRC_Tx) || ((CRC) == SPI_CRC_Rx))
N/**
N  * @}
N  */
N
N/** @defgroup SPI_direction_transmit_receive 
N  * @{
N  */
N
N#define SPI_Direction_Rx                ((uint16_t)0xBFFF)
N#define SPI_Direction_Tx                ((uint16_t)0x4000)
N#define IS_SPI_DIRECTION(DIRECTION) (((DIRECTION) == SPI_Direction_Rx) || \
N                                     ((DIRECTION) == SPI_Direction_Tx))
X#define IS_SPI_DIRECTION(DIRECTION) (((DIRECTION) == SPI_Direction_Rx) ||                                      ((DIRECTION) == SPI_Direction_Tx))
N/**
N  * @}
N  */
N
N/** @defgroup SPI_I2S_interrupts_definition 
N  * @{
N  */
N
N#define SPI_I2S_IT_TXE                  ((uint8_t)0x71)
N#define SPI_I2S_IT_RXNE                 ((uint8_t)0x60)
N#define SPI_I2S_IT_ERR                  ((uint8_t)0x50)
N#define IS_SPI_I2S_CONFIG_IT(IT) (((IT) == SPI_I2S_IT_TXE) || \
N                                 ((IT) == SPI_I2S_IT_RXNE) || \
N                                 ((IT) == SPI_I2S_IT_ERR))
X#define IS_SPI_I2S_CONFIG_IT(IT) (((IT) == SPI_I2S_IT_TXE) ||                                  ((IT) == SPI_I2S_IT_RXNE) ||                                  ((IT) == SPI_I2S_IT_ERR))
N#define SPI_I2S_IT_OVR                  ((uint8_t)0x56)
N#define SPI_IT_MODF                     ((uint8_t)0x55)
N#define SPI_IT_CRCERR                   ((uint8_t)0x54)
N#define I2S_IT_UDR                      ((uint8_t)0x53)
N#define IS_SPI_I2S_CLEAR_IT(IT) (((IT) == SPI_IT_CRCERR))
N#define IS_SPI_I2S_GET_IT(IT) (((IT) == SPI_I2S_IT_RXNE) || ((IT) == SPI_I2S_IT_TXE) || \
N                               ((IT) == I2S_IT_UDR) || ((IT) == SPI_IT_CRCERR) || \
N                               ((IT) == SPI_IT_MODF) || ((IT) == SPI_I2S_IT_OVR))
X#define IS_SPI_I2S_GET_IT(IT) (((IT) == SPI_I2S_IT_RXNE) || ((IT) == SPI_I2S_IT_TXE) ||                                ((IT) == I2S_IT_UDR) || ((IT) == SPI_IT_CRCERR) ||                                ((IT) == SPI_IT_MODF) || ((IT) == SPI_I2S_IT_OVR))
N/**
N  * @}
N  */
N
N/** @defgroup SPI_I2S_flags_definition 
N  * @{
N  */
N
N#define SPI_I2S_FLAG_RXNE               ((uint16_t)0x0001)
N#define SPI_I2S_FLAG_TXE                ((uint16_t)0x0002)
N#define I2S_FLAG_CHSIDE                 ((uint16_t)0x0004)
N#define I2S_FLAG_UDR                    ((uint16_t)0x0008)
N#define SPI_FLAG_CRCERR                 ((uint16_t)0x0010)
N#define SPI_FLAG_MODF                   ((uint16_t)0x0020)
N#define SPI_I2S_FLAG_OVR                ((uint16_t)0x0040)
N#define SPI_I2S_FLAG_BSY                ((uint16_t)0x0080)
N#define IS_SPI_I2S_CLEAR_FLAG(FLAG) (((FLAG) == SPI_FLAG_CRCERR))
N#define IS_SPI_I2S_GET_FLAG(FLAG) (((FLAG) == SPI_I2S_FLAG_BSY) || ((FLAG) == SPI_I2S_FLAG_OVR) || \
N                                   ((FLAG) == SPI_FLAG_MODF) || ((FLAG) == SPI_FLAG_CRCERR) || \
N                                   ((FLAG) == I2S_FLAG_UDR) || ((FLAG) == I2S_FLAG_CHSIDE) || \
N                                   ((FLAG) == SPI_I2S_FLAG_TXE) || ((FLAG) == SPI_I2S_FLAG_RXNE))
X#define IS_SPI_I2S_GET_FLAG(FLAG) (((FLAG) == SPI_I2S_FLAG_BSY) || ((FLAG) == SPI_I2S_FLAG_OVR) ||                                    ((FLAG) == SPI_FLAG_MODF) || ((FLAG) == SPI_FLAG_CRCERR) ||                                    ((FLAG) == I2S_FLAG_UDR) || ((FLAG) == I2S_FLAG_CHSIDE) ||                                    ((FLAG) == SPI_I2S_FLAG_TXE) || ((FLAG) == SPI_I2S_FLAG_RXNE))
N/**
N  * @}
N  */
N
N/** @defgroup SPI_CRC_polynomial 
N  * @{
N  */
N
N#define IS_SPI_CRC_POLYNOMIAL(POLYNOMIAL) ((POLYNOMIAL) >= 0x1)
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */
N
N/** @defgroup SPI_Exported_Macros
N  * @{
N  */
N
N/**
N  * @}
N  */
N
N/** @defgroup SPI_Exported_Functions
N  * @{
N  */
N
Nvoid SPI_I2S_DeInit(SPI_TypeDef* SPIx);
Nvoid SPI_Init(SPI_TypeDef* SPIx, SPI_InitTypeDef* SPI_InitStruct);
Nvoid I2S_Init(SPI_TypeDef* SPIx, I2S_InitTypeDef* I2S_InitStruct);
Nvoid SPI_StructInit(SPI_InitTypeDef* SPI_InitStruct);
Nvoid I2S_StructInit(I2S_InitTypeDef* I2S_InitStruct);
Nvoid SPI_Cmd(SPI_TypeDef* SPIx, FunctionalState NewState);
Nvoid I2S_Cmd(SPI_TypeDef* SPIx, FunctionalState NewState);
Nvoid SPI_I2S_ITConfig(SPI_TypeDef* SPIx, uint8_t SPI_I2S_IT, FunctionalState NewState);
Nvoid SPI_I2S_DMACmd(SPI_TypeDef* SPIx, uint16_t SPI_I2S_DMAReq, FunctionalState NewState);
Nvoid SPI_I2S_SendData(SPI_TypeDef* SPIx, uint16_t Data);
Nuint16_t SPI_I2S_ReceiveData(SPI_TypeDef* SPIx);
Nvoid SPI_NSSInternalSoftwareConfig(SPI_TypeDef* SPIx, uint16_t SPI_NSSInternalSoft);
Nvoid SPI_SSOutputCmd(SPI_TypeDef* SPIx, FunctionalState NewState);
Nvoid SPI_DataSizeConfig(SPI_TypeDef* SPIx, uint16_t SPI_DataSize);
Nvoid SPI_TransmitCRC(SPI_TypeDef* SPIx);
Nvoid SPI_CalculateCRC(SPI_TypeDef* SPIx, FunctionalState NewState);
Nuint16_t SPI_GetCRC(SPI_TypeDef* SPIx, uint8_t SPI_CRC);
Nuint16_t SPI_GetCRCPolynomial(SPI_TypeDef* SPIx);
Nvoid SPI_BiDirectionalLineConfig(SPI_TypeDef* SPIx, uint16_t SPI_Direction);
NFlagStatus SPI_I2S_GetFlagStatus(SPI_TypeDef* SPIx, uint16_t SPI_I2S_FLAG);
Nvoid SPI_I2S_ClearFlag(SPI_TypeDef* SPIx, uint16_t SPI_I2S_FLAG);
NITStatus SPI_I2S_GetITStatus(SPI_TypeDef* SPIx, uint8_t SPI_I2S_IT);
Nvoid SPI_I2S_ClearITPendingBit(SPI_TypeDef* SPIx, uint8_t SPI_I2S_IT);
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif /*__STM32F10x_SPI_H */
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */
N
N/******************* (C) COPYRIGHT 2011 STMicroelectronics *****END OF FILE****/
L 47 "..\..\User\stm32f10x_conf.h" 2
N#include "stm32f10x_tim.h" 
L 1 "..\..\Libraries\FWlib\inc\stm32f10x_tim.h" 1
N/**
N  ******************************************************************************
N  * @file    stm32f10x_tim.h
N  * @author  MCD Application Team
N  * @version V3.5.0
N  * @date    11-March-2011
N  * @brief   This file contains all the functions prototypes for the TIM firmware 
N  *          library.
N  ******************************************************************************
N  * @attention
N  *
N  * THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
N  * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE
N  * TIME. AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY
N  * DIRECT, INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING
N  * FROM THE CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE
N  * CODING INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
N  *
N  * <h2><center>&copy; COPYRIGHT 2011 STMicroelectronics</center></h2>
N  ******************************************************************************
N  */
N
N/* Define to prevent recursive inclusion -------------------------------------*/
N#ifndef __STM32F10x_TIM_H
N#define __STM32F10x_TIM_H
N
N#ifdef __cplusplus
S extern "C" {
N#endif
N
N/* Includes ------------------------------------------------------------------*/
N#include "stm32f10x.h"
N
N/** @addtogroup STM32F10x_StdPeriph_Driver
N  * @{
N  */
N
N/** @addtogroup TIM
N  * @{
N  */ 
N
N/** @defgroup TIM_Exported_Types
N  * @{
N  */ 
N
N/** 
N  * @brief  TIM Time Base Init structure definition
N  * @note   This structure is used with all TIMx except for TIM6 and TIM7.    
N  */
N
Ntypedef struct
N{
N  uint16_t TIM_Prescaler;         /*!< Specifies the prescaler value used to divide the TIM clock.
N                                       This parameter can be a number between 0x0000 and 0xFFFF */
N
N  uint16_t TIM_CounterMode;       /*!< Specifies the counter mode.
N                                       This parameter can be a value of @ref TIM_Counter_Mode */
N
N  uint16_t TIM_Period;            /*!< Specifies the period value to be loaded into the active
N                                       Auto-Reload Register at the next update event.
N                                       This parameter must be a number between 0x0000 and 0xFFFF.  */ 
N
N  uint16_t TIM_ClockDivision;     /*!< Specifies the clock division.
N                                      This parameter can be a value of @ref TIM_Clock_Division_CKD */
N
N  uint8_t TIM_RepetitionCounter;  /*!< Specifies the repetition counter value. Each time the RCR downcounter
N                                       reaches zero, an update event is generated and counting restarts
N                                       from the RCR value (N).
N                                       This means in PWM mode that (N+1) corresponds to:
N                                          - the number of PWM periods in edge-aligned mode
N                                          - the number of half PWM period in center-aligned mode
N                                       This parameter must be a number between 0x00 and 0xFF. 
N                                       @note This parameter is valid only for TIM1 and TIM8. */
N} TIM_TimeBaseInitTypeDef;       
N
N/** 
N  * @brief  TIM Output Compare Init structure definition  
N  */
N
Ntypedef struct
N{
N  uint16_t TIM_OCMode;        /*!< Specifies the TIM mode.
N                                   This parameter can be a value of @ref TIM_Output_Compare_and_PWM_modes */
N
N  uint16_t TIM_OutputState;   /*!< Specifies the TIM Output Compare state.
N                                   This parameter can be a value of @ref TIM_Output_Compare_state */
N
N  uint16_t TIM_OutputNState;  /*!< Specifies the TIM complementary Output Compare state.
N                                   This parameter can be a value of @ref TIM_Output_Compare_N_state
N                                   @note This parameter is valid only for TIM1 and TIM8. */
N
N  uint16_t TIM_Pulse;         /*!< Specifies the pulse value to be loaded into the Capture Compare Register. 
N                                   This parameter can be a number between 0x0000 and 0xFFFF */
N
N  uint16_t TIM_OCPolarity;    /*!< Specifies the output polarity.
N                                   This parameter can be a value of @ref TIM_Output_Compare_Polarity */
N
N  uint16_t TIM_OCNPolarity;   /*!< Specifies the complementary output polarity.
N                                   This parameter can be a value of @ref TIM_Output_Compare_N_Polarity
N                                   @note This parameter is valid only for TIM1 and TIM8. */
N
N  uint16_t TIM_OCIdleState;   /*!< Specifies the TIM Output Compare pin state during Idle state.
N                                   This parameter can be a value of @ref TIM_Output_Compare_Idle_State
N                                   @note This parameter is valid only for TIM1 and TIM8. */
N
N  uint16_t TIM_OCNIdleState;  /*!< Specifies the TIM Output Compare pin state during Idle state.
N                                   This parameter can be a value of @ref TIM_Output_Compare_N_Idle_State
N                                   @note This parameter is valid only for TIM1 and TIM8. */
N} TIM_OCInitTypeDef;
N
N/** 
N  * @brief  TIM Input Capture Init structure definition  
N  */
N
Ntypedef struct
N{
N
N  uint16_t TIM_Channel;      /*!< Specifies the TIM channel.
N                                  This parameter can be a value of @ref TIM_Channel */
N
N  uint16_t TIM_ICPolarity;   /*!< Specifies the active edge of the input signal.
N                                  This parameter can be a value of @ref TIM_Input_Capture_Polarity */
N
N  uint16_t TIM_ICSelection;  /*!< Specifies the input.
N                                  This parameter can be a value of @ref TIM_Input_Capture_Selection */
N
N  uint16_t TIM_ICPrescaler;  /*!< Specifies the Input Capture Prescaler.
N                                  This parameter can be a value of @ref TIM_Input_Capture_Prescaler */
N
N  uint16_t TIM_ICFilter;     /*!< Specifies the input capture filter.
N                                  This parameter can be a number between 0x0 and 0xF */
N} TIM_ICInitTypeDef;
N
N/** 
N  * @brief  BDTR structure definition 
N  * @note   This structure is used only with TIM1 and TIM8.    
N  */
N
Ntypedef struct
N{
N
N  uint16_t TIM_OSSRState;        /*!< Specifies the Off-State selection used in Run mode.
N                                      This parameter can be a value of @ref OSSR_Off_State_Selection_for_Run_mode_state */
N
N  uint16_t TIM_OSSIState;        /*!< Specifies the Off-State used in Idle state.
N                                      This parameter can be a value of @ref OSSI_Off_State_Selection_for_Idle_mode_state */
N
N  uint16_t TIM_LOCKLevel;        /*!< Specifies the LOCK level parameters.
N                                      This parameter can be a value of @ref Lock_level */ 
N
N  uint16_t TIM_DeadTime;         /*!< Specifies the delay time between the switching-off and the
N                                      switching-on of the outputs.
N                                      This parameter can be a number between 0x00 and 0xFF  */
N
N  uint16_t TIM_Break;            /*!< Specifies whether the TIM Break input is enabled or not. 
N                                      This parameter can be a value of @ref Break_Input_enable_disable */
N
N  uint16_t TIM_BreakPolarity;    /*!< Specifies the TIM Break Input pin polarity.
N                                      This parameter can be a value of @ref Break_Polarity */
N
N  uint16_t TIM_AutomaticOutput;  /*!< Specifies whether the TIM Automatic Output feature is enabled or not. 
N                                      This parameter can be a value of @ref TIM_AOE_Bit_Set_Reset */
N} TIM_BDTRInitTypeDef;
N
N/** @defgroup TIM_Exported_constants 
N  * @{
N  */
N
N#define IS_TIM_ALL_PERIPH(PERIPH) (((PERIPH) == TIM1) || \
N                                   ((PERIPH) == TIM2) || \
N                                   ((PERIPH) == TIM3) || \
N                                   ((PERIPH) == TIM4) || \
N                                   ((PERIPH) == TIM5) || \
N                                   ((PERIPH) == TIM6) || \
N                                   ((PERIPH) == TIM7) || \
N                                   ((PERIPH) == TIM8) || \
N                                   ((PERIPH) == TIM9) || \
N                                   ((PERIPH) == TIM10)|| \
N                                   ((PERIPH) == TIM11)|| \
N                                   ((PERIPH) == TIM12)|| \
N                                   ((PERIPH) == TIM13)|| \
N                                   ((PERIPH) == TIM14)|| \
N                                   ((PERIPH) == TIM15)|| \
N                                   ((PERIPH) == TIM16)|| \
N                                   ((PERIPH) == TIM17))
X#define IS_TIM_ALL_PERIPH(PERIPH) (((PERIPH) == TIM1) ||                                    ((PERIPH) == TIM2) ||                                    ((PERIPH) == TIM3) ||                                    ((PERIPH) == TIM4) ||                                    ((PERIPH) == TIM5) ||                                    ((PERIPH) == TIM6) ||                                    ((PERIPH) == TIM7) ||                                    ((PERIPH) == TIM8) ||                                    ((PERIPH) == TIM9) ||                                    ((PERIPH) == TIM10)||                                    ((PERIPH) == TIM11)||                                    ((PERIPH) == TIM12)||                                    ((PERIPH) == TIM13)||                                    ((PERIPH) == TIM14)||                                    ((PERIPH) == TIM15)||                                    ((PERIPH) == TIM16)||                                    ((PERIPH) == TIM17))
N
N/* LIST1: TIM 1 and 8 */
N#define IS_TIM_LIST1_PERIPH(PERIPH)  (((PERIPH) == TIM1) || \
N                                      ((PERIPH) == TIM8))
X#define IS_TIM_LIST1_PERIPH(PERIPH)  (((PERIPH) == TIM1) ||                                       ((PERIPH) == TIM8))
N
N/* LIST2: TIM 1, 8, 15 16 and 17 */
N#define IS_TIM_LIST2_PERIPH(PERIPH) (((PERIPH) == TIM1) || \
N                                     ((PERIPH) == TIM8) || \
N                                     ((PERIPH) == TIM15)|| \
N                                     ((PERIPH) == TIM16)|| \
N                                     ((PERIPH) == TIM17)) 
X#define IS_TIM_LIST2_PERIPH(PERIPH) (((PERIPH) == TIM1) ||                                      ((PERIPH) == TIM8) ||                                      ((PERIPH) == TIM15)||                                      ((PERIPH) == TIM16)||                                      ((PERIPH) == TIM17)) 
N
N/* LIST3: TIM 1, 2, 3, 4, 5 and 8 */
N#define IS_TIM_LIST3_PERIPH(PERIPH) (((PERIPH) == TIM1) || \
N                                     ((PERIPH) == TIM2) || \
N                                     ((PERIPH) == TIM3) || \
N                                     ((PERIPH) == TIM4) || \
N                                     ((PERIPH) == TIM5) || \
N                                     ((PERIPH) == TIM8)) 
X#define IS_TIM_LIST3_PERIPH(PERIPH) (((PERIPH) == TIM1) ||                                      ((PERIPH) == TIM2) ||                                      ((PERIPH) == TIM3) ||                                      ((PERIPH) == TIM4) ||                                      ((PERIPH) == TIM5) ||                                      ((PERIPH) == TIM8)) 
N									                                 
N/* LIST4: TIM 1, 2, 3, 4, 5, 8, 15, 16 and 17 */
N#define IS_TIM_LIST4_PERIPH(PERIPH) (((PERIPH) == TIM1) || \
N                                     ((PERIPH) == TIM2) || \
N                                     ((PERIPH) == TIM3) || \
N                                     ((PERIPH) == TIM4) || \
N                                     ((PERIPH) == TIM5) || \
N                                     ((PERIPH) == TIM8) || \
N                                     ((PERIPH) == TIM15)|| \
N                                     ((PERIPH) == TIM16)|| \
N                                     ((PERIPH) == TIM17))
X#define IS_TIM_LIST4_PERIPH(PERIPH) (((PERIPH) == TIM1) ||                                      ((PERIPH) == TIM2) ||                                      ((PERIPH) == TIM3) ||                                      ((PERIPH) == TIM4) ||                                      ((PERIPH) == TIM5) ||                                      ((PERIPH) == TIM8) ||                                      ((PERIPH) == TIM15)||                                      ((PERIPH) == TIM16)||                                      ((PERIPH) == TIM17))
N
N/* LIST5: TIM 1, 2, 3, 4, 5, 8 and 15 */                                            
N#define IS_TIM_LIST5_PERIPH(PERIPH) (((PERIPH) == TIM1) || \
N                                     ((PERIPH) == TIM2) || \
N                                     ((PERIPH) == TIM3) || \
N                                     ((PERIPH) == TIM4) || \
N                                     ((PERIPH) == TIM5) || \
N                                     ((PERIPH) == TIM8) || \
N                                     ((PERIPH) == TIM15)) 
X#define IS_TIM_LIST5_PERIPH(PERIPH) (((PERIPH) == TIM1) ||                                      ((PERIPH) == TIM2) ||                                      ((PERIPH) == TIM3) ||                                      ((PERIPH) == TIM4) ||                                      ((PERIPH) == TIM5) ||                                      ((PERIPH) == TIM8) ||                                      ((PERIPH) == TIM15)) 
N
N/* LIST6: TIM 1, 2, 3, 4, 5, 8, 9, 12 and 15 */
N#define IS_TIM_LIST6_PERIPH(PERIPH)  (((PERIPH) == TIM1) || \
N                                      ((PERIPH) == TIM2) || \
N                                      ((PERIPH) == TIM3) || \
N                                      ((PERIPH) == TIM4) || \
N                                      ((PERIPH) == TIM5) || \
N                                      ((PERIPH) == TIM8) || \
N                                      ((PERIPH) == TIM9) || \
N									  ((PERIPH) == TIM12)|| \
N                                      ((PERIPH) == TIM15))
X#define IS_TIM_LIST6_PERIPH(PERIPH)  (((PERIPH) == TIM1) ||                                       ((PERIPH) == TIM2) ||                                       ((PERIPH) == TIM3) ||                                       ((PERIPH) == TIM4) ||                                       ((PERIPH) == TIM5) ||                                       ((PERIPH) == TIM8) ||                                       ((PERIPH) == TIM9) || 									  ((PERIPH) == TIM12)||                                       ((PERIPH) == TIM15))
N
N/* LIST7: TIM 1, 2, 3, 4, 5, 6, 7, 8, 9, 12 and 15 */
N#define IS_TIM_LIST7_PERIPH(PERIPH)  (((PERIPH) == TIM1) || \
N                                      ((PERIPH) == TIM2) || \
N                                      ((PERIPH) == TIM3) || \
N                                      ((PERIPH) == TIM4) || \
N                                      ((PERIPH) == TIM5) || \
N                                      ((PERIPH) == TIM6) || \
N                                      ((PERIPH) == TIM7) || \
N                                      ((PERIPH) == TIM8) || \
N                                      ((PERIPH) == TIM9) || \
N                                      ((PERIPH) == TIM12)|| \
N                                      ((PERIPH) == TIM15))                                    
X#define IS_TIM_LIST7_PERIPH(PERIPH)  (((PERIPH) == TIM1) ||                                       ((PERIPH) == TIM2) ||                                       ((PERIPH) == TIM3) ||                                       ((PERIPH) == TIM4) ||                                       ((PERIPH) == TIM5) ||                                       ((PERIPH) == TIM6) ||                                       ((PERIPH) == TIM7) ||                                       ((PERIPH) == TIM8) ||                                       ((PERIPH) == TIM9) ||                                       ((PERIPH) == TIM12)||                                       ((PERIPH) == TIM15))                                    
N
N/* LIST8: TIM 1, 2, 3, 4, 5, 8, 9, 10, 11, 12, 13, 14, 15, 16 and 17 */                                        
N#define IS_TIM_LIST8_PERIPH(PERIPH)  (((PERIPH) == TIM1) || \
N                                      ((PERIPH) == TIM2) || \
N                                      ((PERIPH) == TIM3) || \
N                                      ((PERIPH) == TIM4) || \
N                                      ((PERIPH) == TIM5) || \
N                                      ((PERIPH) == TIM8) || \
N                                      ((PERIPH) == TIM9) || \
N                                      ((PERIPH) == TIM10)|| \
N                                      ((PERIPH) == TIM11)|| \
N                                      ((PERIPH) == TIM12)|| \
N                                      ((PERIPH) == TIM13)|| \
N                                      ((PERIPH) == TIM14)|| \
N                                      ((PERIPH) == TIM15)|| \
N                                      ((PERIPH) == TIM16)|| \
N                                      ((PERIPH) == TIM17))
X#define IS_TIM_LIST8_PERIPH(PERIPH)  (((PERIPH) == TIM1) ||                                       ((PERIPH) == TIM2) ||                                       ((PERIPH) == TIM3) ||                                       ((PERIPH) == TIM4) ||                                       ((PERIPH) == TIM5) ||                                       ((PERIPH) == TIM8) ||                                       ((PERIPH) == TIM9) ||                                       ((PERIPH) == TIM10)||                                       ((PERIPH) == TIM11)||                                       ((PERIPH) == TIM12)||                                       ((PERIPH) == TIM13)||                                       ((PERIPH) == TIM14)||                                       ((PERIPH) == TIM15)||                                       ((PERIPH) == TIM16)||                                       ((PERIPH) == TIM17))
N
N/* LIST9: TIM 1, 2, 3, 4, 5, 6, 7, 8, 15, 16, and 17 */
N#define IS_TIM_LIST9_PERIPH(PERIPH)  (((PERIPH) == TIM1) || \
N                                      ((PERIPH) == TIM2) || \
N                                      ((PERIPH) == TIM3) || \
N                                      ((PERIPH) == TIM4) || \
N                                      ((PERIPH) == TIM5) || \
N                                      ((PERIPH) == TIM6) || \
N                                      ((PERIPH) == TIM7) || \
N                                      ((PERIPH) == TIM8) || \
N                                      ((PERIPH) == TIM15)|| \
N                                      ((PERIPH) == TIM16)|| \
N                                      ((PERIPH) == TIM17))  
X#define IS_TIM_LIST9_PERIPH(PERIPH)  (((PERIPH) == TIM1) ||                                       ((PERIPH) == TIM2) ||                                       ((PERIPH) == TIM3) ||                                       ((PERIPH) == TIM4) ||                                       ((PERIPH) == TIM5) ||                                       ((PERIPH) == TIM6) ||                                       ((PERIPH) == TIM7) ||                                       ((PERIPH) == TIM8) ||                                       ((PERIPH) == TIM15)||                                       ((PERIPH) == TIM16)||                                       ((PERIPH) == TIM17))  
N                                                                                                                                                                                                                          
N/**
N  * @}
N  */ 
N
N/** @defgroup TIM_Output_Compare_and_PWM_modes 
N  * @{
N  */
N
N#define TIM_OCMode_Timing                  ((uint16_t)0x0000)
N#define TIM_OCMode_Active                  ((uint16_t)0x0010)
N#define TIM_OCMode_Inactive                ((uint16_t)0x0020)
N#define TIM_OCMode_Toggle                  ((uint16_t)0x0030)
N#define TIM_OCMode_PWM1                    ((uint16_t)0x0060)
N#define TIM_OCMode_PWM2                    ((uint16_t)0x0070)
N#define IS_TIM_OC_MODE(MODE) (((MODE) == TIM_OCMode_Timing) || \
N                              ((MODE) == TIM_OCMode_Active) || \
N                              ((MODE) == TIM_OCMode_Inactive) || \
N                              ((MODE) == TIM_OCMode_Toggle)|| \
N                              ((MODE) == TIM_OCMode_PWM1) || \
N                              ((MODE) == TIM_OCMode_PWM2))
X#define IS_TIM_OC_MODE(MODE) (((MODE) == TIM_OCMode_Timing) ||                               ((MODE) == TIM_OCMode_Active) ||                               ((MODE) == TIM_OCMode_Inactive) ||                               ((MODE) == TIM_OCMode_Toggle)||                               ((MODE) == TIM_OCMode_PWM1) ||                               ((MODE) == TIM_OCMode_PWM2))
N#define IS_TIM_OCM(MODE) (((MODE) == TIM_OCMode_Timing) || \
N                          ((MODE) == TIM_OCMode_Active) || \
N                          ((MODE) == TIM_OCMode_Inactive) || \
N                          ((MODE) == TIM_OCMode_Toggle)|| \
N                          ((MODE) == TIM_OCMode_PWM1) || \
N                          ((MODE) == TIM_OCMode_PWM2) ||	\
N                          ((MODE) == TIM_ForcedAction_Active) || \
N                          ((MODE) == TIM_ForcedAction_InActive))
X#define IS_TIM_OCM(MODE) (((MODE) == TIM_OCMode_Timing) ||                           ((MODE) == TIM_OCMode_Active) ||                           ((MODE) == TIM_OCMode_Inactive) ||                           ((MODE) == TIM_OCMode_Toggle)||                           ((MODE) == TIM_OCMode_PWM1) ||                           ((MODE) == TIM_OCMode_PWM2) ||	                          ((MODE) == TIM_ForcedAction_Active) ||                           ((MODE) == TIM_ForcedAction_InActive))
N/**
N  * @}
N  */
N
N/** @defgroup TIM_One_Pulse_Mode 
N  * @{
N  */
N
N#define TIM_OPMode_Single                  ((uint16_t)0x0008)
N#define TIM_OPMode_Repetitive              ((uint16_t)0x0000)
N#define IS_TIM_OPM_MODE(MODE) (((MODE) == TIM_OPMode_Single) || \
N                               ((MODE) == TIM_OPMode_Repetitive))
X#define IS_TIM_OPM_MODE(MODE) (((MODE) == TIM_OPMode_Single) ||                                ((MODE) == TIM_OPMode_Repetitive))
N/**
N  * @}
N  */ 
N
N/** @defgroup TIM_Channel 
N  * @{
N  */
N
N#define TIM_Channel_1                      ((uint16_t)0x0000)
N#define TIM_Channel_2                      ((uint16_t)0x0004)
N#define TIM_Channel_3                      ((uint16_t)0x0008)
N#define TIM_Channel_4                      ((uint16_t)0x000C)
N#define IS_TIM_CHANNEL(CHANNEL) (((CHANNEL) == TIM_Channel_1) || \
N                                 ((CHANNEL) == TIM_Channel_2) || \
N                                 ((CHANNEL) == TIM_Channel_3) || \
N                                 ((CHANNEL) == TIM_Channel_4))
X#define IS_TIM_CHANNEL(CHANNEL) (((CHANNEL) == TIM_Channel_1) ||                                  ((CHANNEL) == TIM_Channel_2) ||                                  ((CHANNEL) == TIM_Channel_3) ||                                  ((CHANNEL) == TIM_Channel_4))
N#define IS_TIM_PWMI_CHANNEL(CHANNEL) (((CHANNEL) == TIM_Channel_1) || \
N                                      ((CHANNEL) == TIM_Channel_2))
X#define IS_TIM_PWMI_CHANNEL(CHANNEL) (((CHANNEL) == TIM_Channel_1) ||                                       ((CHANNEL) == TIM_Channel_2))
N#define IS_TIM_COMPLEMENTARY_CHANNEL(CHANNEL) (((CHANNEL) == TIM_Channel_1) || \
N                                               ((CHANNEL) == TIM_Channel_2) || \
N                                               ((CHANNEL) == TIM_Channel_3))
X#define IS_TIM_COMPLEMENTARY_CHANNEL(CHANNEL) (((CHANNEL) == TIM_Channel_1) ||                                                ((CHANNEL) == TIM_Channel_2) ||                                                ((CHANNEL) == TIM_Channel_3))
N/**
N  * @}
N  */ 
N
N/** @defgroup TIM_Clock_Division_CKD 
N  * @{
N  */
N
N#define TIM_CKD_DIV1                       ((uint16_t)0x0000)
N#define TIM_CKD_DIV2                       ((uint16_t)0x0100)
N#define TIM_CKD_DIV4                       ((uint16_t)0x0200)
N#define IS_TIM_CKD_DIV(DIV) (((DIV) == TIM_CKD_DIV1) || \
N                             ((DIV) == TIM_CKD_DIV2) || \
N                             ((DIV) == TIM_CKD_DIV4))
X#define IS_TIM_CKD_DIV(DIV) (((DIV) == TIM_CKD_DIV1) ||                              ((DIV) == TIM_CKD_DIV2) ||                              ((DIV) == TIM_CKD_DIV4))
N/**
N  * @}
N  */
N
N/** @defgroup TIM_Counter_Mode 
N  * @{
N  */
N
N#define TIM_CounterMode_Up                 ((uint16_t)0x0000)
N#define TIM_CounterMode_Down               ((uint16_t)0x0010)
N#define TIM_CounterMode_CenterAligned1     ((uint16_t)0x0020)
N#define TIM_CounterMode_CenterAligned2     ((uint16_t)0x0040)
N#define TIM_CounterMode_CenterAligned3     ((uint16_t)0x0060)
N#define IS_TIM_COUNTER_MODE(MODE) (((MODE) == TIM_CounterMode_Up) ||  \
N                                   ((MODE) == TIM_CounterMode_Down) || \
N                                   ((MODE) == TIM_CounterMode_CenterAligned1) || \
N                                   ((MODE) == TIM_CounterMode_CenterAligned2) || \
N                                   ((MODE) == TIM_CounterMode_CenterAligned3))
X#define IS_TIM_COUNTER_MODE(MODE) (((MODE) == TIM_CounterMode_Up) ||                                     ((MODE) == TIM_CounterMode_Down) ||                                    ((MODE) == TIM_CounterMode_CenterAligned1) ||                                    ((MODE) == TIM_CounterMode_CenterAligned2) ||                                    ((MODE) == TIM_CounterMode_CenterAligned3))
N/**
N  * @}
N  */ 
N
N/** @defgroup TIM_Output_Compare_Polarity 
N  * @{
N  */
N
N#define TIM_OCPolarity_High                ((uint16_t)0x0000)
N#define TIM_OCPolarity_Low                 ((uint16_t)0x0002)
N#define IS_TIM_OC_POLARITY(POLARITY) (((POLARITY) == TIM_OCPolarity_High) || \
N                                      ((POLARITY) == TIM_OCPolarity_Low))
X#define IS_TIM_OC_POLARITY(POLARITY) (((POLARITY) == TIM_OCPolarity_High) ||                                       ((POLARITY) == TIM_OCPolarity_Low))
N/**
N  * @}
N  */
N
N/** @defgroup TIM_Output_Compare_N_Polarity 
N  * @{
N  */
N  
N#define TIM_OCNPolarity_High               ((uint16_t)0x0000)
N#define TIM_OCNPolarity_Low                ((uint16_t)0x0008)
N#define IS_TIM_OCN_POLARITY(POLARITY) (((POLARITY) == TIM_OCNPolarity_High) || \
N                                       ((POLARITY) == TIM_OCNPolarity_Low))
X#define IS_TIM_OCN_POLARITY(POLARITY) (((POLARITY) == TIM_OCNPolarity_High) ||                                        ((POLARITY) == TIM_OCNPolarity_Low))
N/**
N  * @}
N  */
N
N/** @defgroup TIM_Output_Compare_state 
N  * @{
N  */
N
N#define TIM_OutputState_Disable            ((uint16_t)0x0000)
N#define TIM_OutputState_Enable             ((uint16_t)0x0001)
N#define IS_TIM_OUTPUT_STATE(STATE) (((STATE) == TIM_OutputState_Disable) || \
N                                    ((STATE) == TIM_OutputState_Enable))
X#define IS_TIM_OUTPUT_STATE(STATE) (((STATE) == TIM_OutputState_Disable) ||                                     ((STATE) == TIM_OutputState_Enable))
N/**
N  * @}
N  */ 
N
N/** @defgroup TIM_Output_Compare_N_state 
N  * @{
N  */
N
N#define TIM_OutputNState_Disable           ((uint16_t)0x0000)
N#define TIM_OutputNState_Enable            ((uint16_t)0x0004)
N#define IS_TIM_OUTPUTN_STATE(STATE) (((STATE) == TIM_OutputNState_Disable) || \
N                                     ((STATE) == TIM_OutputNState_Enable))
X#define IS_TIM_OUTPUTN_STATE(STATE) (((STATE) == TIM_OutputNState_Disable) ||                                      ((STATE) == TIM_OutputNState_Enable))
N/**
N  * @}
N  */ 
N
N/** @defgroup TIM_Capture_Compare_state 
N  * @{
N  */
N
N#define TIM_CCx_Enable                      ((uint16_t)0x0001)
N#define TIM_CCx_Disable                     ((uint16_t)0x0000)
N#define IS_TIM_CCX(CCX) (((CCX) == TIM_CCx_Enable) || \
N                         ((CCX) == TIM_CCx_Disable))
X#define IS_TIM_CCX(CCX) (((CCX) == TIM_CCx_Enable) ||                          ((CCX) == TIM_CCx_Disable))
N/**
N  * @}
N  */ 
N
N/** @defgroup TIM_Capture_Compare_N_state 
N  * @{
N  */
N
N#define TIM_CCxN_Enable                     ((uint16_t)0x0004)
N#define TIM_CCxN_Disable                    ((uint16_t)0x0000)
N#define IS_TIM_CCXN(CCXN) (((CCXN) == TIM_CCxN_Enable) || \
N                           ((CCXN) == TIM_CCxN_Disable))
X#define IS_TIM_CCXN(CCXN) (((CCXN) == TIM_CCxN_Enable) ||                            ((CCXN) == TIM_CCxN_Disable))
N/**
N  * @}
N  */ 
N
N/** @defgroup Break_Input_enable_disable 
N  * @{
N  */
N
N#define TIM_Break_Enable                   ((uint16_t)0x1000)
N#define TIM_Break_Disable                  ((uint16_t)0x0000)
N#define IS_TIM_BREAK_STATE(STATE) (((STATE) == TIM_Break_Enable) || \
N                                   ((STATE) == TIM_Break_Disable))
X#define IS_TIM_BREAK_STATE(STATE) (((STATE) == TIM_Break_Enable) ||                                    ((STATE) == TIM_Break_Disable))
N/**
N  * @}
N  */ 
N
N/** @defgroup Break_Polarity 
N  * @{
N  */
N
N#define TIM_BreakPolarity_Low              ((uint16_t)0x0000)
N#define TIM_BreakPolarity_High             ((uint16_t)0x2000)
N#define IS_TIM_BREAK_POLARITY(POLARITY) (((POLARITY) == TIM_BreakPolarity_Low) || \
N                                         ((POLARITY) == TIM_BreakPolarity_High))
X#define IS_TIM_BREAK_POLARITY(POLARITY) (((POLARITY) == TIM_BreakPolarity_Low) ||                                          ((POLARITY) == TIM_BreakPolarity_High))
N/**
N  * @}
N  */ 
N
N/** @defgroup TIM_AOE_Bit_Set_Reset 
N  * @{
N  */
N
N#define TIM_AutomaticOutput_Enable         ((uint16_t)0x4000)
N#define TIM_AutomaticOutput_Disable        ((uint16_t)0x0000)
N#define IS_TIM_AUTOMATIC_OUTPUT_STATE(STATE) (((STATE) == TIM_AutomaticOutput_Enable) || \
N                                              ((STATE) == TIM_AutomaticOutput_Disable))
X#define IS_TIM_AUTOMATIC_OUTPUT_STATE(STATE) (((STATE) == TIM_AutomaticOutput_Enable) ||                                               ((STATE) == TIM_AutomaticOutput_Disable))
N/**
N  * @}
N  */ 
N
N/** @defgroup Lock_level 
N  * @{
N  */
N
N#define TIM_LOCKLevel_OFF                  ((uint16_t)0x0000)
N#define TIM_LOCKLevel_1                    ((uint16_t)0x0100)
N#define TIM_LOCKLevel_2                    ((uint16_t)0x0200)
N#define TIM_LOCKLevel_3                    ((uint16_t)0x0300)
N#define IS_TIM_LOCK_LEVEL(LEVEL) (((LEVEL) == TIM_LOCKLevel_OFF) || \
N                                  ((LEVEL) == TIM_LOCKLevel_1) || \
N                                  ((LEVEL) == TIM_LOCKLevel_2) || \
N                                  ((LEVEL) == TIM_LOCKLevel_3))
X#define IS_TIM_LOCK_LEVEL(LEVEL) (((LEVEL) == TIM_LOCKLevel_OFF) ||                                   ((LEVEL) == TIM_LOCKLevel_1) ||                                   ((LEVEL) == TIM_LOCKLevel_2) ||                                   ((LEVEL) == TIM_LOCKLevel_3))
N/**
N  * @}
N  */ 
N
N/** @defgroup OSSI_Off_State_Selection_for_Idle_mode_state 
N  * @{
N  */
N
N#define TIM_OSSIState_Enable               ((uint16_t)0x0400)
N#define TIM_OSSIState_Disable              ((uint16_t)0x0000)
N#define IS_TIM_OSSI_STATE(STATE) (((STATE) == TIM_OSSIState_Enable) || \
N                                  ((STATE) == TIM_OSSIState_Disable))
X#define IS_TIM_OSSI_STATE(STATE) (((STATE) == TIM_OSSIState_Enable) ||                                   ((STATE) == TIM_OSSIState_Disable))
N/**
N  * @}
N  */
N
N/** @defgroup OSSR_Off_State_Selection_for_Run_mode_state 
N  * @{
N  */
N
N#define TIM_OSSRState_Enable               ((uint16_t)0x0800)
N#define TIM_OSSRState_Disable              ((uint16_t)0x0000)
N#define IS_TIM_OSSR_STATE(STATE) (((STATE) == TIM_OSSRState_Enable) || \
N                                  ((STATE) == TIM_OSSRState_Disable))
X#define IS_TIM_OSSR_STATE(STATE) (((STATE) == TIM_OSSRState_Enable) ||                                   ((STATE) == TIM_OSSRState_Disable))
N/**
N  * @}
N  */ 
N
N/** @defgroup TIM_Output_Compare_Idle_State 
N  * @{
N  */
N
N#define TIM_OCIdleState_Set                ((uint16_t)0x0100)
N#define TIM_OCIdleState_Reset              ((uint16_t)0x0000)
N#define IS_TIM_OCIDLE_STATE(STATE) (((STATE) == TIM_OCIdleState_Set) || \
N                                    ((STATE) == TIM_OCIdleState_Reset))
X#define IS_TIM_OCIDLE_STATE(STATE) (((STATE) == TIM_OCIdleState_Set) ||                                     ((STATE) == TIM_OCIdleState_Reset))
N/**
N  * @}
N  */ 
N
N/** @defgroup TIM_Output_Compare_N_Idle_State 
N  * @{
N  */
N
N#define TIM_OCNIdleState_Set               ((uint16_t)0x0200)
N#define TIM_OCNIdleState_Reset             ((uint16_t)0x0000)
N#define IS_TIM_OCNIDLE_STATE(STATE) (((STATE) == TIM_OCNIdleState_Set) || \
N                                     ((STATE) == TIM_OCNIdleState_Reset))
X#define IS_TIM_OCNIDLE_STATE(STATE) (((STATE) == TIM_OCNIdleState_Set) ||                                      ((STATE) == TIM_OCNIdleState_Reset))
N/**
N  * @}
N  */ 
N
N/** @defgroup TIM_Input_Capture_Polarity 
N  * @{
N  */
N
N#define  TIM_ICPolarity_Rising             ((uint16_t)0x0000)
N#define  TIM_ICPolarity_Falling            ((uint16_t)0x0002)
N#define  TIM_ICPolarity_BothEdge           ((uint16_t)0x000A)
N#define IS_TIM_IC_POLARITY(POLARITY) (((POLARITY) == TIM_ICPolarity_Rising) || \
N                                      ((POLARITY) == TIM_ICPolarity_Falling))
X#define IS_TIM_IC_POLARITY(POLARITY) (((POLARITY) == TIM_ICPolarity_Rising) ||                                       ((POLARITY) == TIM_ICPolarity_Falling))
N#define IS_TIM_IC_POLARITY_LITE(POLARITY) (((POLARITY) == TIM_ICPolarity_Rising) || \
N                                           ((POLARITY) == TIM_ICPolarity_Falling)|| \
N                                           ((POLARITY) == TIM_ICPolarity_BothEdge))                                      
X#define IS_TIM_IC_POLARITY_LITE(POLARITY) (((POLARITY) == TIM_ICPolarity_Rising) ||                                            ((POLARITY) == TIM_ICPolarity_Falling)||                                            ((POLARITY) == TIM_ICPolarity_BothEdge))                                      
N/**
N  * @}
N  */ 
N
N/** @defgroup TIM_Input_Capture_Selection 
N  * @{
N  */
N
N#define TIM_ICSelection_DirectTI           ((uint16_t)0x0001) /*!< TIM Input 1, 2, 3 or 4 is selected to be 
N                                                                   connected to IC1, IC2, IC3 or IC4, respectively */
N#define TIM_ICSelection_IndirectTI         ((uint16_t)0x0002) /*!< TIM Input 1, 2, 3 or 4 is selected to be
N                                                                   connected to IC2, IC1, IC4 or IC3, respectively. */
N#define TIM_ICSelection_TRC                ((uint16_t)0x0003) /*!< TIM Input 1, 2, 3 or 4 is selected to be connected to TRC. */
N#define IS_TIM_IC_SELECTION(SELECTION) (((SELECTION) == TIM_ICSelection_DirectTI) || \
N                                        ((SELECTION) == TIM_ICSelection_IndirectTI) || \
N                                        ((SELECTION) == TIM_ICSelection_TRC))
X#define IS_TIM_IC_SELECTION(SELECTION) (((SELECTION) == TIM_ICSelection_DirectTI) ||                                         ((SELECTION) == TIM_ICSelection_IndirectTI) ||                                         ((SELECTION) == TIM_ICSelection_TRC))
N/**
N  * @}
N  */ 
N
N/** @defgroup TIM_Input_Capture_Prescaler 
N  * @{
N  */
N
N#define TIM_ICPSC_DIV1                     ((uint16_t)0x0000) /*!< Capture performed each time an edge is detected on the capture input. */
N#define TIM_ICPSC_DIV2                     ((uint16_t)0x0004) /*!< Capture performed once every 2 events. */
N#define TIM_ICPSC_DIV4                     ((uint16_t)0x0008) /*!< Capture performed once every 4 events. */
N#define TIM_ICPSC_DIV8                     ((uint16_t)0x000C) /*!< Capture performed once every 8 events. */
N#define IS_TIM_IC_PRESCALER(PRESCALER) (((PRESCALER) == TIM_ICPSC_DIV1) || \
N                                        ((PRESCALER) == TIM_ICPSC_DIV2) || \
N                                        ((PRESCALER) == TIM_ICPSC_DIV4) || \
N                                        ((PRESCALER) == TIM_ICPSC_DIV8))
X#define IS_TIM_IC_PRESCALER(PRESCALER) (((PRESCALER) == TIM_ICPSC_DIV1) ||                                         ((PRESCALER) == TIM_ICPSC_DIV2) ||                                         ((PRESCALER) == TIM_ICPSC_DIV4) ||                                         ((PRESCALER) == TIM_ICPSC_DIV8))
N/**
N  * @}
N  */ 
N
N/** @defgroup TIM_interrupt_sources 
N  * @{
N  */
N
N#define TIM_IT_Update                      ((uint16_t)0x0001)
N#define TIM_IT_CC1                         ((uint16_t)0x0002)
N#define TIM_IT_CC2                         ((uint16_t)0x0004)
N#define TIM_IT_CC3                         ((uint16_t)0x0008)
N#define TIM_IT_CC4                         ((uint16_t)0x0010)
N#define TIM_IT_COM                         ((uint16_t)0x0020)
N#define TIM_IT_Trigger                     ((uint16_t)0x0040)
N#define TIM_IT_Break                       ((uint16_t)0x0080)
N#define IS_TIM_IT(IT) ((((IT) & (uint16_t)0xFF00) == 0x0000) && ((IT) != 0x0000))
N
N#define IS_TIM_GET_IT(IT) (((IT) == TIM_IT_Update) || \
N                           ((IT) == TIM_IT_CC1) || \
N                           ((IT) == TIM_IT_CC2) || \
N                           ((IT) == TIM_IT_CC3) || \
N                           ((IT) == TIM_IT_CC4) || \
N                           ((IT) == TIM_IT_COM) || \
N                           ((IT) == TIM_IT_Trigger) || \
N                           ((IT) == TIM_IT_Break))
X#define IS_TIM_GET_IT(IT) (((IT) == TIM_IT_Update) ||                            ((IT) == TIM_IT_CC1) ||                            ((IT) == TIM_IT_CC2) ||                            ((IT) == TIM_IT_CC3) ||                            ((IT) == TIM_IT_CC4) ||                            ((IT) == TIM_IT_COM) ||                            ((IT) == TIM_IT_Trigger) ||                            ((IT) == TIM_IT_Break))
N/**
N  * @}
N  */ 
N
N/** @defgroup TIM_DMA_Base_address 
N  * @{
N  */
N
N#define TIM_DMABase_CR1                    ((uint16_t)0x0000)
N#define TIM_DMABase_CR2                    ((uint16_t)0x0001)
N#define TIM_DMABase_SMCR                   ((uint16_t)0x0002)
N#define TIM_DMABase_DIER                   ((uint16_t)0x0003)
N#define TIM_DMABase_SR                     ((uint16_t)0x0004)
N#define TIM_DMABase_EGR                    ((uint16_t)0x0005)
N#define TIM_DMABase_CCMR1                  ((uint16_t)0x0006)
N#define TIM_DMABase_CCMR2                  ((uint16_t)0x0007)
N#define TIM_DMABase_CCER                   ((uint16_t)0x0008)
N#define TIM_DMABase_CNT                    ((uint16_t)0x0009)
N#define TIM_DMABase_PSC                    ((uint16_t)0x000A)
N#define TIM_DMABase_ARR                    ((uint16_t)0x000B)
N#define TIM_DMABase_RCR                    ((uint16_t)0x000C)
N#define TIM_DMABase_CCR1                   ((uint16_t)0x000D)
N#define TIM_DMABase_CCR2                   ((uint16_t)0x000E)
N#define TIM_DMABase_CCR3                   ((uint16_t)0x000F)
N#define TIM_DMABase_CCR4                   ((uint16_t)0x0010)
N#define TIM_DMABase_BDTR                   ((uint16_t)0x0011)
N#define TIM_DMABase_DCR                    ((uint16_t)0x0012)
N#define IS_TIM_DMA_BASE(BASE) (((BASE) == TIM_DMABase_CR1) || \
N                               ((BASE) == TIM_DMABase_CR2) || \
N                               ((BASE) == TIM_DMABase_SMCR) || \
N                               ((BASE) == TIM_DMABase_DIER) || \
N                               ((BASE) == TIM_DMABase_SR) || \
N                               ((BASE) == TIM_DMABase_EGR) || \
N                               ((BASE) == TIM_DMABase_CCMR1) || \
N                               ((BASE) == TIM_DMABase_CCMR2) || \
N                               ((BASE) == TIM_DMABase_CCER) || \
N                               ((BASE) == TIM_DMABase_CNT) || \
N                               ((BASE) == TIM_DMABase_PSC) || \
N                               ((BASE) == TIM_DMABase_ARR) || \
N                               ((BASE) == TIM_DMABase_RCR) || \
N                               ((BASE) == TIM_DMABase_CCR1) || \
N                               ((BASE) == TIM_DMABase_CCR2) || \
N                               ((BASE) == TIM_DMABase_CCR3) || \
N                               ((BASE) == TIM_DMABase_CCR4) || \
N                               ((BASE) == TIM_DMABase_BDTR) || \
N                               ((BASE) == TIM_DMABase_DCR))
X#define IS_TIM_DMA_BASE(BASE) (((BASE) == TIM_DMABase_CR1) ||                                ((BASE) == TIM_DMABase_CR2) ||                                ((BASE) == TIM_DMABase_SMCR) ||                                ((BASE) == TIM_DMABase_DIER) ||                                ((BASE) == TIM_DMABase_SR) ||                                ((BASE) == TIM_DMABase_EGR) ||                                ((BASE) == TIM_DMABase_CCMR1) ||                                ((BASE) == TIM_DMABase_CCMR2) ||                                ((BASE) == TIM_DMABase_CCER) ||                                ((BASE) == TIM_DMABase_CNT) ||                                ((BASE) == TIM_DMABase_PSC) ||                                ((BASE) == TIM_DMABase_ARR) ||                                ((BASE) == TIM_DMABase_RCR) ||                                ((BASE) == TIM_DMABase_CCR1) ||                                ((BASE) == TIM_DMABase_CCR2) ||                                ((BASE) == TIM_DMABase_CCR3) ||                                ((BASE) == TIM_DMABase_CCR4) ||                                ((BASE) == TIM_DMABase_BDTR) ||                                ((BASE) == TIM_DMABase_DCR))
N/**
N  * @}
N  */ 
N
N/** @defgroup TIM_DMA_Burst_Length 
N  * @{
N  */
N
N#define TIM_DMABurstLength_1Transfer           ((uint16_t)0x0000)
N#define TIM_DMABurstLength_2Transfers          ((uint16_t)0x0100)
N#define TIM_DMABurstLength_3Transfers          ((uint16_t)0x0200)
N#define TIM_DMABurstLength_4Transfers          ((uint16_t)0x0300)
N#define TIM_DMABurstLength_5Transfers          ((uint16_t)0x0400)
N#define TIM_DMABurstLength_6Transfers          ((uint16_t)0x0500)
N#define TIM_DMABurstLength_7Transfers          ((uint16_t)0x0600)
N#define TIM_DMABurstLength_8Transfers          ((uint16_t)0x0700)
N#define TIM_DMABurstLength_9Transfers          ((uint16_t)0x0800)
N#define TIM_DMABurstLength_10Transfers         ((uint16_t)0x0900)
N#define TIM_DMABurstLength_11Transfers         ((uint16_t)0x0A00)
N#define TIM_DMABurstLength_12Transfers         ((uint16_t)0x0B00)
N#define TIM_DMABurstLength_13Transfers         ((uint16_t)0x0C00)
N#define TIM_DMABurstLength_14Transfers         ((uint16_t)0x0D00)
N#define TIM_DMABurstLength_15Transfers         ((uint16_t)0x0E00)
N#define TIM_DMABurstLength_16Transfers         ((uint16_t)0x0F00)
N#define TIM_DMABurstLength_17Transfers         ((uint16_t)0x1000)
N#define TIM_DMABurstLength_18Transfers         ((uint16_t)0x1100)
N#define IS_TIM_DMA_LENGTH(LENGTH) (((LENGTH) == TIM_DMABurstLength_1Transfer) || \
N                                   ((LENGTH) == TIM_DMABurstLength_2Transfers) || \
N                                   ((LENGTH) == TIM_DMABurstLength_3Transfers) || \
N                                   ((LENGTH) == TIM_DMABurstLength_4Transfers) || \
N                                   ((LENGTH) == TIM_DMABurstLength_5Transfers) || \
N                                   ((LENGTH) == TIM_DMABurstLength_6Transfers) || \
N                                   ((LENGTH) == TIM_DMABurstLength_7Transfers) || \
N                                   ((LENGTH) == TIM_DMABurstLength_8Transfers) || \
N                                   ((LENGTH) == TIM_DMABurstLength_9Transfers) || \
N                                   ((LENGTH) == TIM_DMABurstLength_10Transfers) || \
N                                   ((LENGTH) == TIM_DMABurstLength_11Transfers) || \
N                                   ((LENGTH) == TIM_DMABurstLength_12Transfers) || \
N                                   ((LENGTH) == TIM_DMABurstLength_13Transfers) || \
N                                   ((LENGTH) == TIM_DMABurstLength_14Transfers) || \
N                                   ((LENGTH) == TIM_DMABurstLength_15Transfers) || \
N                                   ((LENGTH) == TIM_DMABurstLength_16Transfers) || \
N                                   ((LENGTH) == TIM_DMABurstLength_17Transfers) || \
N                                   ((LENGTH) == TIM_DMABurstLength_18Transfers))
X#define IS_TIM_DMA_LENGTH(LENGTH) (((LENGTH) == TIM_DMABurstLength_1Transfer) ||                                    ((LENGTH) == TIM_DMABurstLength_2Transfers) ||                                    ((LENGTH) == TIM_DMABurstLength_3Transfers) ||                                    ((LENGTH) == TIM_DMABurstLength_4Transfers) ||                                    ((LENGTH) == TIM_DMABurstLength_5Transfers) ||                                    ((LENGTH) == TIM_DMABurstLength_6Transfers) ||                                    ((LENGTH) == TIM_DMABurstLength_7Transfers) ||                                    ((LENGTH) == TIM_DMABurstLength_8Transfers) ||                                    ((LENGTH) == TIM_DMABurstLength_9Transfers) ||                                    ((LENGTH) == TIM_DMABurstLength_10Transfers) ||                                    ((LENGTH) == TIM_DMABurstLength_11Transfers) ||                                    ((LENGTH) == TIM_DMABurstLength_12Transfers) ||                                    ((LENGTH) == TIM_DMABurstLength_13Transfers) ||                                    ((LENGTH) == TIM_DMABurstLength_14Transfers) ||                                    ((LENGTH) == TIM_DMABurstLength_15Transfers) ||                                    ((LENGTH) == TIM_DMABurstLength_16Transfers) ||                                    ((LENGTH) == TIM_DMABurstLength_17Transfers) ||                                    ((LENGTH) == TIM_DMABurstLength_18Transfers))
N/**
N  * @}
N  */ 
N
N/** @defgroup TIM_DMA_sources 
N  * @{
N  */
N
N#define TIM_DMA_Update                     ((uint16_t)0x0100)
N#define TIM_DMA_CC1                        ((uint16_t)0x0200)
N#define TIM_DMA_CC2                        ((uint16_t)0x0400)
N#define TIM_DMA_CC3                        ((uint16_t)0x0800)
N#define TIM_DMA_CC4                        ((uint16_t)0x1000)
N#define TIM_DMA_COM                        ((uint16_t)0x2000)
N#define TIM_DMA_Trigger                    ((uint16_t)0x4000)
N#define IS_TIM_DMA_SOURCE(SOURCE) ((((SOURCE) & (uint16_t)0x80FF) == 0x0000) && ((SOURCE) != 0x0000))
N
N/**
N  * @}
N  */ 
N
N/** @defgroup TIM_External_Trigger_Prescaler 
N  * @{
N  */
N
N#define TIM_ExtTRGPSC_OFF                  ((uint16_t)0x0000)
N#define TIM_ExtTRGPSC_DIV2                 ((uint16_t)0x1000)
N#define TIM_ExtTRGPSC_DIV4                 ((uint16_t)0x2000)
N#define TIM_ExtTRGPSC_DIV8                 ((uint16_t)0x3000)
N#define IS_TIM_EXT_PRESCALER(PRESCALER) (((PRESCALER) == TIM_ExtTRGPSC_OFF) || \
N                                         ((PRESCALER) == TIM_ExtTRGPSC_DIV2) || \
N                                         ((PRESCALER) == TIM_ExtTRGPSC_DIV4) || \
N                                         ((PRESCALER) == TIM_ExtTRGPSC_DIV8))
X#define IS_TIM_EXT_PRESCALER(PRESCALER) (((PRESCALER) == TIM_ExtTRGPSC_OFF) ||                                          ((PRESCALER) == TIM_ExtTRGPSC_DIV2) ||                                          ((PRESCALER) == TIM_ExtTRGPSC_DIV4) ||                                          ((PRESCALER) == TIM_ExtTRGPSC_DIV8))
N/**
N  * @}
N  */ 
N
N/** @defgroup TIM_Internal_Trigger_Selection 
N  * @{
N  */
N
N#define TIM_TS_ITR0                        ((uint16_t)0x0000)
N#define TIM_TS_ITR1                        ((uint16_t)0x0010)
N#define TIM_TS_ITR2                        ((uint16_t)0x0020)
N#define TIM_TS_ITR3                        ((uint16_t)0x0030)
N#define TIM_TS_TI1F_ED                     ((uint16_t)0x0040)
N#define TIM_TS_TI1FP1                      ((uint16_t)0x0050)
N#define TIM_TS_TI2FP2                      ((uint16_t)0x0060)
N#define TIM_TS_ETRF                        ((uint16_t)0x0070)
N#define IS_TIM_TRIGGER_SELECTION(SELECTION) (((SELECTION) == TIM_TS_ITR0) || \
N                                             ((SELECTION) == TIM_TS_ITR1) || \
N                                             ((SELECTION) == TIM_TS_ITR2) || \
N                                             ((SELECTION) == TIM_TS_ITR3) || \
N                                             ((SELECTION) == TIM_TS_TI1F_ED) || \
N                                             ((SELECTION) == TIM_TS_TI1FP1) || \
N                                             ((SELECTION) == TIM_TS_TI2FP2) || \
N                                             ((SELECTION) == TIM_TS_ETRF))
X#define IS_TIM_TRIGGER_SELECTION(SELECTION) (((SELECTION) == TIM_TS_ITR0) ||                                              ((SELECTION) == TIM_TS_ITR1) ||                                              ((SELECTION) == TIM_TS_ITR2) ||                                              ((SELECTION) == TIM_TS_ITR3) ||                                              ((SELECTION) == TIM_TS_TI1F_ED) ||                                              ((SELECTION) == TIM_TS_TI1FP1) ||                                              ((SELECTION) == TIM_TS_TI2FP2) ||                                              ((SELECTION) == TIM_TS_ETRF))
N#define IS_TIM_INTERNAL_TRIGGER_SELECTION(SELECTION) (((SELECTION) == TIM_TS_ITR0) || \
N                                                      ((SELECTION) == TIM_TS_ITR1) || \
N                                                      ((SELECTION) == TIM_TS_ITR2) || \
N                                                      ((SELECTION) == TIM_TS_ITR3))
X#define IS_TIM_INTERNAL_TRIGGER_SELECTION(SELECTION) (((SELECTION) == TIM_TS_ITR0) ||                                                       ((SELECTION) == TIM_TS_ITR1) ||                                                       ((SELECTION) == TIM_TS_ITR2) ||                                                       ((SELECTION) == TIM_TS_ITR3))
N/**
N  * @}
N  */ 
N
N/** @defgroup TIM_TIx_External_Clock_Source 
N  * @{
N  */
N
N#define TIM_TIxExternalCLK1Source_TI1      ((uint16_t)0x0050)
N#define TIM_TIxExternalCLK1Source_TI2      ((uint16_t)0x0060)
N#define TIM_TIxExternalCLK1Source_TI1ED    ((uint16_t)0x0040)
N#define IS_TIM_TIXCLK_SOURCE(SOURCE) (((SOURCE) == TIM_TIxExternalCLK1Source_TI1) || \
N                                      ((SOURCE) == TIM_TIxExternalCLK1Source_TI2) || \
N                                      ((SOURCE) == TIM_TIxExternalCLK1Source_TI1ED))
X#define IS_TIM_TIXCLK_SOURCE(SOURCE) (((SOURCE) == TIM_TIxExternalCLK1Source_TI1) ||                                       ((SOURCE) == TIM_TIxExternalCLK1Source_TI2) ||                                       ((SOURCE) == TIM_TIxExternalCLK1Source_TI1ED))
N/**
N  * @}
N  */ 
N
N/** @defgroup TIM_External_Trigger_Polarity 
N  * @{
N  */ 
N#define TIM_ExtTRGPolarity_Inverted        ((uint16_t)0x8000)
N#define TIM_ExtTRGPolarity_NonInverted     ((uint16_t)0x0000)
N#define IS_TIM_EXT_POLARITY(POLARITY) (((POLARITY) == TIM_ExtTRGPolarity_Inverted) || \
N                                       ((POLARITY) == TIM_ExtTRGPolarity_NonInverted))
X#define IS_TIM_EXT_POLARITY(POLARITY) (((POLARITY) == TIM_ExtTRGPolarity_Inverted) ||                                        ((POLARITY) == TIM_ExtTRGPolarity_NonInverted))
N/**
N  * @}
N  */
N
N/** @defgroup TIM_Prescaler_Reload_Mode 
N  * @{
N  */
N
N#define TIM_PSCReloadMode_Update           ((uint16_t)0x0000)
N#define TIM_PSCReloadMode_Immediate        ((uint16_t)0x0001)
N#define IS_TIM_PRESCALER_RELOAD(RELOAD) (((RELOAD) == TIM_PSCReloadMode_Update) || \
N                                         ((RELOAD) == TIM_PSCReloadMode_Immediate))
X#define IS_TIM_PRESCALER_RELOAD(RELOAD) (((RELOAD) == TIM_PSCReloadMode_Update) ||                                          ((RELOAD) == TIM_PSCReloadMode_Immediate))
N/**
N  * @}
N  */ 
N
N/** @defgroup TIM_Forced_Action 
N  * @{
N  */
N
N#define TIM_ForcedAction_Active            ((uint16_t)0x0050)
N#define TIM_ForcedAction_InActive          ((uint16_t)0x0040)
N#define IS_TIM_FORCED_ACTION(ACTION) (((ACTION) == TIM_ForcedAction_Active) || \
N                                      ((ACTION) == TIM_ForcedAction_InActive))
X#define IS_TIM_FORCED_ACTION(ACTION) (((ACTION) == TIM_ForcedAction_Active) ||                                       ((ACTION) == TIM_ForcedAction_InActive))
N/**
N  * @}
N  */ 
N
N/** @defgroup TIM_Encoder_Mode 
N  * @{
N  */
N
N#define TIM_EncoderMode_TI1                ((uint16_t)0x0001)
N#define TIM_EncoderMode_TI2                ((uint16_t)0x0002)
N#define TIM_EncoderMode_TI12               ((uint16_t)0x0003)
N#define IS_TIM_ENCODER_MODE(MODE) (((MODE) == TIM_EncoderMode_TI1) || \
N                                   ((MODE) == TIM_EncoderMode_TI2) || \
N                                   ((MODE) == TIM_EncoderMode_TI12))
X#define IS_TIM_ENCODER_MODE(MODE) (((MODE) == TIM_EncoderMode_TI1) ||                                    ((MODE) == TIM_EncoderMode_TI2) ||                                    ((MODE) == TIM_EncoderMode_TI12))
N/**
N  * @}
N  */ 
N
N
N/** @defgroup TIM_Event_Source 
N  * @{
N  */
N
N#define TIM_EventSource_Update             ((uint16_t)0x0001)
N#define TIM_EventSource_CC1                ((uint16_t)0x0002)
N#define TIM_EventSource_CC2                ((uint16_t)0x0004)
N#define TIM_EventSource_CC3                ((uint16_t)0x0008)
N#define TIM_EventSource_CC4                ((uint16_t)0x0010)
N#define TIM_EventSource_COM                ((uint16_t)0x0020)
N#define TIM_EventSource_Trigger            ((uint16_t)0x0040)
N#define TIM_EventSource_Break              ((uint16_t)0x0080)
N#define IS_TIM_EVENT_SOURCE(SOURCE) ((((SOURCE) & (uint16_t)0xFF00) == 0x0000) && ((SOURCE) != 0x0000))
N
N/**
N  * @}
N  */ 
N
N/** @defgroup TIM_Update_Source 
N  * @{
N  */
N
N#define TIM_UpdateSource_Global            ((uint16_t)0x0000) /*!< Source of update is the counter overflow/underflow
N                                                                   or the setting of UG bit, or an update generation
N                                                                   through the slave mode controller. */
N#define TIM_UpdateSource_Regular           ((uint16_t)0x0001) /*!< Source of update is counter overflow/underflow. */
N#define IS_TIM_UPDATE_SOURCE(SOURCE) (((SOURCE) == TIM_UpdateSource_Global) || \
N                                      ((SOURCE) == TIM_UpdateSource_Regular))
X#define IS_TIM_UPDATE_SOURCE(SOURCE) (((SOURCE) == TIM_UpdateSource_Global) ||                                       ((SOURCE) == TIM_UpdateSource_Regular))
N/**
N  * @}
N  */ 
N
N/** @defgroup TIM_Output_Compare_Preload_State 
N  * @{
N  */
N
N#define TIM_OCPreload_Enable               ((uint16_t)0x0008)
N#define TIM_OCPreload_Disable              ((uint16_t)0x0000)
N#define IS_TIM_OCPRELOAD_STATE(STATE) (((STATE) == TIM_OCPreload_Enable) || \
N                                       ((STATE) == TIM_OCPreload_Disable))
X#define IS_TIM_OCPRELOAD_STATE(STATE) (((STATE) == TIM_OCPreload_Enable) ||                                        ((STATE) == TIM_OCPreload_Disable))
N/**
N  * @}
N  */ 
N
N/** @defgroup TIM_Output_Compare_Fast_State 
N  * @{
N  */
N
N#define TIM_OCFast_Enable                  ((uint16_t)0x0004)
N#define TIM_OCFast_Disable                 ((uint16_t)0x0000)
N#define IS_TIM_OCFAST_STATE(STATE) (((STATE) == TIM_OCFast_Enable) || \
N                                    ((STATE) == TIM_OCFast_Disable))
X#define IS_TIM_OCFAST_STATE(STATE) (((STATE) == TIM_OCFast_Enable) ||                                     ((STATE) == TIM_OCFast_Disable))
N                                     
N/**
N  * @}
N  */ 
N
N/** @defgroup TIM_Output_Compare_Clear_State 
N  * @{
N  */
N
N#define TIM_OCClear_Enable                 ((uint16_t)0x0080)
N#define TIM_OCClear_Disable                ((uint16_t)0x0000)
N#define IS_TIM_OCCLEAR_STATE(STATE) (((STATE) == TIM_OCClear_Enable) || \
N                                     ((STATE) == TIM_OCClear_Disable))
X#define IS_TIM_OCCLEAR_STATE(STATE) (((STATE) == TIM_OCClear_Enable) ||                                      ((STATE) == TIM_OCClear_Disable))
N/**
N  * @}
N  */ 
N
N/** @defgroup TIM_Trigger_Output_Source 
N  * @{
N  */
N
N#define TIM_TRGOSource_Reset               ((uint16_t)0x0000)
N#define TIM_TRGOSource_Enable              ((uint16_t)0x0010)
N#define TIM_TRGOSource_Update              ((uint16_t)0x0020)
N#define TIM_TRGOSource_OC1                 ((uint16_t)0x0030)
N#define TIM_TRGOSource_OC1Ref              ((uint16_t)0x0040)
N#define TIM_TRGOSource_OC2Ref              ((uint16_t)0x0050)
N#define TIM_TRGOSource_OC3Ref              ((uint16_t)0x0060)
N#define TIM_TRGOSource_OC4Ref              ((uint16_t)0x0070)
N#define IS_TIM_TRGO_SOURCE(SOURCE) (((SOURCE) == TIM_TRGOSource_Reset) || \
N                                    ((SOURCE) == TIM_TRGOSource_Enable) || \
N                                    ((SOURCE) == TIM_TRGOSource_Update) || \
N                                    ((SOURCE) == TIM_TRGOSource_OC1) || \
N                                    ((SOURCE) == TIM_TRGOSource_OC1Ref) || \
N                                    ((SOURCE) == TIM_TRGOSource_OC2Ref) || \
N                                    ((SOURCE) == TIM_TRGOSource_OC3Ref) || \
N                                    ((SOURCE) == TIM_TRGOSource_OC4Ref))
X#define IS_TIM_TRGO_SOURCE(SOURCE) (((SOURCE) == TIM_TRGOSource_Reset) ||                                     ((SOURCE) == TIM_TRGOSource_Enable) ||                                     ((SOURCE) == TIM_TRGOSource_Update) ||                                     ((SOURCE) == TIM_TRGOSource_OC1) ||                                     ((SOURCE) == TIM_TRGOSource_OC1Ref) ||                                     ((SOURCE) == TIM_TRGOSource_OC2Ref) ||                                     ((SOURCE) == TIM_TRGOSource_OC3Ref) ||                                     ((SOURCE) == TIM_TRGOSource_OC4Ref))
N/**
N  * @}
N  */ 
N
N/** @defgroup TIM_Slave_Mode 
N  * @{
N  */
N
N#define TIM_SlaveMode_Reset                ((uint16_t)0x0004)
N#define TIM_SlaveMode_Gated                ((uint16_t)0x0005)
N#define TIM_SlaveMode_Trigger              ((uint16_t)0x0006)
N#define TIM_SlaveMode_External1            ((uint16_t)0x0007)
N#define IS_TIM_SLAVE_MODE(MODE) (((MODE) == TIM_SlaveMode_Reset) || \
N                                 ((MODE) == TIM_SlaveMode_Gated) || \
N                                 ((MODE) == TIM_SlaveMode_Trigger) || \
N                                 ((MODE) == TIM_SlaveMode_External1))
X#define IS_TIM_SLAVE_MODE(MODE) (((MODE) == TIM_SlaveMode_Reset) ||                                  ((MODE) == TIM_SlaveMode_Gated) ||                                  ((MODE) == TIM_SlaveMode_Trigger) ||                                  ((MODE) == TIM_SlaveMode_External1))
N/**
N  * @}
N  */ 
N
N/** @defgroup TIM_Master_Slave_Mode 
N  * @{
N  */
N
N#define TIM_MasterSlaveMode_Enable         ((uint16_t)0x0080)
N#define TIM_MasterSlaveMode_Disable        ((uint16_t)0x0000)
N#define IS_TIM_MSM_STATE(STATE) (((STATE) == TIM_MasterSlaveMode_Enable) || \
N                                 ((STATE) == TIM_MasterSlaveMode_Disable))
X#define IS_TIM_MSM_STATE(STATE) (((STATE) == TIM_MasterSlaveMode_Enable) ||                                  ((STATE) == TIM_MasterSlaveMode_Disable))
N/**
N  * @}
N  */ 
N
N/** @defgroup TIM_Flags 
N  * @{
N  */
N
N#define TIM_FLAG_Update                    ((uint16_t)0x0001)
N#define TIM_FLAG_CC1                       ((uint16_t)0x0002)
N#define TIM_FLAG_CC2                       ((uint16_t)0x0004)
N#define TIM_FLAG_CC3                       ((uint16_t)0x0008)
N#define TIM_FLAG_CC4                       ((uint16_t)0x0010)
N#define TIM_FLAG_COM                       ((uint16_t)0x0020)
N#define TIM_FLAG_Trigger                   ((uint16_t)0x0040)
N#define TIM_FLAG_Break                     ((uint16_t)0x0080)
N#define TIM_FLAG_CC1OF                     ((uint16_t)0x0200)
N#define TIM_FLAG_CC2OF                     ((uint16_t)0x0400)
N#define TIM_FLAG_CC3OF                     ((uint16_t)0x0800)
N#define TIM_FLAG_CC4OF                     ((uint16_t)0x1000)
N#define IS_TIM_GET_FLAG(FLAG) (((FLAG) == TIM_FLAG_Update) || \
N                               ((FLAG) == TIM_FLAG_CC1) || \
N                               ((FLAG) == TIM_FLAG_CC2) || \
N                               ((FLAG) == TIM_FLAG_CC3) || \
N                               ((FLAG) == TIM_FLAG_CC4) || \
N                               ((FLAG) == TIM_FLAG_COM) || \
N                               ((FLAG) == TIM_FLAG_Trigger) || \
N                               ((FLAG) == TIM_FLAG_Break) || \
N                               ((FLAG) == TIM_FLAG_CC1OF) || \
N                               ((FLAG) == TIM_FLAG_CC2OF) || \
N                               ((FLAG) == TIM_FLAG_CC3OF) || \
N                               ((FLAG) == TIM_FLAG_CC4OF))
X#define IS_TIM_GET_FLAG(FLAG) (((FLAG) == TIM_FLAG_Update) ||                                ((FLAG) == TIM_FLAG_CC1) ||                                ((FLAG) == TIM_FLAG_CC2) ||                                ((FLAG) == TIM_FLAG_CC3) ||                                ((FLAG) == TIM_FLAG_CC4) ||                                ((FLAG) == TIM_FLAG_COM) ||                                ((FLAG) == TIM_FLAG_Trigger) ||                                ((FLAG) == TIM_FLAG_Break) ||                                ((FLAG) == TIM_FLAG_CC1OF) ||                                ((FLAG) == TIM_FLAG_CC2OF) ||                                ((FLAG) == TIM_FLAG_CC3OF) ||                                ((FLAG) == TIM_FLAG_CC4OF))
N                               
N                               
N#define IS_TIM_CLEAR_FLAG(TIM_FLAG) ((((TIM_FLAG) & (uint16_t)0xE100) == 0x0000) && ((TIM_FLAG) != 0x0000))
N/**
N  * @}
N  */ 
N
N/** @defgroup TIM_Input_Capture_Filer_Value 
N  * @{
N  */
N
N#define IS_TIM_IC_FILTER(ICFILTER) ((ICFILTER) <= 0xF) 
N/**
N  * @}
N  */ 
N
N/** @defgroup TIM_External_Trigger_Filter 
N  * @{
N  */
N
N#define IS_TIM_EXT_FILTER(EXTFILTER) ((EXTFILTER) <= 0xF)
N/**
N  * @}
N  */ 
N
N/** @defgroup TIM_Legacy 
N  * @{
N  */
N
N#define TIM_DMABurstLength_1Byte           TIM_DMABurstLength_1Transfer
N#define TIM_DMABurstLength_2Bytes          TIM_DMABurstLength_2Transfers
N#define TIM_DMABurstLength_3Bytes          TIM_DMABurstLength_3Transfers
N#define TIM_DMABurstLength_4Bytes          TIM_DMABurstLength_4Transfers
N#define TIM_DMABurstLength_5Bytes          TIM_DMABurstLength_5Transfers
N#define TIM_DMABurstLength_6Bytes          TIM_DMABurstLength_6Transfers
N#define TIM_DMABurstLength_7Bytes          TIM_DMABurstLength_7Transfers
N#define TIM_DMABurstLength_8Bytes          TIM_DMABurstLength_8Transfers
N#define TIM_DMABurstLength_9Bytes          TIM_DMABurstLength_9Transfers
N#define TIM_DMABurstLength_10Bytes         TIM_DMABurstLength_10Transfers
N#define TIM_DMABurstLength_11Bytes         TIM_DMABurstLength_11Transfers
N#define TIM_DMABurstLength_12Bytes         TIM_DMABurstLength_12Transfers
N#define TIM_DMABurstLength_13Bytes         TIM_DMABurstLength_13Transfers
N#define TIM_DMABurstLength_14Bytes         TIM_DMABurstLength_14Transfers
N#define TIM_DMABurstLength_15Bytes         TIM_DMABurstLength_15Transfers
N#define TIM_DMABurstLength_16Bytes         TIM_DMABurstLength_16Transfers
N#define TIM_DMABurstLength_17Bytes         TIM_DMABurstLength_17Transfers
N#define TIM_DMABurstLength_18Bytes         TIM_DMABurstLength_18Transfers
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */
N
N/** @defgroup TIM_Exported_Macros
N  * @{
N  */
N
N/**
N  * @}
N  */ 
N
N/** @defgroup TIM_Exported_Functions
N  * @{
N  */
N
Nvoid TIM_DeInit(TIM_TypeDef* TIMx);
Nvoid TIM_TimeBaseInit(TIM_TypeDef* TIMx, TIM_TimeBaseInitTypeDef* TIM_TimeBaseInitStruct);
Nvoid TIM_OC1Init(TIM_TypeDef* TIMx, TIM_OCInitTypeDef* TIM_OCInitStruct);
Nvoid TIM_OC2Init(TIM_TypeDef* TIMx, TIM_OCInitTypeDef* TIM_OCInitStruct);
Nvoid TIM_OC3Init(TIM_TypeDef* TIMx, TIM_OCInitTypeDef* TIM_OCInitStruct);
Nvoid TIM_OC4Init(TIM_TypeDef* TIMx, TIM_OCInitTypeDef* TIM_OCInitStruct);
Nvoid TIM_ICInit(TIM_TypeDef* TIMx, TIM_ICInitTypeDef* TIM_ICInitStruct);
Nvoid TIM_PWMIConfig(TIM_TypeDef* TIMx, TIM_ICInitTypeDef* TIM_ICInitStruct);
Nvoid TIM_BDTRConfig(TIM_TypeDef* TIMx, TIM_BDTRInitTypeDef *TIM_BDTRInitStruct);
Nvoid TIM_TimeBaseStructInit(TIM_TimeBaseInitTypeDef* TIM_TimeBaseInitStruct);
Nvoid TIM_OCStructInit(TIM_OCInitTypeDef* TIM_OCInitStruct);
Nvoid TIM_ICStructInit(TIM_ICInitTypeDef* TIM_ICInitStruct);
Nvoid TIM_BDTRStructInit(TIM_BDTRInitTypeDef* TIM_BDTRInitStruct);
Nvoid TIM_Cmd(TIM_TypeDef* TIMx, FunctionalState NewState);
Nvoid TIM_CtrlPWMOutputs(TIM_TypeDef* TIMx, FunctionalState NewState);
Nvoid TIM_ITConfig(TIM_TypeDef* TIMx, uint16_t TIM_IT, FunctionalState NewState);
Nvoid TIM_GenerateEvent(TIM_TypeDef* TIMx, uint16_t TIM_EventSource);
Nvoid TIM_DMAConfig(TIM_TypeDef* TIMx, uint16_t TIM_DMABase, uint16_t TIM_DMABurstLength);
Nvoid TIM_DMACmd(TIM_TypeDef* TIMx, uint16_t TIM_DMASource, FunctionalState NewState);
Nvoid TIM_InternalClockConfig(TIM_TypeDef* TIMx);
Nvoid TIM_ITRxExternalClockConfig(TIM_TypeDef* TIMx, uint16_t TIM_InputTriggerSource);
Nvoid TIM_TIxExternalClockConfig(TIM_TypeDef* TIMx, uint16_t TIM_TIxExternalCLKSource,
N                                uint16_t TIM_ICPolarity, uint16_t ICFilter);
Nvoid TIM_ETRClockMode1Config(TIM_TypeDef* TIMx, uint16_t TIM_ExtTRGPrescaler, uint16_t TIM_ExtTRGPolarity,
N                             uint16_t ExtTRGFilter);
Nvoid TIM_ETRClockMode2Config(TIM_TypeDef* TIMx, uint16_t TIM_ExtTRGPrescaler, 
N                             uint16_t TIM_ExtTRGPolarity, uint16_t ExtTRGFilter);
Nvoid TIM_ETRConfig(TIM_TypeDef* TIMx, uint16_t TIM_ExtTRGPrescaler, uint16_t TIM_ExtTRGPolarity,
N                   uint16_t ExtTRGFilter);
Nvoid TIM_PrescalerConfig(TIM_TypeDef* TIMx, uint16_t Prescaler, uint16_t TIM_PSCReloadMode);
Nvoid TIM_CounterModeConfig(TIM_TypeDef* TIMx, uint16_t TIM_CounterMode);
Nvoid TIM_SelectInputTrigger(TIM_TypeDef* TIMx, uint16_t TIM_InputTriggerSource);
Nvoid TIM_EncoderInterfaceConfig(TIM_TypeDef* TIMx, uint16_t TIM_EncoderMode,
N                                uint16_t TIM_IC1Polarity, uint16_t TIM_IC2Polarity);
Nvoid TIM_ForcedOC1Config(TIM_TypeDef* TIMx, uint16_t TIM_ForcedAction);
Nvoid TIM_ForcedOC2Config(TIM_TypeDef* TIMx, uint16_t TIM_ForcedAction);
Nvoid TIM_ForcedOC3Config(TIM_TypeDef* TIMx, uint16_t TIM_ForcedAction);
Nvoid TIM_ForcedOC4Config(TIM_TypeDef* TIMx, uint16_t TIM_ForcedAction);
Nvoid TIM_ARRPreloadConfig(TIM_TypeDef* TIMx, FunctionalState NewState);
Nvoid TIM_SelectCOM(TIM_TypeDef* TIMx, FunctionalState NewState);
Nvoid TIM_SelectCCDMA(TIM_TypeDef* TIMx, FunctionalState NewState);
Nvoid TIM_CCPreloadControl(TIM_TypeDef* TIMx, FunctionalState NewState);
Nvoid TIM_OC1PreloadConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCPreload);
Nvoid TIM_OC2PreloadConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCPreload);
Nvoid TIM_OC3PreloadConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCPreload);
Nvoid TIM_OC4PreloadConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCPreload);
Nvoid TIM_OC1FastConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCFast);
Nvoid TIM_OC2FastConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCFast);
Nvoid TIM_OC3FastConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCFast);
Nvoid TIM_OC4FastConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCFast);
Nvoid TIM_ClearOC1Ref(TIM_TypeDef* TIMx, uint16_t TIM_OCClear);
Nvoid TIM_ClearOC2Ref(TIM_TypeDef* TIMx, uint16_t TIM_OCClear);
Nvoid TIM_ClearOC3Ref(TIM_TypeDef* TIMx, uint16_t TIM_OCClear);
Nvoid TIM_ClearOC4Ref(TIM_TypeDef* TIMx, uint16_t TIM_OCClear);
Nvoid TIM_OC1PolarityConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCPolarity);
Nvoid TIM_OC1NPolarityConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCNPolarity);
Nvoid TIM_OC2PolarityConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCPolarity);
Nvoid TIM_OC2NPolarityConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCNPolarity);
Nvoid TIM_OC3PolarityConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCPolarity);
Nvoid TIM_OC3NPolarityConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCNPolarity);
Nvoid TIM_OC4PolarityConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCPolarity);
Nvoid TIM_CCxCmd(TIM_TypeDef* TIMx, uint16_t TIM_Channel, uint16_t TIM_CCx);
Nvoid TIM_CCxNCmd(TIM_TypeDef* TIMx, uint16_t TIM_Channel, uint16_t TIM_CCxN);
Nvoid TIM_SelectOCxM(TIM_TypeDef* TIMx, uint16_t TIM_Channel, uint16_t TIM_OCMode);
Nvoid TIM_UpdateDisableConfig(TIM_TypeDef* TIMx, FunctionalState NewState);
Nvoid TIM_UpdateRequestConfig(TIM_TypeDef* TIMx, uint16_t TIM_UpdateSource);
Nvoid TIM_SelectHallSensor(TIM_TypeDef* TIMx, FunctionalState NewState);
Nvoid TIM_SelectOnePulseMode(TIM_TypeDef* TIMx, uint16_t TIM_OPMode);
Nvoid TIM_SelectOutputTrigger(TIM_TypeDef* TIMx, uint16_t TIM_TRGOSource);
Nvoid TIM_SelectSlaveMode(TIM_TypeDef* TIMx, uint16_t TIM_SlaveMode);
Nvoid TIM_SelectMasterSlaveMode(TIM_TypeDef* TIMx, uint16_t TIM_MasterSlaveMode);
Nvoid TIM_SetCounter(TIM_TypeDef* TIMx, uint16_t Counter);
Nvoid TIM_SetAutoreload(TIM_TypeDef* TIMx, uint16_t Autoreload);
Nvoid TIM_SetCompare1(TIM_TypeDef* TIMx, uint16_t Compare1);
Nvoid TIM_SetCompare2(TIM_TypeDef* TIMx, uint16_t Compare2);
Nvoid TIM_SetCompare3(TIM_TypeDef* TIMx, uint16_t Compare3);
Nvoid TIM_SetCompare4(TIM_TypeDef* TIMx, uint16_t Compare4);
Nvoid TIM_SetIC1Prescaler(TIM_TypeDef* TIMx, uint16_t TIM_ICPSC);
Nvoid TIM_SetIC2Prescaler(TIM_TypeDef* TIMx, uint16_t TIM_ICPSC);
Nvoid TIM_SetIC3Prescaler(TIM_TypeDef* TIMx, uint16_t TIM_ICPSC);
Nvoid TIM_SetIC4Prescaler(TIM_TypeDef* TIMx, uint16_t TIM_ICPSC);
Nvoid TIM_SetClockDivision(TIM_TypeDef* TIMx, uint16_t TIM_CKD);
Nuint16_t TIM_GetCapture1(TIM_TypeDef* TIMx);
Nuint16_t TIM_GetCapture2(TIM_TypeDef* TIMx);
Nuint16_t TIM_GetCapture3(TIM_TypeDef* TIMx);
Nuint16_t TIM_GetCapture4(TIM_TypeDef* TIMx);
Nuint16_t TIM_GetCounter(TIM_TypeDef* TIMx);
Nuint16_t TIM_GetPrescaler(TIM_TypeDef* TIMx);
NFlagStatus TIM_GetFlagStatus(TIM_TypeDef* TIMx, uint16_t TIM_FLAG);
Nvoid TIM_ClearFlag(TIM_TypeDef* TIMx, uint16_t TIM_FLAG);
NITStatus TIM_GetITStatus(TIM_TypeDef* TIMx, uint16_t TIM_IT);
Nvoid TIM_ClearITPendingBit(TIM_TypeDef* TIMx, uint16_t TIM_IT);
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif /*__STM32F10x_TIM_H */
N/**
N  * @}
N  */ 
N
N/**
N  * @}
N  */ 
N
N/**
N  * @}
N  */
N
N/******************* (C) COPYRIGHT 2011 STMicroelectronics *****END OF FILE****/
L 48 "..\..\User\stm32f10x_conf.h" 2
N#include "stm32f10x_usart.h" 
L 1 "..\..\Libraries\FWlib\inc\stm32f10x_usart.h" 1
N/**
N  ******************************************************************************
N  * @file    stm32f10x_usart.h
N  * @author  MCD Application Team
N  * @version V3.5.0
N  * @date    11-March-2011
N  * @brief   This file contains all the functions prototypes for the USART 
N  *          firmware library.
N  ******************************************************************************
N  * @attention
N  *
N  * THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
N  * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE
N  * TIME. AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY
N  * DIRECT, INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING
N  * FROM THE CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE
N  * CODING INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
N  *
N  * <h2><center>&copy; COPYRIGHT 2011 STMicroelectronics</center></h2>
N  ******************************************************************************
N  */
N
N/* Define to prevent recursive inclusion -------------------------------------*/
N#ifndef __STM32F10x_USART_H
N#define __STM32F10x_USART_H
N
N#ifdef __cplusplus
S extern "C" {
N#endif
N
N/* Includes ------------------------------------------------------------------*/
N#include "stm32f10x.h"
N
N/** @addtogroup STM32F10x_StdPeriph_Driver
N  * @{
N  */
N
N/** @addtogroup USART
N  * @{
N  */ 
N
N/** @defgroup USART_Exported_Types
N  * @{
N  */ 
N
N/** 
N  * @brief  USART Init Structure definition  
N  */ 
N  
Ntypedef struct
N{
N  uint32_t USART_BaudRate;            /*!< This member configures the USART communication baud rate.
N                                           The baud rate is computed using the following formula:
N                                            - IntegerDivider = ((PCLKx) / (16 * (USART_InitStruct->USART_BaudRate)))
N                                            - FractionalDivider = ((IntegerDivider - ((u32) IntegerDivider)) * 16) + 0.5 */
N
N  uint16_t USART_WordLength;          /*!< Specifies the number of data bits transmitted or received in a frame.
N                                           This parameter can be a value of @ref USART_Word_Length */
N
N  uint16_t USART_StopBits;            /*!< Specifies the number of stop bits transmitted.
N                                           This parameter can be a value of @ref USART_Stop_Bits */
N
N  uint16_t USART_Parity;              /*!< Specifies the parity mode.
N                                           This parameter can be a value of @ref USART_Parity
N                                           @note When parity is enabled, the computed parity is inserted
N                                                 at the MSB position of the transmitted data (9th bit when
N                                                 the word length is set to 9 data bits; 8th bit when the
N                                                 word length is set to 8 data bits). */
N 
N  uint16_t USART_Mode;                /*!< Specifies wether the Receive or Transmit mode is enabled or disabled.
N                                           This parameter can be a value of @ref USART_Mode */
N
N  uint16_t USART_HardwareFlowControl; /*!< Specifies wether the hardware flow control mode is enabled
N                                           or disabled.
N                                           This parameter can be a value of @ref USART_Hardware_Flow_Control */
N} USART_InitTypeDef;
N
N/** 
N  * @brief  USART Clock Init Structure definition  
N  */ 
N  
Ntypedef struct
N{
N
N  uint16_t USART_Clock;   /*!< Specifies whether the USART clock is enabled or disabled.
N                               This parameter can be a value of @ref USART_Clock */
N
N  uint16_t USART_CPOL;    /*!< Specifies the steady state value of the serial clock.
N                               This parameter can be a value of @ref USART_Clock_Polarity */
N
N  uint16_t USART_CPHA;    /*!< Specifies the clock transition on which the bit capture is made.
N                               This parameter can be a value of @ref USART_Clock_Phase */
N
N  uint16_t USART_LastBit; /*!< Specifies whether the clock pulse corresponding to the last transmitted
N                               data bit (MSB) has to be output on the SCLK pin in synchronous mode.
N                               This parameter can be a value of @ref USART_Last_Bit */
N} USART_ClockInitTypeDef;
N
N/**
N  * @}
N  */ 
N
N/** @defgroup USART_Exported_Constants
N  * @{
N  */ 
N  
N#define IS_USART_ALL_PERIPH(PERIPH) (((PERIPH) == USART1) || \
N                                     ((PERIPH) == USART2) || \
N                                     ((PERIPH) == USART3) || \
N                                     ((PERIPH) == UART4) || \
N                                     ((PERIPH) == UART5))
X#define IS_USART_ALL_PERIPH(PERIPH) (((PERIPH) == USART1) ||                                      ((PERIPH) == USART2) ||                                      ((PERIPH) == USART3) ||                                      ((PERIPH) == UART4) ||                                      ((PERIPH) == UART5))
N
N#define IS_USART_123_PERIPH(PERIPH) (((PERIPH) == USART1) || \
N                                     ((PERIPH) == USART2) || \
N                                     ((PERIPH) == USART3))
X#define IS_USART_123_PERIPH(PERIPH) (((PERIPH) == USART1) ||                                      ((PERIPH) == USART2) ||                                      ((PERIPH) == USART3))
N
N#define IS_USART_1234_PERIPH(PERIPH) (((PERIPH) == USART1) || \
N                                      ((PERIPH) == USART2) || \
N                                      ((PERIPH) == USART3) || \
N                                      ((PERIPH) == UART4))
X#define IS_USART_1234_PERIPH(PERIPH) (((PERIPH) == USART1) ||                                       ((PERIPH) == USART2) ||                                       ((PERIPH) == USART3) ||                                       ((PERIPH) == UART4))
N/** @defgroup USART_Word_Length 
N  * @{
N  */ 
N  
N#define USART_WordLength_8b                  ((uint16_t)0x0000)
N#define USART_WordLength_9b                  ((uint16_t)0x1000)
N                                    
N#define IS_USART_WORD_LENGTH(LENGTH) (((LENGTH) == USART_WordLength_8b) || \
N                                      ((LENGTH) == USART_WordLength_9b))
X#define IS_USART_WORD_LENGTH(LENGTH) (((LENGTH) == USART_WordLength_8b) ||                                       ((LENGTH) == USART_WordLength_9b))
N/**
N  * @}
N  */ 
N
N/** @defgroup USART_Stop_Bits 
N  * @{
N  */ 
N  
N#define USART_StopBits_1                     ((uint16_t)0x0000)
N#define USART_StopBits_0_5                   ((uint16_t)0x1000)
N#define USART_StopBits_2                     ((uint16_t)0x2000)
N#define USART_StopBits_1_5                   ((uint16_t)0x3000)
N#define IS_USART_STOPBITS(STOPBITS) (((STOPBITS) == USART_StopBits_1) || \
N                                     ((STOPBITS) == USART_StopBits_0_5) || \
N                                     ((STOPBITS) == USART_StopBits_2) || \
N                                     ((STOPBITS) == USART_StopBits_1_5))
X#define IS_USART_STOPBITS(STOPBITS) (((STOPBITS) == USART_StopBits_1) ||                                      ((STOPBITS) == USART_StopBits_0_5) ||                                      ((STOPBITS) == USART_StopBits_2) ||                                      ((STOPBITS) == USART_StopBits_1_5))
N/**
N  * @}
N  */ 
N
N/** @defgroup USART_Parity 
N  * @{
N  */ 
N  
N#define USART_Parity_No                      ((uint16_t)0x0000)
N#define USART_Parity_Even                    ((uint16_t)0x0400)
N#define USART_Parity_Odd                     ((uint16_t)0x0600) 
N#define IS_USART_PARITY(PARITY) (((PARITY) == USART_Parity_No) || \
N                                 ((PARITY) == USART_Parity_Even) || \
N                                 ((PARITY) == USART_Parity_Odd))
X#define IS_USART_PARITY(PARITY) (((PARITY) == USART_Parity_No) ||                                  ((PARITY) == USART_Parity_Even) ||                                  ((PARITY) == USART_Parity_Odd))
N/**
N  * @}
N  */ 
N
N/** @defgroup USART_Mode 
N  * @{
N  */ 
N  
N#define USART_Mode_Rx                        ((uint16_t)0x0004)
N#define USART_Mode_Tx                        ((uint16_t)0x0008)
N#define IS_USART_MODE(MODE) ((((MODE) & (uint16_t)0xFFF3) == 0x00) && ((MODE) != (uint16_t)0x00))
N/**
N  * @}
N  */ 
N
N/** @defgroup USART_Hardware_Flow_Control 
N  * @{
N  */ 
N#define USART_HardwareFlowControl_None       ((uint16_t)0x0000)
N#define USART_HardwareFlowControl_RTS        ((uint16_t)0x0100)
N#define USART_HardwareFlowControl_CTS        ((uint16_t)0x0200)
N#define USART_HardwareFlowControl_RTS_CTS    ((uint16_t)0x0300)
N#define IS_USART_HARDWARE_FLOW_CONTROL(CONTROL)\
N                              (((CONTROL) == USART_HardwareFlowControl_None) || \
N                               ((CONTROL) == USART_HardwareFlowControl_RTS) || \
N                               ((CONTROL) == USART_HardwareFlowControl_CTS) || \
N                               ((CONTROL) == USART_HardwareFlowControl_RTS_CTS))
X#define IS_USART_HARDWARE_FLOW_CONTROL(CONTROL)                              (((CONTROL) == USART_HardwareFlowControl_None) ||                                ((CONTROL) == USART_HardwareFlowControl_RTS) ||                                ((CONTROL) == USART_HardwareFlowControl_CTS) ||                                ((CONTROL) == USART_HardwareFlowControl_RTS_CTS))
N/**
N  * @}
N  */ 
N
N/** @defgroup USART_Clock 
N  * @{
N  */ 
N#define USART_Clock_Disable                  ((uint16_t)0x0000)
N#define USART_Clock_Enable                   ((uint16_t)0x0800)
N#define IS_USART_CLOCK(CLOCK) (((CLOCK) == USART_Clock_Disable) || \
N                               ((CLOCK) == USART_Clock_Enable))
X#define IS_USART_CLOCK(CLOCK) (((CLOCK) == USART_Clock_Disable) ||                                ((CLOCK) == USART_Clock_Enable))
N/**
N  * @}
N  */ 
N
N/** @defgroup USART_Clock_Polarity 
N  * @{
N  */
N  
N#define USART_CPOL_Low                       ((uint16_t)0x0000)
N#define USART_CPOL_High                      ((uint16_t)0x0400)
N#define IS_USART_CPOL(CPOL) (((CPOL) == USART_CPOL_Low) || ((CPOL) == USART_CPOL_High))
N
N/**
N  * @}
N  */ 
N
N/** @defgroup USART_Clock_Phase
N  * @{
N  */
N
N#define USART_CPHA_1Edge                     ((uint16_t)0x0000)
N#define USART_CPHA_2Edge                     ((uint16_t)0x0200)
N#define IS_USART_CPHA(CPHA) (((CPHA) == USART_CPHA_1Edge) || ((CPHA) == USART_CPHA_2Edge))
N
N/**
N  * @}
N  */
N
N/** @defgroup USART_Last_Bit
N  * @{
N  */
N
N#define USART_LastBit_Disable                ((uint16_t)0x0000)
N#define USART_LastBit_Enable                 ((uint16_t)0x0100)
N#define IS_USART_LASTBIT(LASTBIT) (((LASTBIT) == USART_LastBit_Disable) || \
N                                   ((LASTBIT) == USART_LastBit_Enable))
X#define IS_USART_LASTBIT(LASTBIT) (((LASTBIT) == USART_LastBit_Disable) ||                                    ((LASTBIT) == USART_LastBit_Enable))
N/**
N  * @}
N  */ 
N
N/** @defgroup USART_Interrupt_definition 
N  * @{
N  */
N  
N#define USART_IT_PE                          ((uint16_t)0x0028)
N#define USART_IT_TXE                         ((uint16_t)0x0727)
N#define USART_IT_TC                          ((uint16_t)0x0626)
N#define USART_IT_RXNE                        ((uint16_t)0x0525)
N#define USART_IT_IDLE                        ((uint16_t)0x0424)
N#define USART_IT_LBD                         ((uint16_t)0x0846)
N#define USART_IT_CTS                         ((uint16_t)0x096A)
N#define USART_IT_ERR                         ((uint16_t)0x0060)
N#define USART_IT_ORE                         ((uint16_t)0x0360)
N#define USART_IT_NE                          ((uint16_t)0x0260)
N#define USART_IT_FE                          ((uint16_t)0x0160)
N#define IS_USART_CONFIG_IT(IT) (((IT) == USART_IT_PE) || ((IT) == USART_IT_TXE) || \
N                               ((IT) == USART_IT_TC) || ((IT) == USART_IT_RXNE) || \
N                               ((IT) == USART_IT_IDLE) || ((IT) == USART_IT_LBD) || \
N                               ((IT) == USART_IT_CTS) || ((IT) == USART_IT_ERR))
X#define IS_USART_CONFIG_IT(IT) (((IT) == USART_IT_PE) || ((IT) == USART_IT_TXE) ||                                ((IT) == USART_IT_TC) || ((IT) == USART_IT_RXNE) ||                                ((IT) == USART_IT_IDLE) || ((IT) == USART_IT_LBD) ||                                ((IT) == USART_IT_CTS) || ((IT) == USART_IT_ERR))
N#define IS_USART_GET_IT(IT) (((IT) == USART_IT_PE) || ((IT) == USART_IT_TXE) || \
N                            ((IT) == USART_IT_TC) || ((IT) == USART_IT_RXNE) || \
N                            ((IT) == USART_IT_IDLE) || ((IT) == USART_IT_LBD) || \
N                            ((IT) == USART_IT_CTS) || ((IT) == USART_IT_ORE) || \
N                            ((IT) == USART_IT_NE) || ((IT) == USART_IT_FE))
X#define IS_USART_GET_IT(IT) (((IT) == USART_IT_PE) || ((IT) == USART_IT_TXE) ||                             ((IT) == USART_IT_TC) || ((IT) == USART_IT_RXNE) ||                             ((IT) == USART_IT_IDLE) || ((IT) == USART_IT_LBD) ||                             ((IT) == USART_IT_CTS) || ((IT) == USART_IT_ORE) ||                             ((IT) == USART_IT_NE) || ((IT) == USART_IT_FE))
N#define IS_USART_CLEAR_IT(IT) (((IT) == USART_IT_TC) || ((IT) == USART_IT_RXNE) || \
N                               ((IT) == USART_IT_LBD) || ((IT) == USART_IT_CTS))
X#define IS_USART_CLEAR_IT(IT) (((IT) == USART_IT_TC) || ((IT) == USART_IT_RXNE) ||                                ((IT) == USART_IT_LBD) || ((IT) == USART_IT_CTS))
N/**
N  * @}
N  */
N
N/** @defgroup USART_DMA_Requests 
N  * @{
N  */
N
N#define USART_DMAReq_Tx                      ((uint16_t)0x0080)
N#define USART_DMAReq_Rx                      ((uint16_t)0x0040)
N#define IS_USART_DMAREQ(DMAREQ) ((((DMAREQ) & (uint16_t)0xFF3F) == 0x00) && ((DMAREQ) != (uint16_t)0x00))
N
N/**
N  * @}
N  */ 
N
N/** @defgroup USART_WakeUp_methods
N  * @{
N  */
N
N#define USART_WakeUp_IdleLine                ((uint16_t)0x0000)
N#define USART_WakeUp_AddressMark             ((uint16_t)0x0800)
N#define IS_USART_WAKEUP(WAKEUP) (((WAKEUP) == USART_WakeUp_IdleLine) || \
N                                 ((WAKEUP) == USART_WakeUp_AddressMark))
X#define IS_USART_WAKEUP(WAKEUP) (((WAKEUP) == USART_WakeUp_IdleLine) ||                                  ((WAKEUP) == USART_WakeUp_AddressMark))
N/**
N  * @}
N  */
N
N/** @defgroup USART_LIN_Break_Detection_Length 
N  * @{
N  */
N  
N#define USART_LINBreakDetectLength_10b      ((uint16_t)0x0000)
N#define USART_LINBreakDetectLength_11b      ((uint16_t)0x0020)
N#define IS_USART_LIN_BREAK_DETECT_LENGTH(LENGTH) \
N                               (((LENGTH) == USART_LINBreakDetectLength_10b) || \
N                                ((LENGTH) == USART_LINBreakDetectLength_11b))
X#define IS_USART_LIN_BREAK_DETECT_LENGTH(LENGTH)                                (((LENGTH) == USART_LINBreakDetectLength_10b) ||                                 ((LENGTH) == USART_LINBreakDetectLength_11b))
N/**
N  * @}
N  */
N
N/** @defgroup USART_IrDA_Low_Power 
N  * @{
N  */
N
N#define USART_IrDAMode_LowPower              ((uint16_t)0x0004)
N#define USART_IrDAMode_Normal                ((uint16_t)0x0000)
N#define IS_USART_IRDA_MODE(MODE) (((MODE) == USART_IrDAMode_LowPower) || \
N                                  ((MODE) == USART_IrDAMode_Normal))
X#define IS_USART_IRDA_MODE(MODE) (((MODE) == USART_IrDAMode_LowPower) ||                                   ((MODE) == USART_IrDAMode_Normal))
N/**
N  * @}
N  */ 
N
N/** @defgroup USART_Flags 
N  * @{
N  */
N
N#define USART_FLAG_CTS                       ((uint16_t)0x0200)
N#define USART_FLAG_LBD                       ((uint16_t)0x0100)
N#define USART_FLAG_TXE                       ((uint16_t)0x0080)
N#define USART_FLAG_TC                        ((uint16_t)0x0040)
N#define USART_FLAG_RXNE                      ((uint16_t)0x0020)
N#define USART_FLAG_IDLE                      ((uint16_t)0x0010)
N#define USART_FLAG_ORE                       ((uint16_t)0x0008)
N#define USART_FLAG_NE                        ((uint16_t)0x0004)
N#define USART_FLAG_FE                        ((uint16_t)0x0002)
N#define USART_FLAG_PE                        ((uint16_t)0x0001)
N#define IS_USART_FLAG(FLAG) (((FLAG) == USART_FLAG_PE) || ((FLAG) == USART_FLAG_TXE) || \
N                             ((FLAG) == USART_FLAG_TC) || ((FLAG) == USART_FLAG_RXNE) || \
N                             ((FLAG) == USART_FLAG_IDLE) || ((FLAG) == USART_FLAG_LBD) || \
N                             ((FLAG) == USART_FLAG_CTS) || ((FLAG) == USART_FLAG_ORE) || \
N                             ((FLAG) == USART_FLAG_NE) || ((FLAG) == USART_FLAG_FE))
X#define IS_USART_FLAG(FLAG) (((FLAG) == USART_FLAG_PE) || ((FLAG) == USART_FLAG_TXE) ||                              ((FLAG) == USART_FLAG_TC) || ((FLAG) == USART_FLAG_RXNE) ||                              ((FLAG) == USART_FLAG_IDLE) || ((FLAG) == USART_FLAG_LBD) ||                              ((FLAG) == USART_FLAG_CTS) || ((FLAG) == USART_FLAG_ORE) ||                              ((FLAG) == USART_FLAG_NE) || ((FLAG) == USART_FLAG_FE))
N                              
N#define IS_USART_CLEAR_FLAG(FLAG) ((((FLAG) & (uint16_t)0xFC9F) == 0x00) && ((FLAG) != (uint16_t)0x00))
N#define IS_USART_PERIPH_FLAG(PERIPH, USART_FLAG) ((((*(uint32_t*)&(PERIPH)) != UART4_BASE) &&\
N                                                  ((*(uint32_t*)&(PERIPH)) != UART5_BASE)) \
N                                                  || ((USART_FLAG) != USART_FLAG_CTS)) 
X#define IS_USART_PERIPH_FLAG(PERIPH, USART_FLAG) ((((*(uint32_t*)&(PERIPH)) != UART4_BASE) &&                                                  ((*(uint32_t*)&(PERIPH)) != UART5_BASE))                                                   || ((USART_FLAG) != USART_FLAG_CTS)) 
N#define IS_USART_BAUDRATE(BAUDRATE) (((BAUDRATE) > 0) && ((BAUDRATE) < 0x0044AA21))
N#define IS_USART_ADDRESS(ADDRESS) ((ADDRESS) <= 0xF)
N#define IS_USART_DATA(DATA) ((DATA) <= 0x1FF)
N
N/**
N  * @}
N  */ 
N
N/**
N  * @}
N  */ 
N
N/** @defgroup USART_Exported_Macros
N  * @{
N  */ 
N
N/**
N  * @}
N  */ 
N
N/** @defgroup USART_Exported_Functions
N  * @{
N  */
N
Nvoid USART_DeInit(USART_TypeDef* USARTx);
Nvoid USART_Init(USART_TypeDef* USARTx, USART_InitTypeDef* USART_InitStruct);
Nvoid USART_StructInit(USART_InitTypeDef* USART_InitStruct);
Nvoid USART_ClockInit(USART_TypeDef* USARTx, USART_ClockInitTypeDef* USART_ClockInitStruct);
Nvoid USART_ClockStructInit(USART_ClockInitTypeDef* USART_ClockInitStruct);
Nvoid USART_Cmd(USART_TypeDef* USARTx, FunctionalState NewState);
Nvoid USART_ITConfig(USART_TypeDef* USARTx, uint16_t USART_IT, FunctionalState NewState);
Nvoid USART_DMACmd(USART_TypeDef* USARTx, uint16_t USART_DMAReq, FunctionalState NewState);
Nvoid USART_SetAddress(USART_TypeDef* USARTx, uint8_t USART_Address);
Nvoid USART_WakeUpConfig(USART_TypeDef* USARTx, uint16_t USART_WakeUp);
Nvoid USART_ReceiverWakeUpCmd(USART_TypeDef* USARTx, FunctionalState NewState);
Nvoid USART_LINBreakDetectLengthConfig(USART_TypeDef* USARTx, uint16_t USART_LINBreakDetectLength);
Nvoid USART_LINCmd(USART_TypeDef* USARTx, FunctionalState NewState);
Nvoid USART_SendData(USART_TypeDef* USARTx, uint16_t Data);
Nuint16_t USART_ReceiveData(USART_TypeDef* USARTx);
Nvoid USART_SendBreak(USART_TypeDef* USARTx);
Nvoid USART_SetGuardTime(USART_TypeDef* USARTx, uint8_t USART_GuardTime);
Nvoid USART_SetPrescaler(USART_TypeDef* USARTx, uint8_t USART_Prescaler);
Nvoid USART_SmartCardCmd(USART_TypeDef* USARTx, FunctionalState NewState);
Nvoid USART_SmartCardNACKCmd(USART_TypeDef* USARTx, FunctionalState NewState);
Nvoid USART_HalfDuplexCmd(USART_TypeDef* USARTx, FunctionalState NewState);
Nvoid USART_OverSampling8Cmd(USART_TypeDef* USARTx, FunctionalState NewState);
Nvoid USART_OneBitMethodCmd(USART_TypeDef* USARTx, FunctionalState NewState);
Nvoid USART_IrDAConfig(USART_TypeDef* USARTx, uint16_t USART_IrDAMode);
Nvoid USART_IrDACmd(USART_TypeDef* USARTx, FunctionalState NewState);
NFlagStatus USART_GetFlagStatus(USART_TypeDef* USARTx, uint16_t USART_FLAG);
Nvoid USART_ClearFlag(USART_TypeDef* USARTx, uint16_t USART_FLAG);
NITStatus USART_GetITStatus(USART_TypeDef* USARTx, uint16_t USART_IT);
Nvoid USART_ClearITPendingBit(USART_TypeDef* USARTx, uint16_t USART_IT);
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif /* __STM32F10x_USART_H */
N/**
N  * @}
N  */ 
N
N/**
N  * @}
N  */ 
N
N/**
N  * @}
N  */ 
N
N/******************* (C) COPYRIGHT 2011 STMicroelectronics *****END OF FILE****/
L 49 "..\..\User\stm32f10x_conf.h" 2
N#include "stm32f10x_wwdg.h" 
L 1 "..\..\Libraries\FWlib\inc\stm32f10x_wwdg.h" 1
N/**
N  ******************************************************************************
N  * @file    stm32f10x_wwdg.h
N  * @author  MCD Application Team
N  * @version V3.5.0
N  * @date    11-March-2011
N  * @brief   This file contains all the functions prototypes for the WWDG firmware
N  *          library.
N  ******************************************************************************
N  * @attention
N  *
N  * THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
N  * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE
N  * TIME. AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY
N  * DIRECT, INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING
N  * FROM THE CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE
N  * CODING INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
N  *
N  * <h2><center>&copy; COPYRIGHT 2011 STMicroelectronics</center></h2>
N  ******************************************************************************
N  */
N
N/* Define to prevent recursive inclusion -------------------------------------*/
N#ifndef __STM32F10x_WWDG_H
N#define __STM32F10x_WWDG_H
N
N#ifdef __cplusplus
S extern "C" {
N#endif
N
N/* Includes ------------------------------------------------------------------*/
N#include "stm32f10x.h"
N
N/** @addtogroup STM32F10x_StdPeriph_Driver
N  * @{
N  */
N
N/** @addtogroup WWDG
N  * @{
N  */ 
N
N/** @defgroup WWDG_Exported_Types
N  * @{
N  */ 
N  
N/**
N  * @}
N  */ 
N
N/** @defgroup WWDG_Exported_Constants
N  * @{
N  */ 
N  
N/** @defgroup WWDG_Prescaler 
N  * @{
N  */ 
N  
N#define WWDG_Prescaler_1    ((uint32_t)0x00000000)
N#define WWDG_Prescaler_2    ((uint32_t)0x00000080)
N#define WWDG_Prescaler_4    ((uint32_t)0x00000100)
N#define WWDG_Prescaler_8    ((uint32_t)0x00000180)
N#define IS_WWDG_PRESCALER(PRESCALER) (((PRESCALER) == WWDG_Prescaler_1) || \
N                                      ((PRESCALER) == WWDG_Prescaler_2) || \
N                                      ((PRESCALER) == WWDG_Prescaler_4) || \
N                                      ((PRESCALER) == WWDG_Prescaler_8))
X#define IS_WWDG_PRESCALER(PRESCALER) (((PRESCALER) == WWDG_Prescaler_1) ||                                       ((PRESCALER) == WWDG_Prescaler_2) ||                                       ((PRESCALER) == WWDG_Prescaler_4) ||                                       ((PRESCALER) == WWDG_Prescaler_8))
N#define IS_WWDG_WINDOW_VALUE(VALUE) ((VALUE) <= 0x7F)
N#define IS_WWDG_COUNTER(COUNTER) (((COUNTER) >= 0x40) && ((COUNTER) <= 0x7F))
N
N/**
N  * @}
N  */ 
N
N/**
N  * @}
N  */ 
N
N/** @defgroup WWDG_Exported_Macros
N  * @{
N  */ 
N/**
N  * @}
N  */ 
N
N/** @defgroup WWDG_Exported_Functions
N  * @{
N  */ 
N  
Nvoid WWDG_DeInit(void);
Nvoid WWDG_SetPrescaler(uint32_t WWDG_Prescaler);
Nvoid WWDG_SetWindowValue(uint8_t WindowValue);
Nvoid WWDG_EnableIT(void);
Nvoid WWDG_SetCounter(uint8_t Counter);
Nvoid WWDG_Enable(uint8_t Counter);
NFlagStatus WWDG_GetFlagStatus(void);
Nvoid WWDG_ClearFlag(void);
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif /* __STM32F10x_WWDG_H */
N
N/**
N  * @}
N  */ 
N
N/**
N  * @}
N  */ 
N
N/**
N  * @}
N  */ 
N
N/******************* (C) COPYRIGHT 2011 STMicroelectronics *****END OF FILE****/
L 50 "..\..\User\stm32f10x_conf.h" 2
N#include "misc.h" /* High level functions for NVIC and SysTick (add-on to CMSIS functions) */
L 1 "..\..\Libraries\FWlib\inc\misc.h" 1
N/**
N  ******************************************************************************
N  * @file    misc.h
N  * @author  MCD Application Team
N  * @version V3.5.0
N  * @date    11-March-2011
N  * @brief   This file contains all the functions prototypes for the miscellaneous
N  *          firmware library functions (add-on to CMSIS functions).
N  ******************************************************************************
N  * @attention
N  *
N  * THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
N  * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE
N  * TIME. AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY
N  * DIRECT, INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING
N  * FROM THE CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE
N  * CODING INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
N  *
N  * <h2><center>&copy; COPYRIGHT 2011 STMicroelectronics</center></h2>
N  ******************************************************************************
N  */
N
N/* Define to prevent recursive inclusion -------------------------------------*/
N#ifndef __MISC_H
N#define __MISC_H
N
N#ifdef __cplusplus
S extern "C" {
N#endif
N
N/* Includes ------------------------------------------------------------------*/
N#include "stm32f10x.h"
N
N/** @addtogroup STM32F10x_StdPeriph_Driver
N  * @{
N  */
N
N/** @addtogroup MISC
N  * @{
N  */
N
N/** @defgroup MISC_Exported_Types
N  * @{
N  */
N
N/** 
N  * @brief  NVIC Init Structure definition  
N  */
N
Ntypedef struct
N{
N  uint8_t NVIC_IRQChannel;                    /*!< Specifies the IRQ channel to be enabled or disabled.
N                                                   This parameter can be a value of @ref IRQn_Type 
N                                                   (For the complete STM32 Devices IRQ Channels list, please
N                                                    refer to stm32f10x.h file) */
N
N  uint8_t NVIC_IRQChannelPreemptionPriority;  /*!< Specifies the pre-emption priority for the IRQ channel
N                                                   specified in NVIC_IRQChannel. This parameter can be a value
N                                                   between 0 and 15 as described in the table @ref NVIC_Priority_Table */
N
N  uint8_t NVIC_IRQChannelSubPriority;         /*!< Specifies the subpriority level for the IRQ channel specified
N                                                   in NVIC_IRQChannel. This parameter can be a value
N                                                   between 0 and 15 as described in the table @ref NVIC_Priority_Table */
N
N  FunctionalState NVIC_IRQChannelCmd;         /*!< Specifies whether the IRQ channel defined in NVIC_IRQChannel
N                                                   will be enabled or disabled. 
N                                                   This parameter can be set either to ENABLE or DISABLE */   
N} NVIC_InitTypeDef;
N 
N/**
N  * @}
N  */
N
N/** @defgroup NVIC_Priority_Table 
N  * @{
N  */
N
N/**
N@code  
N The table below gives the allowed values of the pre-emption priority and subpriority according
N to the Priority Grouping configuration performed by NVIC_PriorityGroupConfig function
N  ============================================================================================================================
N    NVIC_PriorityGroup   | NVIC_IRQChannelPreemptionPriority | NVIC_IRQChannelSubPriority  | Description
N  ============================================================================================================================
N   NVIC_PriorityGroup_0  |                0                  |            0-15             |   0 bits for pre-emption priority
N                         |                                   |                             |   4 bits for subpriority
N  ----------------------------------------------------------------------------------------------------------------------------
N   NVIC_PriorityGroup_1  |                0-1                |            0-7              |   1 bits for pre-emption priority
N                         |                                   |                             |   3 bits for subpriority
N  ----------------------------------------------------------------------------------------------------------------------------    
N   NVIC_PriorityGroup_2  |                0-3                |            0-3              |   2 bits for pre-emption priority
N                         |                                   |                             |   2 bits for subpriority
N  ----------------------------------------------------------------------------------------------------------------------------    
N   NVIC_PriorityGroup_3  |                0-7                |            0-1              |   3 bits for pre-emption priority
N                         |                                   |                             |   1 bits for subpriority
N  ----------------------------------------------------------------------------------------------------------------------------    
N   NVIC_PriorityGroup_4  |                0-15               |            0                |   4 bits for pre-emption priority
N                         |                                   |                             |   0 bits for subpriority                       
N  ============================================================================================================================
N@endcode
N*/
N
N/**
N  * @}
N  */
N
N/** @defgroup MISC_Exported_Constants
N  * @{
N  */
N
N/** @defgroup Vector_Table_Base 
N  * @{
N  */
N
N#define NVIC_VectTab_RAM             ((uint32_t)0x20000000)
N#define NVIC_VectTab_FLASH           ((uint32_t)0x08000000)
N#define IS_NVIC_VECTTAB(VECTTAB) (((VECTTAB) == NVIC_VectTab_RAM) || \
N                                  ((VECTTAB) == NVIC_VectTab_FLASH))
X#define IS_NVIC_VECTTAB(VECTTAB) (((VECTTAB) == NVIC_VectTab_RAM) ||                                   ((VECTTAB) == NVIC_VectTab_FLASH))
N/**
N  * @}
N  */
N
N/** @defgroup System_Low_Power 
N  * @{
N  */
N
N#define NVIC_LP_SEVONPEND            ((uint8_t)0x10)
N#define NVIC_LP_SLEEPDEEP            ((uint8_t)0x04)
N#define NVIC_LP_SLEEPONEXIT          ((uint8_t)0x02)
N#define IS_NVIC_LP(LP) (((LP) == NVIC_LP_SEVONPEND) || \
N                        ((LP) == NVIC_LP_SLEEPDEEP) || \
N                        ((LP) == NVIC_LP_SLEEPONEXIT))
X#define IS_NVIC_LP(LP) (((LP) == NVIC_LP_SEVONPEND) ||                         ((LP) == NVIC_LP_SLEEPDEEP) ||                         ((LP) == NVIC_LP_SLEEPONEXIT))
N/**
N  * @}
N  */
N
N/** @defgroup Preemption_Priority_Group 
N  * @{
N  */
N
N#define NVIC_PriorityGroup_0         ((uint32_t)0x700) /*!< 0 bits for pre-emption priority
N                                                            4 bits for subpriority */
N#define NVIC_PriorityGroup_1         ((uint32_t)0x600) /*!< 1 bits for pre-emption priority
N                                                            3 bits for subpriority */
N#define NVIC_PriorityGroup_2         ((uint32_t)0x500) /*!< 2 bits for pre-emption priority
N                                                            2 bits for subpriority */
N#define NVIC_PriorityGroup_3         ((uint32_t)0x400) /*!< 3 bits for pre-emption priority
N                                                            1 bits for subpriority */
N#define NVIC_PriorityGroup_4         ((uint32_t)0x300) /*!< 4 bits for pre-emption priority
N                                                            0 bits for subpriority */
N
N#define IS_NVIC_PRIORITY_GROUP(GROUP) (((GROUP) == NVIC_PriorityGroup_0) || \
N                                       ((GROUP) == NVIC_PriorityGroup_1) || \
N                                       ((GROUP) == NVIC_PriorityGroup_2) || \
N                                       ((GROUP) == NVIC_PriorityGroup_3) || \
N                                       ((GROUP) == NVIC_PriorityGroup_4))
X#define IS_NVIC_PRIORITY_GROUP(GROUP) (((GROUP) == NVIC_PriorityGroup_0) ||                                        ((GROUP) == NVIC_PriorityGroup_1) ||                                        ((GROUP) == NVIC_PriorityGroup_2) ||                                        ((GROUP) == NVIC_PriorityGroup_3) ||                                        ((GROUP) == NVIC_PriorityGroup_4))
N
N#define IS_NVIC_PREEMPTION_PRIORITY(PRIORITY)  ((PRIORITY) < 0x10)
N
N#define IS_NVIC_SUB_PRIORITY(PRIORITY)  ((PRIORITY) < 0x10)
N
N#define IS_NVIC_OFFSET(OFFSET)  ((OFFSET) < 0x000FFFFF)
N
N/**
N  * @}
N  */
N
N/** @defgroup SysTick_clock_source 
N  * @{
N  */
N
N#define SysTick_CLKSource_HCLK_Div8    ((uint32_t)0xFFFFFFFB)
N#define SysTick_CLKSource_HCLK         ((uint32_t)0x00000004)
N#define IS_SYSTICK_CLK_SOURCE(SOURCE) (((SOURCE) == SysTick_CLKSource_HCLK) || \
N                                       ((SOURCE) == SysTick_CLKSource_HCLK_Div8))
X#define IS_SYSTICK_CLK_SOURCE(SOURCE) (((SOURCE) == SysTick_CLKSource_HCLK) ||                                        ((SOURCE) == SysTick_CLKSource_HCLK_Div8))
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */
N
N/** @defgroup MISC_Exported_Macros
N  * @{
N  */
N
N/**
N  * @}
N  */
N
N/** @defgroup MISC_Exported_Functions
N  * @{
N  */
N
Nvoid NVIC_PriorityGroupConfig(uint32_t NVIC_PriorityGroup);
Nvoid NVIC_Init(NVIC_InitTypeDef* NVIC_InitStruct);
Nvoid NVIC_SetVectorTable(uint32_t NVIC_VectTab, uint32_t Offset);
Nvoid NVIC_SystemLPConfig(uint8_t LowPowerMode, FunctionalState NewState);
Nvoid SysTick_CLKSourceConfig(uint32_t SysTick_CLKSource);
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif /* __MISC_H */
N
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */
N
N/******************* (C) COPYRIGHT 2011 STMicroelectronics *****END OF FILE****/
L 51 "..\..\User\stm32f10x_conf.h" 2
N
N/* Exported types ------------------------------------------------------------*/
N/* Exported constants --------------------------------------------------------*/
N/* Uncomment the line below to expanse the "assert_param" macro in the 
N   Standard Peripheral Library drivers code */
N/* #define USE_FULL_ASSERT    1 */
N
N/* Exported macro ------------------------------------------------------------*/
N#ifdef  USE_FULL_ASSERT
S
S/**
S  * @brief  The assert_param macro is used for function's parameters check.
S  * @param  expr: If expr is false, it calls assert_failed function which reports 
S  *         the name of the source file and the source line number of the call 
S  *         that failed. If expr is true, it returns no value.
S  * @retval None
S  */
S  #define assert_param(expr) ((expr) ? (void)0 : assert_failed((uint8_t *)__FILE__, __LINE__))
S/* Exported functions ------------------------------------------------------- */
S  void assert_failed(uint8_t* file, uint32_t line);
N#else
N  #define assert_param(expr) ((void)0)
N#endif /* USE_FULL_ASSERT */
N
N#endif /* __STM32F10x_CONF_H */
N
N/******************* (C) COPYRIGHT 2011 STMicroelectronics *****END OF FILE****/
L 8298 "..\..\Libraries\CMSIS\stm32f10x.h" 2
N#endif
N
N/** @addtogroup Exported_macro
N  * @{
N  */
N
N#define SET_BIT(REG, BIT)     ((REG) |= (BIT))
N
N#define CLEAR_BIT(REG, BIT)   ((REG) &= ~(BIT))
N
N#define READ_BIT(REG, BIT)    ((REG) & (BIT))
N
N#define CLEAR_REG(REG)        ((REG) = (0x0))
N
N#define WRITE_REG(REG, VAL)   ((REG) = (VAL))
N
N#define READ_REG(REG)         ((REG))
N
N#define MODIFY_REG(REG, CLEARMASK, SETMASK)  WRITE_REG((REG), (((READ_REG(REG)) & (~(CLEARMASK))) | (SETMASK)))
N
N/**
N  * @}
N  */
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif /* __STM32F10x_H */
N
N/**
N  * @}
N  */
N
N  /**
N  * @}
N  */
N
N/******************* (C) COPYRIGHT 2011 STMicroelectronics *****END OF FILE****/
L 4 "..\..\User\main.c" 2
N#include "./ov7725/bsp_ov7725.h"
L 1 "..\..\User\./ov7725/bsp_ov7725.h" 1
N#ifndef __OV7725_H
N#define __OV7725_H 
N	   
N#include "stm32f10x.h"
N
N#define camera_HEIGHT 272
N#define camera_WIDTH   480
N
N
N/*ÉãÏñÍ·ÅäÖÃ½á¹¹Ìå*/
Ntypedef struct
N{	
N
N	
N	uint8_t QVGA_VGA; //0£ºQVGA£¬1VGA
N	
N	/*VGA:sx + width <= 320 »ò 240 ,sy+height <= 320 »ò 240*/
N	/*QVGA:sx + width <= 320 ,sy+height <= 240*/
N	uint16_t cam_sx; //ÉãÏñÍ·´°¿ÚXÆðÊ¼Î»ÖÃ
N	uint16_t cam_sy; //ÉãÏñÍ·´°¿ÚYÆðÊ¼Î»ÖÃ
N	
N	uint16_t cam_width;//Í¼Ïñ·Ö±æÂÊ£¬¿í
N	uint16_t cam_height;//Í¼Ïñ·Ö±æÂÊ£¬¸ß
N	
N	uint16_t lcd_sx;//Í¼ÏñÏÔÊ¾ÔÚÒº¾§ÆÁµÄXÆðÊ¼Î»ÖÃ
N	uint16_t lcd_sy;//Í¼ÏñÏÔÊ¾ÔÚÒº¾§ÆÁµÄYÆðÊ¼Î»ÖÃ
N	uint8_t lcd_scan;//Òº¾§ÆÁµÄÉ¨ÃèÄ£Ê½£¨0-7£©
N	
N	uint8_t light_mode;//¹âÕÕÄ£Ê½£¬²ÎÊý·¶Î§[0~5]
N	int8_t saturation;//±¥ºÍ¶È,²ÎÊý·¶Î§[-4 ~ +4]   
N	int8_t brightness;//¹âÕÕ¶È£¬²ÎÊý·¶Î§[-4~+4]
N	int8_t contrast;//¶Ô±È¶È£¬²ÎÊý·¶Î§[-4~+4]
N	uint8_t effect;	//ÌØÊâÐ§¹û£¬²ÎÊý·¶Î§[0~6]:	
N
N
N}OV7725_MODE_PARAM;
N
N
N/* ¼Ä´æÆ÷ºê¶¨Òå */
N#define REG_GAIN      0x00
N#define REG_BLUE      0x01
N#define REG_RED       0x02
N#define REG_GREEN     0x03
N#define REG_BAVG      0x05
N#define REG_GAVG      0x06
N#define REG_RAVG      0x07
N#define REG_AECH      0x08
N#define REG_COM2      0x09
N#define REG_PID       0x0A
N#define REG_VER       0x0B
N#define REG_COM3      0x0C
N#define REG_COM4      0x0D
N#define REG_COM5      0x0E
N#define REG_COM6      0x0F
N#define REG_AEC       0x10
N#define REG_CLKRC     0x11
N#define REG_COM7      0x12
N#define REG_COM8      0x13
N#define REG_COM9      0x14
N#define REG_COM10     0x15
N#define REG_REG16     0x16
N#define REG_HSTART    0x17
N#define REG_HSIZE     0x18
N#define REG_VSTRT     0x19
N#define REG_VSIZE     0x1A
N#define REG_PSHFT     0x1B
N#define REG_MIDH      0x1C
N#define REG_MIDL      0x1D
N#define REG_LAEC      0x1F
N#define REG_COM11     0x20
N#define REG_BDBase    0x22
N#define REG_BDMStep   0x23
N#define REG_AEW       0x24
N#define REG_AEB       0x25
N#define REG_VPT       0x26
N#define REG_REG28     0x28
N#define REG_HOutSize  0x29
N#define REG_EXHCH     0x2A
N#define REG_EXHCL     0x2B
N#define REG_VOutSize  0x2C
N#define REG_ADVFL     0x2D
N#define REG_ADVFH     0x2E
N#define REG_YAVE      0x2F
N#define REG_LumHTh    0x30
N#define REG_LumLTh    0x31
N#define REG_HREF      0x32
N#define REG_DM_LNL    0x33
N#define REG_DM_LNH    0x34
N#define REG_ADoff_B   0x35
N#define REG_ADoff_R   0x36
N#define REG_ADoff_Gb  0x37
N#define REG_ADoff_Gr  0x38
N#define REG_Off_B     0x39
N#define REG_Off_R     0x3A
N#define REG_Off_Gb    0x3B
N#define REG_Off_Gr    0x3C
N#define REG_COM12     0x3D
N#define REG_COM13     0x3E
N#define REG_COM14     0x3F
N#define REG_COM16     0x41
N#define REG_TGT_B     0x42
N#define REG_TGT_R     0x43
N#define REG_TGT_Gb    0x44
N#define REG_TGT_Gr    0x45
N#define REG_LC_CTR    0x46
N#define REG_LC_XC     0x47
N#define REG_LC_YC     0x48
N#define REG_LC_COEF   0x49
N#define REG_LC_RADI   0x4A
N#define REG_LC_COEFB  0x4B 
N#define REG_LC_COEFR  0x4C
N#define REG_FixGain   0x4D
N#define REG_AREF1     0x4F
N#define REG_AREF6     0x54
N#define REG_UFix      0x60
N#define REG_VFix      0x61
N#define REG_AWBb_blk  0x62
N#define REG_AWB_Ctrl0 0x63
N#define REG_DSP_Ctrl1 0x64
N#define REG_DSP_Ctrl2 0x65
N#define REG_DSP_Ctrl3 0x66
N#define REG_DSP_Ctrl4 0x67
N#define REG_AWB_bias  0x68
N#define REG_AWBCtrl1  0x69
N#define REG_AWBCtrl2  0x6A
N#define REG_AWBCtrl3  0x6B
N#define REG_AWBCtrl4  0x6C
N#define REG_AWBCtrl5  0x6D
N#define REG_AWBCtrl6  0x6E
N#define REG_AWBCtrl7  0x6F
N#define REG_AWBCtrl8  0x70
N#define REG_AWBCtrl9  0x71
N#define REG_AWBCtrl10 0x72
N#define REG_AWBCtrl11 0x73
N#define REG_AWBCtrl12 0x74
N#define REG_AWBCtrl13 0x75
N#define REG_AWBCtrl14 0x76
N#define REG_AWBCtrl15 0x77
N#define REG_AWBCtrl16 0x78
N#define REG_AWBCtrl17 0x79
N#define REG_AWBCtrl18 0x7A
N#define REG_AWBCtrl19 0x7B
N#define REG_AWBCtrl20 0x7C
N#define REG_AWBCtrl21 0x7D 
N#define REG_GAM1      0x7E
N#define REG_GAM2      0x7F
N#define REG_GAM3      0x80
N#define REG_GAM4      0x81
N#define REG_GAM5      0x82
N#define REG_GAM6      0x83
N#define REG_GAM7      0x84
N#define REG_GAM8      0x85
N#define REG_GAM9      0x86
N#define REG_GAM10     0x87
N#define REG_GAM11     0x88
N#define REG_GAM12     0x89
N#define REG_GAM13     0x8A
N#define REG_GAM14     0x8B
N#define REG_GAM15     0x8C
N#define REG_SLOP      0x8D
N#define REG_DNSTh     0x8E
N#define REG_EDGE0     0x8F
N#define REG_EDGE1     0x90
N#define REG_DNSOff    0x91
N#define REG_EDGE2     0x92
N#define REG_EDGE3     0x93
N#define REG_MTX1      0x94
N#define REG_MTX2      0x95
N#define REG_MTX3      0x96
N#define REG_MTX4      0x97
N#define REG_MTX5      0x98
N#define REG_MTX6      0x99
N#define REG_MTX_Ctrl  0x9A
N#define REG_BRIGHT    0x9B
N#define REG_CNST      0x9C
N#define REG_UVADJ0    0x9E
N#define REG_UVADJ1    0x9F
N#define REG_SCAL0     0xA0
N#define REG_SCAL1     0xA1
N#define REG_SCAL2     0xA2
N#define REG_SDE       0xA6
N#define REG_USAT      0xA7
N#define REG_VSAT      0xA8
N#define REG_HUECOS    0xA9
N#define REG_HUESIN    0xAA
N#define REG_SIGN      0xAB
N#define REG_DSPAuto   0xAC
N
N
N
N/************************** OV7725 Á¬½ÓÒý½Å¶¨Òå********************************/
N// FIFO Êä³öÊ¹ÄÜ£¬¼´Ä£¿éÖÐµÄOE
N#define      OV7725_OE_GPIO_CLK                       RCC_APB2Periph_GPIOA
N#define      OV7725_OE_GPIO_PORT                      GPIOA
N#define      OV7725_OE_GPIO_PIN                       GPIO_Pin_3
N
N// FIFO Ð´¸´Î»
N#define      OV7725_WRST_GPIO_CLK                     RCC_APB2Periph_GPIOC
N#define      OV7725_WRST_GPIO_PORT                    GPIOC
N#define      OV7725_WRST_GPIO_PIN                     GPIO_Pin_4
N
N// FIFO ¶Á¸´Î»
N#define      OV7725_RRST_GPIO_CLK                     RCC_APB2Periph_GPIOA
N#define      OV7725_RRST_GPIO_PORT                    GPIOA
N#define      OV7725_RRST_GPIO_PIN                     GPIO_Pin_2
N
N// FIFO ¶ÁÊ±ÖÓ
N#define      OV7725_RCLK_GPIO_CLK                     RCC_APB2Periph_GPIOC
N#define      OV7725_RCLK_GPIO_PORT                    GPIOC
N#define      OV7725_RCLK_GPIO_PIN                     GPIO_Pin_5
N
N// FIFO Ð´Ê¹ÄÜ
N#define      OV7725_WE_GPIO_CLK                       RCC_APB2Periph_GPIOD
N#define      OV7725_WE_GPIO_PORT                      GPIOD
N#define      OV7725_WE_GPIO_PIN                       GPIO_Pin_3
N
N
N// 8Î»Êý¾Ý¿Ú
N#define      OV7725_DATA_GPIO_CLK                     RCC_APB2Periph_GPIOB
N#define      OV7725_DATA_GPIO_PORT                    GPIOB
N#define      OV7725_DATA_0_GPIO_PIN                   GPIO_Pin_8
N#define      OV7725_DATA_1_GPIO_PIN                   GPIO_Pin_9
N#define      OV7725_DATA_2_GPIO_PIN                   GPIO_Pin_10
N#define      OV7725_DATA_3_GPIO_PIN                   GPIO_Pin_11
N#define      OV7725_DATA_4_GPIO_PIN                   GPIO_Pin_12
N#define      OV7725_DATA_5_GPIO_PIN                   GPIO_Pin_13
N#define      OV7725_DATA_6_GPIO_PIN                   GPIO_Pin_14
N#define      OV7725_DATA_7_GPIO_PIN                   GPIO_Pin_15
N
N// OV7725³¡ÖÐ¶Ï
N#define      OV7725_VSYNC_GPIO_CLK                    RCC_APB2Periph_GPIOE
N#define      OV7725_VSYNC_GPIO_PORT                   GPIOC
N#define      OV7725_VSYNC_GPIO_PIN                    GPIO_Pin_3
N
N#define      OV7725_VSYNC_EXTI_SOURCE_PORT            GPIO_PortSourceGPIOC
N#define      OV7725_VSYNC_EXTI_SOURCE_PIN             GPIO_PinSource3
N#define      OV7725_VSYNC_EXTI_LINE                   EXTI_Line3
N#define      OV7725_VSYNC_EXTI_IRQ                    EXTI3_IRQn
N#define      OV7725_VSYNC_EXTI_INT_FUNCTION           EXTI3_IRQHandler
N
N
N
N
N#define FIFO_OE_H()     OV7725_OE_GPIO_PORT->BSRR =OV7725_OE_GPIO_PIN	  
N#define FIFO_OE_L()     OV7725_OE_GPIO_PORT->BRR  =OV7725_OE_GPIO_PIN	  /*À­µÍÊ¹FIFOÊä³öÊ¹ÄÜ*/
N
N#define FIFO_WRST_H()   OV7725_WRST_GPIO_PORT->BSRR =OV7725_WRST_GPIO_PIN	  /*À­¸ßÔÊÐíFIFOÐ´(Êý¾ÝfromÉãÏñÍ·)Ö¸ÕëÔË¶¯ */
N#define FIFO_WRST_L()   OV7725_WRST_GPIO_PORT->BRR  =OV7725_WRST_GPIO_PIN	  /*À­µÍÊ¹FIFOÐ´(Êý¾ÝfromÉãÏñÍ·)Ö¸Õë¸´Î»*/
N
N#define FIFO_RRST_H()   OV7725_RRST_GPIO_PORT->BSRR =OV7725_RRST_GPIO_PIN	  /*À­¸ßÔÊÐíFIFO¶Á(Êý¾Ý´ÓFIFOÊä³ö)Ö¸ÕëÔË¶¯ */
N#define FIFO_RRST_L()   OV7725_RRST_GPIO_PORT->BRR  =OV7725_RRST_GPIO_PIN	  /*À­µÍÊ¹FIFO¶Á(Êý¾Ý´ÓFIFOÊä³ö)Ö¸Õë¸´Î» */
N
N#define FIFO_RCLK_H()   OV7725_RCLK_GPIO_PORT->BSRR =OV7725_RCLK_GPIO_PIN	  
N#define FIFO_RCLK_L()   OV7725_RCLK_GPIO_PORT->BRR  =OV7725_RCLK_GPIO_PIN	  /*FIFOÊä³öÊý¾ÝÊ±ÖÓ*/
N
N#define FIFO_WE_H()     OV7725_WE_GPIO_PORT->BSRR =OV7725_WE_GPIO_PIN	  /*À­¸ßÊ¹FIFOÐ´ÔÊÐí*/
N#define FIFO_WE_L()     OV7725_WE_GPIO_PORT->BRR  =OV7725_WE_GPIO_PIN
N
N
N#define READ_FIFO_PIXEL(RGB565)   	do{\
N	                                  RGB565=0;\
N	                                  FIFO_RCLK_L();\
N	                                  RGB565 = (OV7725_DATA_GPIO_PORT->IDR) & 0xff00;\
N	                                  FIFO_RCLK_H();\
N                                    FIFO_RCLK_L();\
N	                                  RGB565 |= (OV7725_DATA_GPIO_PORT->IDR >>8) & 0x00ff;\
N	                                  FIFO_RCLK_H();\
N                                    }while(0)
X#define READ_FIFO_PIXEL(RGB565)   	do{	                                  RGB565=0;	                                  FIFO_RCLK_L();	                                  RGB565 = (OV7725_DATA_GPIO_PORT->IDR) & 0xff00;	                                  FIFO_RCLK_H();                                    FIFO_RCLK_L();	                                  RGB565 |= (OV7725_DATA_GPIO_PORT->IDR >>8) & 0x00ff;	                                  FIFO_RCLK_H();                                    }while(0)
N
N#define FIFO_PREPARE                do{\
N	                                  FIFO_RRST_L();\
N	                                  FIFO_RCLK_L();\
N	                                  FIFO_RCLK_H();\
N	                                  FIFO_RRST_H();\
N	                                  FIFO_RCLK_L();\
N	                                  FIFO_RCLK_H();\
N                                    }while(0)
X#define FIFO_PREPARE                do{	                                  FIFO_RRST_L();	                                  FIFO_RCLK_L();	                                  FIFO_RCLK_H();	                                  FIFO_RRST_H();	                                  FIFO_RCLK_L();	                                  FIFO_RCLK_H();                                    }while(0)
N
N#define OV7725_ID       0x21
N																		
N																		
N																		
N
N/*ÐÅÏ¢Êä³ö*/
N#define OV7725_DEBUG_ON         0
N
N#define OV7725_INFO(fmt,arg...)           printf("<<-OV7725-INFO->> "fmt"\n",##arg)
N#define OV7725_ERROR(fmt,arg...)          printf("<<-OV7725-ERROR->> "fmt"\n",##arg)
N#define OV7725_DEBUG(fmt,arg...)          do{\
N                                          if(OV7725_DEBUG_ON)\
N                                          printf("<<-OV7725-DEBUG->> [%d]"fmt"\n",__LINE__, ##arg);\
N                                          }while(0)
X#define OV7725_DEBUG(fmt,arg...)          do{                                          if(OV7725_DEBUG_ON)                                          printf("<<-OV7725-DEBUG->> [%d]"fmt"\n",__LINE__, ##arg);                                          }while(0)
N
N																		
N
Nvoid OV7725_GPIO_Config(void);
NErrorStatus OV7725_Init(void);
Nvoid ImagDisp(uint16_t sx,uint16_t sy,uint16_t width,uint16_t height);
Nvoid OV7725_Light_Mode(uint8_t mode);
Nvoid OV7725_Color_Saturation(int8_t sat);
Nvoid OV7725_Brightness(int8_t bri);
Nvoid OV7725_Contrast(int8_t cnst);
Nvoid OV7725_Special_Effect(uint8_t eff);
Nvoid VSYNC_Init(void);				
Nvoid OV7725_Window_Set(uint16_t sx,uint16_t sy,uint16_t width,uint16_t height,uint8_t QVGA_VGA);
Nvoid ShanWai_SendCamera(u16 length_w, u16 length_h);
Nvoid CameraFous(void);
Nvoid Camera_Set(void);
Nvoid Camera_Set_Test(void);
W "..\..\User\./ov7725/bsp_ov7725.h" 310 6 Deprecated declaration Camera_Init - give arg types
Nvoid Camera_Init();
N
N
N																					
N
N
N#endif
N
N
N
N
N
N
N
N
N
N
N
N
N
N
N
N
N
N
N
N
N
N
N
L 5 "..\..\User\main.c" 2
N#include "./lcd/bsp_ili9341_lcd.h"
L 1 "..\..\User\./lcd/bsp_ili9341_lcd.h" 1
N#ifndef      __BSP_ILI9341_LCD_H
N#define	     __BSP_ILI9341_LCD_H
N
N
N#include "stm32f10x.h"
N#include "./font/fonts.h"
L 1 "..\..\User\./font/fonts.h" 1
N#ifndef __FONT_H
N#define __FONT_H       
N
N#include "stm32f10x.h"
N#include "./font/fonts.h"
L 1 "..\..\User\./font/fonts.h" 1
N#ifndef __FONT_H
S#define __FONT_H       
S
S#include "stm32f10x.h"
S#include "./font/fonts.h"
S
S
S#define LINE(x) ((x) * (((sFONT *)LCD_GetFont())->Height))
S#define LINEY(x) ((x) * (((sFONT *)LCD_GetFont())->Width))
S
S/** @defgroup FONTS_Exported_Types
S  * @{
S  */ 
Stypedef struct _tFont
S{    
S  const uint8_t *table;
S  uint16_t Width;
S  uint16_t Height;
S  
S} sFONT;
S
Sextern sFONT Font24x32;
Sextern sFONT Font16x24;
Sextern sFONT Font8x16;
S
S//ÒªÖ§³ÖÖÐÎÄÐèÒªÊµÏÖ±¾º¯Êý£¬¿É²Î¿¼¡°Òº¾§ÏÔÊ¾ÖÐÓ¢ÎÄ£¨×Ö¿âÔÚÍâ²¿FLASH£©¡±Àý³Ì
S#define      GetGBKCode( ucBuffer, usChar ) 
S
S
N#endif /*end of __FONT_H    */
L 6 "..\..\User\./font/fonts.h" 2
N
N
N#define LINE(x) ((x) * (((sFONT *)LCD_GetFont())->Height))
N#define LINEY(x) ((x) * (((sFONT *)LCD_GetFont())->Width))
N
N/** @defgroup FONTS_Exported_Types
N  * @{
N  */ 
Ntypedef struct _tFont
N{    
N  const uint8_t *table;
N  uint16_t Width;
N  uint16_t Height;
N  
N} sFONT;
N
Nextern sFONT Font24x32;
Nextern sFONT Font16x24;
Nextern sFONT Font8x16;
N
N//ÒªÖ§³ÖÖÐÎÄÐèÒªÊµÏÖ±¾º¯Êý£¬¿É²Î¿¼¡°Òº¾§ÏÔÊ¾ÖÐÓ¢ÎÄ£¨×Ö¿âÔÚÍâ²¿FLASH£©¡±Àý³Ì
N#define      GetGBKCode( ucBuffer, usChar ) 
N
N
N#endif /*end of __FONT_H    */
L 7 "..\..\User\./lcd/bsp_ili9341_lcd.h" 2
N
N
N/***************************************************************************************
N2^26 =0X0400 0000 = 64MB,Ã¿¸ö BANK ÓÐ4*64MB = 256MB
N64MB:FSMC_Bank1_NORSRAM1:0X6000 0000 ~ 0X63FF FFFF
N64MB:FSMC_Bank1_NORSRAM2:0X6400 0000 ~ 0X67FF FFFF
N64MB:FSMC_Bank1_NORSRAM3:0X6800 0000 ~ 0X6BFF FFFF
N64MB:FSMC_Bank1_NORSRAM4:0X6C00 0000 ~ 0X6FFF FFFF
N
NÑ¡ÔñBANK1-BORSRAM1 Á¬½Ó TFT£¬µØÖ··¶Î§Îª0X6000 0000 ~ 0X63FF FFFF
NFSMC_A16 ½ÓLCDµÄDC(¼Ä´æÆ÷/Êý¾ÝÑ¡Ôñ)½Å
N¼Ä´æÆ÷»ùµØÖ· = 0X60000000
NRAM»ùµØÖ· = 0X60020000 = 0X60000000+2^16*2 = 0X60000000 + 0X20000 = 0X60020000
Nµ±Ñ¡Ôñ²»Í¬µÄµØÖ·ÏßÊ±£¬µØÖ·ÒªÖØÐÂ¼ÆËã  
N****************************************************************************************/
N
N/******************************* ILI9341 ÏÔÊ¾ÆÁµÄ FSMC ²ÎÊý¶¨Òå ***************************/
N//FSMC_Bank1_NORSRAMÓÃÓÚLCDÃüÁî²Ù×÷µÄµØÖ·
N#define      FSMC_Addr_ILI9341_CMD         ( ( uint32_t ) 0x60000000 )
N
N//FSMC_Bank1_NORSRAMÓÃÓÚLCDÊý¾Ý²Ù×÷µÄµØÖ·      
N#define      FSMC_Addr_ILI9341_DATA        ( ( uint32_t ) 0x60020000 )
N
N//ÓÉÆ¬Ñ¡Òý½Å¾ö¶¨µÄNOR/SRAM¿é
N#define      FSMC_Bank1_NORSRAMx           FSMC_Bank1_NORSRAM1
N
N
N
N/******************************* ILI9341 ÏÔÊ¾ÆÁ8080Í¨Ñ¶Òý½Å¶¨Òå ***************************/
N/******¿ØÖÆÐÅºÅÏß******/
N//Æ¬Ñ¡£¬Ñ¡ÔñNOR/SRAM¿é
N#define      ILI9341_CS_CLK                RCC_APB2Periph_GPIOD   
N#define      ILI9341_CS_PORT               GPIOD
N#define      ILI9341_CS_PIN                GPIO_Pin_7
N
N//DCÒý½Å£¬Ê¹ÓÃFSMCµÄµØÖ·ÐÅºÅ¿ØÖÆ£¬±¾Òý½Å¾ö¶¨ÁË·ÃÎÊLCDÊ±Ê¹ÓÃµÄµØÖ·
N//PD11ÎªFSMC_A16
N#define      ILI9341_DC_CLK                RCC_APB2Periph_GPIOD   
N#define      ILI9341_DC_PORT               GPIOD
N#define      ILI9341_DC_PIN                GPIO_Pin_11
N
N//Ð´Ê¹ÄÜ
N#define      ILI9341_WR_CLK                RCC_APB2Periph_GPIOD   
N#define      ILI9341_WR_PORT               GPIOD
N#define      ILI9341_WR_PIN                GPIO_Pin_5
N
N//¶ÁÊ¹ÄÜ
N#define      ILI9341_RD_CLK                RCC_APB2Periph_GPIOD   
N#define      ILI9341_RD_PORT               GPIOD
N#define      ILI9341_RD_PIN                GPIO_Pin_4
N
N//¸´Î»Òý½Å
N#define      ILI9341_RST_CLK               RCC_APB2Periph_GPIOE
N#define      ILI9341_RST_PORT              GPIOE
N#define      ILI9341_RST_PIN               GPIO_Pin_1
N
N//±³¹âÒý½Å
N#define      ILI9341_BK_CLK                RCC_APB2Periph_GPIOD    
N#define      ILI9341_BK_PORT               GPIOD
N#define      ILI9341_BK_PIN                GPIO_Pin_12
N
N/********Êý¾ÝÐÅºÅÏß***************/
N#define      ILI9341_D0_CLK                RCC_APB2Periph_GPIOD   
N#define      ILI9341_D0_PORT               GPIOD
N#define      ILI9341_D0_PIN                GPIO_Pin_14
N
N#define      ILI9341_D1_CLK                RCC_APB2Periph_GPIOD   
N#define      ILI9341_D1_PORT               GPIOD
N#define      ILI9341_D1_PIN                GPIO_Pin_15
N
N#define      ILI9341_D2_CLK                RCC_APB2Periph_GPIOD   
N#define      ILI9341_D2_PORT               GPIOD
N#define      ILI9341_D2_PIN                GPIO_Pin_0
N
N#define      ILI9341_D3_CLK                RCC_APB2Periph_GPIOD  
N#define      ILI9341_D3_PORT               GPIOD
N#define      ILI9341_D3_PIN                GPIO_Pin_1
N
N#define      ILI9341_D4_CLK                RCC_APB2Periph_GPIOE   
N#define      ILI9341_D4_PORT               GPIOE
N#define      ILI9341_D4_PIN                GPIO_Pin_7
N
N#define      ILI9341_D5_CLK                RCC_APB2Periph_GPIOE   
N#define      ILI9341_D5_PORT               GPIOE
N#define      ILI9341_D5_PIN                GPIO_Pin_8
N
N#define      ILI9341_D6_CLK                RCC_APB2Periph_GPIOE   
N#define      ILI9341_D6_PORT               GPIOE
N#define      ILI9341_D6_PIN                GPIO_Pin_9
N
N#define      ILI9341_D7_CLK                RCC_APB2Periph_GPIOE  
N#define      ILI9341_D7_PORT               GPIOE
N#define      ILI9341_D7_PIN                GPIO_Pin_10
N
N#define      ILI9341_D8_CLK                RCC_APB2Periph_GPIOE   
N#define      ILI9341_D8_PORT               GPIOE
N#define      ILI9341_D8_PIN                GPIO_Pin_11
N
N#define      ILI9341_D9_CLK                RCC_APB2Periph_GPIOE   
N#define      ILI9341_D9_PORT               GPIOE
N#define      ILI9341_D9_PIN                GPIO_Pin_12
N
N#define      ILI9341_D10_CLK                RCC_APB2Periph_GPIOE   
N#define      ILI9341_D10_PORT               GPIOE
N#define      ILI9341_D10_PIN                GPIO_Pin_13
N
N#define      ILI9341_D11_CLK                RCC_APB2Periph_GPIOE   
N#define      ILI9341_D11_PORT               GPIOE
N#define      ILI9341_D11_PIN                GPIO_Pin_14
N
N#define      ILI9341_D12_CLK                RCC_APB2Periph_GPIOE   
N#define      ILI9341_D12_PORT               GPIOE
N#define      ILI9341_D12_PIN                GPIO_Pin_15
N
N#define      ILI9341_D13_CLK                RCC_APB2Periph_GPIOD   
N#define      ILI9341_D13_PORT               GPIOD
N#define      ILI9341_D13_PIN                GPIO_Pin_8
N
N#define      ILI9341_D14_CLK                RCC_APB2Periph_GPIOD   
N#define      ILI9341_D14_PORT               GPIOD
N#define      ILI9341_D14_PIN                GPIO_Pin_9
N
N#define      ILI9341_D15_CLK                RCC_APB2Periph_GPIOD   
N#define      ILI9341_D15_PORT               GPIOD
N#define      ILI9341_D15_PIN                GPIO_Pin_10
N
N/*************************************** µ÷ÊÔÔ¤ÓÃ ******************************************/
N#define      DEBUG_DELAY()                
N
N/***************************** ILI934 ÏÔÊ¾ÇøÓòµÄÆðÊ¼×ø±êºÍ×ÜÐÐÁÐÊý ***************************/
N#define      ILI9341_DispWindow_X_Star		    0     //ÆðÊ¼µãµÄX×ø±ê
N#define      ILI9341_DispWindow_Y_Star		    0     //ÆðÊ¼µãµÄY×ø±ê
N
N#define 			ILI9341_LESS_PIXEL	  							240			//Òº¾§ÆÁ½Ï¶Ì·½ÏòµÄÏñËØ¿í¶È
N#define 			ILI9341_MORE_PIXEL	 								320			//Òº¾§ÆÁ½Ï³¤·½ÏòµÄÏñËØ¿í¶È
N
N//¸ù¾ÝÒº¾§É¨Ãè·½Ïò¶ø±ä»¯µÄXYÏñËØ¿í¶È
N//µ÷ÓÃILI9341_GramScanº¯ÊýÉèÖÃ·½ÏòÊ±»á×Ô¶¯¸ü¸Ä
Nextern uint16_t LCD_X_LENGTH,LCD_Y_LENGTH; 
N
N//Òº¾§ÆÁÉ¨ÃèÄ£Ê½
N//²ÎÊý¿ÉÑ¡ÖµÎª0-7
Nextern uint8_t LCD_SCAN_MODE;
N
N/******************************* ¶¨Òå ILI934 ÏÔÊ¾ÆÁ³£ÓÃÑÕÉ« ********************************/
N#define      BACKGROUND		                BLACK   //Ä¬ÈÏ±³¾°ÑÕÉ«
N
N#define      WHITE		 		                  0xFFFF	   //°×É«
N#define      BLACK                         0x0000	   //ºÚÉ« 
N#define      GREY                          0xF7DE	   //»ÒÉ« 
N#define      BLUE                          0x001F	   //À¶É« 
N#define      BLUE2                         0x051F	   //Ç³À¶É« 
N#define      RED                           0xF800	   //ºìÉ« 
N#define      MAGENTA                       0xF81F	   //ºì×ÏÉ«£¬ÑóºìÉ« 
N#define      GREEN                         0x07E0	   //ÂÌÉ« 
N#define      CYAN                          0x7FFF	   //À¶ÂÌÉ«£¬ÇàÉ« 
N#define      YELLOW                        0xFFE0	   //»ÆÉ« 
N#define      BRED                          0xF81F
N#define      GRED                          0xFFE0
N#define      GBLUE                         0x07FF
N
N
N
N/******************************* ¶¨Òå ILI934 ³£ÓÃÃüÁî ********************************/
N#define      CMD_SetCoordinateX		 		    0x2A	     //ÉèÖÃX×ø±ê
N#define      CMD_SetCoordinateY		 		    0x2B	     //ÉèÖÃY×ø±ê
N#define      CMD_SetPixel		 		          0x2C	     //Ìî³äÏñËØ
N
N
N
N
N/********************************** ÉùÃ÷ ILI934 º¯Êý ***************************************/
Nvoid                     ILI9341_Init                    ( void );
Nvoid                     ILI9341_Rst                     ( void );
Nvoid                     ILI9341_BackLed_Control         ( FunctionalState enumState );
Nvoid                     ILI9341_GramScan                ( uint8_t ucOtion );
Nvoid                     ILI9341_OpenWindow              ( uint16_t usX, uint16_t usY, uint16_t usWidth, uint16_t usHeight );
Nvoid                     ILI9341_Clear                   ( uint16_t usX, uint16_t usY, uint16_t usWidth, uint16_t usHeight );
Nvoid                     ILI9341_SetPointPixel           ( uint16_t usX, uint16_t usY );
Nuint16_t                 ILI9341_GetPointPixel           ( uint16_t usX , uint16_t usY );
Nvoid                     ILI9341_DrawLine                ( uint16_t usX1, uint16_t usY1, uint16_t usX2, uint16_t usY2 );
Nvoid                     ILI9341_DrawRectangle           ( uint16_t usX_Start, uint16_t usY_Start, uint16_t usWidth, uint16_t usHeight,uint8_t ucFilled );
Nvoid                     ILI9341_DrawCircle              ( uint16_t usX_Center, uint16_t usY_Center, uint16_t usRadius, uint8_t ucFilled );
Nvoid                     ILI9341_DispChar_EN             ( uint16_t usX, uint16_t usY, const char cChar );
Nvoid                     ILI9341_DispStringLine_EN      ( uint16_t line, char * pStr );
Nvoid                     ILI9341_DispString_EN      			( uint16_t usX, uint16_t usY, char * pStr );
Nvoid 											ILI9341_DispString_EN_YDir 		(   uint16_t usX,uint16_t usY ,  char * pStr );
N
Nvoid 											LCD_SetFont											(sFONT *fonts);
NsFONT 										*LCD_GetFont											(void);
Nvoid 											LCD_ClearLine										(uint16_t Line);
Nvoid 											LCD_SetBackColor								(uint16_t Color);
Nvoid 											LCD_SetTextColor								(uint16_t Color)	;
Nvoid 											LCD_SetColors										(uint16_t TextColor, uint16_t BackColor);
Nvoid 											LCD_GetColors										(uint16_t *TextColor, uint16_t *BackColor);
N
N
Nvoid                 ILI9341_Write_Cmd           ( uint16_t usCmd );
Nvoid                 ILI9341_Write_Data          ( uint16_t usData );
Nuint16_t             ILI9341_Read_Data           ( void );
N
N#endif /* __BSP_ILI9341_ILI9341_H */
N
N
L 6 "..\..\User\main.c" 2
N#include "./led/bsp_led.h"   
L 1 "..\..\User\./led/bsp_led.h" 1
N#ifndef __LED_H
N#define	__LED_H
N
N
N#include "stm32f10x.h"
N
N
N/* ¶¨ÒåLEDÁ¬½ÓµÄGPIO¶Ë¿Ú, ÓÃ»§Ö»ÐèÒªÐÞ¸ÄÏÂÃæµÄ´úÂë¼´¿É¸Ä±ä¿ØÖÆµÄLEDÒý½Å */
N// R-ºìÉ«
N#define LED1_GPIO_PORT    	GPIOB			              /* GPIO¶Ë¿Ú */
N#define LED1_GPIO_CLK 	    RCC_APB2Periph_GPIOB		/* GPIO¶Ë¿ÚÊ±ÖÓ */
N#define LED1_GPIO_PIN		GPIO_Pin_5			        /* Á¬½Óµ½SCLÊ±ÖÓÏßµÄGPIO */
N
N// G-ÂÌÉ«
N#define LED2_GPIO_PORT    	GPIOB			              /* GPIO¶Ë¿Ú */
N#define LED2_GPIO_CLK 	    RCC_APB2Periph_GPIOB		/* GPIO¶Ë¿ÚÊ±ÖÓ */
N#define LED2_GPIO_PIN		GPIO_Pin_0			        /* Á¬½Óµ½SCLÊ±ÖÓÏßµÄGPIO */
N
N// B-À¶É«
N#define LED3_GPIO_PORT    	GPIOB			              /* GPIO¶Ë¿Ú */
N#define LED3_GPIO_CLK 	    RCC_APB2Periph_GPIOB		/* GPIO¶Ë¿ÚÊ±ÖÓ */
N#define LED3_GPIO_PIN		GPIO_Pin_1			        /* Á¬½Óµ½SCLÊ±ÖÓÏßµÄGPIO */
N
N
N/** the macro definition to trigger the led on or off 
N  * 1 - off
N  *0 - on
N  */
N#define ON  0
N#define OFF 1
N
N/* Ê¹ÓÃ±ê×¼µÄ¹Ì¼þ¿â¿ØÖÆIO*/
N#define LED1(a)	if (a)	\
N					GPIO_SetBits(LED1_GPIO_PORT,LED1_GPIO_PIN);\
N					else		\
N					GPIO_ResetBits(LED1_GPIO_PORT,LED1_GPIO_PIN)
X#define LED1(a)	if (a)						GPIO_SetBits(LED1_GPIO_PORT,LED1_GPIO_PIN);					else							GPIO_ResetBits(LED1_GPIO_PORT,LED1_GPIO_PIN)
N
N#define LED2(a)	if (a)	\
N					GPIO_SetBits(LED2_GPIO_PORT,LED2_GPIO_PIN);\
N					else		\
N					GPIO_ResetBits(LED2_GPIO_PORT,LED2_GPIO_PIN)
X#define LED2(a)	if (a)						GPIO_SetBits(LED2_GPIO_PORT,LED2_GPIO_PIN);					else							GPIO_ResetBits(LED2_GPIO_PORT,LED2_GPIO_PIN)
N
N#define LED3(a)	if (a)	\
N					GPIO_SetBits(LED3_GPIO_PORT,LED3_GPIO_PIN);\
N					else		\
N					GPIO_ResetBits(LED3_GPIO_PORT,LED3_GPIO_PIN)
X#define LED3(a)	if (a)						GPIO_SetBits(LED3_GPIO_PORT,LED3_GPIO_PIN);					else							GPIO_ResetBits(LED3_GPIO_PORT,LED3_GPIO_PIN)
N
N
N/* Ö±½Ó²Ù×÷¼Ä´æÆ÷µÄ·½·¨¿ØÖÆIO */
N#define	digitalHi(p,i)		 {p->BSRR=i;}	 //Êä³öÎª¸ßµçÆ½		
N#define digitalLo(p,i)		 {p->BRR=i;}	 //Êä³öµÍµçÆ½
N#define digitalToggle(p,i) {p->ODR ^=i;} //Êä³ö·´×ª×´Ì¬
N
N
N/* ¶¨Òå¿ØÖÆIOµÄºê */
N#define LED1_TOGGLE		 digitalToggle(LED1_GPIO_PORT,LED1_GPIO_PIN)
N#define LED1_OFF		   digitalHi(LED1_GPIO_PORT,LED1_GPIO_PIN)
N#define LED1_ON			   digitalLo(LED1_GPIO_PORT,LED1_GPIO_PIN)
N
N#define LED2_TOGGLE		 digitalToggle(LED2_GPIO_PORT,LED2_GPIO_PIN)
N#define LED2_OFF		   digitalHi(LED2_GPIO_PORT,LED2_GPIO_PIN)
N#define LED2_ON			   digitalLo(LED2_GPIO_PORT,LED2_GPIO_PIN)
N
N#define LED3_TOGGLE		 digitalToggle(LED3_GPIO_PORT,LED3_GPIO_PIN)
N#define LED3_OFF		   digitalHi(LED3_GPIO_PORT,LED3_GPIO_PIN)
N#define LED3_ON			   digitalLo(LED3_GPIO_PORT,LED3_GPIO_PIN)
N
N/* »ù±¾»ìÉ«£¬ºóÃæ¸ß¼¶ÓÃ·¨Ê¹ÓÃPWM¿É»ì³öÈ«²ÊÑÕÉ«,ÇÒÐ§¹û¸üºÃ */
N
N//ºì
N#define LED_RED  \
N					LED1_ON;\
N					LED2_OFF\
N					LED3_OFF
X#define LED_RED  					LED1_ON;					LED2_OFF					LED3_OFF
N
N//ÂÌ
N#define LED_GREEN		\
N					LED1_OFF;\
N					LED2_ON\
N					LED3_OFF
X#define LED_GREEN							LED1_OFF;					LED2_ON					LED3_OFF
N
N//À¶
N#define LED_BLUE	\
N					LED1_OFF;\
N					LED2_OFF\
N					LED3_ON
X#define LED_BLUE						LED1_OFF;					LED2_OFF					LED3_ON
N
N					
N//»Æ(ºì+ÂÌ)					
N#define LED_YELLOW	\
N					LED1_ON;\
N					LED2_ON\
N					LED3_OFF
X#define LED_YELLOW						LED1_ON;					LED2_ON					LED3_OFF
N//×Ï(ºì+À¶)
N#define LED_PURPLE	\
N					LED1_ON;\
N					LED2_OFF\
N					LED3_ON
X#define LED_PURPLE						LED1_ON;					LED2_OFF					LED3_ON
N
N//Çà(ÂÌ+À¶)
N#define LED_CYAN \
N					LED1_OFF;\
N					LED2_ON\
N					LED3_ON
X#define LED_CYAN 					LED1_OFF;					LED2_ON					LED3_ON
N					
N//°×(ºì+ÂÌ+À¶)
N#define LED_WHITE	\
N					LED1_ON;\
N					LED2_ON\
N					LED3_ON
X#define LED_WHITE						LED1_ON;					LED2_ON					LED3_ON
N					
N//ºÚ(È«²¿¹Ø±Õ)
N#define LED_RGBOFF	\
N					LED1_OFF;\
N					LED2_OFF\
N					LED3_OFF
X#define LED_RGBOFF						LED1_OFF;					LED2_OFF					LED3_OFF
N
Nvoid LED_GPIO_Config(void);
N
N#endif /* __LED_H */
L 7 "..\..\User\main.c" 2
N#include "./usart/bsp_usart.h"
L 1 "..\..\User\./usart/bsp_usart.h" 1
N#ifndef __USART_H
N#define	__USART_H
N
N
N#include "stm32f10x.h"
N#include "delay.h"
L 1 "..\..\User\delay\delay.h" 1
N#ifndef _DELAY_H_
N#define _DELAY_H_
N#include "stm32f10x.h"
N
N
N
N
N
N
N
N
Nvoid mDelay(uint32_t i);
N   void udelay(u16 time);
N
N
N
N#endif
L 7 "..\..\User\./usart/bsp_usart.h" 2
N
N//C¿â
N#include <stdarg.h>
L 1 "F:\Keil_v5\ARM\ARMCC\Bin\..\include\stdarg.h" 1
N/* stdarg.h: ANSI 'C' (X3J11 Oct 88) library header, section 4.8 */
N/* Copyright (C) Codemist Ltd., 1988                            */
N/* Copyright (C) ARM Ltd., 1991-1999. All rights reserved */
N
N/*
N * RCS $Revision$
N * Checkin $Date$
N * Revising $Author: agrant $
N */
N
N#ifndef __stdarg_h
N#define __stdarg_h
N#define __ARMCLIB_VERSION 5060037
N
N  #ifndef __STDARG_DECLS
N  #define __STDARG_DECLS
N
N    #undef __CLIBNS
N
N    #ifdef __cplusplus
S      namespace std {
S          #define __CLIBNS ::std::
S          extern "C" {
N    #else
N      #define __CLIBNS
N    #endif  /* __cplusplus */
N
N/*
N * stdarg.h declares a type and defines macros for advancing through a
N * list of arguments whose number and types are not known to the called
N * function when it is translated. A function may be called with a variable
N * number of arguments of differing types. Its parameter list contains one or
N * more parameters. The rightmost parameter plays a special role in the access
N * mechanism, and will be called parmN in this description.
N */
N
N/* N.B. <stdio.h> is required to declare vfprintf() without defining      */
N/* va_list.  Clearly the type __va_list there must keep in step.          */
N#ifdef __clang__
S  typedef __builtin_va_list va_list;
S  #define va_start(ap, param) __builtin_va_start(ap, param)
S  #define va_end(ap)          __builtin_va_end(ap)
S  #define va_arg(ap, type)    __builtin_va_arg(ap, type)
S  #if __STDC_VERSION__ >= 199900L || __cplusplus >= 201103L || !defined(__STRICT_ANSI__)
S  #define va_copy(dest, src)  __builtin_va_copy(dest, src)
S  #endif
N#else
N  #ifdef __TARGET_ARCH_AARCH64
S    typedef struct __va_list {
S      void *__stack;
S      void *__gr_top;
S      void *__vr_top;
S      int __gr_offs;
S      int __vr_offs;
S    } va_list;
N  #else
N    typedef struct __va_list { void *__ap; } va_list;
N  #endif
N   /*
N    * an array type suitable for holding information needed by the macro va_arg
N    * and the function va_end. The called function shall declare a variable
N    * (referred to as ap) having type va_list. The variable ap may be passed as
N    * an argument to another function.
N    * Note: va_list is an array type so that when an object of that type
N    * is passed as an argument it gets passed by reference.
N    */
N  #define va_start(ap, parmN) __va_start(ap, parmN)
N
N   /*
N    * The va_start macro shall be executed before any access to the unnamed
N    * arguments. The parameter ap points to an object that has type va_list.
N    * The va_start macro initialises ap for subsequent use by va_arg and
N    * va_end. The parameter parmN is the identifier of the rightmost parameter
N    * in the variable parameter list in the function definition (the one just
N    * before the '...'). If the parameter parmN is declared with the register
N    * storage class an error is given.
N    * If parmN is a narrow type (char, short, float) an error is given in
N    * strict ANSI mode, or a warning otherwise.
N    * Returns: no value.
N    */
N  #define va_arg(ap, type) __va_arg(ap, type)
N
N   /*
N    * The va_arg macro expands to an expression that has the type and value of
N    * the next argument in the call. The parameter ap shall be the same as the
N    * va_list ap initialised by va_start. Each invocation of va_arg modifies
N    * ap so that successive arguments are returned in turn. The parameter
N    * 'type' is a type name such that the type of a pointer to an object that
N    * has the specified type can be obtained simply by postfixing a * to
N    * 'type'. If type is a narrow type, an error is given in strict ANSI
N    * mode, or a warning otherwise. If the type is an array or function type,
N    * an error is given.
N    * In non-strict ANSI mode, 'type' is allowed to be any expression.
N    * Returns: The first invocation of the va_arg macro after that of the
N    *          va_start macro returns the value of the argument after that
N    *          specified by parmN. Successive invocations return the values of
N    *          the remaining arguments in succession.
N    *          The result is cast to 'type', even if 'type' is narrow.
N    */
N
N#define __va_copy(dest, src) ((void)((dest) = (src)))
N
N#if !defined(__STRICT_ANSI__) || (defined(__STDC_VERSION__) && 199901L <= __STDC_VERSION__) || (defined(__cplusplus) && 201103L <= __cplusplus)
X#if !0L || (1L && 199901L <= 199901L) || (0L && 201103L <= __cplusplus)
N   /* va_copy is in C99 and non-strict C90 and non-strict C++
N    * __va_copy is always present.
N    */
N  #define va_copy(dest, src) ((void)((dest) = (src)))
N
N   /* The va_copy macro makes the va_list dest be a copy of
N    * the va_list src, as if the va_start macro had been applied
N    * to it followed by the same sequence of uses of the va_arg
N    * macro as had previously been used to reach the present state
N    * of src.
N    */
N#endif
N
N#define va_end(ap) __va_end(ap)
N   /*
N    * The va_end macro facilitates a normal return from the function whose
N    * variable argument list was referenced by the expansion of va_start that
N    * initialised the va_list ap. If the va_end macro is not invoked before
N    * the return, the behaviour is undefined.
N    * Returns: no value.
N    */
N#endif /* __clang__ */
N
N    #ifdef __cplusplus
S         }  /* extern "C" */
S      }  /* namespace std */
N    #endif /* __cplusplus */
N
N    #ifdef __GNUC__
S     /* be cooperative with glibc */
S     typedef __CLIBNS va_list __gnuc_va_list;
S     #define __GNUC_VA_LIST
S     #undef __need___va_list
N    #endif
N
N  #endif /* __STDARG_DECLS */
N
N  #ifdef __cplusplus
S    #ifndef __STDARG_NO_EXPORTS
S      using ::std::va_list;
S    #endif
N  #endif /* __cplusplus */
N#endif
N
N/* end of stdarg.h */
N
L 10 "..\..\User\./usart/bsp_usart.h" 2
N#include <string.h>
L 1 "F:\Keil_v5\ARM\ARMCC\Bin\..\include\string.h" 1
N/* string.h: ANSI 'C' (X3J11 Oct 88) library header, section 4.11 */
N/* Copyright (C) Codemist Ltd., 1988-1993.                        */
N/* Copyright 1991-1993 ARM Limited. All rights reserved.          */
N/* version 0.04 */
N
N/*
N * RCS $Revision$
N * Checkin $Date$
N */
N
N/*
N * string.h declares one type and several functions, and defines one macro
N * useful for manipulating character arrays and other objects treated as
N * character arrays. Various methods are used for determining the lengths of
N * the arrays, but in all cases a char * or void * argument points to the
N * initial (lowest addresses) character of the array. If an array is written
N * beyond the end of an object, the behaviour is undefined.
N */
N
N#ifndef __string_h
N#define __string_h
N#define __ARMCLIB_VERSION 5060037
N
N#define _ARMABI __declspec(__nothrow)
N
N  #ifndef __STRING_DECLS
N  #define __STRING_DECLS
N
N    #undef __CLIBNS
N
N    #ifdef __cplusplus
S        namespace std {
S        #define __CLIBNS std::
S        extern "C" {
N    #else
N      #define __CLIBNS
N    #endif  /* __cplusplus */
N
N#if defined(__cplusplus) || !defined(__STRICT_ANSI__)
X#if 0L || !0L
N /* unconditional in C++ and non-strict C for consistency of debug info */
N  #if __sizeof_ptr == 8
X  #if 4 == 8
S    typedef unsigned long size_t;   /* see <stddef.h> */
N  #else
N    typedef unsigned int size_t;   /* see <stddef.h> */
N  #endif
N#elif !defined(__size_t)
S  #define __size_t 1
S  #if __sizeof_ptr == 8
S    typedef unsigned long size_t;   /* see <stddef.h> */
S  #else
S    typedef unsigned int size_t;   /* see <stddef.h> */
S  #endif
N#endif
N
N#undef NULL
N#define NULL 0                   /* see <stddef.h> */
N
Nextern _ARMABI void *memcpy(void * __restrict /*s1*/,
Xextern __declspec(__nothrow) void *memcpy(void * __restrict  ,
N                    const void * __restrict /*s2*/, size_t /*n*/) __attribute__((__nonnull__(1,2)));
N   /*
N    * copies n characters from the object pointed to by s2 into the object
N    * pointed to by s1. If copying takes place between objects that overlap,
N    * the behaviour is undefined.
N    * Returns: the value of s1.
N    */
Nextern _ARMABI void *memmove(void * /*s1*/,
Xextern __declspec(__nothrow) void *memmove(void *  ,
N                    const void * /*s2*/, size_t /*n*/) __attribute__((__nonnull__(1,2)));
N   /*
N    * copies n characters from the object pointed to by s2 into the object
N    * pointed to by s1. Copying takes place as if the n characters from the
N    * object pointed to by s2 are first copied into a temporary array of n
N    * characters that does not overlap the objects pointed to by s1 and s2,
N    * and then the n characters from the temporary array are copied into the
N    * object pointed to by s1.
N    * Returns: the value of s1.
N    */
Nextern _ARMABI char *strcpy(char * __restrict /*s1*/, const char * __restrict /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) char *strcpy(char * __restrict  , const char * __restrict  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * copies the string pointed to by s2 (including the terminating nul
N    * character) into the array pointed to by s1. If copying takes place
N    * between objects that overlap, the behaviour is undefined.
N    * Returns: the value of s1.
N    */
Nextern _ARMABI char *strncpy(char * __restrict /*s1*/, const char * __restrict /*s2*/, size_t /*n*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) char *strncpy(char * __restrict  , const char * __restrict  , size_t  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * copies not more than n characters (characters that follow a null
N    * character are not copied) from the array pointed to by s2 into the array
N    * pointed to by s1. If copying takes place between objects that overlap,
N    * the behaviour is undefined.
N    * Returns: the value of s1.
N    */
N
Nextern _ARMABI char *strcat(char * __restrict /*s1*/, const char * __restrict /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) char *strcat(char * __restrict  , const char * __restrict  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * appends a copy of the string pointed to by s2 (including the terminating
N    * null character) to the end of the string pointed to by s1. The initial
N    * character of s2 overwrites the null character at the end of s1.
N    * Returns: the value of s1.
N    */
Nextern _ARMABI char *strncat(char * __restrict /*s1*/, const char * __restrict /*s2*/, size_t /*n*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) char *strncat(char * __restrict  , const char * __restrict  , size_t  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * appends not more than n characters (a null character and characters that
N    * follow it are not appended) from the array pointed to by s2 to the end of
N    * the string pointed to by s1. The initial character of s2 overwrites the
N    * null character at the end of s1. A terminating null character is always
N    * appended to the result.
N    * Returns: the value of s1.
N    */
N
N/*
N * The sign of a nonzero value returned by the comparison functions is
N * determined by the sign of the difference between the values of the first
N * pair of characters (both interpreted as unsigned char) that differ in the
N * objects being compared.
N */
N
Nextern _ARMABI int memcmp(const void * /*s1*/, const void * /*s2*/, size_t /*n*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int memcmp(const void *  , const void *  , size_t  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * compares the first n characters of the object pointed to by s1 to the
N    * first n characters of the object pointed to by s2.
N    * Returns: an integer greater than, equal to, or less than zero, according
N    *          as the object pointed to by s1 is greater than, equal to, or
N    *          less than the object pointed to by s2.
N    */
Nextern _ARMABI int strcmp(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int strcmp(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * compares the string pointed to by s1 to the string pointed to by s2.
N    * Returns: an integer greater than, equal to, or less than zero, according
N    *          as the string pointed to by s1 is greater than, equal to, or
N    *          less than the string pointed to by s2.
N    */
Nextern _ARMABI int strncmp(const char * /*s1*/, const char * /*s2*/, size_t /*n*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int strncmp(const char *  , const char *  , size_t  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * compares not more than n characters (characters that follow a null
N    * character are not compared) from the array pointed to by s1 to the array
N    * pointed to by s2.
N    * Returns: an integer greater than, equal to, or less than zero, according
N    *          as the string pointed to by s1 is greater than, equal to, or
N    *          less than the string pointed to by s2.
N    */
Nextern _ARMABI int strcasecmp(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int strcasecmp(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * compares the string pointed to by s1 to the string pointed to by s2,
N    * case-insensitively as defined by the current locale.
N    * Returns: an integer greater than, equal to, or less than zero, according
N    *          as the string pointed to by s1 is greater than, equal to, or
N    *          less than the string pointed to by s2.
N    */
Nextern _ARMABI int strncasecmp(const char * /*s1*/, const char * /*s2*/, size_t /*n*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int strncasecmp(const char *  , const char *  , size_t  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * compares not more than n characters (characters that follow a null
N    * character are not compared) from the array pointed to by s1 to the array
N    * pointed to by s2, case-insensitively as defined by the current locale.
N    * Returns: an integer greater than, equal to, or less than zero, according
N    *          as the string pointed to by s1 is greater than, equal to, or
N    *          less than the string pointed to by s2.
N    */
Nextern _ARMABI int strcoll(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int strcoll(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * compares the string pointed to by s1 to the string pointed to by s2, both
N    * interpreted as appropriate to the LC_COLLATE category of the current
N    * locale.
N    * Returns: an integer greater than, equal to, or less than zero, according
N    *          as the string pointed to by s1 is greater than, equal to, or
N    *          less than the string pointed to by s2 when both are interpreted
N    *          as appropriate to the current locale.
N    */
N
Nextern _ARMABI size_t strxfrm(char * __restrict /*s1*/, const char * __restrict /*s2*/, size_t /*n*/) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) size_t strxfrm(char * __restrict  , const char * __restrict  , size_t  ) __attribute__((__nonnull__(2)));
N   /*
N    * transforms the string pointed to by s2 and places the resulting string
N    * into the array pointed to by s1. The transformation function is such that
N    * if the strcmp function is applied to two transformed strings, it returns
N    * a value greater than, equal to or less than zero, corresponding to the
N    * result of the strcoll function applied to the same two original strings.
N    * No more than n characters are placed into the resulting array pointed to
N    * by s1, including the terminating null character. If n is zero, s1 is
N    * permitted to be a null pointer. If copying takes place between objects
N    * that overlap, the behaviour is undefined.
N    * Returns: The length of the transformed string is returned (not including
N    *          the terminating null character). If the value returned is n or
N    *          more, the contents of the array pointed to by s1 are
N    *          indeterminate.
N    */
N
N
N#ifdef __cplusplus
Sextern _ARMABI const void *memchr(const void * /*s*/, int /*c*/, size_t /*n*/) __attribute__((__nonnull__(1)));
Sextern "C++" void *memchr(void * __s, int __c, size_t __n) __attribute__((__nonnull__(1)));
Sextern "C++" inline void *memchr(void * __s, int __c, size_t __n)
S    { return const_cast<void *>(memchr(const_cast<const void *>(__s), __c, __n)); }
N#else
Nextern _ARMABI void *memchr(const void * /*s*/, int /*c*/, size_t /*n*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) void *memchr(const void *  , int  , size_t  ) __attribute__((__nonnull__(1)));
N#endif
N   /*
N    * locates the first occurence of c (converted to an unsigned char) in the
N    * initial n characters (each interpreted as unsigned char) of the object
N    * pointed to by s.
N    * Returns: a pointer to the located character, or a null pointer if the
N    *          character does not occur in the object.
N    */
N
N#ifdef __cplusplus
Sextern _ARMABI const char *strchr(const char * /*s*/, int /*c*/) __attribute__((__nonnull__(1)));
Sextern "C++" char *strchr(char * __s, int __c) __attribute__((__nonnull__(1)));
Sextern "C++" inline char *strchr(char * __s, int __c)
S    { return const_cast<char *>(strchr(const_cast<const char *>(__s), __c)); }
N#else
Nextern _ARMABI char *strchr(const char * /*s*/, int /*c*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) char *strchr(const char *  , int  ) __attribute__((__nonnull__(1)));
N#endif
N   /*
N    * locates the first occurence of c (converted to an char) in the string
N    * pointed to by s (including the terminating null character).
N    * Returns: a pointer to the located character, or a null pointer if the
N    *          character does not occur in the string.
N    */
N
Nextern _ARMABI size_t strcspn(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) size_t strcspn(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * computes the length of the initial segment of the string pointed to by s1
N    * which consists entirely of characters not from the string pointed to by
N    * s2. The terminating null character is not considered part of s2.
N    * Returns: the length of the segment.
N    */
N
N#ifdef __cplusplus
Sextern _ARMABI const char *strpbrk(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Sextern "C++" char *strpbrk(char * __s1, const char * __s2) __attribute__((__nonnull__(1,2)));
Sextern "C++" inline char *strpbrk(char * __s1, const char * __s2)
S    { return const_cast<char *>(strpbrk(const_cast<const char *>(__s1), __s2)); }
N#else
Nextern _ARMABI char *strpbrk(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) char *strpbrk(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N#endif
N   /*
N    * locates the first occurence in the string pointed to by s1 of any
N    * character from the string pointed to by s2.
N    * Returns: returns a pointer to the character, or a null pointer if no
N    *          character form s2 occurs in s1.
N    */
N
N#ifdef __cplusplus
Sextern _ARMABI const char *strrchr(const char * /*s*/, int /*c*/) __attribute__((__nonnull__(1)));
Sextern "C++" char *strrchr(char * __s, int __c) __attribute__((__nonnull__(1)));
Sextern "C++" inline char *strrchr(char * __s, int __c)
S    { return const_cast<char *>(strrchr(const_cast<const char *>(__s), __c)); }
N#else
Nextern _ARMABI char *strrchr(const char * /*s*/, int /*c*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) char *strrchr(const char *  , int  ) __attribute__((__nonnull__(1)));
N#endif
N   /*
N    * locates the last occurence of c (converted to a char) in the string
N    * pointed to by s. The terminating null character is considered part of
N    * the string.
N    * Returns: returns a pointer to the character, or a null pointer if c does
N    *          not occur in the string.
N    */
N
Nextern _ARMABI size_t strspn(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) size_t strspn(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * computes the length of the initial segment of the string pointed to by s1
N    * which consists entirely of characters from the string pointed to by S2
N    * Returns: the length of the segment.
N    */
N
N#ifdef __cplusplus
Sextern _ARMABI const char *strstr(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Sextern "C++" char *strstr(char * __s1, const char * __s2) __attribute__((__nonnull__(1,2)));
Sextern "C++" inline char *strstr(char * __s1, const char * __s2)
S    { return const_cast<char *>(strstr(const_cast<const char *>(__s1), __s2)); }
N#else
Nextern _ARMABI char *strstr(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) char *strstr(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N#endif
N   /*
N    * locates the first occurence in the string pointed to by s1 of the
N    * sequence of characters (excluding the terminating null character) in the
N    * string pointed to by s2.
N    * Returns: a pointer to the located string, or a null pointer if the string
N    *          is not found.
N    */
N
Nextern _ARMABI char *strtok(char * __restrict /*s1*/, const char * __restrict /*s2*/) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) char *strtok(char * __restrict  , const char * __restrict  ) __attribute__((__nonnull__(2)));
Nextern _ARMABI char *_strtok_r(char * /*s1*/, const char * /*s2*/, char ** /*ptr*/) __attribute__((__nonnull__(2,3)));
Xextern __declspec(__nothrow) char *_strtok_r(char *  , const char *  , char **  ) __attribute__((__nonnull__(2,3)));
N#ifndef __STRICT_ANSI__
Nextern _ARMABI char *strtok_r(char * /*s1*/, const char * /*s2*/, char ** /*ptr*/) __attribute__((__nonnull__(2,3)));
Xextern __declspec(__nothrow) char *strtok_r(char *  , const char *  , char **  ) __attribute__((__nonnull__(2,3)));
N#endif
N   /*
N    * A sequence of calls to the strtok function breaks the string pointed to
N    * by s1 into a sequence of tokens, each of which is delimited by a
N    * character from the string pointed to by s2. The first call in the
N    * sequence has s1 as its first argument, and is followed by calls with a
N    * null pointer as their first argument. The separator string pointed to by
N    * s2 may be different from call to call.
N    * The first call in the sequence searches for the first character that is
N    * not contained in the current separator string s2. If no such character
N    * is found, then there are no tokens in s1 and the strtok function returns
N    * a null pointer. If such a character is found, it is the start of the
N    * first token.
N    * The strtok function then searches from there for a character that is
N    * contained in the current separator string. If no such character is found,
N    * the current token extends to the end of the string pointed to by s1, and
N    * subsequent searches for a token will fail. If such a character is found,
N    * it is overwritten by a null character, which terminates the current
N    * token. The strtok function saves a pointer to the following character,
N    * from which the next search for a token will start.
N    * Each subsequent call, with a null pointer as the value for the first
N    * argument, starts searching from the saved pointer and behaves as
N    * described above.
N    * Returns: pointer to the first character of a token, or a null pointer if
N    *          there is no token.
N    *
N    * strtok_r() is a common extension which works exactly like
N    * strtok(), but instead of storing its state in a hidden
N    * library variable, requires the user to pass in a pointer to a
N    * char * variable which will be used instead. Any sequence of
N    * calls to strtok_r() passing the same char ** pointer should
N    * behave exactly like the corresponding sequence of calls to
N    * strtok(). This means that strtok_r() can safely be used in
N    * multi-threaded programs, and also that you can tokenise two
N    * strings in parallel.
N    */
N
Nextern _ARMABI void *memset(void * /*s*/, int /*c*/, size_t /*n*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) void *memset(void *  , int  , size_t  ) __attribute__((__nonnull__(1)));
N   /*
N    * copies the value of c (converted to an unsigned char) into each of the
N    * first n charactes of the object pointed to by s.
N    * Returns: the value of s.
N    */
Nextern _ARMABI char *strerror(int /*errnum*/);
Xextern __declspec(__nothrow) char *strerror(int  );
N   /*
N    * maps the error number in errnum to an error message string.
N    * Returns: a pointer to the string, the contents of which are
N    *          implementation-defined. The array pointed to shall not be
N    *          modified by the program, but may be overwritten by a
N    *          subsequent call to the strerror function.
N    */
Nextern _ARMABI size_t strlen(const char * /*s*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) size_t strlen(const char *  ) __attribute__((__nonnull__(1)));
N   /*
N    * computes the length of the string pointed to by s.
N    * Returns: the number of characters that precede the terminating null
N    *          character.
N    */
N
Nextern _ARMABI size_t strlcpy(char * /*dst*/, const char * /*src*/, size_t /*len*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) size_t strlcpy(char *  , const char *  , size_t  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * copies the string src into the string dst, using no more than
N    * len bytes of dst. Always null-terminates dst _within the
N    * length len (i.e. will copy at most len-1 bytes of string plus
N    * a NUL), unless len is actually zero.
N    * 
N    * Return value is the length of the string that _would_ have
N    * been written, i.e. the length of src. Thus, the operation
N    * succeeded without truncation if and only if ret < len;
N    * otherwise, the value in ret tells you how big to make dst if
N    * you decide to reallocate it. (That value does _not_ include
N    * the NUL.)
N    * 
N    * This is a BSD-derived library extension, which we are
N    * permitted to declare in a standard header because ISO defines
N    * function names beginning with 'str' as reserved for future
N    * expansion of <string.h>.
N    */
N
Nextern _ARMABI size_t strlcat(char * /*dst*/, const char * /*src*/, size_t /*len*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) size_t strlcat(char *  , const char *  , size_t  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * concatenates the string src to the string dst, using no more
N    * than len bytes of dst. Always null-terminates dst _within the
N    * length len (i.e. will copy at most len-1 bytes of string plus
N    * a NUL), unless len is actually zero.
N    * 
N    * Return value is the length of the string that _would_ have
N    * been written, i.e. the length of src plus the original length
N    * of dst. Thus, the operation succeeded without truncation if
N    * and only if ret < len; otherwise, the value in ret tells you
N    * how big to make dst if you decide to reallocate it. (That
N    * value does _not_ include the NUL.)
N    * 
N    * If no NUL is encountered within the first len bytes of dst,
N    * then the length of dst is considered to have been equal to
N    * len for the purposes of the return value (as if there were a
N    * NUL at dst[len]). Thus, the return value in this case is len
N    * + strlen(src).
N    * 
N    * This is a BSD-derived library extension, which we are
N    * permitted to declare in a standard header because ISO defines
N    * function names beginning with 'str' as reserved for future
N    * expansion of <string.h>.
N    */
N
Nextern _ARMABI void _membitcpybl(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitcpybl(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitcpybb(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitcpybb(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitcpyhl(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitcpyhl(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitcpyhb(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitcpyhb(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitcpywl(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitcpywl(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitcpywb(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitcpywb(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitmovebl(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitmovebl(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitmovebb(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitmovebb(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitmovehl(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitmovehl(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitmovehb(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitmovehb(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitmovewl(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitmovewl(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitmovewb(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitmovewb(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
N    /*
N     * Copies or moves a piece of memory from one place to another,
N     * with one-bit granularity. So you can start or finish a copy
N     * part way through a byte, and you can copy between regions
N     * with different alignment within a byte.
N     * 
N     * All these functions have the same prototype: two void *
N     * pointers for destination and source, then two integers
N     * giving the bit offset from those pointers, and finally the
N     * number of bits to copy.
N     * 
N     * Just like memcpy and memmove, the "cpy" functions copy as
N     * fast as they can in the assumption that the memory regions
N     * do not overlap, while the "move" functions cope correctly
N     * with overlap.
N     *
N     * Treating memory as a stream of individual bits requires
N     * defining a convention about what order those bits are
N     * considered to be arranged in. The above functions support
N     * multiple conventions:
N     * 
N     *  - the "bl" functions consider the unit of memory to be the
N     *    byte, and consider the bits within each byte to be
N     *    arranged in little-endian fashion, so that the LSB comes
N     *    first. (For example, membitcpybl(a,b,0,7,1) would copy
N     *    the MSB of the byte at b to the LSB of the byte at a.)
N     * 
N     *  - the "bb" functions consider the unit of memory to be the
N     *    byte, and consider the bits within each byte to be
N     *    arranged in big-endian fashion, so that the MSB comes
N     *    first.
N     * 
N     *  - the "hl" functions consider the unit of memory to be the
N     *    16-bit halfword, and consider the bits within each word
N     *    to be arranged in little-endian fashion.
N     * 
N     *  - the "hb" functions consider the unit of memory to be the
N     *    16-bit halfword, and consider the bits within each word
N     *    to be arranged in big-endian fashion.
N     * 
N     *  - the "wl" functions consider the unit of memory to be the
N     *    32-bit word, and consider the bits within each word to be
N     *    arranged in little-endian fashion.
N     * 
N     *  - the "wb" functions consider the unit of memory to be the
N     *    32-bit word, and consider the bits within each word to be
N     *    arranged in big-endian fashion.
N     */
N
N    #ifdef __cplusplus
S         }  /* extern "C" */
S      }  /* namespace std */
N    #endif /* __cplusplus */
N  #endif /* __STRING_DECLS */
N
N  #ifdef __cplusplus
S    #ifndef __STRING_NO_EXPORTS
S      using ::std::size_t;
S      using ::std::memcpy;
S      using ::std::memmove;
S      using ::std::strcpy;
S      using ::std::strncpy;
S      using ::std::strcat;
S      using ::std::strncat;
S      using ::std::memcmp;
S      using ::std::strcmp;
S      using ::std::strncmp;
S      using ::std::strcasecmp;
S      using ::std::strncasecmp;
S      using ::std::strcoll;
S      using ::std::strxfrm;
S      using ::std::memchr;
S      using ::std::strchr;
S      using ::std::strcspn;
S      using ::std::strpbrk;
S      using ::std::strrchr;
S      using ::std::strspn;
S      using ::std::strstr;
S      using ::std::strtok;
S#ifndef __STRICT_ANSI__
S      using ::std::strtok_r;
S#endif
S      using ::std::_strtok_r;
S      using ::std::memset;
S      using ::std::strerror;
S      using ::std::strlen;
S      using ::std::strlcpy;
S      using ::std::strlcat;
S      using ::std::_membitcpybl;
S      using ::std::_membitcpybb;
S      using ::std::_membitcpyhl;
S      using ::std::_membitcpyhb;
S      using ::std::_membitcpywl;
S      using ::std::_membitcpywb;
S      using ::std::_membitmovebl;
S      using ::std::_membitmovebb;
S      using ::std::_membitmovehl;
S      using ::std::_membitmovehb;
S      using ::std::_membitmovewl;
S      using ::std::_membitmovewb;
S    #endif /* __STRING_NO_EXPORTS */
N  #endif /* __cplusplus */
N
N#endif
N
N/* end of string.h */
N
L 11 "..\..\User\./usart/bsp_usart.h" 2
N#include <stdio.h>
L 1 "F:\Keil_v5\ARM\ARMCC\Bin\..\include\stdio.h" 1
N/* stdio.h: ANSI 'C' (X3J11 Oct 88) library header, section 4.9 */
N/* Copyright (C) Codemist Ltd., 1988-1993                       */
N/* Copyright 1991-1998 ARM Limited. All rights reserved.        */
N
N/*
N * RCS $Revision$
N * Checkin $Date$
N * Revising $Author: sdouglas $
N */
N
N/*
N * stdio.h declares two types, several macros, and many functions for
N * performing input and output. For a discussion on Streams and Files
N * refer to sections 4.9.2 and 4.9.3 in the above ANSI draft, or to a
N * modern textbook on C.
N */
N
N#ifndef __stdio_h
N#define __stdio_h
N#define __ARMCLIB_VERSION 5060037
N
N/*
N * Depending on compiler version __int64 or __INT64_TYPE__ should be defined.
N */
N#ifndef __int64
N  #ifdef __INT64_TYPE__
S    #define __int64 __INT64_TYPE__
N  #endif
N  /* On some architectures neither of these may be defined - if so, fall
N     through and error out if used. */
N#endif
N
N
N#define _ARMABI __declspec(__nothrow)
N
N  #ifndef __STDIO_DECLS
N  #define __STDIO_DECLS
N
N    #undef __CLIBNS
N    #ifdef __cplusplus
S      namespace std {
S      #define __CLIBNS ::std::
S        extern "C" {
N    #else /* ndef __cplusplus */
N      #define __CLIBNS
N    #endif /* ndef __cplusplus */
N
N#if defined(__cplusplus) || !defined(__STRICT_ANSI__) || !defined(__size_t)
X#if 0L || !0L || !0L
N /* always defined in C++ and non-strict C for consistency of debug info */
N  #if __sizeof_ptr == 8
X  #if 4 == 8
S    typedef unsigned long size_t;   /* see <stddef.h> */
N  #else
N    typedef unsigned int size_t;   /* see <stddef.h> */
N  #endif
N  #if !defined(__cplusplus) && defined(__STRICT_ANSI__)
X  #if !0L && 0L
S    #define __size_t 1
N  #endif
N#endif
N
N#undef NULL
N#define NULL 0                   /* see <stddef.h> */
N
N/* ANSI forbids va_list to be defined here */
N/* keep in step with <stdarg.h> and <wchar.h> */
N#if !defined(__va_list) && (defined(__cplusplus) || !defined(__STRICT_ANSI__) || !defined(__va_list_defined))
X#if !0L && (0L || !0L || !0L)
N/* always defined in C++ and non-strict C for consistency of debug info */
N  #ifdef __clang__
S    typedef __builtin_va_list __va_list;
N  #else
N    typedef struct __va_list __va_list;
N  #endif
N  #if !defined(__cplusplus) && defined(__STRICT_ANSI__)
X  #if !0L && 0L
S    #define __va_list_defined 1
N  #endif
N#endif
N
N   /*
N    * If the compiler supports signalling nans as per N965 then it
N    * will define __SUPPORT_SNAN__, in which case a user may define
N    * _WANT_SNAN in order to obtain compliant versions of the printf
N    * and scanf families of functions
N    */
N#if defined(__SUPPORT_SNAN__) && defined(_WANT_SNAN)
X#if 0L && 0L
S#pragma import(__use_snan)
N#endif
N
Ntypedef struct __fpos_t_struct {
N    unsigned __int64 __pos;
N    /*
N     * this structure is equivalent to an mbstate_t, but we're not
N     * allowed to actually define the type name `mbstate_t' within
N     * stdio.h
N     */
N    struct {
N        unsigned int __state1, __state2;
N    } __mbstate;
N} fpos_t;
N   /*
N    * fpos_t is an object capable of recording all information needed to
N    * specify uniquely every position within a file.
N    */
N
N#define _SYS_OPEN 16
N   /* _SYS_OPEN defines a limit on the number of open files that is imposed
N    * by this C library
N    */
N
Ntypedef struct __FILE FILE;
N   /*
N    * FILE is an object capable of recording all information needed to control
N    * a stream, such as its file position indicator, a pointer to its
N    * associated buffer, an error indicator that records whether a read/write
N    * error has occurred and an end-of-file indicator that records whether the
N    * end-of-file has been reached.
N    * Its structure is not made known to library clients.
N    */
N
N#if defined(__STRICT_ANSI__) && !__FILE_INCOMPLETE
X#if 0L && !__FILE_INCOMPLETE
Sstruct __FILE {
S    union {
S        long __FILE_alignment;
S#ifdef __TARGET_ARCH_AARCH64
S        char __FILE_size[136];
S#else /* __TARGET_ARCH_AARCH64 */
S        char __FILE_size[84];
S#endif /* __TARGET_ARCH_AARCH64 */
S    } __FILE_opaque;
S};
S    /*
S     * FILE must be an object type (C99 - 7.19.1) and an object type fully
S     * describes an object [including its static size] (C99 - 6.2.5).
S     * This definition is a placeholder which matches the struct __FILE in
S     * size and alignment as used internally by libc.
S     */
N#endif
N
N
Nextern FILE __stdin, __stdout, __stderr;
Nextern FILE *__aeabi_stdin, *__aeabi_stdout, *__aeabi_stderr;
N
N#if _AEABI_PORTABILITY_LEVEL != 0 || (!defined _AEABI_PORTABILITY_LEVEL && __DEFAULT_AEABI_PORTABILITY_LEVEL != 0)
X#if _AEABI_PORTABILITY_LEVEL != 0 || (!0L && __DEFAULT_AEABI_PORTABILITY_LEVEL != 0)
S#define stdin  (__CLIBNS __aeabi_stdin)
S   /* pointer to a FILE object associated with standard input stream */
S#define stdout (__CLIBNS __aeabi_stdout)
S   /* pointer to a FILE object associated with standard output stream */
S#define stderr (__CLIBNS __aeabi_stderr)
S   /* pointer to a FILE object associated with standard error stream */
Sextern const int __aeabi_IOFBF;
S#define _IOFBF (__CLIBNS __aeabi_IOFBF)
Sextern const int __aeabi_IONBF;
S#define _IONBF (__CLIBNS __aeabi_IONBF)
Sextern const int __aeabi_IOLBF;
S#define _IOLBF (__CLIBNS __aeabi_IOLBF)
Sextern const int __aeabi_BUFSIZ;
S#define BUFSIZ (__CLIBNS __aeabi_BUFSIZ)
Sextern const int __aeabi_FOPEN_MAX;
S#define FOPEN_MAX (__CLIBNS __aeabi_FOPEN_MAX)
Sextern const int __aeabi_TMP_MAX;
S#define TMP_MAX (__CLIBNS __aeabi_TMP_MAX)
Sextern const int __aeabi_FILENAME_MAX;
S#define FILENAME_MAX (__CLIBNS __aeabi_FILENAME_MAX)
Sextern const int __aeabi_L_tmpnam;
S#define L_tmpnam (__CLIBNS __aeabi_L_tmpnam)
N#else
N#define stdin  (&__CLIBNS __stdin)
N   /* pointer to a FILE object associated with standard input stream */
N#define stdout (&__CLIBNS __stdout)
N   /* pointer to a FILE object associated with standard output stream */
N#define stderr (&__CLIBNS __stderr)
N   /* pointer to a FILE object associated with standard error stream */
N
N#define _IOFBF           0x100 /* fully buffered IO */
N#define _IOLBF           0x200 /* line buffered IO */
N#define _IONBF           0x400 /* unbuffered IO */
N
N    /* Various default file IO buffer sizes */
N#define BUFSIZ       (512)  /* system buffer size (as used by setbuf) */
N
N#define FOPEN_MAX _SYS_OPEN
N   /*
N    * an integral constant expression that is the minimum number of files that
N    * this implementation guarantees can be open simultaneously.
N    */
N
N#define FILENAME_MAX 256
N   /*
N    * an integral constant expression that is the size of an array of char
N    * large enough to hold the longest filename string
N    */
N#define L_tmpnam FILENAME_MAX
N   /*
N    * an integral constant expression that is the size of an array of char
N    * large enough to hold a temporary file name string generated by the
N    * tmpnam function.
N    */
N#define TMP_MAX 256
N   /*
N    * an integral constant expression that is the minimum number of unique
N    * file names that shall be generated by the tmpnam function.
N    */
N
N#endif
N
N#define EOF      (-1)
N   /*
N    * negative integral constant, indicates end-of-file, that is, no more input
N    * from a stream.
N    */
N
N#define SEEK_SET 0 /* start of stream (see fseek) */
N#define SEEK_CUR 1 /* current position in stream (see fseek) */
N#define SEEK_END 2 /* end of stream (see fseek) */
N
N    /*
N     * _IOBIN is the flag passed to _sys_write to denote a binary
N     * file.
N     */
N#define _IOBIN            0x04     /* binary stream */
N
N#define __STDIN_BUFSIZ  (64)  /* default stdin buffer size */
N#define __STDOUT_BUFSIZ (64)  /* default stdout buffer size */
N#define __STDERR_BUFSIZ (16)  /* default stderr buffer size */
N
Nextern _ARMABI int remove(const char * /*filename*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int remove(const char *  ) __attribute__((__nonnull__(1)));
N   /*
N    * causes the file whose name is the string pointed to by filename to be
N    * removed. Subsequent attempts to open the file will fail, unless it is
N    * created anew. If the file is open, the behaviour of the remove function
N    * is implementation-defined.
N    * Returns: zero if the operation succeeds, nonzero if it fails.
N    */
Nextern _ARMABI int rename(const char * /*old*/, const char * /*new*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int rename(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * causes the file whose name is the string pointed to by old to be
N    * henceforth known by the name given by the string pointed to by new. The
N    * file named old is effectively removed. If a file named by the string
N    * pointed to by new exists prior to the call of the rename function, the
N    * behaviour is implementation-defined.
N    * Returns: zero if the operation succeeds, nonzero if it fails, in which
N    *          case if the file existed previously it is still known by its
N    *          original name.
N    */
Nextern _ARMABI FILE *tmpfile(void);
Xextern __declspec(__nothrow) FILE *tmpfile(void);
N   /*
N    * creates a temporary binary file that will be automatically removed when
N    * it is closed or at program termination. The file is opened for update.
N    * Returns: a pointer to the stream of the file that it created. If the file
N    *          cannot be created, a null pointer is returned.
N    */
Nextern _ARMABI char *tmpnam(char * /*s*/);
Xextern __declspec(__nothrow) char *tmpnam(char *  );
N   /*
N    * generates a string that is not the same as the name of an existing file.
N    * The tmpnam function generates a different string each time it is called,
N    * up to TMP_MAX times. If it is called more than TMP_MAX times, the
N    * behaviour is implementation-defined.
N    * Returns: If the argument is a null pointer, the tmpnam function leaves
N    *          its result in an internal static object and returns a pointer to
N    *          that object. Subsequent calls to the tmpnam function may modify
N    *          the same object. if the argument is not a null pointer, it is
N    *          assumed to point to an array of at least L_tmpnam characters;
N    *          the tmpnam function writes its result in that array and returns
N    *          the argument as its value.
N    */
N
Nextern _ARMABI int fclose(FILE * /*stream*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int fclose(FILE *  ) __attribute__((__nonnull__(1)));
N   /*
N    * causes the stream pointed to by stream to be flushed and the associated
N    * file to be closed. Any unwritten buffered data for the stream are
N    * delivered to the host environment to be written to the file; any unread
N    * buffered data are discarded. The stream is disassociated from the file.
N    * If the associated buffer was automatically allocated, it is deallocated.
N    * Returns: zero if the stream was succesfully closed, or nonzero if any
N    *          errors were detected or if the stream was already closed.
N    */
Nextern _ARMABI int fflush(FILE * /*stream*/);
Xextern __declspec(__nothrow) int fflush(FILE *  );
N   /*
N    * If the stream points to an output or update stream in which the most
N    * recent operation was output, the fflush function causes any unwritten
N    * data for that stream to be delivered to the host environment to be
N    * written to the file. If the stream points to an input or update stream,
N    * the fflush function undoes the effect of any preceding ungetc operation
N    * on the stream.
N    * Returns: nonzero if a write error occurs.
N    */
Nextern _ARMABI FILE *fopen(const char * __restrict /*filename*/,
Xextern __declspec(__nothrow) FILE *fopen(const char * __restrict  ,
N                           const char * __restrict /*mode*/) __attribute__((__nonnull__(1,2)));
N   /*
N    * opens the file whose name is the string pointed to by filename, and
N    * associates a stream with it.
N    * The argument mode points to a string beginning with one of the following
N    * sequences:
N    * "r"         open text file for reading
N    * "w"         create text file for writing, or truncate to zero length
N    * "a"         append; open text file or create for writing at eof
N    * "rb"        open binary file for reading
N    * "wb"        create binary file for writing, or truncate to zero length
N    * "ab"        append; open binary file or create for writing at eof
N    * "r+"        open text file for update (reading and writing)
N    * "w+"        create text file for update, or truncate to zero length
N    * "a+"        append; open text file or create for update, writing at eof
N    * "r+b"/"rb+" open binary file for update (reading and writing)
N    * "w+b"/"wb+" create binary file for update, or truncate to zero length
N    * "a+b"/"ab+" append; open binary file or create for update, writing at eof
N    *
N    * Opening a file with read mode ('r' as the first character in the mode
N    * argument) fails if the file does not exist or cannot be read.
N    * Opening a file with append mode ('a' as the first character in the mode
N    * argument) causes all subsequent writes to be forced to the current end of
N    * file, regardless of intervening calls to the fseek function. In some
N    * implementations, opening a binary file with append mode ('b' as the
N    * second or third character in the mode argument) may initially position
N    * the file position indicator beyond the last data written, because of the
N    * NUL padding.
N    * When a file is opened with update mode ('+' as the second or third
N    * character in the mode argument), both input and output may be performed
N    * on the associated stream. However, output may not be directly followed
N    * by input without an intervening call to the fflush fuction or to a file
N    * positioning function (fseek, fsetpos, or rewind), and input be not be
N    * directly followed by output without an intervening call to the fflush
N    * fuction or to a file positioning function, unless the input operation
N    * encounters end-of-file. Opening a file with update mode may open or
N    * create a binary stream in some implementations. When opened, a stream
N    * is fully buffered if and only if it does not refer to an interactive
N    * device. The error and end-of-file indicators for the stream are
N    * cleared.
N    * Returns: a pointer to the object controlling the stream. If the open
N    *          operation fails, fopen returns a null pointer.
N    */
Nextern _ARMABI FILE *freopen(const char * __restrict /*filename*/,
Xextern __declspec(__nothrow) FILE *freopen(const char * __restrict  ,
N                    const char * __restrict /*mode*/,
N                    FILE * __restrict /*stream*/) __attribute__((__nonnull__(2,3)));
N   /*
N    * opens the file whose name is the string pointed to by filename and
N    * associates the stream pointed to by stream with it. The mode argument is
N    * used just as in the fopen function.
N    * The freopen function first attempts to close any file that is associated
N    * with the specified stream. Failure to close the file successfully is
N    * ignored. The error and end-of-file indicators for the stream are cleared.
N    * Returns: a null pointer if the operation fails. Otherwise, freopen
N    *          returns the value of the stream.
N    */
Nextern _ARMABI void setbuf(FILE * __restrict /*stream*/,
Xextern __declspec(__nothrow) void setbuf(FILE * __restrict  ,
N                    char * __restrict /*buf*/) __attribute__((__nonnull__(1)));
N   /*
N    * Except that it returns no value, the setbuf function is equivalent to the
N    * setvbuf function invoked with the values _IOFBF for mode and BUFSIZ for
N    * size, or (if buf is a null pointer), with the value _IONBF for mode.
N    * Returns: no value.
N    */
Nextern _ARMABI int setvbuf(FILE * __restrict /*stream*/,
Xextern __declspec(__nothrow) int setvbuf(FILE * __restrict  ,
N                   char * __restrict /*buf*/,
N                   int /*mode*/, size_t /*size*/) __attribute__((__nonnull__(1)));
N   /*
N    * may be used after the stream pointed to by stream has been associated
N    * with an open file but before it is read or written. The argument mode
N    * determines how stream will be buffered, as follows: _IOFBF causes
N    * input/output to be fully buffered; _IOLBF causes output to be line
N    * buffered (the buffer will be flushed when a new-line character is
N    * written, when the buffer is full, or when input is requested); _IONBF
N    * causes input/output to be completely unbuffered. If buf is not the null
N    * pointer, the array it points to may be used instead of an automatically
N    * allocated buffer (the buffer must have a lifetime at least as great as
N    * the open stream, so the stream should be closed before a buffer that has
N    * automatic storage duration is deallocated upon block exit). The argument
N    * size specifies the size of the array. The contents of the array at any
N    * time are indeterminate.
N    * Returns: zero on success, or nonzero if an invalid value is given for
N    *          mode or size, or if the request cannot be honoured.
N    */
N#pragma __printf_args
Nextern _ARMABI int fprintf(FILE * __restrict /*stream*/,
Xextern __declspec(__nothrow) int fprintf(FILE * __restrict  ,
N                    const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1,2)));
N   /*
N    * writes output to the stream pointed to by stream, under control of the
N    * string pointed to by format that specifies how subsequent arguments are
N    * converted for output. If there are insufficient arguments for the format,
N    * the behaviour is undefined. If the format is exhausted while arguments
N    * remain, the excess arguments are evaluated but otherwise ignored. The
N    * fprintf function returns when the end of the format string is reached.
N    * The format shall be a multibyte character sequence, beginning and ending
N    * in its initial shift state. The format is composed of zero or more
N    * directives: ordinary multibyte characters (not %), which are copied
N    * unchanged to the output stream; and conversion specifiers, each of which
N    * results in fetching zero or more subsequent arguments. Each conversion
N    * specification is introduced by the character %. For a description of the
N    * available conversion specifiers refer to section 4.9.6.1 in the ANSI
N    * draft mentioned at the start of this file or to any modern textbook on C.
N    * The minimum value for the maximum number of characters producable by any
N    * single conversion is at least 509.
N    * Returns: the number of characters transmitted, or a negative value if an
N    *          output error occurred.
N    */
N#pragma __printf_args
Nextern _ARMABI int _fprintf(FILE * __restrict /*stream*/,
Xextern __declspec(__nothrow) int _fprintf(FILE * __restrict  ,
N                     const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to fprintf, but does not support floating-point formats.
N    * You can use instead of fprintf to improve code size.
N    * Returns: as fprintf.
N    */
N#pragma __printf_args
Nextern _ARMABI int printf(const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int printf(const char * __restrict  , ...) __attribute__((__nonnull__(1)));
N   /*
N    * is equivalent to fprintf with the argument stdout interposed before the
N    * arguments to printf.
N    * Returns: the number of characters transmitted, or a negative value if an
N    *          output error occurred.
N    */
N#pragma __printf_args
Nextern _ARMABI int _printf(const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int _printf(const char * __restrict  , ...) __attribute__((__nonnull__(1)));
N   /*
N    * is equivalent to printf, but does not support floating-point formats.
N    * You can use instead of printf to improve code size.
N    * Returns: as printf.
N    */
N#pragma __printf_args
Nextern _ARMABI int sprintf(char * __restrict /*s*/, const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int sprintf(char * __restrict  , const char * __restrict  , ...) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to fprintf, except that the argument s specifies an array
N    * into which the generated output is to be written, rather than to a
N    * stream. A null character is written at the end of the characters written;
N    * it is not counted as part of the returned sum.
N    * Returns: the number of characters written to the array, not counting the
N    *          terminating null character.
N    */
N#pragma __printf_args
Nextern _ARMABI int _sprintf(char * __restrict /*s*/, const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int _sprintf(char * __restrict  , const char * __restrict  , ...) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to sprintf, but does not support floating-point formats.
N    * You can use instead of sprintf to improve code size.
N    * Returns: as sprintf.
N    */
N
N#pragma __printf_args
Nextern _ARMABI int __ARM_snprintf(char * __restrict /*s*/, size_t /*n*/,
Xextern __declspec(__nothrow) int __ARM_snprintf(char * __restrict  , size_t  ,
N                     const char * __restrict /*format*/, ...) __attribute__((__nonnull__(3)));
N
N#if !defined(__STRICT_ANSI__) || (defined(__STDC_VERSION__) && 199901L <= __STDC_VERSION__) || (defined(__cplusplus) && 201103L <= __cplusplus)
X#if !0L || (1L && 199901L <= 199901L) || (0L && 201103L <= __cplusplus)
N#pragma __printf_args
Nextern _ARMABI int snprintf(char * __restrict /*s*/, size_t /*n*/,
Xextern __declspec(__nothrow) int snprintf(char * __restrict  , size_t  ,
N                     const char * __restrict /*format*/, ...) __attribute__((__nonnull__(3)));
N   /*
N    * is equivalent to fprintf, except that the argument s specifies an array
N    * into which the generated output is to be written, rather than to a
N    * stream. The argument n specifies the size of the output array, so as to
N    * avoid overflowing the buffer.
N    * A null character is written at the end of the characters written, even
N    * if the formatting was not completed; it is not counted as part of the
N    * returned sum. At most n characters of the output buffer are used,
N    * _including_ the null character.
N    * Returns: the number of characters that would have been written to the
N    *          array, not counting the terminating null character, if the
N    *          array had been big enough. So if the return is >=0 and <n, then
N    *          the entire string was successfully formatted; if the return is
N    *          >=n, the string was truncated (but there is still a null char
N    *          at the end of what was written); if the return is <0, there was
N    *          an error.
N    */
N#endif
N#pragma __printf_args
Nextern _ARMABI int _snprintf(char * __restrict /*s*/, size_t /*n*/,
Xextern __declspec(__nothrow) int _snprintf(char * __restrict  , size_t  ,
N                      const char * __restrict /*format*/, ...) __attribute__((__nonnull__(3)));
N   /*
N    * is equivalent to snprintf, but does not support floating-point formats.
N    * You can use instead of snprintf to improve code size.
N    * Returns: as snprintf.
N    */
N#pragma __scanf_args
Nextern _ARMABI int fscanf(FILE * __restrict /*stream*/,
Xextern __declspec(__nothrow) int fscanf(FILE * __restrict  ,
N                    const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1,2)));
N   /*
N    * reads input from the stream pointed to by stream, under control of the
N    * string pointed to by format that specifies the admissible input sequences
N    * and how thay are to be converted for assignment, using subsequent
N    * arguments as pointers to the objects to receive the converted input. If
N    * there are insufficient arguments for the format, the behaviour is
N    * undefined. If the format is exhausted while arguments remain, the excess
N    * arguments are evaluated but otherwise ignored.
N    * The format is composed of zero or more directives: one or more
N    * white-space characters; an ordinary character (not %); or a conversion
N    * specification. Each conversion specification is introduced by the
N    * character %. For a description of the available conversion specifiers
N    * refer to section 4.9.6.2 in the ANSI draft mentioned at the start of this
N    * file, or to any modern textbook on C.
N    * If end-of-file is encountered during input, conversion is terminated. If
N    * end-of-file occurs before any characters matching the current directive
N    * have been read (other than leading white space, where permitted),
N    * execution of the current directive terminates with an input failure;
N    * otherwise, unless execution of the current directive is terminated with a
N    * matching failure, execution of the following directive (if any) is
N    * terminated with an input failure.
N    * If conversions terminates on a conflicting input character, the offending
N    * input character is left unread in the input strem. Trailing white space
N    * (including new-line characters) is left unread unless matched by a
N    * directive. The success of literal matches and suppressed asignments is
N    * not directly determinable other than via the %n directive.
N    * Returns: the value of the macro EOF if an input failure occurs before any
N    *          conversion. Otherwise, the fscanf function returns the number of
N    *          input items assigned, which can be fewer than provided for, or
N    *          even zero, in the event of an early conflict between an input
N    *          character and the format.
N    */
N#pragma __scanf_args
Nextern _ARMABI int _fscanf(FILE * __restrict /*stream*/,
Xextern __declspec(__nothrow) int _fscanf(FILE * __restrict  ,
N                     const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to fscanf, but does not support floating-point formats.
N    * You can use instead of fscanf to improve code size.
N    * Returns: as fscanf.
N    */
N#pragma __scanf_args
Nextern _ARMABI int scanf(const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int scanf(const char * __restrict  , ...) __attribute__((__nonnull__(1)));
N   /*
N    * is equivalent to fscanf with the argument stdin interposed before the
N    * arguments to scanf.
N    * Returns: the value of the macro EOF if an input failure occurs before any
N    *          conversion. Otherwise, the scanf function returns the number of
N    *          input items assigned, which can be fewer than provided for, or
N    *          even zero, in the event of an early matching failure.
N    */
N#pragma __scanf_args
Nextern _ARMABI int _scanf(const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int _scanf(const char * __restrict  , ...) __attribute__((__nonnull__(1)));
N   /*
N    * is equivalent to scanf, but does not support floating-point formats.
N    * You can use instead of scanf to improve code size.
N    * Returns: as scanf.
N    */
N#pragma __scanf_args
Nextern _ARMABI int sscanf(const char * __restrict /*s*/,
Xextern __declspec(__nothrow) int sscanf(const char * __restrict  ,
N                    const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to fscanf except that the argument s specifies a string
N    * from which the input is to be obtained, rather than from a stream.
N    * Reaching the end of the string is equivalent to encountering end-of-file
N    * for the fscanf function.
N    * Returns: the value of the macro EOF if an input failure occurs before any
N    *          conversion. Otherwise, the scanf function returns the number of
N    *          input items assigned, which can be fewer than provided for, or
N    *          even zero, in the event of an early matching failure.
N    */
N#pragma __scanf_args
Nextern _ARMABI int _sscanf(const char * __restrict /*s*/,
Xextern __declspec(__nothrow) int _sscanf(const char * __restrict  ,
N                     const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to sscanf, but does not support floating-point formats.
N    * You can use instead of sscanf to improve code size.
N    * Returns: as sscanf.
N    */
N#if !defined(__STRICT_ANSI__) || (defined(__STDC_VERSION__) && 199901L <= __STDC_VERSION__) || (defined(__cplusplus) && 201103L <= __cplusplus)
X#if !0L || (1L && 199901L <= 199901L) || (0L && 201103L <= __cplusplus)
N/* C99 additions */
Nextern _ARMABI int vfscanf(FILE * __restrict /*stream*/, const char * __restrict /*format*/, __va_list) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int vfscanf(FILE * __restrict  , const char * __restrict  , __va_list) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI int vscanf(const char * __restrict /*format*/, __va_list) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int vscanf(const char * __restrict  , __va_list) __attribute__((__nonnull__(1)));
Nextern _ARMABI int vsscanf(const char * __restrict /*s*/, const char * __restrict /*format*/, __va_list) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int vsscanf(const char * __restrict  , const char * __restrict  , __va_list) __attribute__((__nonnull__(1,2)));
N#endif
Nextern _ARMABI int _vfscanf(FILE * __restrict /*stream*/, const char * __restrict /*format*/, __va_list) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int _vfscanf(FILE * __restrict  , const char * __restrict  , __va_list) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI int _vscanf(const char * __restrict /*format*/, __va_list) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int _vscanf(const char * __restrict  , __va_list) __attribute__((__nonnull__(1)));
Nextern _ARMABI int _vsscanf(const char * __restrict /*s*/, const char * __restrict /*format*/, __va_list) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int _vsscanf(const char * __restrict  , const char * __restrict  , __va_list) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI int __ARM_vsscanf(const char * __restrict /*s*/, const char * __restrict /*format*/, __va_list) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int __ARM_vsscanf(const char * __restrict  , const char * __restrict  , __va_list) __attribute__((__nonnull__(1,2)));
N
Nextern _ARMABI int vprintf(const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int vprintf(const char * __restrict  , __va_list  ) __attribute__((__nonnull__(1)));
N   /*
N    * is equivalent to printf, with the variable argument list replaced by arg,
N    * which has been initialised by the va_start macro (and possibly subsequent
N    * va_arg calls). The vprintf function does not invoke the va_end function.
N    * Returns: the number of characters transmitted, or a negative value if an
N    *          output error occurred.
N    */
Nextern _ARMABI int _vprintf(const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int _vprintf(const char * __restrict  , __va_list  ) __attribute__((__nonnull__(1)));
N   /*
N    * is equivalent to vprintf, but does not support floating-point formats.
N    * You can use instead of vprintf to improve code size.
N    * Returns: as vprintf.
N    */
Nextern _ARMABI int vfprintf(FILE * __restrict /*stream*/,
Xextern __declspec(__nothrow) int vfprintf(FILE * __restrict  ,
N                    const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to fprintf, with the variable argument list replaced by
N    * arg, which has been initialised by the va_start macro (and possibly
N    * subsequent va_arg calls). The vfprintf function does not invoke the
N    * va_end function.
N    * Returns: the number of characters transmitted, or a negative value if an
N    *          output error occurred.
N    */
Nextern _ARMABI int vsprintf(char * __restrict /*s*/,
Xextern __declspec(__nothrow) int vsprintf(char * __restrict  ,
N                     const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to sprintf, with the variable argument list replaced by
N    * arg, which has been initialised by the va_start macro (and possibly
N    * subsequent va_arg calls). The vsprintf function does not invoke the
N    * va_end function.
N    * Returns: the number of characters written in the array, not counting the
N    *          terminating null character.
N    */
Nextern _ARMABI int __ARM_vsnprintf(char * __restrict /*s*/, size_t /*n*/,
Xextern __declspec(__nothrow) int __ARM_vsnprintf(char * __restrict  , size_t  ,
N                     const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(3)));
N#if !defined(__STRICT_ANSI__) || (defined(__STDC_VERSION__) && 199901L <= __STDC_VERSION__) || (defined(__cplusplus) && 201103L <= __cplusplus)
X#if !0L || (1L && 199901L <= 199901L) || (0L && 201103L <= __cplusplus)
Nextern _ARMABI int vsnprintf(char * __restrict /*s*/, size_t /*n*/,
Xextern __declspec(__nothrow) int vsnprintf(char * __restrict  , size_t  ,
N                     const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(3)));
N   /*
N    * is equivalent to snprintf, with the variable argument list replaced by
N    * arg, which has been initialised by the va_start macro (and possibly
N    * subsequent va_arg calls). The vsprintf function does not invoke the
N    * va_end function.
N    * Returns: the number of characters that would have been written in the
N    *          array, not counting the terminating null character. As
N    *          snprintf.
N    */
N#endif
Nextern _ARMABI int _vsprintf(char * __restrict /*s*/,
Xextern __declspec(__nothrow) int _vsprintf(char * __restrict  ,
N                      const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to vsprintf, but does not support floating-point formats.
N    * You can use instead of vsprintf to improve code size.
N    * Returns: as vsprintf.
N    */
Nextern _ARMABI int _vfprintf(FILE * __restrict /*stream*/,
Xextern __declspec(__nothrow) int _vfprintf(FILE * __restrict  ,
N                     const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to vfprintf, but does not support floating-point formats.
N    * You can use instead of vfprintf to improve code size.
N    * Returns: as vfprintf.
N    */
Nextern _ARMABI int _vsnprintf(char * __restrict /*s*/, size_t /*n*/,
Xextern __declspec(__nothrow) int _vsnprintf(char * __restrict  , size_t  ,
N                      const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(3)));
N   /*
N    * is equivalent to vsnprintf, but does not support floating-point formats.
N    * You can use instead of vsnprintf to improve code size.
N    * Returns: as vsnprintf.
N    */
N#if !defined(__STRICT_ANSI__)
X#if !0L
N#pragma __printf_args
Nextern _ARMABI int asprintf(char ** /*strp*/, const char * __restrict /*format*/, ...) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) int asprintf(char **  , const char * __restrict  , ...) __attribute__((__nonnull__(2)));
Nextern _ARMABI int vasprintf(char ** /*strp*/, const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) int vasprintf(char **  , const char * __restrict  , __va_list  ) __attribute__((__nonnull__(2)));
N#endif
N#pragma __printf_args
Nextern _ARMABI int __ARM_asprintf(char ** /*strp*/, const char * __restrict /*format*/, ...) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) int __ARM_asprintf(char **  , const char * __restrict  , ...) __attribute__((__nonnull__(2)));
Nextern _ARMABI int __ARM_vasprintf(char ** /*strp*/, const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) int __ARM_vasprintf(char **  , const char * __restrict  , __va_list  ) __attribute__((__nonnull__(2)));
N   /*
N    * dynamically allocates a buffer of the right size for the
N    * formatted string, and returns it in (*strp). Formal return value
N    * is the same as any other printf variant, except that it returns
N    * -1 if the buffer could not be allocated.
N    *
N    * (The functions with __ARM_ prefixed names are identical to the
N    * ones without, but are available in all compilation modes without
N    * violating user namespace.)
N    */
N
Nextern _ARMABI int fgetc(FILE * /*stream*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int fgetc(FILE *  ) __attribute__((__nonnull__(1)));
N   /*
N    * obtains the next character (if present) as an unsigned char converted to
N    * an int, from the input stream pointed to by stream, and advances the
N    * associated file position indicator (if defined).
N    * Returns: the next character from the input stream pointed to by stream.
N    *          If the stream is at end-of-file, the end-of-file indicator is
N    *          set and fgetc returns EOF. If a read error occurs, the error
N    *          indicator is set and fgetc returns EOF.
N    */
Nextern _ARMABI char *fgets(char * __restrict /*s*/, int /*n*/,
Xextern __declspec(__nothrow) char *fgets(char * __restrict  , int  ,
N                    FILE * __restrict /*stream*/) __attribute__((__nonnull__(1,3)));
N   /*
N    * reads at most one less than the number of characters specified by n from
N    * the stream pointed to by stream into the array pointed to by s. No
N    * additional characters are read after a new-line character (which is
N    * retained) or after end-of-file. A null character is written immediately
N    * after the last character read into the array.
N    * Returns: s if successful. If end-of-file is encountered and no characters
N    *          have been read into the array, the contents of the array remain
N    *          unchanged and a null pointer is returned. If a read error occurs
N    *          during the operation, the array contents are indeterminate and a
N    *          null pointer is returned.
N    */
Nextern _ARMABI int fputc(int /*c*/, FILE * /*stream*/) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) int fputc(int  , FILE *  ) __attribute__((__nonnull__(2)));
N   /*
N    * writes the character specified by c (converted to an unsigned char) to
N    * the output stream pointed to by stream, at the position indicated by the
N    * asociated file position indicator (if defined), and advances the
N    * indicator appropriately. If the file position indicator is not defined,
N    * the character is appended to the output stream.
N    * Returns: the character written. If a write error occurs, the error
N    *          indicator is set and fputc returns EOF.
N    */
Nextern _ARMABI int fputs(const char * __restrict /*s*/, FILE * __restrict /*stream*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int fputs(const char * __restrict  , FILE * __restrict  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * writes the string pointed to by s to the stream pointed to by stream.
N    * The terminating null character is not written.
N    * Returns: EOF if a write error occurs; otherwise it returns a nonnegative
N    *          value.
N    */
Nextern _ARMABI int getc(FILE * /*stream*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int getc(FILE *  ) __attribute__((__nonnull__(1)));
N   /*
N    * is equivalent to fgetc except that it may be implemented as an unsafe
N    * macro (stream may be evaluated more than once, so the argument should
N    * never be an expression with side-effects).
N    * Returns: the next character from the input stream pointed to by stream.
N    *          If the stream is at end-of-file, the end-of-file indicator is
N    *          set and getc returns EOF. If a read error occurs, the error
N    *          indicator is set and getc returns EOF.
N    */
N#ifdef __cplusplus
S    inline int getchar() { return getc(stdin); }
N#else
N    #define getchar() getc(stdin)
N    extern _ARMABI int (getchar)(void);
X    extern __declspec(__nothrow) int (getchar)(void);
N#endif
N   /*
N    * is equivalent to getc with the argument stdin.
N    * Returns: the next character from the input stream pointed to by stdin.
N    *          If the stream is at end-of-file, the end-of-file indicator is
N    *          set and getchar returns EOF. If a read error occurs, the error
N    *          indicator is set and getchar returns EOF.
N    */
Nextern _ARMABI char *gets(char * /*s*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) char *gets(char *  ) __attribute__((__nonnull__(1)));
N   /*
N    * reads characters from the input stream pointed to by stdin into the array
N    * pointed to by s, until end-of-file is encountered or a new-line character
N    * is read. Any new-line character is discarded, and a null character is
N    * written immediately after the last character read into the array.
N    * Returns: s if successful. If end-of-file is encountered and no characters
N    *          have been read into the array, the contents of the array remain
N    *          unchanged and a null pointer is returned. If a read error occurs
N    *          during the operation, the array contents are indeterminate and a
N    *          null pointer is returned.
N    */
Nextern _ARMABI int putc(int /*c*/, FILE * /*stream*/) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) int putc(int  , FILE *  ) __attribute__((__nonnull__(2)));
N   /*
N    * is equivalent to fputc except that it may be implemented as aan unsafe
N    * macro (stream may be evaluated more than once, so the argument should
N    * never be an expression with side-effects).
N    * Returns: the character written. If a write error occurs, the error
N    *          indicator is set and putc returns EOF.
N    */
N#ifdef __cplusplus
S    inline int putchar(int __c) { return putc(__c, stdout); }
N#else
N    #define putchar(c) putc(c, stdout)
N    extern _ARMABI int (putchar)(int /*c*/);
X    extern __declspec(__nothrow) int (putchar)(int  );
N#endif
N   /*
N    * is equivalent to putc with the second argument stdout.
N    * Returns: the character written. If a write error occurs, the error
N    *          indicator is set and putc returns EOF.
N    */
Nextern _ARMABI int puts(const char * /*s*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int puts(const char *  ) __attribute__((__nonnull__(1)));
N   /*
N    * writes the string pointed to by s to the stream pointed to by stdout, and
N    * appends a new-line character to the output. The terminating null
N    * character is not written.
N    * Returns: EOF if a write error occurs; otherwise it returns a nonnegative
N    *          value.
N    */
Nextern _ARMABI int ungetc(int /*c*/, FILE * /*stream*/) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) int ungetc(int  , FILE *  ) __attribute__((__nonnull__(2)));
N   /*
N    * pushes the character specified by c (converted to an unsigned char) back
N    * onto the input stream pointed to by stream. The character will be
N    * returned by the next read on that stream. An intervening call to the
N    * fflush function or to a file positioning function (fseek, fsetpos,
N    * rewind) discards any pushed-back characters. The extern _ARMABIal storage
N    * corresponding to the stream is unchanged.
N    * One character pushback is guaranteed. If the unget function is called too
N    * many times on the same stream without an intervening read or file
N    * positioning operation on that stream, the operation may fail.
N    * If the value of c equals that of the macro EOF, the operation fails and
N    * the input stream is unchanged.
N    * A successful call to the ungetc function clears the end-of-file
N    * indicator. The value of the file position indicator after reading or
N    * discarding all pushed-back characters shall be the same as it was before
N    * the characters were pushed back. For a text stream, the value of the file
N    * position indicator after a successful call to the ungetc function is
N    * unspecified until all pushed-back characters are read or discarded. For a
N    * binary stream, the file position indicator is decremented by each
N    * successful call to the ungetc function; if its value was zero before a
N    * call, it is indeterminate after the call.
N    * Returns: the character pushed back after conversion, or EOF if the
N    *          operation fails.
N    */
N
Nextern _ARMABI size_t fread(void * __restrict /*ptr*/,
Xextern __declspec(__nothrow) size_t fread(void * __restrict  ,
N                    size_t /*size*/, size_t /*nmemb*/, FILE * __restrict /*stream*/) __attribute__((__nonnull__(1,4)));
N   /*
N    * reads into the array pointed to by ptr, up to nmemb members whose size is
N    * specified by size, from the stream pointed to by stream. The file
N    * position indicator (if defined) is advanced by the number of characters
N    * successfully read. If an error occurs, the resulting value of the file
N    * position indicator is indeterminate. If a partial member is read, its
N    * value is indeterminate. The ferror or feof function shall be used to
N    * distinguish between a read error and end-of-file.
N    * Returns: the number of members successfully read, which may be less than
N    *          nmemb if a read error or end-of-file is encountered. If size or
N    *          nmemb is zero, fread returns zero and the contents of the array
N    *          and the state of the stream remain unchanged.
N    */
N
Nextern _ARMABI size_t __fread_bytes_avail(void * __restrict /*ptr*/,
Xextern __declspec(__nothrow) size_t __fread_bytes_avail(void * __restrict  ,
N                    size_t /*count*/, FILE * __restrict /*stream*/) __attribute__((__nonnull__(1,3)));
N   /*
N    * reads into the array pointed to by ptr, up to count characters from the
N    * stream pointed to by stream. The file position indicator (if defined)
N    * is advanced by the number of characters successfully read. If an error
N    * occurs, the resulting value of the file position indicator is
N    * indeterminate. The ferror or feof function shall be used to
N    * distinguish between a read error and end-of-file.  The call will block
N    * only if no characters are available.
N    * Returns: the number of characters successfully read, which may be less than
N    *          count. If count is zero, __fread_bytes_avail returns zero and
N    *          the contents of the array and the state of the stream remain
N    *          unchanged.
N    */
N
Nextern _ARMABI size_t fwrite(const void * __restrict /*ptr*/,
Xextern __declspec(__nothrow) size_t fwrite(const void * __restrict  ,
N                    size_t /*size*/, size_t /*nmemb*/, FILE * __restrict /*stream*/) __attribute__((__nonnull__(1,4)));
N   /*
N    * writes, from the array pointed to by ptr up to nmemb members whose size
N    * is specified by size, to the stream pointed to by stream. The file
N    * position indicator (if defined) is advanced by the number of characters
N    * successfully written. If an error occurs, the resulting value of the file
N    * position indicator is indeterminate.
N    * Returns: the number of members successfully written, which will be less
N    *          than nmemb only if a write error is encountered.
N    */
N
Nextern _ARMABI int fgetpos(FILE * __restrict /*stream*/, fpos_t * __restrict /*pos*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int fgetpos(FILE * __restrict  , fpos_t * __restrict  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * stores the current value of the file position indicator for the stream
N    * pointed to by stream in the object pointed to by pos. The value stored
N    * contains unspecified information usable by the fsetpos function for
N    * repositioning the stream to its position at the time  of the call to the
N    * fgetpos function.
N    * Returns: zero, if successful. Otherwise nonzero is returned and the
N    *          integer expression errno is set to an implementation-defined
N    *          nonzero value.
N    */
Nextern _ARMABI int fseek(FILE * /*stream*/, long int /*offset*/, int /*whence*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int fseek(FILE *  , long int  , int  ) __attribute__((__nonnull__(1)));
N   /*
N    * sets the file position indicator for the stream pointed to by stream.
N    * For a binary stream, the new position is at the signed number of
N    * characters specified by offset away from the point specified by whence.
N    * The specified point is the beginning of the file for SEEK_SET, the
N    * current position in the file for SEEK_CUR, or end-of-file for SEEK_END.
N    * A binary stream need not meaningfully support fseek calls with a whence
N    * value of SEEK_END.
N    * For a text stream, either offset shall be zero, or offset shall be a
N    * value returned by an earlier call to the ftell function on the same
N    * stream and whence shall be SEEK_SET.
N    * The fseek function clears the end-of-file indicator and undoes any
N    * effects of the ungetc function on the same stream. After an fseek call,
N    * the next operation on an update stream may be either input or output.
N    * Returns: nonzero only for a request that cannot be satisfied.
N    */
Nextern _ARMABI int fsetpos(FILE * __restrict /*stream*/, const fpos_t * __restrict /*pos*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int fsetpos(FILE * __restrict  , const fpos_t * __restrict  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * sets  the file position indicator for the stream pointed to by stream
N    * according to the value of the object pointed to by pos, which shall be a
N    * value returned by an earlier call to the fgetpos function on the same
N    * stream.
N    * The fsetpos function clears the end-of-file indicator and undoes any
N    * effects of the ungetc function on the same stream. After an fsetpos call,
N    * the next operation on an update stream may be either input or output.
N    * Returns: zero, if successful. Otherwise nonzero is returned and the
N    *          integer expression errno is set to an implementation-defined
N    *          nonzero value.
N    */
Nextern _ARMABI long int ftell(FILE * /*stream*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) long int ftell(FILE *  ) __attribute__((__nonnull__(1)));
N   /*
N    * obtains the current value of the file position indicator for the stream
N    * pointed to by stream. For a binary stream, the value is the number of
N    * characters from the beginning of the file. For a text stream, the file
N    * position indicator contains unspecified information, usable by the fseek
N    * function for returning the file position indicator to its position at the
N    * time of the ftell call; the difference between two such return values is
N    * not necessarily a meaningful measure of the number of characters written
N    * or read.
N    * Returns: if successful, the current value of the file position indicator.
N    *          On failure, the ftell function returns -1L and sets the integer
N    *          expression errno to an implementation-defined nonzero value.
N    */
Nextern _ARMABI void rewind(FILE * /*stream*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) void rewind(FILE *  ) __attribute__((__nonnull__(1)));
N   /*
N    * sets the file position indicator for the stream pointed to by stream to
N    * the beginning of the file. It is equivalent to
N    *          (void)fseek(stream, 0L, SEEK_SET)
N    * except that the error indicator for the stream is also cleared.
N    * Returns: no value.
N    */
N
Nextern _ARMABI void clearerr(FILE * /*stream*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) void clearerr(FILE *  ) __attribute__((__nonnull__(1)));
N   /*
N    * clears the end-of-file and error indicators for the stream pointed to by
N    * stream. These indicators are cleared only when the file is opened or by
N    * an explicit call to the clearerr function or to the rewind function.
N    * Returns: no value.
N    */
N
Nextern _ARMABI int feof(FILE * /*stream*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int feof(FILE *  ) __attribute__((__nonnull__(1)));
N   /*
N    * tests the end-of-file indicator for the stream pointed to by stream.
N    * Returns: nonzero iff the end-of-file indicator is set for stream.
N    */
Nextern _ARMABI int ferror(FILE * /*stream*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int ferror(FILE *  ) __attribute__((__nonnull__(1)));
N   /*
N    * tests the error indicator for the stream pointed to by stream.
N    * Returns: nonzero iff the error indicator is set for stream.
N    */
Nextern _ARMABI void perror(const char * /*s*/);
Xextern __declspec(__nothrow) void perror(const char *  );
N   /*
N    * maps the error number  in the integer expression errno to an error
N    * message. It writes a sequence of characters to the standard error stream
N    * thus: first (if s is not a null pointer and the character pointed to by
N    * s is not the null character), the string pointed to by s followed by a
N    * colon and a space; then an appropriate error message string followed by
N    * a new-line character. The contents of the error message strings are the
N    * same as those returned by the strerror function with argument errno,
N    * which are implementation-defined.
N    * Returns: no value.
N    */
N
Nextern _ARMABI int _fisatty(FILE * /*stream*/ ) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int _fisatty(FILE *   ) __attribute__((__nonnull__(1)));
N    /* Returns 1 if the stream is tty (stdin), 0 otherwise. Not ANSI compliant.
N     */
N
Nextern _ARMABI void __use_no_semihosting_swi(void);
Xextern __declspec(__nothrow) void __use_no_semihosting_swi(void);
Nextern _ARMABI void __use_no_semihosting(void);
Xextern __declspec(__nothrow) void __use_no_semihosting(void);
N    /*
N     * Referencing either of these symbols will cause a link-time
N     * error if any library functions that use semihosting SWI
N     * calls are also present in the link, i.e. you define it if
N     * you want to make sure you haven't accidentally used any such
N     * SWIs.
N     */
N
N    #ifdef __cplusplus
S        }  /* extern "C" */
S      }  /* namespace std */
N    #endif
N  #endif /* __STDIO_DECLS */
N
N  #if _AEABI_PORTABILITY_LEVEL != 0 && !defined _AEABI_PORTABLE
X  #if _AEABI_PORTABILITY_LEVEL != 0 && !0L
S    #define _AEABI_PORTABLE
N  #endif
N
N  #if defined(__cplusplus) && !defined(__STDIO_NO_EXPORTS)
X  #if 0L && !0L
S    using ::std::size_t;
S    using ::std::fpos_t;
S    using ::std::FILE;
S    using ::std::remove;
S    using ::std::rename;
S    using ::std::tmpfile;
S    using ::std::tmpnam;
S    using ::std::fclose;
S    using ::std::fflush;
S    using ::std::fopen;
S    using ::std::freopen;
S    using ::std::setbuf;
S    using ::std::setvbuf;
S    using ::std::fprintf;
S    using ::std::_fprintf;
S    using ::std::printf;
S    using ::std::_printf;
S    using ::std::sprintf;
S    using ::std::_sprintf;
S    #if !defined(__STRICT_ANSI__) || (defined(__STDC_VERSION__) && 199901L <= __STDC_VERSION__) || (defined(__cplusplus) && 201103L <= __cplusplus)
S      using ::std::snprintf;
S      using ::std::vsnprintf;
S      using ::std::vfscanf;
S      using ::std::vscanf;
S      using ::std::vsscanf;
S    #endif
S    using ::std::_snprintf;
S    using ::std::_vsnprintf;
S#if !defined(__STRICT_ANSI__)
S    using ::std::asprintf;
S    using ::std::vasprintf;
S#endif
S    using ::std::__ARM_asprintf;
S    using ::std::__ARM_vasprintf;
S    using ::std::__ARM_vsnprintf;
S    using ::std::__ARM_snprintf;
S    using ::std::__ARM_vsscanf;
S    using ::std::fscanf;
S    using ::std::_fscanf;
S    using ::std::scanf;
S    using ::std::_scanf;
S    using ::std::sscanf;
S    using ::std::_sscanf;
S    using ::std::_vfscanf;
S    using ::std::_vscanf;
S    using ::std::_vsscanf;
S    using ::std::vprintf;
S    using ::std::_vprintf;
S    using ::std::vfprintf;
S    using ::std::_vfprintf;
S    using ::std::vsprintf;
S    using ::std::_vsprintf;
S    using ::std::fgetc;
S    using ::std::fgets;
S    using ::std::fputc;
S    using ::std::fputs;
S    using ::std::getc;
S    using ::std::getchar;
S    using ::std::gets;
S    using ::std::putc;
S    using ::std::putchar;
S    using ::std::puts;
S    using ::std::ungetc;
S    using ::std::fread;
S    using ::std::__fread_bytes_avail;
S    using ::std::fwrite;
S    using ::std::fgetpos;
S    using ::std::fseek;
S    using ::std::fsetpos;
S    using ::std::ftell;
S    using ::std::rewind;
S    using ::std::clearerr;
S    using ::std::feof;
S    using ::std::ferror;
S    using ::std::perror;
S    using ::std::_fisatty;
S    using ::std::__use_no_semihosting_swi;
S    using ::std::__use_no_semihosting;
N  #endif
N
N#endif /* ndef __stdio_h */
N
N/* end of stdio.h */
N
L 12 "..\..\User\./usart/bsp_usart.h" 2
N#define USART_DEBUG		USART1		//µ÷ÊÔ´òÓ¡ËùÊ¹ÓÃµÄ´®¿Ú×é
N
N/** 
N  * ´®¿Úºê¶¨Òå£¬²»Í¬µÄ´®¿Ú¹ÒÔØµÄ×ÜÏßºÍIO²»Ò»Ñù£¬ÒÆÖ²Ê±ÐèÒªÐÞ¸ÄÕâ¼¸¸öºê
N	* 1-ÐÞ¸Ä×ÜÏßÊ±ÖÓµÄºê£¬uart1¹ÒÔØµ½apb2×ÜÏß£¬ÆäËûuart¹ÒÔØµ½apb1×ÜÏß
N	* 2-ÐÞ¸ÄGPIOµÄºê
N  */
N	
N// ´®¿Ú1-USART1
N#define  DEBUG_USARTx                   USART1
N#define  DEBUG_USART_CLK                RCC_APB2Periph_USART1
N#define  DEBUG_USART_APBxClkCmd         RCC_APB2PeriphClockCmd
N#define  DEBUG_USART_BAUDRATE           115200
N
N// USART GPIO Òý½Åºê¶¨Òå
N#define  DEBUG_USART_GPIO_CLK           (RCC_APB2Periph_GPIOA)
N#define  DEBUG_USART_GPIO_APBxClkCmd    RCC_APB2PeriphClockCmd
N    
N#define  DEBUG_USART_TX_GPIO_PORT         GPIOA   
N#define  DEBUG_USART_TX_GPIO_PIN          GPIO_Pin_9
N#define  DEBUG_USART_RX_GPIO_PORT       GPIOA
N#define  DEBUG_USART_RX_GPIO_PIN        GPIO_Pin_10
N
N#define  DEBUG_USART_IRQ                USART1_IRQn
N#define  DEBUG_USART_IRQHandler         USART1_IRQHandler
N
N
N
Nvoid USART_Config(void);
Nvoid USART_Send2Byre(USART_TypeDef* USARTx, u16 data);
Nvoid Usart3_Init(unsigned int baud);
Nvoid Usart_SendString(USART_TypeDef *USARTx, unsigned char *str, unsigned short len);
Nvoid UsartPrintf(USART_TypeDef *USARTx, char *fmt,...);
N
N
N#endif /* __USART_H */
L 8 "..\..\User\main.c" 2
N#include "./key/bsp_key.h"  
L 1 "..\..\User\./key/bsp_key.h" 1
N#ifndef __KEY_H
N#define	__KEY_H
N
N
N#include "stm32f10x.h"
N
N//  Òý½Å¶¨Òå
N#define    KEY1_GPIO_CLK     RCC_APB2Periph_GPIOA
N#define    KEY1_GPIO_PORT    GPIOA			   
N#define    KEY1_GPIO_PIN		 GPIO_Pin_0
N
N#define    KEY2_GPIO_CLK     RCC_APB2Periph_GPIOC
N#define    KEY2_GPIO_PORT    GPIOC		   
N#define    KEY2_GPIO_PIN		  GPIO_Pin_13
N#define Door_OPEN 	GPIO_WriteBit(GPIOA,GPIO_Pin_12,Bit_RESET)
N#define Door_ClOSE 	GPIO_WriteBit(GPIOA,GPIO_Pin_12,Bit_SET)
N
N
N
N
N /** °´¼ü°´ÏÂ±êÖÃºê
N	*  °´¼ü°´ÏÂÎª¸ßµçÆ½£¬ÉèÖÃ KEY_ON=1£¬ KEY_OFF=0
N	*  Èô°´¼ü°´ÏÂÎªµÍµçÆ½£¬°ÑºêÉèÖÃ³ÉKEY_ON=0 £¬KEY_OFF=1 ¼´¿É
N	*/
N#define KEY_ON	1
N#define KEY_OFF	0
N
Nvoid Key_GPIO_Config(void);
Nuint8_t Key_Scan(GPIO_TypeDef* GPIOx,uint16_t GPIO_Pin);
W "..\..\User\./key/bsp_key.h" 30 6 Deprecated declaration Door_GPIO_Config - give arg types
Nvoid Door_GPIO_Config();
N
N
N#endif /* __KEY_H */
N
L 9 "..\..\User\main.c" 2
N#include "./systick/bsp_SysTick.h"
L 1 "..\..\User\./systick/bsp_SysTick.h" 1
N#ifndef __SYSTICK_H
N#define __SYSTICK_H
N
N#include "stm32f10x.h"
N
N
N#define TASK_ENABLE 0
N#define NumOfTask 3
N
Nvoid SysTick_Init(void);
Nvoid mdelay(unsigned long nTime);
N
Nint get_tick_count(unsigned long *count);
Nvoid TimeStamp_Increment(void);
Nvoid Delay_us(__IO u32 nTime);         // µ¥Î»1us
Xvoid Delay_us(volatile u32 nTime);         
N
N#define Delay_ms(x) Delay_us(1000*x); //µ¥Î»ms
N
N
N#endif /* __SYSTICK_H */
L 10 "..\..\User\main.c" 2
N#include "ff.h"
L 1 "..\..\User\FATFS\ff.h" 1
N/*---------------------------------------------------------------------------/
N/  FatFs - FAT file system module include R0.11a    (C)ChaN, 2015
N/----------------------------------------------------------------------------/
N/ FatFs module is a free software that opened under license policy of
N/ following conditions.
N/
N/ Copyright (C) 2015, ChaN, all right reserved.
N/
N/ 1. Redistributions of source code must retain the above copyright notice,
N/    this condition and the following disclaimer.
N/
N/ This software is provided by the copyright holder and contributors "AS IS"
N/ and any warranties related to this software are DISCLAIMED.
N/ The copyright owner or contributors be NOT LIABLE for any damages caused
N/ by use of this software.
N/---------------------------------------------------------------------------*/
N
N
N#ifndef _FATFS
N#define _FATFS	64180	/* Revision ID */
N
N#ifdef __cplusplus
Sextern "C" {
N#endif
N
N#include "integer.h"	/* Basic integer types */
L 1 "..\..\User\FATFS\integer.h" 1
N/*-------------------------------------------*/
N/* Integer type definitions for FatFs module */
N/*-------------------------------------------*/
N
N#ifndef _FF_INTEGER
N#define _FF_INTEGER
N
N#ifdef _WIN32	/* Development platform */
S
S#include <windows.h>
S#include <tchar.h>
S
N#else			/* Embedded platform */
N
N/* This type MUST be 8-bit */
Ntypedef unsigned char	BYTE;
N
N/* These types MUST be 16-bit */
Ntypedef short			SHORT;
Ntypedef unsigned short	WORD;
Ntypedef unsigned short	WCHAR;
N
N/* These types MUST be 16-bit or 32-bit */
Ntypedef int				INT;
Ntypedef unsigned int	UINT;
N
N/* These types MUST be 32-bit */
Ntypedef long			LONG;
Ntypedef unsigned long	DWORD;
N
N#endif
N
N#endif
L 27 "..\..\User\FATFS\ff.h" 2
N#include "ffconf.h"		/* FatFs configuration options */
L 1 "..\..\User\FATFS\ffconf.h" 1
N/*---------------------------------------------------------------------------/
N/  FatFs - FAT file system module configuration file  R0.11a (C)ChaN, 2015
N/---------------------------------------------------------------------------*/
N
N#define _FFCONF 64180	/* Revision ID */
N
N/*---------------------------------------------------------------------------/
N/ Function Configurations
N/---------------------------------------------------------------------------*/
N
N#define _FS_READONLY	0
N/* This option switches read-only configuration. (0:Read/Write or 1:Read-only)
N/  Read-only configuration removes writing API functions, f_write(), f_sync(),
N/  f_unlink(), f_mkdir(), f_chmod(), f_rename(), f_truncate(), f_getfree()
N/  and optional writing functions as well. */
N
N
N#define _FS_MINIMIZE	0
N/* This option defines minimization level to remove some basic API functions.
N/
N/   0: All basic functions are enabled.
N/   1: f_stat(), f_getfree(), f_unlink(), f_mkdir(), f_chmod(), f_utime(),
N/      f_truncate() and f_rename() function are removed.
N/   2: f_opendir(), f_readdir() and f_closedir() are removed in addition to 1.
N/   3: f_lseek() function is removed in addition to 2. */
N
N
N#define	_USE_STRFUNC	1
N/* This option switches string functions, f_gets(), f_putc(), f_puts() and
N/  f_printf().
N/
N/  0: Disable string functions.
N/  1: Enable without LF-CRLF conversion.
N/  2: Enable with LF-CRLF conversion. */
N
N
N#define _USE_FIND		0
N/* This option switches filtered directory read feature and related functions,
N/  f_findfirst() and f_findnext(). (0:Disable or 1:Enable) */
N
N
N#define	_USE_MKFS		1
N/* This option switches f_mkfs() function. (0:Disable or 1:Enable) */
N
N
N#define	_USE_FASTSEEK	0
N/* This option switches fast seek feature. (0:Disable or 1:Enable) */
N
N
N#define _USE_LABEL		0
N/* This option switches volume label functions, f_getlabel() and f_setlabel().
N/  (0:Disable or 1:Enable) */
N
N
N#define	_USE_FORWARD	0
N/* This option switches f_forward() function. (0:Disable or 1:Enable)
N/  To enable it, also _FS_TINY need to be set to 1. */
N
N
N/*---------------------------------------------------------------------------/
N/ Locale and Namespace Configurations
N/---------------------------------------------------------------------------*/
N
N#define _CODE_PAGE	437
N/* This option specifies the OEM code page to be used on the target system.
N/  Incorrect setting of the code page can cause a file open failure.
N/
N/   1   - ASCII (No extended character. Non-LFN cfg. only)
N/   437 - U.S.
N/   720 - Arabic
N/   737 - Greek
N/   771 - KBL
N/   775 - Baltic
N/   850 - Latin 1
N/   852 - Latin 2
N/   855 - Cyrillic
N/   857 - Turkish
N/   860 - Portuguese
N/   861 - Icelandic
N/   862 - Hebrew
N/   863 - Canadian French
N/   864 - Arabic
N/   865 - Nordic
N/   866 - Russian
N/   869 - Greek 2
N/   932 - Japanese (DBCS)
N/   936 - Simplified Chinese (DBCS)
N/   949 - Korean (DBCS)
N/   950 - Traditional Chinese (DBCS)
N*/
N
N
N#define	_USE_LFN	2
N#define	_MAX_LFN	255
N/* The _USE_LFN option switches the LFN feature.
N/
N/   0: Disable LFN feature. _MAX_LFN has no effect.
N/   1: Enable LFN with static working buffer on the BSS. Always NOT thread-safe.
N/   2: Enable LFN with dynamic working buffer on the STACK.
N/   3: Enable LFN with dynamic working buffer on the HEAP.
N/
N/  When enable the LFN feature, Unicode handling functions (option/unicode.c) must
N/  be added to the project. The LFN working buffer occupies (_MAX_LFN + 1) * 2 bytes.
N/  When use stack for the working buffer, take care on stack overflow. When use heap
N/  memory for the working buffer, memory management functions, ff_memalloc() and
N/  ff_memfree(), must be added to the project. */
N
N
N#define	_LFN_UNICODE	0
N/* This option switches character encoding on the API. (0:ANSI/OEM or 1:Unicode)
N/  To use Unicode string for the path name, enable LFN feature and set _LFN_UNICODE
N/  to 1. This option also affects behavior of string I/O functions. */
N
N
N#define _STRF_ENCODE	3
N/* When _LFN_UNICODE is 1, this option selects the character encoding on the file to
N/  be read/written via string I/O functions, f_gets(), f_putc(), f_puts and f_printf().
N/
N/  0: ANSI/OEM
N/  1: UTF-16LE
N/  2: UTF-16BE
N/  3: UTF-8
N/
N/  When _LFN_UNICODE is 0, this option has no effect. */
N
N
N#define _FS_RPATH	0
N/* This option configures relative path feature.
N/
N/   0: Disable relative path feature and remove related functions.
N/   1: Enable relative path feature. f_chdir() and f_chdrive() are available.
N/   2: f_getcwd() function is available in addition to 1.
N/
N/  Note that directory items read via f_readdir() are affected by this option. */
N
N
N/*---------------------------------------------------------------------------/
N/ Drive/Volume Configurations
N/---------------------------------------------------------------------------*/
N
N#define _VOLUMES	2
N/* Number of volumes (logical drives) to be used. */
N
N
N#define _STR_VOLUME_ID	0
N#define _VOLUME_STRS	"RAM","NAND","CF","SD1","SD2","USB1","USB2","USB3"
N/* _STR_VOLUME_ID option switches string volume ID feature.
N/  When _STR_VOLUME_ID is set to 1, also pre-defined strings can be used as drive
N/  number in the path name. _VOLUME_STRS defines the drive ID strings for each
N/  logical drives. Number of items must be equal to _VOLUMES. Valid characters for
N/  the drive ID strings are: A-Z and 0-9. */
N
N
N#define	_MULTI_PARTITION	0
N/* This option switches multi-partition feature. By default (0), each logical drive
N/  number is bound to the same physical drive number and only an FAT volume found on
N/  the physical drive will be mounted. When multi-partition feature is enabled (1),
N/  each logical drive number is bound to arbitrary physical drive and partition
N/  listed in the VolToPart[]. Also f_fdisk() funciton will be available. */
N
N
N#define	_MIN_SS		512
N#define	_MAX_SS		4096
N/* These options configure the range of sector size to be supported. (512, 1024,
N/  2048 or 4096) Always set both 512 for most systems, all type of memory cards and
N/  harddisk. But a larger value may be required for on-board flash memory and some
N/  type of optical media. When _MAX_SS is larger than _MIN_SS, FatFs is configured
N/  to variable sector size and GET_SECTOR_SIZE command must be implemented to the
N/  disk_ioctl() function. */
N
N
N#define	_USE_TRIM	0
N/* This option switches ATA-TRIM feature. (0:Disable or 1:Enable)
N/  To enable Trim feature, also CTRL_TRIM command should be implemented to the
N/  disk_ioctl() function. */
N
N
N#define _FS_NOFSINFO	0
N/* If you need to know correct free space on the FAT32 volume, set bit 0 of this
N/  option, and f_getfree() function at first time after volume mount will force
N/  a full FAT scan. Bit 1 controls the use of last allocated cluster number.
N/
N/  bit0=0: Use free cluster count in the FSINFO if available.
N/  bit0=1: Do not trust free cluster count in the FSINFO.
N/  bit1=0: Use last allocated cluster number in the FSINFO if available.
N/  bit1=1: Do not trust last allocated cluster number in the FSINFO.
N*/
N
N
N
N/*---------------------------------------------------------------------------/
N/ System Configurations
N/---------------------------------------------------------------------------*/
N
N#define	_FS_TINY	0
N/* This option switches tiny buffer configuration. (0:Normal or 1:Tiny)
N/  At the tiny configuration, size of the file object (FIL) is reduced _MAX_SS
N/  bytes. Instead of private sector buffer eliminated from the file object,
N/  common sector buffer in the file system object (FATFS) is used for the file
N/  data transfer. */
N
N
N#define _FS_NORTC	0
N#define _NORTC_MON	1
N#define _NORTC_MDAY	1
N#define _NORTC_YEAR	2015
N/* The _FS_NORTC option switches timestamp feature. If the system does not have
N/  an RTC function or valid timestamp is not needed, set _FS_NORTC to 1 to disable
N/  the timestamp feature. All objects modified by FatFs will have a fixed timestamp
N/  defined by _NORTC_MON, _NORTC_MDAY and _NORTC_YEAR.
N/  When timestamp feature is enabled (_FS_NORTC == 0), get_fattime() function need
N/  to be added to the project to read current time form RTC. _NORTC_MON,
N/  _NORTC_MDAY and _NORTC_YEAR have no effect. 
N/  These options have no effect at read-only configuration (_FS_READONLY == 1). */
N
N
N#define	_FS_LOCK	0
N/* The _FS_LOCK option switches file lock feature to control duplicated file open
N/  and illegal operation to open objects. This option must be 0 when _FS_READONLY
N/  is 1.
N/
N/  0:  Disable file lock feature. To avoid volume corruption, application program
N/      should avoid illegal open, remove and rename to the open objects.
N/  >0: Enable file lock feature. The value defines how many files/sub-directories
N/      can be opened simultaneously under file lock control. Note that the file
N/      lock feature is independent of re-entrancy. */
N
N
N#define _FS_REENTRANT	0
N#define _FS_TIMEOUT		1000
N#define	_SYNC_t			HANDLE
N/* The _FS_REENTRANT option switches the re-entrancy (thread safe) of the FatFs
N/  module itself. Note that regardless of this option, file access to different
N/  volume is always re-entrant and volume control functions, f_mount(), f_mkfs()
N/  and f_fdisk() function, are always not re-entrant. Only file/directory access
N/  to the same volume is under control of this feature.
N/
N/   0: Disable re-entrancy. _FS_TIMEOUT and _SYNC_t have no effect.
N/   1: Enable re-entrancy. Also user provided synchronization handlers,
N/      ff_req_grant(), ff_rel_grant(), ff_del_syncobj() and ff_cre_syncobj()
N/      function, must be added to the project. Samples are available in
N/      option/syscall.c.
N/
N/  The _FS_TIMEOUT defines timeout period in unit of time tick.
N/  The _SYNC_t defines O/S dependent sync object type. e.g. HANDLE, ID, OS_EVENT*,
N/  SemaphoreHandle_t and etc.. A header file for O/S definitions needs to be
N/  included somewhere in the scope of ff.c. */
N
N
N#define _WORD_ACCESS	0
N/* The _WORD_ACCESS option is an only platform dependent option. It defines
N/  which access method is used to the word data on the FAT volume.
N/
N/   0: Byte-by-byte access. Always compatible with all platforms.
N/   1: Word access. Do not choose this unless under both the following conditions.
N/
N/  * Address misaligned memory access is always allowed to ALL instructions.
N/  * Byte order on the memory is little-endian.
N/
N/  If it is the case, _WORD_ACCESS can also be set to 1 to reduce code size.
N/  Following table shows allowable settings of some type of processors.
N/
N/  ARM7TDMI   0   *2          ColdFire   0    *1         V850E      0    *2
N/  Cortex-M3  0   *3          Z80        0/1             V850ES     0/1
N/  Cortex-M0  0   *2          x86        0/1             TLCS-870   0/1
N/  AVR        0/1             RX600(LE)  0/1             TLCS-900   0/1
N/  AVR32      0   *1          RL78       0    *2         R32C       0    *2
N/  PIC18      0/1             SH-2       0    *1         M16C       0/1
N/  PIC24      0   *2          H8S        0    *1         MSP430     0    *2
N/  PIC32      0   *1          H8/300H    0    *1         8051       0/1
N/
N/  *1:Big-endian.
N/  *2:Unaligned memory access is not supported.
N/  *3:Some compilers generate LDM/STM for mem_cpy function.
N*/
N
L 28 "..\..\User\FATFS\ff.h" 2
N#if _FATFS != _FFCONF
X#if 64180 != 64180
S#error Wrong configuration file (ffconf.h).
N#endif
N
N
N
N/* Definitions of volume management */
N
N#if _MULTI_PARTITION		/* Multiple partition configuration */
X#if 0		 
Stypedef struct {
S	BYTE pd;	/* Physical drive number */
S	BYTE pt;	/* Partition: 0:Auto detect, 1-4:Forced partition) */
S} PARTITION;
Sextern PARTITION VolToPart[];	/* Volume - Partition resolution table */
S#define LD2PD(vol) (VolToPart[vol].pd)	/* Get physical drive number */
S#define LD2PT(vol) (VolToPart[vol].pt)	/* Get partition index */
S
N#else							/* Single partition configuration */
N#define LD2PD(vol) (BYTE)(vol)	/* Each logical drive is bound to the same physical drive number */
N#define LD2PT(vol) 0			/* Find first valid partition or in SFD */
N
N#endif
N
N
N
N/* Type of path name strings on FatFs API */
N
N#if _LFN_UNICODE			/* Unicode string */
X#if 0			 
S#if !_USE_LFN
S#error _LFN_UNICODE must be 0 at non-LFN cfg.
S#endif
S#ifndef _INC_TCHAR
Stypedef WCHAR TCHAR;
S#define _T(x) L ## x
S#define _TEXT(x) L ## x
S#endif
S
N#else						/* ANSI/OEM string */
N#ifndef _INC_TCHAR
Ntypedef char TCHAR;
N#define _T(x) x
N#define _TEXT(x) x
N#endif
N
N#endif
N
N
N
N/* File system object structure (FATFS) */
N
Ntypedef struct {
N	BYTE	fs_type;		/* FAT sub-type (0:Not mounted) */
N	BYTE	drv;			/* Physical drive number */
N	BYTE	csize;			/* Sectors per cluster (1,2,4...128) */
N	BYTE	n_fats;			/* Number of FAT copies (1 or 2) */
N	BYTE	wflag;			/* win[] flag (b0:dirty) */
N	BYTE	fsi_flag;		/* FSINFO flags (b7:disabled, b0:dirty) */
N	WORD	id;				/* File system mount ID */
N	WORD	n_rootdir;		/* Number of root directory entries (FAT12/16) */
N#if _MAX_SS != _MIN_SS
X#if 4096 != 512
N	WORD	ssize;			/* Bytes per sector (512, 1024, 2048 or 4096) */
N#endif
N#if _FS_REENTRANT
X#if 0
S	_SYNC_t	sobj;			/* Identifier of sync object */
N#endif
N#if !_FS_READONLY
X#if !0
N	DWORD	last_clust;		/* Last allocated cluster */
N	DWORD	free_clust;		/* Number of free clusters */
N#endif
N#if _FS_RPATH
X#if 0
S	DWORD	cdir;			/* Current directory start cluster (0:root) */
N#endif
N	DWORD	n_fatent;		/* Number of FAT entries, = number of clusters + 2 */
N	DWORD	fsize;			/* Sectors per FAT */
N	DWORD	volbase;		/* Volume start sector */
N	DWORD	fatbase;		/* FAT start sector */
N	DWORD	dirbase;		/* Root directory start sector (FAT32:Cluster#) */
N	DWORD	database;		/* Data start sector */
N	DWORD	winsect;		/* Current sector appearing in the win[] */
N	BYTE	win[_MAX_SS];	/* Disk access window for Directory, FAT (and file data at tiny cfg) */
X	BYTE	win[4096];	 
N} FATFS;
N
N
N
N/* File object structure (FIL) */
N
Ntypedef struct {
N	FATFS*	fs;				/* Pointer to the related file system object (**do not change order**) */
N	WORD	id;				/* Owner file system mount ID (**do not change order**) */
N	BYTE	flag;			/* Status flags */
N	BYTE	err;			/* Abort flag (error code) */
N	DWORD	fptr;			/* File read/write pointer (Zeroed on file open) */
N	DWORD	fsize;			/* File size */
N	DWORD	sclust;			/* File start cluster (0:no cluster chain, always 0 when fsize is 0) */
N	DWORD	clust;			/* Current cluster of fpter (not valid when fprt is 0) */
N	DWORD	dsect;			/* Sector number appearing in buf[] (0:invalid) */
N#if !_FS_READONLY
X#if !0
N	DWORD	dir_sect;		/* Sector number containing the directory entry */
N	BYTE*	dir_ptr;		/* Pointer to the directory entry in the win[] */
N#endif
N#if _USE_FASTSEEK
X#if 0
S	DWORD*	cltbl;			/* Pointer to the cluster link map table (Nulled on file open) */
N#endif
N#if _FS_LOCK
X#if 0
S	UINT	lockid;			/* File lock ID origin from 1 (index of file semaphore table Files[]) */
N#endif
N#if !_FS_TINY
X#if !0
N	BYTE	buf[_MAX_SS];	/* File private data read/write window */
X	BYTE	buf[4096];	 
N#endif
N} FIL;
N
N
N
N/* Directory object structure (DIR) */
N
Ntypedef struct {
N	FATFS*	fs;				/* Pointer to the owner file system object (**do not change order**) */
N	WORD	id;				/* Owner file system mount ID (**do not change order**) */
N	WORD	index;			/* Current read/write index number */
N	DWORD	sclust;			/* Table start cluster (0:Root dir) */
N	DWORD	clust;			/* Current cluster */
N	DWORD	sect;			/* Current sector */
N	BYTE*	dir;			/* Pointer to the current SFN entry in the win[] */
N	BYTE*	fn;				/* Pointer to the SFN (in/out) {file[8],ext[3],status[1]} */
N#if _FS_LOCK
X#if 0
S	UINT	lockid;			/* File lock ID (index of file semaphore table Files[]) */
N#endif
N#if _USE_LFN
X#if 2
N	WCHAR*	lfn;			/* Pointer to the LFN working buffer */
N	WORD	lfn_idx;		/* Last matched LFN index number (0xFFFF:No LFN) */
N#endif
N#if _USE_FIND
X#if 0
S	const TCHAR*	pat;	/* Pointer to the name matching pattern */
N#endif
N} DIR;
N
N
N
N/* File information structure (FILINFO) */
N
Ntypedef struct {
N	DWORD	fsize;			/* File size */
N	WORD	fdate;			/* Last modified date */
N	WORD	ftime;			/* Last modified time */
N	BYTE	fattrib;		/* Attribute */
N	TCHAR	fname[13];		/* Short file name (8.3 format) */
N#if _USE_LFN
X#if 2
N	TCHAR*	lfname;			/* Pointer to the LFN buffer */
N	UINT 	lfsize;			/* Size of LFN buffer in TCHAR */
N#endif
N} FILINFO;
N
N
N
N/* File function return code (FRESULT) */
N
Ntypedef enum {
N	FR_OK = 0,				/* (0) Succeeded */
N	FR_DISK_ERR,			/* (1) A hard error occurred in the low level disk I/O layer */
N	FR_INT_ERR,				/* (2) Assertion failed */
N	FR_NOT_READY,			/* (3) The physical drive cannot work */
N	FR_NO_FILE,				/* (4) Could not find the file */
N	FR_NO_PATH,				/* (5) Could not find the path */
N	FR_INVALID_NAME,		/* (6) The path name format is invalid */
N	FR_DENIED,				/* (7) Access denied due to prohibited access or directory full */
N	FR_EXIST,				/* (8) Access denied due to prohibited access */
N	FR_INVALID_OBJECT,		/* (9) The file/directory object is invalid */
N	FR_WRITE_PROTECTED,		/* (10) The physical drive is write protected */
N	FR_INVALID_DRIVE,		/* (11) The logical drive number is invalid */
N	FR_NOT_ENABLED,			/* (12) The volume has no work area */
N	FR_NO_FILESYSTEM,		/* (13) There is no valid FAT volume */
N	FR_MKFS_ABORTED,		/* (14) The f_mkfs() aborted due to any parameter error */
N	FR_TIMEOUT,				/* (15) Could not get a grant to access the volume within defined period */
N	FR_LOCKED,				/* (16) The operation is rejected according to the file sharing policy */
N	FR_NOT_ENOUGH_CORE,		/* (17) LFN working buffer could not be allocated */
N	FR_TOO_MANY_OPEN_FILES,	/* (18) Number of open files > _FS_LOCK */
N	FR_INVALID_PARAMETER	/* (19) Given parameter is invalid */
N} FRESULT;
N
N
N
N/*--------------------------------------------------------------*/
N/* FatFs module application interface                           */
N
NFRESULT f_open (FIL* fp, const TCHAR* path, BYTE mode);				/* Open or create a file */
NFRESULT f_close (FIL* fp);											/* Close an open file object */
NFRESULT f_read (FIL* fp, void* buff, UINT btr, UINT* br);			/* Read data from a file */
NFRESULT f_write (FIL* fp, const void* buff, UINT btw, UINT* bw);	/* Write data to a file */
NFRESULT f_forward (FIL* fp, UINT(*func)(const BYTE*,UINT), UINT btf, UINT* bf);	/* Forward data to the stream */
NFRESULT f_lseek (FIL* fp, DWORD ofs);								/* Move file pointer of a file object */
NFRESULT f_truncate (FIL* fp);										/* Truncate file */
NFRESULT f_sync (FIL* fp);											/* Flush cached data of a writing file */
NFRESULT f_opendir (DIR* dp, const TCHAR* path);						/* Open a directory */
NFRESULT f_closedir (DIR* dp);										/* Close an open directory */
NFRESULT f_readdir (DIR* dp, FILINFO* fno);							/* Read a directory item */
NFRESULT f_findfirst (DIR* dp, FILINFO* fno, const TCHAR* path, const TCHAR* pattern);	/* Find first file */
NFRESULT f_findnext (DIR* dp, FILINFO* fno);							/* Find next file */
NFRESULT f_mkdir (const TCHAR* path);								/* Create a sub directory */
NFRESULT f_unlink (const TCHAR* path);								/* Delete an existing file or directory */
NFRESULT f_rename (const TCHAR* path_old, const TCHAR* path_new);	/* Rename/Move a file or directory */
NFRESULT f_stat (const TCHAR* path, FILINFO* fno);					/* Get file status */
NFRESULT f_chmod (const TCHAR* path, BYTE attr, BYTE mask);			/* Change attribute of the file/dir */
NFRESULT f_utime (const TCHAR* path, const FILINFO* fno);			/* Change times-tamp of the file/dir */
NFRESULT f_chdir (const TCHAR* path);								/* Change current directory */
NFRESULT f_chdrive (const TCHAR* path);								/* Change current drive */
NFRESULT f_getcwd (TCHAR* buff, UINT len);							/* Get current directory */
NFRESULT f_getfree (const TCHAR* path, DWORD* nclst, FATFS** fatfs);	/* Get number of free clusters on the drive */
NFRESULT f_getlabel (const TCHAR* path, TCHAR* label, DWORD* vsn);	/* Get volume label */
NFRESULT f_setlabel (const TCHAR* label);							/* Set volume label */
NFRESULT f_mount (FATFS* fs, const TCHAR* path, BYTE opt);			/* Mount/Unmount a logical drive */
NFRESULT f_mkfs (const TCHAR* path, BYTE sfd, UINT au);				/* Create a file system on the volume */
NFRESULT f_fdisk (BYTE pdrv, const DWORD szt[], void* work);			/* Divide a physical drive into some partitions */
Nint f_putc (TCHAR c, FIL* fp);										/* Put a character to the file */
Nint f_puts (const TCHAR* str, FIL* cp);								/* Put a string to the file */
Nint f_printf (FIL* fp, const TCHAR* str, ...);						/* Put a formatted string to the file */
NTCHAR* f_gets (TCHAR* buff, int len, FIL* fp);						/* Get a string from the file */
Nvoid Fatfs_Init(void);                                         /*FAtFs¹ÒÔØ*/
N
N#define f_eof(fp) ((int)((fp)->fptr == (fp)->fsize))
N#define f_error(fp) ((fp)->err)
N#define f_tell(fp) ((fp)->fptr)
N#define f_size(fp) ((fp)->fsize)
N#define f_rewind(fp) f_lseek((fp), 0)
N#define f_rewinddir(dp) f_readdir((dp), 0)
N
N#ifndef EOF
S#define EOF (-1)
N#endif
N
N
N
N
N/*--------------------------------------------------------------*/
N/* Additional user defined functions                            */
N
N/* RTC function */
N#if !_FS_READONLY && !_FS_NORTC
X#if !0 && !0
NDWORD get_fattime (void);
N#endif
N
N/* Unicode support functions */
N#if _USE_LFN							/* Unicode - OEM code conversion */
X#if 2							 
NWCHAR ff_convert (WCHAR chr, UINT dir);	/* OEM-Unicode bidirectional conversion */
NWCHAR ff_wtoupper (WCHAR chr);			/* Unicode upper-case conversion */
N#if _USE_LFN == 3						/* Memory functions */
X#if 2 == 3						 
Svoid* ff_memalloc (UINT msize);			/* Allocate memory block */
Svoid ff_memfree (void* mblock);			/* Free memory block */
N#endif
N#endif
N
N/* Sync functions */
N#if _FS_REENTRANT
X#if 0
Sint ff_cre_syncobj (BYTE vol, _SYNC_t* sobj);	/* Create a sync object */
Sint ff_req_grant (_SYNC_t sobj);				/* Lock sync object */
Svoid ff_rel_grant (_SYNC_t sobj);				/* Unlock sync object */
Sint ff_del_syncobj (_SYNC_t sobj);				/* Delete a sync object */
N#endif
N
N
N
N
N/*--------------------------------------------------------------*/
N/* Flags and offset address                                     */
N
N
N/* File access control and file status flags (FIL.flag) */
N
N#define	FA_READ				0x01
N#define	FA_OPEN_EXISTING	0x00
N
N#if !_FS_READONLY
X#if !0
N#define	FA_WRITE			0x02
N#define	FA_CREATE_NEW		0x04
N#define	FA_CREATE_ALWAYS	0x08
N#define	FA_OPEN_ALWAYS		0x10
N#define FA__WRITTEN			0x20
N#define FA__DIRTY			0x40
N#endif
N
N
N/* FAT sub type (FATFS.fs_type) */
N
N#define FS_FAT12	1
N#define FS_FAT16	2
N#define FS_FAT32	3
N
N
N/* File attribute bits for directory entry */
N
N#define	AM_RDO	0x01	/* Read only */
N#define	AM_HID	0x02	/* Hidden */
N#define	AM_SYS	0x04	/* System */
N#define	AM_VOL	0x08	/* Volume label */
N#define AM_LFN	0x0F	/* LFN entry */
N#define AM_DIR	0x10	/* Directory */
N#define AM_ARC	0x20	/* Archive */
N#define AM_MASK	0x3F	/* Mask of defined bits */
N
N
N/* Fast seek feature */
N#define CREATE_LINKMAP	0xFFFFFFFF
N
N
N
N/*--------------------------------*/
N/* Multi-byte word access macros  */
N
N#if _WORD_ACCESS == 1	/* Enable word access to the FAT structure */
X#if 0 == 1	 
S#define	LD_WORD(ptr)		(WORD)(*(WORD*)(BYTE*)(ptr))
S#define	LD_DWORD(ptr)		(DWORD)(*(DWORD*)(BYTE*)(ptr))
S#define	ST_WORD(ptr,val)	*(WORD*)(BYTE*)(ptr)=(WORD)(val)
S#define	ST_DWORD(ptr,val)	*(DWORD*)(BYTE*)(ptr)=(DWORD)(val)
N#else					/* Use byte-by-byte access to the FAT structure */
N#define	LD_WORD(ptr)		(WORD)(((WORD)*((BYTE*)(ptr)+1)<<8)|(WORD)*(BYTE*)(ptr))
N#define	LD_DWORD(ptr)		(DWORD)(((DWORD)*((BYTE*)(ptr)+3)<<24)|((DWORD)*((BYTE*)(ptr)+2)<<16)|((WORD)*((BYTE*)(ptr)+1)<<8)|*(BYTE*)(ptr))
N#define	ST_WORD(ptr,val)	*(BYTE*)(ptr)=(BYTE)(val); *((BYTE*)(ptr)+1)=(BYTE)((WORD)(val)>>8)
N#define	ST_DWORD(ptr,val)	*(BYTE*)(ptr)=(BYTE)(val); *((BYTE*)(ptr)+1)=(BYTE)((WORD)(val)>>8); *((BYTE*)(ptr)+2)=(BYTE)((DWORD)(val)>>16); *((BYTE*)(ptr)+3)=(BYTE)((DWORD)(val)>>24)
N#endif
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif /* _FATFS */
L 11 "..\..\User\main.c" 2
N#include "encode.h"
L 1 "..\..\User\JPEGENCODE\encode.h" 1
N#ifndef _JENCODE_H
N#define _JENCODE_H
N#include <stm32f10x.h>
N#include "ff.h"
N//////////////////////////////////////////ÓÃ»§ÅäÖÃÇø//////////////////////////////////
N#define JPG_USE_MALLOC		1 	//¶¨ÒåÊÇ·ñÊ¹ÓÃmalloc,ÕâÀïÎÒÃÇÑ¡ÔñÊ¹ÓÃmalloc	    
N//////////////////////////////////////////////END/////////////////////////////////////
N#define JPEG_QUALITY 0.8f
N#define DCTSIZE   8
N#define DCTSIZE2 64
N#define MAX_COMPONENT  4
N#define NUM_HUFF_TBLS  2  //huffman±íµÄÊýÁ¿,»ù±¾ÏµÍ³ÖÐÎª2
N#define NUM_QUANT_TBLS 4  //Á¿»¯±íµÄÊýÁ¿,Ä¬ÈÏÎª4,µ«ÎÒÃÇÊ¹ÓÃ2
N#define MAX_BLOCK_IN_MCU 10 //ISO¹æ¶¨µÄ
N#define DC_HUFF_TBL 0     
N#define AC_HUFF_TBL 1//ÕâÁ½¸ö±äÁ¿ÓÃÓÚ±íÑ¡ÔñºÍÆÀ¹À
N#define BGR565toRGB565(BGR) ((BGR&0x1f)<<11)+(BGR&0x7e0)+((BGR&0xF800)>>11)
N#define SET_COMP(TARGET,ID,H,V,Tq,Td,Ta)\
N(TARGET.comp_id=(ID),\
NTARGET.comp_index=(ID),\
NTARGET.h_factor=(H),\
NTARGET.v_factor=(V),\
NTARGET.quant_tbl_no=(Tq),\
NTARGET.dc_tbl_no=(Td),\
NTARGET.ac_tbl_no=(Ta))
X#define SET_COMP(TARGET,ID,H,V,Tq,Td,Ta)(TARGET.comp_id=(ID),TARGET.comp_index=(ID),TARGET.h_factor=(H),TARGET.v_factor=(V),TARGET.quant_tbl_no=(Tq),TARGET.dc_tbl_no=(Td),TARGET.ac_tbl_no=(Ta))
N
Ntypedef short  DCTVAL;
Ntypedef u8 JSAMPLE;
Ntypedef DCTVAL DCTBLOCK[DCTSIZE2];
Xtypedef DCTVAL DCTBLOCK[64];
N
Ntypedef struct {
N  	DCTBLOCK quantval;
N} JQUANT_TBL;
N
Ntypedef struct {
N  	u8 bits[17];
N  	u8 huffval[256]; 
N  	u16 esize[256];
N  	u16 ecode[256];
N} JHUFF_TBL;
N//É«²Ê¿Õ¼äÁÐ±í
Ntypedef enum {
N  	JCS_UNKNOWN,
N  	JCS_GRAY,
N  	JCS_RGB,
N  	JCS_CMYK,
N  	JCS_YCbCr,
N  	JCS_YUV
N} JC_COLORSPACE;
N//×´Ì¬ÁÐ±í
Ntypedef enum {
N  	JC_CREATING,
N  	JC_SETTING,
N  	JC_START,
N  	JC_FINISH,
N  	JC_DESTORING
N} JC_STATE;
N//±êÖ¾×Ö½Ú
Ntypedef enum {
N  	SOF0=0xC0,//basic dct 
N  	SOF1=0xC1,//extend dct
N  	DHT =0xC4,//¶¨Òåhuffman±í
N  	SOI =0xD8,//Ö¡¿ªÊ¼
N  	EOI =0xD9,//Ö¡½áÊø
N  	SOS =0xDA,//É¨Ãè¿ªÊ¼
N  	DQT =0xDB,//¶¨ÒåÁ¿»¯±í
N  	COM =0xDE //common
N} MARKER;
N//Ôª¼þ½á¹¹Ìå
Ntypedef struct {
N	u8 comp_id;//Ôª¼þID
N	u8 comp_index;//Ôª¼þÔÚJPEGÎÄ¼þÐÅÏ¢ÖÐµÄÎ»ÖÃ
N	int h_factor;
N	int v_factor;
N	int quant_tbl_no;//±íºÅÑ¡Ôñ
N	int dc_tbl_no;//Ö±Á÷·ÖÁ¿¹þ·òÂü±íÑ¡Ôñ
N	int ac_tbl_no;//½»Á÷·ÖÁ¿¹þ·òÂü±íÑ¡Ôñ
N	int num_dct_table;
N	DCTBLOCK *dct_table;
N	DCTVAL preval;
N} jpeg_component_info;
N//Ñ¹ËõÎÄ¼þÐÅÏ¢½á¹¹Ìå
Ntypedef struct {
N  	int image_width;  
N  	int image_height;
N  	char *output; //JPEGÊý¾ÝÊä³öÖ¸Õë
N  	int precision;//²ÉÑù¾«¶È,Ä¬ÈÏÎª8
N  	float quality;
N  	JC_COLORSPACE in_color_space;
N  	int num_comp;//ÑÕÉ«Ôª¼þÊý,Ä¬ÈÏÎª3(YCrCb²ÊÉ«Í¼)
N  	jpeg_component_info comp[MAX_COMPONENT];//JPEGÔª¼þÐÅÏ¢
X  	jpeg_component_info comp[4];
N  	int mcu_per_row;//ºáÏòMCUµ¥ÔªÊý
N  	int mcu_rows;   //Ã¿ÐÐMCUµ¥ÔªÊý
N  	int block_in_mcu;//Ã¿¸öMCUµ¥ÔªµÄ¿éÊý 
N  	int mcu_width;//MCUµ¥ÔªË®Æ½ÏñËØ
N  	int mcu_height; //MCUµ¥Ôª´¹Ö±ÏñËØ
N  	int mcu_blocks; //MCUµ¥ÔªÃæ»ý 
N  	int max_h_factor;
N  	int max_v_factor; 
N  	JHUFF_TBL *dc_huff_table[NUM_HUFF_TBLS];//Ö±Á÷Huffman±í
X  	JHUFF_TBL *dc_huff_table[2];
N  	JHUFF_TBL *ac_huff_table[NUM_HUFF_TBLS];//½»Á÷Huffman±í  
X  	JHUFF_TBL *ac_huff_table[2];
N  	JQUANT_TBL *quant_table[NUM_QUANT_TBLS];//Á¿»¯±í
X  	JQUANT_TBL *quant_table[4];
N    JSAMPLE *inbuf;//ÑÕÉ«×ª»»,ÐÐÉ¨Ãè»º³åÇø
N  	int inbuf_width;  //»º³å¿í
N  	int inbuf_height; //»º³å¸ß
N  	int inbuf_size;   //»º³åÇø´óÐ¡,²»µÈÍ¬ÓÚ»º³å¿í*»º³å¸ß
N  	JC_STATE state;//×´Ì¬±äÁ¿
N  	int  next_line; 
N		FIL *fileW;//ÎÄ¼þ/////////////ÎÄ¼þ///////////ÎÄ¼þ///////////ÎÄ¼þ///////////ÎÄ¼þ///////////ÎÄ¼þ///////////ÎÄ¼þ//////////
N} jpeg_compress_info;
N
Ntypedef u8 JSAMPLE;
N
Nunion buffer_tag 
N{
N  	u32 all;
N  	u8  c[4];
N};
N
Nstatic const u8 jfcode[]= 
N{
N	0xFF, 0xE0, 0x00, 0x10, 0x4A, 0x46, 0x49, 0x46, 0x00, 
N	0x01, 0x01, 0x00, 0x00, 0x01, 0x00, 0x01, 0x00, 0x00
N};
Nstatic const u16 std_luminance_quant_tbl[DCTSIZE2]=
Xstatic const u16 std_luminance_quant_tbl[64]=
N{
N	16,  11,  10,  16,  24,  40,  51,  61,
N	12,  12,  14,  19,  26,  58,  60,  55,
N	14,  13,  16,  24,  40,  57,  69,  56,
N	14,  17,  22,  29,  51,  87,  80,  62,
N	18,  22,  37,  56,  68, 109, 103,  77,
N	24,  35,  55,  64,  81, 104, 113,  92,
N	49,  64,  78,  87, 103, 121, 120, 101,
N	72,  92,  95,  98, 112, 100, 103,  99
N};///////±ê×¼ÁÁ¶ÈÁ¿»¯±í
Nstatic const u16 std_chrominance_quant_tbl[DCTSIZE2]=
Xstatic const u16 std_chrominance_quant_tbl[64]=
N{
N	17,  18,  24,  47,  99,  99,  99,  99,
N	18,  21,  26,  66,  99,  99,  99,  99,
N	24,  26,  56,  99,  99,  99,  99,  99,
N	47,  66,  99,  99,  99,  99,  99,  99,
N	99,  99,  99,  99,  99,  99,  99,  99,
N	99,  99,  99,  99,  99,  99,  99,  99,
N	99,  99,  99,  99,  99,  99,  99,  99,
N	99,  99,  99,  99,  99,  99,  99,  99
N};//±ê×¼É«²îÁ¿»¯±í
Nstatic const char zz_order[DCTSIZE2]= 
Xstatic const char zz_order[64]= 
N{
N	 0,  1,  5,  6, 14, 15, 27, 28,
N	 2,  4,  7, 13, 16, 26, 29, 42,
N	 3,  8, 12, 17, 25, 30, 41, 43,
N	 9, 11, 18, 24, 31, 40, 44, 53,
N	10, 19, 23, 32, 39, 45, 52, 54,
N	20, 22, 33, 38, 46, 51, 55, 60,
N	21, 34, 37, 47, 50, 56, 59, 61,
N	35, 36, 48, 49, 57, 58, 62, 63
N};///////zÐÎ±í
Nstatic const u8 bits_dc_luminance[17]={ 0, 0, 1, 5, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0 };
Nstatic const u8 val_dc_luminance[]={ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11 }; 
Nstatic const u8 bits_dc_chrominance[17]={ 0, 0, 3, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0 };
Nstatic const u8 val_dc_chrominance[]={ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11 };  
Nstatic const u8 bits_ac_luminance[17]={ 0, 0, 2, 1, 3, 3, 2, 4, 3, 5, 5, 4, 4, 0, 0, 1, 0x7d };
Nstatic const u8 bits_ac_chrominance[17]={ 0, 0, 2, 1, 2, 4, 4, 3, 4, 7, 5, 4, 4, 0, 1, 2, 0x77 };
Nstatic const u8 val_ac_luminance[]=
N{ 
N	0x01, 0x02, 0x03, 0x00, 0x04, 0x11, 0x05, 0x12,
N	0x21, 0x31, 0x41, 0x06, 0x13, 0x51, 0x61, 0x07,
N	0x22, 0x71, 0x14, 0x32, 0x81, 0x91, 0xa1, 0x08,
N	0x23, 0x42, 0xb1, 0xc1, 0x15, 0x52, 0xd1, 0xf0,
N	0x24, 0x33, 0x62, 0x72, 0x82, 0x09, 0x0a, 0x16,
N	0x17, 0x18, 0x19, 0x1a, 0x25, 0x26, 0x27, 0x28,
N	0x29, 0x2a, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39,
N	0x3a, 0x43, 0x44, 0x45, 0x46, 0x47, 0x48, 0x49,
N	0x4a, 0x53, 0x54, 0x55, 0x56, 0x57, 0x58, 0x59,
N	0x5a, 0x63, 0x64, 0x65, 0x66, 0x67, 0x68, 0x69,
N	0x6a, 0x73, 0x74, 0x75, 0x76, 0x77, 0x78, 0x79,
N	0x7a, 0x83, 0x84, 0x85, 0x86, 0x87, 0x88, 0x89,
N	0x8a, 0x92, 0x93, 0x94, 0x95, 0x96, 0x97, 0x98,
N	0x99, 0x9a, 0xa2, 0xa3, 0xa4, 0xa5, 0xa6, 0xa7,
N	0xa8, 0xa9, 0xaa, 0xb2, 0xb3, 0xb4, 0xb5, 0xb6,
N	0xb7, 0xb8, 0xb9, 0xba, 0xc2, 0xc3, 0xc4, 0xc5,
N	0xc6, 0xc7, 0xc8, 0xc9, 0xca, 0xd2, 0xd3, 0xd4,
N	0xd5, 0xd6, 0xd7, 0xd8, 0xd9, 0xda, 0xe1, 0xe2,
N	0xe3, 0xe4, 0xe5, 0xe6, 0xe7, 0xe8, 0xe9, 0xea,
N	0xf1, 0xf2, 0xf3, 0xf4, 0xf5, 0xf6, 0xf7, 0xf8,
N	0xf9, 0xfa 
N};  
Nstatic const u8 val_ac_chrominance[]=
N{ 
N	0x00, 0x01, 0x02, 0x03, 0x11, 0x04, 0x05, 0x21,
N	0x31, 0x06, 0x12, 0x41, 0x51, 0x07, 0x61, 0x71,
N	0x13, 0x22, 0x32, 0x81, 0x08, 0x14, 0x42, 0x91,
N	0xa1, 0xb1, 0xc1, 0x09, 0x23, 0x33, 0x52, 0xf0,
N	0x15, 0x62, 0x72, 0xd1, 0x0a, 0x16, 0x24, 0x34,
N	0xe1, 0x25, 0xf1, 0x17, 0x18, 0x19, 0x1a, 0x26,
N	0x27, 0x28, 0x29, 0x2a, 0x35, 0x36, 0x37, 0x38,
N	0x39, 0x3a, 0x43, 0x44, 0x45, 0x46, 0x47, 0x48,
N	0x49, 0x4a, 0x53, 0x54, 0x55, 0x56, 0x57, 0x58,
N	0x59, 0x5a, 0x63, 0x64, 0x65, 0x66, 0x67, 0x68,
N	0x69, 0x6a, 0x73, 0x74, 0x75, 0x76, 0x77, 0x78,
N	0x79, 0x7a, 0x82, 0x83, 0x84, 0x85, 0x86, 0x87,
N	0x88, 0x89, 0x8a, 0x92, 0x93, 0x94, 0x95, 0x96,
N	0x97, 0x98, 0x99, 0x9a, 0xa2, 0xa3, 0xa4, 0xa5,
N	0xa6, 0xa7, 0xa8, 0xa9, 0xaa, 0xb2, 0xb3, 0xb4,
N	0xb5, 0xb6, 0xb7, 0xb8, 0xb9, 0xba, 0xc2, 0xc3,
N	0xc4, 0xc5, 0xc6, 0xc7, 0xc8, 0xc9, 0xca, 0xd2,
N	0xd3, 0xd4, 0xd5, 0xd6, 0xd7, 0xd8, 0xd9, 0xda,
N	0xe2, 0xe3, 0xe4, 0xe5, 0xe6, 0xe7, 0xe8, 0xe9,
N	0xea, 0xf2, 0xf3, 0xf4, 0xf5, 0xf6, 0xf7, 0xf8,
N	0xf9, 0xfa 
N}; 
N
N
N_Bool JPEG_encode(char *filename);//±àÂëÖ÷º¯Êý
N/////////////////³õÊ¼»¯º¯Êý×é/////////////////////////////////////////////////////
Njpeg_compress_info *jpeg_create_compress(void);//´´½¨Ñ¹ËõÎÄ¼þÐÅÏ¢
N//void jpeg_set_default(jpeg_compress_info *cinfo);//ÉèÖÃÄ¬ÈÏ²ÎÊý 
Nvoid jpeg_set_default(jpeg_compress_info *cinfo,u8 *inbuf_buf);//ÉèÖÃÄ¬ÈÏ²ÎÊý 
Nvoid jint_std_quant_tables(jpeg_compress_info *cinfo);//ÉèÖÃ±ê×¼Á¿»¯±í
Nvoid jint_std_huff_tables (jpeg_compress_info *cinfo);//ÉèÖÃ±ê×¼huffman±í 
Nvoid jint_add_quant_table(jpeg_compress_info *cinfo,u16 which_tbl,const u16 *base_tbl,float quality);//Ìí¼ÓÁ¿»¯±í 						   
Nvoid jint_add_huff_table(jpeg_compress_info *cinfo,u16 which_tbl,int what_tbl,const u8 *bits,const u8 *value);//Ìí¼Óhuffman±í
Nvoid jutl_zigzag_sort(DCTBLOCK dptr);//Z±ä»» 
Nvoid jint_calc_huff_tbl(JHUFF_TBL *htblptr);//Éú³Éhuffman±í
N//void jpeg_calc_value(jpeg_compress_info *cinfo);
Nvoid jpeg_calc_value(jpeg_compress_info *cinfo,u8 *inbuf_buf);//¼ÆËã³öÒ»Ð©ÓÐÓÃµÄÖµ²¢·ÖÅäµ½»º³åÇøÖÐ
N/////////////////Ð´Í·ÐÅÏ¢º¯Êý×é///////////////////////////////////////////////////
Nvoid jpeg_start_compress(jpeg_compress_info *cinfo);//¿ªÊ¼Ñ¹Ëõ±àÂë,Ð´ÈëÍ·ÐÅÏ¢ 
Nvoid jmkr_write_start(jpeg_compress_info *cinfo);//ZÐÎÅÅÐò
Nvoid jmkr_write_image_start(jpeg_compress_info *cinfo);//Ð´ÈëÎÄ¼þ¿ªÊ¼±êÖ¾
Nvoid jmkr_write_jfif(jpeg_compress_info *cinfo);//Ð´ÈëAPP0Ó¦ÓÃÊý¾Ý¶Î
Nvoid jmkr_write_quant_table(jpeg_compress_info *cinfo);//Ð´ÈëÁ¿»¯±í
Nvoid jmkr_write_frame_head(jpeg_compress_info *cinfo);//Ð´ÈëÖ¡Í·
Nvoid jmkr_write_huff_table(jpeg_compress_info *cinfo);//Ð´Èë¹þ·òÂü±í
Nvoid jmkr_write_scan_head(jpeg_compress_info *cinfo);//Ð´ÈëÉ¨Ãè¿ªÊ¼±êÖ¾
Nvoid jmkr_write_end(jpeg_compress_info *cinfo);//Ð´ÎÄ¼þ½áÊø±êÖ¾ 
N/////////////////É¨Ãè±àÂëº¯Êý×é///////////////////////////////////////////////////
Nvoid jint_process_rows(jpeg_compress_info *cinfo);//ÐÐÑ¹Ëõº¯Êý
Nvoid jutl_cc_rgb2ycc(JSAMPLE *data,int num);//RGB×ªYUV
Nvoid jint_process_mcu(jpeg_compress_info *cinfo);//´¦ÀíÔª¼þÖÐµÄMCUÊý¾Ý 
Nvoid dsp_fdct_8x8(short *dct_data, unsigned num_fdcts);//¿ìËÙÀëÉ¢ÓàÏÒ±ä»»
Nvoid jhuff_encode_one_block(jpeg_compress_info *cinfo,DCTBLOCK src,JHUFF_TBL *dc_tbl,JHUFF_TBL *ac_tbl);//huffman±àÂë 
Nvoid jpeg_finish_compress(jpeg_compress_info *cinfo);//Íê³É»º³åÇøÖÐÊ£ÏÂÊý¾ÝµÄÑ¹Ëõ±àÂë,²¢Ð´ÎÄ¼þÎ²µ½Êä³öÎÄ¼þ
N/////////////////////ÆäËüº¯Êý×é///////////////////////////////////////////////////
Nvoid jhuff_flush_buffer(jpeg_compress_info *cinfo);//Çå³ý/ÊÍ·Å»º³åÇø
Nvoid jhuff_write_bits(jpeg_compress_info *cinfo,u32 data,int len);//Ð´±ÈÌØ 
Nint  bit_num(int a); 
N
N
N#endif
L 12 "..\..\User\main.c" 2
N#include "malloc.h"
L 1 "..\..\User\MALLOC\malloc.h" 1
N#ifndef __MALLOC_H
N#define __MALLOC_H
N#include "stm32f10x.h"
N
N//////////////////////////////////////////////////////////////////////////////////	 
N//±¾³ÌÐòÖ»¹©Ñ§Ï°Ê¹ÓÃ£¬Î´¾­×÷ÕßÐí¿É£¬²»µÃÓÃÓÚÆäËüÈÎºÎÓÃÍ¾
N//ALIENTEK ¿ª·¢°å
N//ÄÚ´æ¹ÜÀí ´úÂë		   
N//ÕýµãÔ­×Ó@ALIENTEK
N//¼¼ÊõÂÛÌ³:www.openedv.com
N//´´½¨ÈÕÆÚ:2011/7/5 
N//°æ±¾£ºV2.0
N//°æÈ¨ËùÓÐ£¬µÁ°æ±Ø¾¿¡£
N//Copyright(C) ÕýµãÔ­×Ó 2009-2019
N//All rights reserved
N//********************************************************************************
N//V2.0 20111008
N//1,´ó·ùÐÞ¸Ä½Ó¿Úº¯Êý,Ôö¼Ó¶à¿éÄÚ´æµÄ¹ÜÀí.
N////////////////////////////////////////////////////////////////////////////////// 	  
N
N//typedef unsigned long  u32;
N//typedef unsigned short u16;
N//typedef unsigned char  u8;	  
N#ifndef NULL
S#define NULL 0
N#endif
N
N#define SRAMIN	0	//ÄÚ²¿ÄÚ´æ³Ø
N#define SRAMEX  1	//Íâ²¿ÄÚ´æ³Ø
N
N
N//mem1ÄÚ´æ²ÎÊýÉè¶¨.mem1ÍêÈ«´¦ÓÚÄÚ²¿SRAMÀïÃæ
N#define MEM1_BLOCK_SIZE			32  	  						//ÄÚ´æ¿é´óÐ¡Îª32×Ö½Ú
N#define MEM1_MAX_SIZE			40*1024  						//×î´ó¹ÜÀíÄÚ´æ 45K
N#define MEM1_ALLOC_TABLE_SIZE	MEM1_MAX_SIZE/MEM1_BLOCK_SIZE 	//ÄÚ´æ±í´óÐ¡
N
N//mem2ÄÚ´æ²ÎÊýÉè¶¨.mem2µÄÄÚ´æ³Ø´¦ÓÚÍâ²¿SRAMÀïÃæ,ÆäËûµÄ´¦ÓÚÄÚ²¿SRAMÀïÃæ
N#define MEM2_BLOCK_SIZE			32  	  						//ÄÚ´æ¿é´óÐ¡Îª32×Ö½Ú
N#define MEM2_MAX_SIZE			192*1024  						//×î´ó¹ÜÀíÄÚ´æ 192K
N#define MEM2_ALLOC_TABLE_SIZE	MEM2_MAX_SIZE/MEM2_BLOCK_SIZE 	//ÄÚ´æ±í´óÐ¡
N		 
N		 
N//ÄÚ´æ¹ÜÀí¿ØÖÆÆ÷
Nstruct _m_mallco_dev
N{
N	void (*init)(u8);					//³õÊ¼»¯
N	u8 (*perused)(u8);		  	    	//ÄÚ´æÊ¹ÓÃÂÊ
N	u8 	*membase[2];					//ÄÚ´æ³Ø ¹ÜÀí2¸öÇøÓòµÄÄÚ´æ
N	u16 *memmap[2]; 					//ÄÚ´æ¹ÜÀí×´Ì¬±í
N	u8  memrdy[2]; 						//ÄÚ´æ¹ÜÀíÊÇ·ñ¾ÍÐ÷
N};
Nextern struct _m_mallco_dev mallco_dev;	 //ÔÚmallco.cÀïÃæ¶¨Òå
N
Nvoid mymemset(void *s,u8 c,u32 count);	 //ÉèÖÃÄÚ´æ
Nvoid mymemcpy(void *des,void *src,u32 n);//¸´ÖÆÄÚ´æ 
N
Nvoid mem_init(u8 memx);					 //ÄÚ´æ¹ÜÀí³õÊ¼»¯º¯Êý(Íâ/ÄÚ²¿µ÷ÓÃ)
Nu32 mem_malloc(u8 memx,u32 size);		 //ÄÚ´æ·ÖÅä(ÄÚ²¿µ÷ÓÃ)
Nu8 mem_free(u8 memx,u32 offset);		 //ÄÚ´æÊÍ·Å(ÄÚ²¿µ÷ÓÃ)
Nu8 mem_perused(u8 memx);				 //»ñµÃÄÚ´æÊ¹ÓÃÂÊ(Íâ/ÄÚ²¿µ÷ÓÃ) 
N////////////////////////////////////////////////////////////////////////////////
N//ÓÃ»§µ÷ÓÃº¯Êý
Nvoid myfree(u8 memx,void *ptr);  			//ÄÚ´æÊÍ·Å(Íâ²¿µ÷ÓÃ)
Nvoid *mymalloc(u8 memx,u32 size);			//ÄÚ´æ·ÖÅä(Íâ²¿µ÷ÓÃ)
Nvoid *myrealloc(u8 memx,void *ptr,u32 size);//ÖØÐÂ·ÖÅäÄÚ´æ(Íâ²¿µ÷ÓÃ)
N#endif
N
N
N
N
N
N
N
N
N
N
N
N
N
L 13 "..\..\User\main.c" 2
N
N//ÍøÂçÐ­Òé²ã
N#include "onenet.h"
L 1 "..\..\User\onenet\inc\onenet.h" 1
N#ifndef _ONENET_H_
N#define _ONENET_H_
N
N
N
N#define DEVID	"30964714"
N
N#define APIKEY	"Uv=e=yMBymo8In9FVA4Ub16Oleo="
N#define Heart_OK 1
N#define Heart_err 0
N
N
Ntypedef struct
N{
N	unsigned short time;
N	unsigned   char temp;
N	unsigned   char humidit;
N	_Bool fire;
N	unsigned char tem_max;
N	unsigned char  tem_min;
N	unsigned char hum_max;
N	unsigned char hum_min;
N	
N	
N	
N	
N
N} data_Stream;
N
N
Ntypedef enum
N{
N
N	NET_EVENT_Timer_Check_Err = 0,			//ÍøÂç¶¨Ê±¼ì²é³¬Ê±´íÎó
N	NET_EVENT_Timer_Send_Err,				//ÍøÂç·¢ËÍÊ§°Ü´íÎó
N	
N	NET_EVENT_Send_HeartBeat,				//¼´½«·¢ËÍÐÄÌø°ü
N	NET_EVENT_Send_Data,					//¼´½«·¢ËÍÊý¾Ýµã
N	
N	NET_EVENT_Recv,							//ModbusÓÃ-ÊÕµ½Êý¾Ý²éÑ¯Ö¸Áî
N	NET_EVENT_SendPhoto,         //·¢ËÍÕÕÆ¬
N	
N	NET_EVENT_Check_Status,					//½øÈëÍøÂçÄ£×é×´Ì¬¼ì²é
N	
N	NET_EVENT_Device_Ok,					//ÍøÂçÄ£×é¼ì²âOk
N	NET_EVENT_Device_Err,					//ÍøÂçÄ£×é¼ì²â´íÎó
N	
N	NET_EVENT_Initialize,					//ÕýÔÚ³õÊ¼»¯ÍøÂçÄ£×é
N	NET_EVENT_Init_Ok,						//ÍøÂçÄ£×é³õÊ¼»¯³É¹¦
N	
N	NET_EVENT_Auto_Create_Ok,				//×Ô¶¯´´½¨Éè±¸³É¹¦
N	NET_EVENT_Auto_Create_Err,				//×Ô¶¯´´½¨Éè±¸Ê§°Ü
N	
N	NET_EVENT_Connect,						//ÕýÔÚÁ¬½Ó¡¢µÇÂ¼OneNET
N	NET_EVENT_Connect_Ok,					//Á¬½Ó¡¢µÇÂ¼³É¹¦
N	NET_EVENT_Connect_Err,					//Á¬½Ó¡¢µÇÂ¼´íÎó
N	
N	NET_EVENT_Fault_Process,				//½øÈë´íÎó´¦Àí
N
N} NET_EVENT;
N
N
N
Nenum data_type{data_stream=0,picture,heart,Cmd} ;
N
N
N_Bool OneNet_DevLink(void);
N
Nvoid OneNet_SendData(volatile data_Stream *data_stream);
Nvoid OneNet_RevPro(unsigned char *cmd);
N
N//unsigned char EDP_UnPacketRecv(unsigned char *cmd);
Nvoid OneNet_SendData_Picture(char *devid,  char * pic_name);
Nvoid OneNet_Send_heart(void);
Nunsigned char OneNET_CmdHandle(void);
Nunsigned char OneNet_SendPhoto(void);
N
N
N#endif
L 16 "..\..\User\main.c" 2
N#include "EdpKit.h"
L 1 "..\..\User\EDP\EdpKit.h" 1
N#ifndef _EDPKIT_H_
N#define _EDPKIT_H_
N
N
N#include "Common.h"
L 1 "..\..\User\EDP\Common.h" 1
N#ifndef __COMMON_H__
N#define __COMMON_H__
N
N/*---------------------------------------------------------------------------*/
N/* Type Definition Macros                                                    */
N/*---------------------------------------------------------------------------*/
N
N	typedef _Bool			uint1;
N    typedef unsigned char   uint8;
N    typedef char			int8;
N    typedef unsigned short  uint16;
N    typedef short			int16;
N    typedef unsigned int    uint32;
N    typedef int				int32;
N	typedef unsigned int	size_t;
N	
N
N	
N#endif /* __COMMON_H__ */
L 6 "..\..\User\EDP\EdpKit.h" 2
N#include <stdlib.h>
L 1 "F:\Keil_v5\ARM\ARMCC\Bin\..\include\stdlib.h" 1
N/* stdlib.h: ANSI draft (X3J11 May 88) library header, section 4.10 */
N/* Copyright (C) Codemist Ltd., 1988-1993.                          */
N/* Copyright 1991-1998,2014 ARM Limited. All rights reserved.       */
N/*
N * RCS $Revision$
N * Checkin $Date$
N * Revising $Author: agrant $
N */
N 
N/*
N * stdlib.h declares four types, several general purpose functions,
N * and defines several macros.
N */
N
N#ifndef __stdlib_h
N#define __stdlib_h
N#define __ARMCLIB_VERSION 5060037
N
N#if defined(__clang__) || (defined(__ARMCC_VERSION) && !defined(__STRICT_ANSI__))
X#if 0L || (1L && !0L)
N  /* armclang and non-strict armcc allow 'long long' in system headers */
N  #define __LONGLONG long long
N#else
S  /* strict armcc has '__int64' */
S  #define __LONGLONG __int64
N#endif
N
N#define _ARMABI __declspec(__nothrow)
N#define _ARMABI_PURE __declspec(__nothrow) __attribute__((const))
N#define _ARMABI_NORETURN __declspec(__nothrow) __declspec(__noreturn)
N#define _ARMABI_THROW
N
N  #ifndef __STDLIB_DECLS
N  #define __STDLIB_DECLS
N
N  /*
N   * Some of these declarations are new in C99.  To access them in C++
N   * you can use -D__USE_C99_STDLIB (or -D__USE_C99ALL).
N   */
N  #ifndef __USE_C99_STDLIB
N    #if defined(__USE_C99_ALL) || (defined(__STDC_VERSION__) && 199901L <= __STDC_VERSION__) || (defined(__cplusplus) && 201103L <= __cplusplus)
X    #if 0L || (1L && 199901L <= 199901L) || (0L && 201103L <= __cplusplus)
N      #define __USE_C99_STDLIB 1
N    #endif
N  #endif
N
N    #undef __CLIBNS
N
N    #ifdef __cplusplus
S      namespace std {
S          #define __CLIBNS ::std::
S          extern "C" {
N    #else
N      #define __CLIBNS
N    #endif  /* __cplusplus */
N
N#if defined(__cplusplus) || !defined(__STRICT_ANSI__)
X#if 0L || !0L
N /* unconditional in C++ and non-strict C for consistency of debug info */
N  #if __sizeof_ptr == 8
X  #if 4 == 8
S    typedef unsigned long size_t;   /* see <stddef.h> */
N  #else
N    typedef unsigned int size_t;   /* see <stddef.h> */
N  #endif
N#elif !defined(__size_t)
S  #define __size_t 1
S  #if __sizeof_ptr == 8
S    typedef unsigned long size_t;   /* see <stddef.h> */
S  #else
S    typedef unsigned int size_t;   /* see <stddef.h> */
S  #endif
N#endif
N
N#undef NULL
N#define NULL 0                   /* see <stddef.h> */
N
N#ifndef __cplusplus  /* wchar_t is a builtin type for C++ */
N  #if !defined(__STRICT_ANSI__)
X  #if !0L
N   /* unconditional in non-strict C for consistency of debug info */
N   #if defined(__WCHAR32) || (defined(__ARM_SIZEOF_WCHAR_T) && __ARM_SIZEOF_WCHAR_T == 4)
X   #if 0L || (0L && __ARM_SIZEOF_WCHAR_T == 4)
S    typedef unsigned int wchar_t; /* see <stddef.h> */
N   #else
N    typedef unsigned short wchar_t; /* see <stddef.h> */
N   #endif
N  #elif !defined(__wchar_t)
S    #define __wchar_t 1
S   #if defined(__WCHAR32) || (defined(__ARM_SIZEOF_WCHAR_T) && __ARM_SIZEOF_WCHAR_T == 4)
S    typedef unsigned int wchar_t; /* see <stddef.h> */
S   #else
S    typedef unsigned short wchar_t; /* see <stddef.h> */
S   #endif
N  #endif
N#endif
N
Ntypedef struct div_t { int quot, rem; } div_t;
N   /* type of the value returned by the div function. */
Ntypedef struct ldiv_t { long int quot, rem; } ldiv_t;
N   /* type of the value returned by the ldiv function. */
N#if !defined(__STRICT_ANSI__) || __USE_C99_STDLIB
X#if !0L || 1
Ntypedef struct lldiv_t { __LONGLONG quot, rem; } lldiv_t;
Xtypedef struct lldiv_t { long long quot, rem; } lldiv_t;
N   /* type of the value returned by the lldiv function. */
N#endif
N
N#ifdef __EXIT_FAILURE
S#  define EXIT_FAILURE __EXIT_FAILURE
S   /*
S    * an integral expression which may be used as an argument to the exit
S    * function to return unsuccessful termination status to the host
S    * environment.
S    */
N#else
N#  define EXIT_FAILURE 1  /* unixoid */
N#endif
N#define EXIT_SUCCESS 0
N   /*
N    * an integral expression which may be used as an argument to the exit
N    * function to return successful termination status to the host
N    * environment.
N    */
N
N   /*
N    * Defining __USE_ANSI_EXAMPLE_RAND at compile time switches to
N    * the example implementation of rand() and srand() provided in
N    * the ANSI C standard. This implementation is very poor, but is
N    * provided for completeness.
N    */
N#ifdef __USE_ANSI_EXAMPLE_RAND
S#define srand _ANSI_srand
S#define rand _ANSI_rand
S#define RAND_MAX 0x7fff
N#else
N#define RAND_MAX 0x7fffffff
N#endif
N   /*
N    * RAND_MAX: an integral constant expression, the value of which
N    * is the maximum value returned by the rand function.
N    */
Nextern _ARMABI int __aeabi_MB_CUR_MAX(void);
Xextern __declspec(__nothrow) int __aeabi_MB_CUR_MAX(void);
N#define MB_CUR_MAX ( __aeabi_MB_CUR_MAX() )
N   /*
N    * a positive integer expression whose value is the maximum number of bytes
N    * in a multibyte character for the extended character set specified by the
N    * current locale (category LC_CTYPE), and whose value is never greater
N    * than MB_LEN_MAX.
N    */
N
N   /*
N    * If the compiler supports signalling nans as per N965 then it
N    * will define __SUPPORT_SNAN__, in which case a user may define
N    * _WANT_SNAN in order to obtain a compliant version of the strtod
N    * family of functions.
N    */
N#if defined(__SUPPORT_SNAN__) && defined(_WANT_SNAN)
X#if 0L && 0L
S#pragma import(__use_snan)
N#endif
N
Nextern _ARMABI double atof(const char * /*nptr*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) double atof(const char *  ) __attribute__((__nonnull__(1)));
N   /*
N    * converts the initial part of the string pointed to by nptr to double
N    * representation.
N    * Returns: the converted value.
N    */
Nextern _ARMABI int atoi(const char * /*nptr*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int atoi(const char *  ) __attribute__((__nonnull__(1)));
N   /*
N    * converts the initial part of the string pointed to by nptr to int
N    * representation.
N    * Returns: the converted value.
N    */
Nextern _ARMABI long int atol(const char * /*nptr*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) long int atol(const char *  ) __attribute__((__nonnull__(1)));
N   /*
N    * converts the initial part of the string pointed to by nptr to long int
N    * representation.
N    * Returns: the converted value.
N    */
N#if !defined(__STRICT_ANSI__) || __USE_C99_STDLIB
X#if !0L || 1
Nextern _ARMABI __LONGLONG atoll(const char * /*nptr*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) long long atoll(const char *  ) __attribute__((__nonnull__(1)));
N   /*
N    * converts the initial part of the string pointed to by nptr to
N    * long long int representation.
N    * Returns: the converted value.
N    */
N#endif
N
Nextern _ARMABI double strtod(const char * __restrict /*nptr*/, char ** __restrict /*endptr*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) double strtod(const char * __restrict  , char ** __restrict  ) __attribute__((__nonnull__(1)));
N   /*
N    * converts the initial part of the string pointed to by nptr to double
N    * representation. First it decomposes the input string into three parts:
N    * an initial, possibly empty, sequence of white-space characters (as
N    * specified by the isspace function), a subject sequence resembling a
N    * floating point constant; and a final string of one or more unrecognised
N    * characters, including the terminating null character of the input string.
N    * Then it attempts to convert the subject sequence to a floating point
N    * number, and returns the result. A pointer to the final string is stored
N    * in the object pointed to by endptr, provided that endptr is not a null
N    * pointer.
N    * Returns: the converted value if any. If no conversion could be performed,
N    *          zero is returned. If the correct value is outside the range of
N    *          representable values, plus or minus HUGE_VAL is returned
N    *          (according to the sign of the value), and the value of the macro
N    *          ERANGE is stored in errno. If the correct value would cause
N    *          underflow, zero is returned and the value of the macro ERANGE is
N    *          stored in errno.
N    */
N#if !defined(__STRICT_ANSI__) || __USE_C99_STDLIB
X#if !0L || 1
Nextern _ARMABI float strtof(const char * __restrict /*nptr*/, char ** __restrict /*endptr*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) float strtof(const char * __restrict  , char ** __restrict  ) __attribute__((__nonnull__(1)));
Nextern _ARMABI long double strtold(const char * __restrict /*nptr*/, char ** __restrict /*endptr*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) long double strtold(const char * __restrict  , char ** __restrict  ) __attribute__((__nonnull__(1)));
N   /*
N    * same as strtod, but return float and long double respectively.
N    */
N#endif
Nextern _ARMABI long int strtol(const char * __restrict /*nptr*/,
Xextern __declspec(__nothrow) long int strtol(const char * __restrict  ,
N                        char ** __restrict /*endptr*/, int /*base*/) __attribute__((__nonnull__(1)));
N   /*
N    * converts the initial part of the string pointed to by nptr to long int
N    * representation. First it decomposes the input string into three parts:
N    * an initial, possibly empty, sequence of white-space characters (as
N    * specified by the isspace function), a subject sequence resembling an
N    * integer represented in some radix determined by the value of base, and a
N    * final string of one or more unrecognised characters, including the
N    * terminating null character of the input string. Then it attempts to
N    * convert the subject sequence to an integer, and returns the result.
N    * If the value of base is 0, the expected form of the subject sequence is
N    * that of an integer constant (described in ANSI Draft, section 3.1.3.2),
N    * optionally preceded by a '+' or '-' sign, but not including an integer
N    * suffix. If the value of base is between 2 and 36, the expected form of
N    * the subject sequence is a sequence of letters and digits representing an
N    * integer with the radix specified by base, optionally preceded by a plus
N    * or minus sign, but not including an integer suffix. The letters from a
N    * (or A) through z (or Z) are ascribed the values 10 to 35; only letters
N    * whose ascribed values are less than that of the base are permitted. If
N    * the value of base is 16, the characters 0x or 0X may optionally precede
N    * the sequence of letters and digits following the sign if present.
N    * A pointer to the final string is stored in the object
N    * pointed to by endptr, provided that endptr is not a null pointer.
N    * Returns: the converted value if any. If no conversion could be performed,
N    *          zero is returned and nptr is stored in *endptr.
N    *          If the correct value is outside the range of
N    *          representable values, LONG_MAX or LONG_MIN is returned
N    *          (according to the sign of the value), and the value of the
N    *          macro ERANGE is stored in errno.
N    */
Nextern _ARMABI unsigned long int strtoul(const char * __restrict /*nptr*/,
Xextern __declspec(__nothrow) unsigned long int strtoul(const char * __restrict  ,
N                                       char ** __restrict /*endptr*/, int /*base*/) __attribute__((__nonnull__(1)));
N   /*
N    * converts the initial part of the string pointed to by nptr to unsigned
N    * long int representation. First it decomposes the input string into three
N    * parts: an initial, possibly empty, sequence of white-space characters (as
N    * determined by the isspace function), a subject sequence resembling an
N    * unsigned integer represented in some radix determined by the value of
N    * base, and a final string of one or more unrecognised characters,
N    * including the terminating null character of the input string. Then it
N    * attempts to convert the subject sequence to an unsigned integer, and
N    * returns the result. If the value of base is zero, the expected form of
N    * the subject sequence is that of an integer constant (described in ANSI
N    * Draft, section 3.1.3.2), optionally preceded by a '+' or '-' sign, but
N    * not including an integer suffix. If the value of base is between 2 and
N    * 36, the expected form of the subject sequence is a sequence of letters
N    * and digits representing an integer with the radix specified by base,
N    * optionally preceded by a '+' or '-' sign, but not including an integer
N    * suffix. The letters from a (or A) through z (or Z) stand for the values
N    * 10 to 35; only letters whose ascribed values are less than that of the
N    * base are permitted. If the value of base is 16, the characters 0x or 0X
N    * may optionally precede the sequence of letters and digits following the
N    * sign, if present. A pointer to the final string is stored in the object
N    * pointed to by endptr, provided that endptr is not a null pointer.
N    * Returns: the converted value if any. If no conversion could be performed,
N    *          zero is returned and nptr is stored in *endptr.
N    *          If the correct value is outside the range of
N    *          representable values, ULONG_MAX is returned, and the value of
N    *          the macro ERANGE is stored in errno.
N    */
N
N/* C90 reserves all names beginning with 'str' */
Nextern _ARMABI __LONGLONG strtoll(const char * __restrict /*nptr*/,
Xextern __declspec(__nothrow) long long strtoll(const char * __restrict  ,
N                                  char ** __restrict /*endptr*/, int /*base*/)
N                          __attribute__((__nonnull__(1)));
N   /*
N    * as strtol but returns a long long int value.  If the correct value is
N    * outside the range of representable values,  LLONG_MAX or LLONG_MIN is
N    * returned (according to the sign of the value), and the value of the
N    * macro ERANGE is stored in errno.
N    */
Nextern _ARMABI unsigned __LONGLONG strtoull(const char * __restrict /*nptr*/,
Xextern __declspec(__nothrow) unsigned long long strtoull(const char * __restrict  ,
N                                            char ** __restrict /*endptr*/, int /*base*/)
N                                   __attribute__((__nonnull__(1)));
N   /*
N    * as strtoul but returns an unsigned long long int value.  If the correct
N    * value is outside the range of representable values, ULLONG_MAX is returned,
N    * and the value of the macro ERANGE is stored in errno.
N    */
N
Nextern _ARMABI int rand(void);
Xextern __declspec(__nothrow) int rand(void);
N   /*
N    * Computes a sequence of pseudo-random integers in the range 0 to RAND_MAX.
N    * Uses an additive generator (Mitchell & Moore) of the form:
N    *   Xn = (X[n-24] + X[n-55]) MOD 2^31
N    * This is described in section 3.2.2 of Knuth, vol 2. It's period is
N    * in excess of 2^55 and its randomness properties, though unproven, are
N    * conjectured to be good. Empirical testing since 1958 has shown no flaws.
N    * Returns: a pseudo-random integer.
N    */
Nextern _ARMABI void srand(unsigned int /*seed*/);
Xextern __declspec(__nothrow) void srand(unsigned int  );
N   /*
N    * uses its argument as a seed for a new sequence of pseudo-random numbers
N    * to be returned by subsequent calls to rand. If srand is then called with
N    * the same seed value, the sequence of pseudo-random numbers is repeated.
N    * If rand is called before any calls to srand have been made, the same
N    * sequence is generated as when srand is first called with a seed value
N    * of 1.
N    */
N
Nstruct _rand_state { int __x[57]; };
Nextern _ARMABI int _rand_r(struct _rand_state *);
Xextern __declspec(__nothrow) int _rand_r(struct _rand_state *);
Nextern _ARMABI void _srand_r(struct _rand_state *, unsigned int);
Xextern __declspec(__nothrow) void _srand_r(struct _rand_state *, unsigned int);
Nstruct _ANSI_rand_state { int __x[1]; };
Nextern _ARMABI int _ANSI_rand_r(struct _ANSI_rand_state *);
Xextern __declspec(__nothrow) int _ANSI_rand_r(struct _ANSI_rand_state *);
Nextern _ARMABI void _ANSI_srand_r(struct _ANSI_rand_state *, unsigned int);
Xextern __declspec(__nothrow) void _ANSI_srand_r(struct _ANSI_rand_state *, unsigned int);
N   /*
N    * Re-entrant variants of both flavours of rand, which operate on
N    * an explicitly supplied state buffer.
N    */
N
Nextern _ARMABI void *calloc(size_t /*nmemb*/, size_t /*size*/);
Xextern __declspec(__nothrow) void *calloc(size_t  , size_t  );
N   /*
N    * allocates space for an array of nmemb objects, each of whose size is
N    * 'size'. The space is initialised to all bits zero.
N    * Returns: either a null pointer or a pointer to the allocated space.
N    */
Nextern _ARMABI void free(void * /*ptr*/);
Xextern __declspec(__nothrow) void free(void *  );
N   /*
N    * causes the space pointed to by ptr to be deallocated (i.e., made
N    * available for further allocation). If ptr is a null pointer, no action
N    * occurs. Otherwise, if ptr does not match a pointer earlier returned by
N    * calloc, malloc or realloc or if the space has been deallocated by a call
N    * to free or realloc, the behaviour is undefined.
N    */
Nextern _ARMABI void *malloc(size_t /*size*/);
Xextern __declspec(__nothrow) void *malloc(size_t  );
N   /*
N    * allocates space for an object whose size is specified by 'size' and whose
N    * value is indeterminate.
N    * Returns: either a null pointer or a pointer to the allocated space.
N    */
Nextern _ARMABI void *realloc(void * /*ptr*/, size_t /*size*/);
Xextern __declspec(__nothrow) void *realloc(void *  , size_t  );
N   /*
N    * changes the size of the object pointed to by ptr to the size specified by
N    * size. The contents of the object shall be unchanged up to the lesser of
N    * the new and old sizes. If the new size is larger, the value of the newly
N    * allocated portion of the object is indeterminate. If ptr is a null
N    * pointer, the realloc function behaves like a call to malloc for the
N    * specified size. Otherwise, if ptr does not match a pointer earlier
N    * returned by calloc, malloc or realloc, or if the space has been
N    * deallocated by a call to free or realloc, the behaviour is undefined.
N    * If the space cannot be allocated, the object pointed to by ptr is
N    * unchanged. If size is zero and ptr is not a null pointer, the object it
N    * points to is freed.
N    * Returns: either a null pointer or a pointer to the possibly moved
N    *          allocated space.
N    */
N#if !defined(__STRICT_ANSI__)
X#if !0L
Nextern _ARMABI int posix_memalign(void ** /*ret*/, size_t /*alignment*/, size_t /*size*/);
Xextern __declspec(__nothrow) int posix_memalign(void **  , size_t  , size_t  );
N   /*
N    * allocates space for an object of size 'size', aligned to a
N    * multiple of 'alignment' (which must be a power of two and at
N    * least 4).
N    *
N    * On success, a pointer to the allocated object is stored in
N    * *ret, and zero is returned. On failure, the return value is
N    * either ENOMEM (allocation failed because no suitable piece of
N    * memory was available) or EINVAL (the 'alignment' parameter was
N    * invalid).
N    */
N#endif
Ntypedef int (*__heapprt)(void *, char const *, ...);
Nextern _ARMABI void __heapstats(int (* /*dprint*/)(void * /*param*/,
Xextern __declspec(__nothrow) void __heapstats(int (*  )(void *  ,
N                                           char const * /*format*/, ...),
N                        void * /*param*/) __attribute__((__nonnull__(1)));
N   /*
N    * reports current heap statistics (eg. number of free blocks in
N    * the free-list). Output is as implementation-defined free-form
N    * text, provided via the dprint function. `param' gives an
N    * extra data word to pass to dprint. You can call
N    * __heapstats(fprintf,stdout) by casting fprintf to the above
N    * function type; the typedef `__heapprt' is provided for this
N    * purpose.
N    *
N    * `dprint' will not be called while the heap is being examined,
N    * so it can allocate memory itself without trouble.
N    */
Nextern _ARMABI int __heapvalid(int (* /*dprint*/)(void * /*param*/,
Xextern __declspec(__nothrow) int __heapvalid(int (*  )(void *  ,
N                                           char const * /*format*/, ...),
N                       void * /*param*/, int /*verbose*/) __attribute__((__nonnull__(1)));
N   /*
N    * performs a consistency check on the heap. Errors are reported
N    * through dprint, like __heapstats. If `verbose' is nonzero,
N    * full diagnostic information on the heap state is printed out.
N    *
N    * This routine probably won't work if the heap isn't a
N    * contiguous chunk (for example, if __user_heap_extend has been
N    * overridden).
N    *
N    * `dprint' may be called while the heap is being examined or
N    * even in an invalid state, so it must perform no memory
N    * allocation. In particular, if `dprint' calls (or is) a stdio
N    * function, the stream it outputs to must already have either
N    * been written to or been setvbuf'ed, or else the system will
N    * allocate buffer space for it on the first call to dprint.
N    */
Nextern _ARMABI_NORETURN void abort(void);
Xextern __declspec(__nothrow) __declspec(__noreturn) void abort(void);
N   /*
N    * causes abnormal program termination to occur, unless the signal SIGABRT
N    * is being caught and the signal handler does not return. Whether open
N    * output streams are flushed or open streams are closed or temporary
N    * files removed is implementation-defined.
N    * An implementation-defined form of the status 'unsuccessful termination'
N    * is returned to the host environment by means of a call to
N    * raise(SIGABRT).
N    */
N
Nextern _ARMABI int atexit(void (* /*func*/)(void)) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int atexit(void (*  )(void)) __attribute__((__nonnull__(1)));
N   /*
N    * registers the function pointed to by func, to be called without its
N    * arguments at normal program termination. It is possible to register at
N    * least 32 functions.
N    * Returns: zero if the registration succeeds, nonzero if it fails.
N    */
N#if defined(__EDG__) && !defined(__GNUC__)
X#if 1L && !0L
N#define __LANGUAGE_LINKAGE_CHANGES_FUNCTION_TYPE
N#endif
N#if defined(__cplusplus) && defined(__LANGUAGE_LINKAGE_CHANGES_FUNCTION_TYPE) 
X#if 0L && 1L 
S    /* atexit that takes a ptr to a function with C++ linkage 
S     * but not in GNU mode  
S     */
S    typedef void (* __C_exitfuncptr)();
S    extern "C++"
S    inline int atexit(void (* __func)()) {
S      return atexit((__C_exitfuncptr)__func);
S    }
N#endif
N
N
Nextern _ARMABI_NORETURN void exit(int /*status*/);
Xextern __declspec(__nothrow) __declspec(__noreturn) void exit(int  );
N   /*
N    * causes normal program termination to occur. If more than one call to the
N    * exit function is executed by a program, the behaviour is undefined.
N    * First, all functions registered by the atexit function are called, in the
N    * reverse order of their registration.
N    * Next, all open output streams are flushed, all open streams are closed,
N    * and all files created by the tmpfile function are removed.
N    * Finally, control is returned to the host environment. If the value of
N    * status is zero or EXIT_SUCCESS, an implementation-defined form of the
N    * status 'successful termination' is returned. If the value of status is
N    * EXIT_FAILURE, an implementation-defined form of the status
N    * 'unsuccessful termination' is returned. Otherwise the status returned
N    * is implementation-defined.
N    */
N
Nextern _ARMABI_NORETURN void _Exit(int /*status*/);
Xextern __declspec(__nothrow) __declspec(__noreturn) void _Exit(int  );
N   /*
N    * causes normal program termination to occur. No functions registered
N    * by the atexit function are called.
N    * In this implementation, all open output streams are flushed, all
N    * open streams are closed, and all files created by the tmpfile function
N    * are removed.
N    * Control is returned to the host environment. The status returned to
N    * the host environment is determined in the same way as for 'exit'.
N    */     
N
Nextern _ARMABI char *getenv(const char * /*name*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) char *getenv(const char *  ) __attribute__((__nonnull__(1)));
N   /*
N    * searches the environment list, provided by the host environment, for a
N    * string that matches the string pointed to by name. The set of environment
N    * names and the method for altering the environment list are
N    * implementation-defined.
N    * Returns: a pointer to a string associated with the matched list member.
N    *          The array pointed to shall not be modified by the program, but
N    *          may be overwritten by a subsequent call to the getenv function.
N    *          If the specified name cannot be found, a null pointer is
N    *          returned.
N    */
N
Nextern _ARMABI int  system(const char * /*string*/);
Xextern __declspec(__nothrow) int  system(const char *  );
N   /*
N    * passes the string pointed to by string to the host environment to be
N    * executed by a command processor in an implementation-defined manner.
N    * A null pointer may be used for string, to inquire whether a command
N    * processor exists.
N    *
N    * Returns: If the argument is a null pointer, the system function returns
N    *          non-zero only if a command processor is available. If the
N    *          argument is not a null pointer, the system function returns an
N    *          implementation-defined value.
N    */
N
Nextern _ARMABI_THROW void *bsearch(const void * /*key*/, const void * /*base*/,
Xextern  void *bsearch(const void *  , const void *  ,
N              size_t /*nmemb*/, size_t /*size*/,
N              int (* /*compar*/)(const void *, const void *)) __attribute__((__nonnull__(1,2,5)));
N   /*
N    * searches an array of nmemb objects, the initial member of which is
N    * pointed to by base, for a member that matches the object pointed to by
N    * key. The size of each member of the array is specified by size.
N    * The contents of the array shall be in ascending sorted order according to
N    * a comparison function pointed to by compar, which is called with two
N    * arguments that point to the key object and to an array member, in that
N    * order. The function shall return an integer less than, equal to, or
N    * greater than zero if the key object is considered, respectively, to be
N    * less than, to match, or to be greater than the array member.
N    * Returns: a pointer to a matching member of the array, or a null pointer
N    *          if no match is found. If two members compare as equal, which
N    *          member is matched is unspecified.
N    */
N#if defined(__cplusplus) && defined(__LANGUAGE_LINKAGE_CHANGES_FUNCTION_TYPE)
X#if 0L && 1L
S    /* bsearch that takes a ptr to a function with C++ linkage 
S     * but not in GNU mode
S     */
S    typedef int (* __C_compareprocptr)(const void *, const void *);
S    extern "C++"
S    void *bsearch(const void * __key, const void * __base,
S              size_t __nmemb, size_t __size,
S              int (* __compar)(const void *, const void *)) __attribute__((__nonnull__(1,2,5)));
S    extern "C++"
S    inline void *bsearch(const void * __key, const void * __base,
S              size_t __nmemb, size_t __size,
S              int (* __compar)(const void *, const void *)) {
S      return bsearch(__key, __base, __nmemb, __size, (__C_compareprocptr)__compar);
S    }
N#endif
N
N
Nextern _ARMABI_THROW void qsort(void * /*base*/, size_t /*nmemb*/, size_t /*size*/,
Xextern  void qsort(void *  , size_t  , size_t  ,
N           int (* /*compar*/)(const void *, const void *)) __attribute__((__nonnull__(1,4)));
N   /*
N    * sorts an array of nmemb objects, the initial member of which is pointed
N    * to by base. The size of each object is specified by size.
N    * The contents of the array shall be in ascending order according to a
N    * comparison function pointed to by compar, which is called with two
N    * arguments that point to the objects being compared. The function shall
N    * return an integer less than, equal to, or greater than zero if the first
N    * argument is considered to be respectively less than, equal to, or greater
N    * than the second. If two members compare as equal, their order in the
N    * sorted array is unspecified.
N    */
N
N#if defined(__cplusplus) && defined(__LANGUAGE_LINKAGE_CHANGES_FUNCTION_TYPE)
X#if 0L && 1L
S    /* qsort that takes a ptr to a function with C++ linkage 
S     * but not in GNU mode
S     */    
S    extern "C++"
S    void qsort(void * __base, size_t __nmemb, size_t __size,
S               int (* __compar)(const void *, const void *)) __attribute__((__nonnull__(1,4)));
S    extern "C++"
S    inline void qsort(void * __base, size_t __nmemb, size_t __size,
S                      int (* __compar)(const void *, const void *)) {
S      qsort(__base, __nmemb, __size, (__C_compareprocptr)__compar);
S    }
N#endif
N
Nextern _ARMABI_PURE int abs(int /*j*/);
Xextern __declspec(__nothrow) __attribute__((const)) int abs(int  );
N   /*
N    * computes the absolute value of an integer j. If the result cannot be
N    * represented, the behaviour is undefined.
N    * Returns: the absolute value.
N    */
N
Nextern _ARMABI_PURE div_t div(int /*numer*/, int /*denom*/);
Xextern __declspec(__nothrow) __attribute__((const)) div_t div(int  , int  );
N   /*
N    * computes the quotient and remainder of the division of the numerator
N    * numer by the denominator denom. If the division is inexact, the resulting
N    * quotient is the integer of lesser magnitude that is the nearest to the
N    * algebraic quotient. If the result cannot be represented, the behaviour is
N    * undefined; otherwise, quot * denom + rem shall equal numer.
N    * Returns: a structure of type div_t, comprising both the quotient and the
N    *          remainder. the structure shall contain the following members,
N    *          in either order.
N    *          int quot; int rem;
N    */
Nextern _ARMABI_PURE long int labs(long int /*j*/);
Xextern __declspec(__nothrow) __attribute__((const)) long int labs(long int  );
N   /*
N    * computes the absolute value of an long integer j. If the result cannot be
N    * represented, the behaviour is undefined.
N    * Returns: the absolute value.
N    */
N#ifdef __cplusplus
S   extern "C++" inline _ARMABI_PURE long abs(long int x) { return labs(x); }
N#endif
N
Nextern _ARMABI_PURE ldiv_t ldiv(long int /*numer*/, long int /*denom*/);
Xextern __declspec(__nothrow) __attribute__((const)) ldiv_t ldiv(long int  , long int  );
N   /*
N    * computes the quotient and remainder of the division of the numerator
N    * numer by the denominator denom. If the division is inexact, the sign of
N    * the resulting quotient is that of the algebraic quotient, and the
N    * magnitude of the resulting quotient is the largest integer less than the
N    * magnitude of the algebraic quotient. If the result cannot be represented,
N    * the behaviour is undefined; otherwise, quot * denom + rem shall equal
N    * numer.
N    * Returns: a structure of type ldiv_t, comprising both the quotient and the
N    *          remainder. the structure shall contain the following members,
N    *          in either order.
N    *          long int quot; long int rem;
N    */
N#ifdef __cplusplus
S   extern "C++" inline _ARMABI_PURE ldiv_t div(long int __numer, long int __denom) {
S       return ldiv(__numer, __denom);
S   }
N#endif
N
N#if !defined(__STRICT_ANSI__) || __USE_C99_STDLIB
X#if !0L || 1
Nextern _ARMABI_PURE __LONGLONG llabs(__LONGLONG /*j*/);
Xextern __declspec(__nothrow) __attribute__((const)) long long llabs(long long  );
N   /*
N    * computes the absolute value of a long long integer j. If the
N    * result cannot be represented, the behaviour is undefined.
N    * Returns: the absolute value.
N    */
N#ifdef __cplusplus
S   extern "C++" inline _ARMABI_PURE __LONGLONG abs(__LONGLONG x) { return llabs(x); }
N#endif
N
Nextern _ARMABI_PURE lldiv_t lldiv(__LONGLONG /*numer*/, __LONGLONG /*denom*/);
Xextern __declspec(__nothrow) __attribute__((const)) lldiv_t lldiv(long long  , long long  );
N   /*
N    * computes the quotient and remainder of the division of the numerator
N    * numer by the denominator denom. If the division is inexact, the sign of
N    * the resulting quotient is that of the algebraic quotient, and the
N    * magnitude of the resulting quotient is the largest integer less than the
N    * magnitude of the algebraic quotient. If the result cannot be represented,
N    * the behaviour is undefined; otherwise, quot * denom + rem shall equal
N    * numer.
N    * Returns: a structure of type lldiv_t, comprising both the quotient and the
N    *          remainder. the structure shall contain the following members,
N    *          in either order.
N    *          long long quot; long long rem;
N    */
N#ifdef __cplusplus
S   extern "C++" inline _ARMABI_PURE lldiv_t div(__LONGLONG __numer, __LONGLONG __denom) {
S       return lldiv(__numer, __denom);
S   }
N#endif
N#endif
N
N#if !(__ARM_NO_DEPRECATED_FUNCTIONS)
N/*
N * ARM real-time divide functions for guaranteed performance
N */
Ntypedef struct __sdiv32by16 { int quot, rem; } __sdiv32by16;
Ntypedef struct __udiv32by16 { unsigned int quot, rem; } __udiv32by16;
N   /* used int so that values return in separate regs, although 16-bit */
Ntypedef struct __sdiv64by32 { int rem, quot; } __sdiv64by32;
N
N__value_in_regs extern _ARMABI_PURE __sdiv32by16 __rt_sdiv32by16(
X__value_in_regs extern __declspec(__nothrow) __attribute__((const)) __sdiv32by16 __rt_sdiv32by16(
N     int /*numer*/,
N     short int /*denom*/);
N   /*
N    * Signed divide: (16-bit quot), (16-bit rem) = (32-bit) / (16-bit)
N    */
N__value_in_regs extern _ARMABI_PURE __udiv32by16 __rt_udiv32by16(
X__value_in_regs extern __declspec(__nothrow) __attribute__((const)) __udiv32by16 __rt_udiv32by16(
N     unsigned int /*numer*/,
N     unsigned short /*denom*/);
N   /*
N    * Unsigned divide: (16-bit quot), (16-bit rem) = (32-bit) / (16-bit)
N    */
N__value_in_regs extern _ARMABI_PURE __sdiv64by32 __rt_sdiv64by32(
X__value_in_regs extern __declspec(__nothrow) __attribute__((const)) __sdiv64by32 __rt_sdiv64by32(
N     int /*numer_h*/, unsigned int /*numer_l*/,
N     int /*denom*/);
N   /*
N    * Signed divide: (32-bit quot), (32-bit rem) = (64-bit) / (32-bit)
N    */
N#endif
N
N/*
N * ARM floating-point mask/status function (for both hardfp and softfp)
N */
Nextern _ARMABI unsigned int __fp_status(unsigned int /*mask*/, unsigned int /*flags*/);
Xextern __declspec(__nothrow) unsigned int __fp_status(unsigned int  , unsigned int  );
N   /*
N    * mask and flags are bit-fields which correspond directly to the
N    * floating point status register in the FPE/FPA and fplib.  
N    * __fp_status returns the current value of the status register,
N    * and also sets the writable bits of the word
N    * (the exception control and flag bytes) to:
N    *
N    *     new = (old & ~mask) ^ flags;
N    */
N#define __fpsr_IXE  0x100000
N#define __fpsr_UFE  0x80000
N#define __fpsr_OFE  0x40000
N#define __fpsr_DZE  0x20000
N#define __fpsr_IOE  0x10000
N
N#define __fpsr_IXC  0x10
N#define __fpsr_UFC  0x8
N#define __fpsr_OFC  0x4
N#define __fpsr_DZC  0x2
N#define __fpsr_IOC  0x1
N
N/*
N * Multibyte Character Functions.
N * The behaviour of the multibyte character functions is affected by the
N * LC_CTYPE category of the current locale. For a state-dependent encoding,
N * each function is placed into its initial state by a call for which its
N * character pointer argument, s, is a null pointer. Subsequent calls with s
N * as other than a null pointer cause the internal state of the function to be
N * altered as necessary. A call with s as a null pointer causes these functions
N * to return a nonzero value if encodings have state dependency, and a zero
N * otherwise. After the LC_CTYPE category is changed, the shift state of these
N * functions is indeterminate.
N */
Nextern _ARMABI int mblen(const char * /*s*/, size_t /*n*/);
Xextern __declspec(__nothrow) int mblen(const char *  , size_t  );
N   /*
N    * If s is not a null pointer, the mblen function determines the number of
N    * bytes compromising the multibyte character pointed to by s. Except that
N    * the shift state of the mbtowc function is not affected, it is equivalent
N    * to   mbtowc((wchar_t *)0, s, n);
N    * Returns: If s is a null pointer, the mblen function returns a nonzero or
N    *          zero value, if multibyte character encodings, respectively, do
N    *          or do not have state-dependent encodings. If s is not a null
N    *          pointer, the mblen function either returns a 0 (if s points to a
N    *          null character), or returns the number of bytes that compromise
N    *          the multibyte character (if the next n of fewer bytes form a
N    *          valid multibyte character), or returns -1 (they do not form a
N    *          valid multibyte character).
N    */
Nextern _ARMABI int mbtowc(wchar_t * __restrict /*pwc*/,
Xextern __declspec(__nothrow) int mbtowc(wchar_t * __restrict  ,
N                   const char * __restrict /*s*/, size_t /*n*/);
N   /*
N    * If s is not a null pointer, the mbtowc function determines the number of
N    * bytes that compromise the multibyte character pointed to by s. It then
N    * determines the code for value of type wchar_t that corresponds to that
N    * multibyte character. (The value of the code corresponding to the null
N    * character is zero). If the multibyte character is valid and pwc is not a
N    * null pointer, the mbtowc function stores the code in the object pointed
N    * to by pwc. At most n bytes of the array pointed to by s will be examined.
N    * Returns: If s is a null pointer, the mbtowc function returns a nonzero or
N    *          zero value, if multibyte character encodings, respectively, do
N    *          or do not have state-dependent encodings. If s is not a null
N    *          pointer, the mbtowc function either returns a 0 (if s points to
N    *          a null character), or returns the number of bytes that
N    *          compromise the converted multibyte character (if the next n of
N    *          fewer bytes form a valid multibyte character), or returns -1
N    *          (they do not form a valid multibyte character).
N    */
Nextern _ARMABI int wctomb(char * /*s*/, wchar_t /*wchar*/);
Xextern __declspec(__nothrow) int wctomb(char *  , wchar_t  );
N   /*
N    * determines the number of bytes need to represent the multibyte character
N    * corresponding to the code whose value is wchar (including any change in
N    * shift state). It stores the multibyte character representation in the
N    * array object pointed to by s (if s is not a null pointer). At most
N    * MB_CUR_MAX characters are stored. If the value of wchar is zero, the
N    * wctomb function is left in the initial shift state).
N    * Returns: If s is a null pointer, the wctomb function returns a nonzero or
N    *          zero value, if multibyte character encodings, respectively, do
N    *          or do not have state-dependent encodings. If s is not a null
N    *          pointer, the wctomb function returns a -1 if the value of wchar
N    *          does not correspond to a valid multibyte character, or returns
N    *          the number of bytes that compromise the multibyte character
N    *          corresponding to the value of wchar.
N    */
N
N/*
N * Multibyte String Functions.
N * The behaviour of the multibyte string functions is affected by the LC_CTYPE
N * category of the current locale.
N */
Nextern _ARMABI size_t mbstowcs(wchar_t * __restrict /*pwcs*/,
Xextern __declspec(__nothrow) size_t mbstowcs(wchar_t * __restrict  ,
N                      const char * __restrict /*s*/, size_t /*n*/) __attribute__((__nonnull__(2)));
N   /*
N    * converts a sequence of multibyte character that begins in the initial
N    * shift state from the array pointed to by s into a sequence of
N    * corresponding codes and stores not more than n codes into the array
N    * pointed to by pwcs. No multibyte character that follow a null character
N    * (which is converted into a code with value zero) will be examined or
N    * converted. Each multibyte character is converted as if by a call to
N    * mbtowc function, except that the shift state of the mbtowc function is
N    * not affected. No more than n elements will be modified in the array
N    * pointed to by pwcs. If copying takes place between objects that overlap,
N    * the behaviour is undefined.
N    * Returns: If an invalid multibyte character is encountered, the mbstowcs
N    *          function returns (size_t)-1. Otherwise, the mbstowcs function
N    *          returns the number of array elements modified, not including
N    *          a terminating zero code, if any.
N    */
Nextern _ARMABI size_t wcstombs(char * __restrict /*s*/,
Xextern __declspec(__nothrow) size_t wcstombs(char * __restrict  ,
N                      const wchar_t * __restrict /*pwcs*/, size_t /*n*/) __attribute__((__nonnull__(2)));
N   /*
N    * converts a sequence of codes that correspond to multibyte characters
N    * from the array pointed to by pwcs into a sequence of multibyte
N    * characters that begins in the initial shift state and stores these
N    * multibyte characters into the array pointed to by s, stopping if a
N    * multibyte character would exceed the limit of n total bytes or if a
N    * null character is stored. Each code is converted as if by a call to the
N    * wctomb function, except that the shift state of the wctomb function is
N    * not affected. No more than n elements will be modified in the array
N    * pointed to by s. If copying takes place between objects that overlap,
N    * the behaviour is undefined.
N    * Returns: If a code is encountered that does not correspond to a valid
N    *          multibyte character, the wcstombs function returns (size_t)-1.
N    *          Otherwise, the wcstombs function returns the number of bytes
N    *          modified, not including a terminating null character, if any.
N    */
N
Nextern _ARMABI void __use_realtime_heap(void);
Xextern __declspec(__nothrow) void __use_realtime_heap(void);
Nextern _ARMABI void __use_realtime_division(void);
Xextern __declspec(__nothrow) void __use_realtime_division(void);
Nextern _ARMABI void __use_two_region_memory(void);
Xextern __declspec(__nothrow) void __use_two_region_memory(void);
Nextern _ARMABI void __use_no_heap(void);
Xextern __declspec(__nothrow) void __use_no_heap(void);
Nextern _ARMABI void __use_no_heap_region(void);
Xextern __declspec(__nothrow) void __use_no_heap_region(void);
N
Nextern _ARMABI char const *__C_library_version_string(void);
Xextern __declspec(__nothrow) char const *__C_library_version_string(void);
Nextern _ARMABI int __C_library_version_number(void);
Xextern __declspec(__nothrow) int __C_library_version_number(void);
N
N    #ifdef __cplusplus
S         }  /* extern "C" */
S      }  /* namespace std */
N    #endif /* __cplusplus */
N  #endif /* __STDLIB_DECLS */
N
N  #if _AEABI_PORTABILITY_LEVEL != 0 && !defined _AEABI_PORTABLE
X  #if _AEABI_PORTABILITY_LEVEL != 0 && !0L
S    #define _AEABI_PORTABLE
N  #endif
N
N  #ifdef __cplusplus
S    #ifndef __STDLIB_NO_EXPORTS
S      #if !defined(__STRICT_ANSI__) || __USE_C99_STDLIB
S        using ::std::atoll;
S        using ::std::lldiv_t;
S      #endif /* !defined(__STRICT_ANSI__) || __USE_C99_STDLIB */
S      using ::std::div_t;
S      using ::std::ldiv_t;
S      using ::std::atof;
S      using ::std::atoi;
S      using ::std::atol;
S      using ::std::strtod;
S#if !defined(__STRICT_ANSI__) || __USE_C99_STDLIB
S      using ::std::strtof;
S      using ::std::strtold;
S#endif
S      using ::std::strtol;
S      using ::std::strtoul;
S      using ::std::strtoll;
S      using ::std::strtoull;
S      using ::std::rand;
S      using ::std::srand;
S      using ::std::_rand_state;
S      using ::std::_rand_r;
S      using ::std::_srand_r;
S      using ::std::_ANSI_rand_state;
S      using ::std::_ANSI_rand_r;
S      using ::std::_ANSI_srand_r;
S      using ::std::calloc;
S      using ::std::free;
S      using ::std::malloc;
S      using ::std::realloc;
S#if !defined(__STRICT_ANSI__)
S      using ::std::posix_memalign;
S#endif
S      using ::std::__heapprt;
S      using ::std::__heapstats;
S      using ::std::__heapvalid;
S      using ::std::abort;
S      using ::std::atexit;
S      using ::std::exit;
S      using ::std::_Exit;
S      using ::std::getenv;
S      using ::std::system;
S      using ::std::bsearch;
S      using ::std::qsort;
S      using ::std::abs;
S      using ::std::div;
S      using ::std::labs;
S      using ::std::ldiv;
S      #if !defined(__STRICT_ANSI__) || __USE_C99_STDLIB
S        using ::std::llabs;
S        using ::std::lldiv;
S      #endif /* !defined(__STRICT_ANSI__) || __USE_C99_STDLIB */
S#if !(__ARM_NO_DEPRECATED_FUNCTIONS)
S      using ::std::__sdiv32by16;
S      using ::std::__udiv32by16;
S      using ::std::__sdiv64by32;
S      using ::std::__rt_sdiv32by16;
S      using ::std::__rt_udiv32by16;
S      using ::std::__rt_sdiv64by32;
S#endif
S      using ::std::__fp_status;
S      using ::std::mblen;
S      using ::std::mbtowc;
S      using ::std::wctomb;
S      using ::std::mbstowcs;
S      using ::std::wcstombs;
S      using ::std::__use_realtime_heap;
S      using ::std::__use_realtime_division;
S      using ::std::__use_two_region_memory;
S      using ::std::__use_no_heap;
S      using ::std::__use_no_heap_region;
S      using ::std::__C_library_version_string;
S      using ::std::__C_library_version_number;
S      using ::std::size_t;
S      using ::std::__aeabi_MB_CUR_MAX;
S    #endif /* __STDLIB_NO_EXPORTS */
N  #endif /* __cplusplus */
N
N#undef __LONGLONG
N
N#endif /* __stdlib_h */
N
N/* end of stdlib.h */
L 7 "..\..\User\EDP\EdpKit.h" 2
N#include <stdio.h>
N#include <string.h>
N
N
N//=============================ÅäÖÃ==============================
N//===========¿ÉÒÔÌá¹©RTOSµÄÄÚ´æ¹ÜÀí·½°¸£¬Ò²¿ÉÒÔÊ¹ÓÃC¿âµÄ=========
N#include <stdlib.h>
N
N#define EDP_MallocBuffer	malloc
N
N#define EDP_FreeBuffer		free
N//==========================================================
N
N
N#define MOSQ_MSB(A)         (uint8)((A & 0xFF00) >> 8)
N#define MOSQ_LSB(A)         (uint8)(A & 0x00FF)
N
N
N/*--------------------------------ÏûÏ¢±àºÅ--------------------------------*/
N#define MSG_ID_HIGH			0x55
N#define MSG_ID_LOW			0xAA
N
N
N/*--------------------------------ÏûÏ¢ÀàÐÍ--------------------------------*/
N/* Á¬½ÓÇëÇó */
N#define CONNREQ             0x10
N/* Á¬½ÓÏìÓ¦ */
N#define CONNRESP            0x20
N/* ×ª·¢(Í¸´«)Êý¾Ý */
N#define PUSHDATA            0x30
N/* ´æ´¢(×ª·¢)Êý¾Ý */
N#define SAVEDATA            0x80
N/* ´æ´¢È·ÈÏ */
N#define SAVEACK             0x90
N/* ÃüÁîÇëÇó */
N#define CMDREQ              0xA0
N/* ÃüÁîÏìÓ¦ */
N#define CMDRESP             0xB0
N/* ÐÄÌøÇëÇó */
N#define PINGREQ             0xC0
N/* ÐÄÌøÏìÓ¦ */
N#define PINGRESP            0xD0
N/* ¼ÓÃÜÇëÇó */
N#define ENCRYPTREQ          0xE0
N/* ¼ÓÃÜÏìÓ¦ */
N#define ENCRYPTRESP         0xF0
N
N
N#ifndef NULL
S#define NULL (void*)0
N#endif
N
N
N/*--------------------------------SAVEDATAÏûÏ¢Ö§³ÖµÄ¸ñÊ½ÀàÐÍ--------------------------------*/
Ntypedef enum
N{
N	
N    kTypeFullJson = 0x01,
N	
N    kTypeBin = 0x02,
N	
N    kTypeSimpleJsonWithoutTime = 0x03,
N	
N    kTypeSimpleJsonWithTime = 0x04,
N	
N    kTypeString = 0x05
N	
N} SaveDataType;
N
N
N
N
N
N/*--------------------------------ÄÚ´æ·ÖÅä·½°¸±êÖ¾--------------------------------*/
N#define MEM_FLAG_NULL		0
N#define MEM_FLAG_ALLOC		1
N#define MEM_FLAG_STATIC		2
N
N
Ntypedef struct Buffer
N{
N	
N	uint8	*_data;		//Ð­ÒéÊý¾Ý
N	
N	uint32	_len;		//Ð´ÈëµÄÊý¾Ý³¤¶È
N	
N	uint32	_size;		//»º´æ×Ü´óÐ¡
N	
N	uint8	_memFlag;	//ÄÚ´æÊ¹ÓÃµÄ·½°¸£º0-Î´·ÖÅä	1-Ê¹ÓÃµÄ¶¯Ì¬·ÖÅä		2-Ê¹ÓÃµÄ¹Ì¶¨ÄÚ´æ
N	
N} EDP_PACKET_STRUCTURE;
N
N
N/*--------------------------------É¾°ü--------------------------------*/
Nvoid EDP_DeleteBuffer(EDP_PACKET_STRUCTURE *edpPacket);
N
N/*--------------------------------½â°ü--------------------------------*/
Nuint8 EDP_UnPacketRecv(uint8 *dataPtr);
N
N/*--------------------------------µÇÂ¼·½Ê½1×é°ü--------------------------------*/
Nuint1 EDP_PacketConnect1(const int8 *devid, const int8 *apikey, uint16 cTime, EDP_PACKET_STRUCTURE *edpPacket);
N
N/*--------------------------------µÇÂ¼·½Ê½2×é°ü--------------------------------*/
Nuint1 EDP_PacketConnect2(const int8 *devid, const int8 *auth_key, uint16 cTime, EDP_PACKET_STRUCTURE *edpPacket);
N
N/*--------------------------------Á¬½Ó»Ø¸´½â°ü--------------------------------*/
Nuint8 EDP_UnPacketConnectRsp(uint8 *rev_data);
N
N/*--------------------------------Êý¾ÝµãÉÏ´«×é°ü--------------------------------*/
Nuint8 EDP_PacketSaveData(const int8 *devid, int32 send_len, int8 *type_bin_head, SaveDataType type, EDP_PACKET_STRUCTURE *edpPacket);
N
N/*--------------------------------PushData×é°ü--------------------------------*/
Nuint8 EDP_PacketPushData(const int8 *devid, const int8 *msg, uint32 msg_len, EDP_PACKET_STRUCTURE *edpPacket);
N
N/*--------------------------------PushData½â°ü--------------------------------*/
Nuint8 EDP_UnPacketPushData(uint8 *rev_data, int8 **src_devid, int8 **req, uint32 *req_len);
N
N/*--------------------------------ÃüÁîÏÂ·¢½â°ü--------------------------------*/
Nuint8 EDP_UnPacketCmd(uint8 *rev_data, int8 **cmdid, uint16 *cmdid_len, int8 **req, uint32 *req_len);
N
N/*--------------------------------ÃüÁî»Ø¸´×é°ü--------------------------------*/
Nuint1 EDP_PacketCmdResp(const int8 *cmdid, uint16 cmdid_len, const int8 *resp, uint32 resp_len, EDP_PACKET_STRUCTURE *edpPacket);
N
N/*--------------------------------ÐÄÌøÇëÇó×é°ü--------------------------------*/
Nuint1  EDP_PacketPing(EDP_PACKET_STRUCTURE *edpPacket);
N
Nvoid hexdump(const unsigned char *buf, uint32 num);//16½øÖÆÊä³ö
N
N
N#endif
L 17 "..\..\User\main.c" 2
N//ÍøÂçÉè±¸
N#include "esp8266.h"
L 1 "..\..\User\device\inc\esp8266.h" 1
N#ifndef _ESP8266_H_
N#define _ESP8266_H_
N
N#include "stm32f10x.h"
N
N#define AT          "AT\r\n"	
N#define CWMODE      "AT+CWMODE=1\r\n"		//STA+APÄ£Ê½
N#define RST         "AT+RST\r\n"
N#define CIFSR       "AT+CIFSR\r\n"
N#define CWJAP       "AT+CWJAP=\"kkk\",\"789632145\"\r\n"	//ssid: onenet ÃÜÂë£º¿Õ
N#define CIPSTART    "AT+CIPSTART=\"TCP\",\"183.230.40.39\",876\r\n"	//EDP·þÎñÆ÷ 183.230.40.39/876
N#define CIPMODE0    "AT+CIPMODE=0\r\n"		//·ÇÍ¸´«Ä£Ê½
N#define CIPMODE1    "AT+CIPMODE=1\r\n"		//Í¸´«Ä£Ê½
N#define CIPSEND     "AT+CIPSEND\r\n"
N#define CIPSTATUS   "AT+CIPSTATUS\r\n"		//ÍøÂç×´Ì¬²éÑ¯
N#define QUITTRANS   "+++"//ÍË³öÍ¸´«
N
N/******************************** ESP8266 Á¬½ÓÒý½Å¶¨Òå ***********************************/
N#define      macESP8266_CH_PD_APBxClock_FUN                   RCC_APB2PeriphClockCmd
N#define      macESP8266_CH_PD_CLK                             RCC_APB2Periph_GPIOA  
N#define      macESP8266_CH_PD_PORT                            GPIOA
N#define      macESP8266_CH_PD_PIN                             GPIO_Pin_12
N
N#define      macESP8266_RST_APBxClock_FUN                     RCC_APB2PeriphClockCmd
N#define      macESP8266_RST_CLK                               RCC_APB2Periph_GPIOA
N#define      macESP8266_RST_PORT                              GPIOA
N#define      macESP8266_RST_PIN                               GPIO_Pin_11
N
N
N 
N
N#define      macESP8266_USART_BAUD_RATE                       115200
N
N#define      macESP8266_USARTx                                USART3
N#define      macESP8266_USART_APBxClock_FUN                   RCC_APB1PeriphClockCmd
N#define      macESP8266_USART_CLK                             RCC_APB1Periph_USART3
N#define      macESP8266_USART_GPIO_APBxClock_FUN              RCC_APB2PeriphClockCmd
N#define      macESP8266_USART_GPIO_CLK                        RCC_APB2Periph_GPIOB     
N#define      macESP8266_USART_TX_PORT                         GPIOB   
N#define      macESP8266_USART_TX_PIN                          GPIO_Pin_10
N#define      macESP8266_USART_RX_PORT                         GPIOB
N#define      macESP8266_USART_RX_PIN                          GPIO_Pin_11
N#define      macESP8266_USART_IRQ                             USART3_IRQn
N#define      macESP8266_USART_INT_FUN                         USART3_IRQHandler
N
N
N#define     macESP8266_CH_ENABLE()                 GPIO_SetBits ( macESP8266_CH_PD_PORT, macESP8266_CH_PD_PIN )
N#define     macESP8266_CH_DISABLE()                GPIO_ResetBits ( macESP8266_CH_PD_PORT, macESP8266_CH_PD_PIN )
N
N#define     macESP8266_RST_HIGH_LEVEL()            GPIO_SetBits ( macESP8266_RST_PORT, macESP8266_RST_PIN )
N#define     macESP8266_RST_LOW_LEVEL()             GPIO_ResetBits ( macESP8266_RST_PORT, macESP8266_RST_PIN )
N
N
N
N
N
N#define REV_OK		0	//½ÓÊÕÍê³É±êÖ¾
N#define REV_WAIT	1	//½ÓÊÕÎ´Íê³É±êÖ¾
N
N
Nvoid ESP8266_Init(void);
N
Nvoid ESP8266_Clear(void);
N
Nvoid ESP8266_SendData(unsigned char *data, unsigned short len);
N
Nunsigned char *ESP8266_GetIPD(unsigned short timeOut);
Nvoid ESP8266_EnterTrans(void);
Nvoid ESP8266_QuitTrans(void);
Nu8 Check_Wifi(void);
Nvoid reLink(void );
N
N
N
N
N#endif
L 19 "..\..\User\main.c" 2
N#include "M8266WIFIDrv.h"
L 1 "..\..\User\M8266WIFI\M8266WIFIDrv.h" 1
N/********************************************************************
N * M8266WIFIDrv.h
N * .Description
N *     Header file of M8266WIFI Dirver Layer
N * .Copyright(c) Anylinkin Technology 2015.5-
N *     IoT@anylinkin.com
N *     http://www.anylinkin.com
N *     http://anylinkin.taobao.com
N * .Author:	wzuo(wzuo@anylinkin.com, 1521340710@qq.com)
N * .History
N *     - 20181218 V1.1.8-G
N ********************************************************************/
N#ifndef _M8266WIFI_H_
N#define _M8266WIFI_H_
N
N//// Holtek HT32F16XX
N//#include "ht32f1655_56.h"
N
N//// TI's MSP430x1xx, MSP430x552x, TMS320F28335, which use usigned long for 32-bit
N//// C8051 Serials, which use usigned long for 32-bit
N//typedef unsigned char       uint8_t;
N//typedef unsigned int  	    uint16_t;
N//typedef unsigned long  	    uint32_t;
N//typedef   signed char       sint8_t;
N
N//Others which use unsigned int for 32-bit
Ntypedef unsigned char         uint8_t;
Ntypedef unsigned short int    uint16_t;
Ntypedef unsigned int          uint32_t;
Ntypedef   signed char         sint8_t;
N
Ntypedef uint32_t  	 u32;
Ntypedef uint16_t 	 u16;
Ntypedef uint8_t  	 u8;
Ntypedef sint8_t          s8;
N
N////////////////////////////////////////////////////////////////////////////////////
N////////////////////////////////////////////////////////////////////////////////////
N//   1. APIs releated to SPI Host I/F Function Configuration and Performance Test // 
N//       - M8266HostIf_SPI_Select                                        4.1.1    //
N//       - M8266WIFI_SPI_Interface_Communication_OK                      4.1.2    //
N//       - M8266WIFI_SPI_Interface_Communication_Stress_Test             4.1.3    //
N////////////////////////////////////////////////////////////////////////////////////
N////////////////////////////////////////////////////////////////////////////////////
N
N/***********************************************************************************
N * M8266HostIf_SPI_Select                                                          *
N * Description                                                                     *
N *  1.To specify the SPI used by providing the base address of SPI used            *
N *  2.Called when Initial M8266WIFI Module before perform SPI read/write           *
N * Parameter(s):                                                                   *
N *  1. spi_base_addr: the base address of used                                     *
N *     you may use M8266WIFI_INTERFACE_SPI defined in brd_cfg.h as example         *
N *  2. spi_clock: the spi_clock you set in HZ                                      *
N *     e.g.  10500000 for 10.5MHz                                                  *
N *  3. status when error                                                           *
N * Return:                                                                         *
N *   1. success                                                                    *
N *   0. failure                                                                    *
N ***********************************************************************************/
Nu8 M8266HostIf_SPI_Select(uint32_t spi_base_addr, uint32_t spi_clock, u16* status);
N
N/***********************************************************************************
N * M8266WIFI_SPI_Interface_Communication_OK                                        *
N * Description                                                                     *
N *  1. To write a byte and then read out from M8266WIFI module SPI registers       *
N *     to check whether the logical fundamentai SPI communication (read/write)     *
N *     is stablly OK under the clock and interconnection                           *
N *  2. Called during the initialization of M8266WIFI Module                        *
N *     DONOT CALL IT AFTER MODULE HAS STARTED THE NORMAL OPERATION                 *
N * Parameter(s):                                                                   *
N *  1. byte:  a pointer to the byte read out during test                           *
N *     - normally the data should be 0x41 during test.                             *
N *       if it is 0x41, this function will return 1 for success as well            *
N *     - If readout other value, it may indicating the fundamental SPI             *
N *       communication is not OK. e.g. 0xFF may indicates that your spi            *
N *       port has problem such incoreect interconnection or initialization         *
N *     - user NULL if you don't expect this data                                   * 
N * Return:                                                                         *
N *   1. success                                                                    *
N *   0. failure                                                                    *
N ***********************************************************************************/
Nu8 M8266WIFI_SPI_Interface_Communication_OK(u8* byte);	
N
N/***********************************************************************************
N * M8266WIFI_SPI_Interface_Communication_Stress_Test                               *
N * Description                                                                     *
N *  1. To perform a batch of byte write and then read out from M8266WIFI module    *
N *     SPI register to check whether the high-speed and bulk fundamentai SPI       *
N *     communication (read/write) is stablly OK under the clock                    *
N *  2. Called during the initialization of M8266WIFI Module                        *
N *     DONOT CALL IT AFTER MODULE HAS STARTED THE NORMAL OPERATION                 *
N *  3. You may call it in your debug code for speed stablility test                *
N *     during your stress performance test to your produc                          * 
N * Parameter(s):                                                                   *
N *  1. max_times:  the max write-read times used for the stress test               *
N *     - And the test data to be written will be nimber byte of data               *
N *       from 0 to  max_times                                                      *
N * Return:                                                                         *
N *  1. success times of write-read-verify                                          *
N ***********************************************************************************/
Nu32 M8266WIFI_SPI_Interface_Communication_Stress_Test(u32 max_times);
N
N
N////////////////////////////////////////////////////////////////////////////////////
N////////////////////////////////////////////////////////////////////////////////////
N//   2. APIs releated to Module WIFI fundamental Query and Configurations via SPI //
N//       - M8266WIFI_SPI_Get_Opmode                                      4.2.1    //
N//       - M8266WIFI_SPI_Set_Opmode                                      4.2.2    //
N//                                                                                //
N//       - M8266WIFI_SPI_STA_Connect_Ap                                  4.2.3    //
N//       - M8266WIFI_SPI_STA_DisConnect_Ap                               4.2.4    //
N//       - M8266WIFI_SPI_Config_STA_StaticIpAddr                         4.2.5    //
N//       - M8266WIFI_SPI_Query_STA_Dhcpc                                 4.2.6    //
N//       - M8266WIFI_SPI_Enable_STA_Dhcpc                                4.2.7    //
N//       - M8266WIFI_SPI_Get_STA_Connection_Status                       4.2.8    //
N//       - M8266WIFI_SPI_Get_STA_IP_Addr                                 4.2.9    //
N//       - M8266WIFI_SPI_STA_Query_Current_SSID_And_RSSI                 4.2.10   //
N//       - M8266WIFI_SPI_STA_Scan_Signals                                4.2.11   //
N//       - M8266WIFI_SPI_STA_Fetch_Last_Scanned_Signals                  4.2.12   //
N//       - M8266WIFI_SPI_Set_STA_Hostname                                4.2.13   //
N//       - M8266WIFI_SPI_Get_STA_Hostname                                4.2.14   //
N//       - M8266WIFI_SPI_Query_STA_Param                                 4.2.15   //
N//                                                                                //
N//       - M8266WIFI_SPI_Config_AP                                  		 4.2.16   //
N//       - M8266WIFI_SPI_Query_AP_Param                             		 4.2.17   //
N//       - M8266WIFI_SPI_Config_AP_Param                             		 4.2.18   //
N//       - M8266WIFI_SPI_AP_List_STAs_Info                               4.2.19   //
N////////////////////////////////////////////////////////////////////////////////////
N////////////////////////////////////////////////////////////////////////////////////
N
N/***********************************************************************************
N * M8266WIFI_SPI_Get_Opmode                                                        *
N * .Description:                                                                   *
N *     To get the op_mode(STA, AP, or STA+AP) of M8266WIFI module via SPI          *
N * .Parameter(s)                                                                   *
N *     1. op_mode : pointer to the op_mode returned                                *
N *        =1, 			STA mode                                                       *
N *        =2, 			AP mode                                                        *
N *        =3, 			STA+AP mode                                                    *
N *     2. status  : pointer to return errcode(LSB) and status(MSB) upon error      *
N *                  Use NULL if you don't expect them returned                     *
N * .Return value:                                                                  *
N *     =1, success                                                                 *
N *     =0, has error(s)                                                            *
N ***********************************************************************************/
Nu8 M8266WIFI_SPI_Get_Opmode(u8* op_mode, u16* status);
N
N/***********************************************************************************
N * M8266WIFI_SPI_Set_Opmode                                                        *
N * .Description:                                                                   *
N *     To set op_mode(STA, AP, or STA+AP) of M8266WIFI module via SPI              *
N * .Parameter(s)                                                                   *
N *     1. op_mode : the op_mode to set                                             *
N *        =1, 			set to STA mode                                                *
N *        =2, 			set to AP mode                                                 *
N *        =3, 			set to STA+AP mode                                             *
N *        =others, 	set to STA+AP mode                                             *
N *     2. saved   : to save into flash the opmode or not                           *
N *        =0,       not saved, i.e. after reboot setting will restore to previous  *
N *        =others,  saved, i.e. after reboot, the saved setting will be loaded     *
N *                  PLEASE DO NOT CALL IT EACH TIME OF BOOTUP WITH SAVED != 0      *
N *                  OR, THE FLASH ON MODULE MIGHT GO TO FAILURE DUE TO LIFT CYCLE  *
N *                  OF WRITE                                                       *
N *     3. status  : pointer to return errcode(LSB) and status(MSB) upon error      *
N *                  Use NULL if you don't expect them returned                     *
N * .Return value:                                                                  *
N *     =1, success                                                                 *
N *     =0, has error(s)                                                            *
N ***********************************************************************************/
Nu8 M8266WIFI_SPI_Set_Opmode(u8 op_mode, u8 saved, u16* status);
N
N/***********************************************************************************
N * M8266WIFI_SPI_STA_Connect_Ap                                                    *
N * .Description:                                                                   *
N *     To connect the M8266WIFI STA to an AP or router via SPI                     *
N * .Parameter(s)                                                                   *
N *     1. ssid    : the ssid of AP connected to. Max len = 32 Bytes                *
N *                  use NULL if use last connected ssid(without reboot)            *
N *     2. password: the passowrd of AP connecting to. Max len = 64 Bytes           *
N *                  use NULL if use last connected ssid(without reboot)            *
N *     3. saved   : to save the ssid and password into flash the opmode or not     *
N *        =0,       not saved, i.e. after reboot setting will restore to previous  *
N *        =others,  saved, i.e. after reboot, the saved setting will be loaded     *
N *                  PLEASE DO NOT CALL IT EACH TIME OF BOOTUP WITH SAVED != 0      *
N *                  OR, THE FLASH ON MODULE MIGHT GO TO FAILURE DUE TO LIFT CYCLE  *
N *                  OF WRITE                                                       *
N *     4. timeout_in_s: max time in seconds waiting for being connected            *
N *     5. status  : pointer to return errcode(LSB) and status(MSB) upon error      *
N *                  Use NULL if you don't expect them returned                     *
N *                  errcode(LSB)                                                   *
N *                    = 0x32, if connect timeout                                   *
N *                    = 0x4A, if SSID not found or not present                     *
N *                    = 0x4B, if SSID found but authentication failed,wrong password*
N *                    = 0x4C, if module in AP Only mode                            *
N *                    = 0x4D, if failed due to other reasons                       *
N * .Return value:                                                                  *
N *     =1, success                                                                 *
N *     =0, has error(s)                                                            *
N ***********************************************************************************/
Nu8 M8266WIFI_SPI_STA_Connect_Ap(u8 ssid[32], u8 password[64], u8 saved, u8 timeout_in_s, u16* status);
N
N/***********************************************************************************
N * M8266WIFI_SPI_STA_DisConnect_Ap                                                 *
N * .Description:                                                                   *
N *     To DisConnect the M8266WIFI STA from an AP or router via SPI                *
N * .Parameter(s)                                                                   *
N *     1. status  : pointer to return errcode(LSB) and status(MSB) upon error      *
N *                  Use NULL if you don't expect them returned                     *
N * .Return value:                                                                  *
N *     =1, success                                                                 *
N *     =0, has error(s)                                                            *
N ***********************************************************************************/
Nu8 M8266WIFI_SPI_STA_DisConnect_Ap(u16* status);
N
N/***********************************************************************************
N * M8266WIFI_SPI_Config_STA_StaticIpAddr                                           *
N * .Description:                                                                   *
N *     To config ip addresses of the module STA via SPI                            *
N * .Parameter(s)                                                                   *
N *     1. ip_addr : the ip address to set                                 				 *
N *                  - SHOULD be string like "192.168.1.103"                        *
N *                  - USE NULL if don't expect to set it                           *
N *     2. gw_addr : the gateway address to set                             				 *
N *                  - SHOULD be string like "192.168.1.1"                          *
N *                  - USE NULL if don't expect to set it                           *
N *     3. netmask : the netmask address to set                             				 *
N *                  - SHOULD be string like "255.255.255.0"                        *
N *                  - USE NULL if don't expect to set it                           *
N *     4  saved                                                                    *
N *             = 0,      config not saved, only this time valid                    *
N *             = others, config be saved, and valid upon next boot                 *
N *               if saved,  module bootup with dhcp diabled using stored           *
N *                          ip address                                             *
N *                  PLEASE DO NOT CALL IT EACH TIME OF BOOTUP WITH SAVED != 0      *
N *                  OR, THE FLASH ON MODULE MIGHT GO TO FAILURE DUE TO LIFT CYCLE  *
N *                  OF WRITE                                                       *
N *     5. status  : pointer to return errcode(LSB) and status(MSB) upon error      *
N *                  Use NULL if you don't expect them returned                     *
N * .Return value:                                                                  *
N *     =1, success                                                                 *
N *     =0, has error(s)                                                            *
N * .Note(s):                                                                       *
N *     Call this API will disable the dhcpc                                        *
N ***********************************************************************************/
Nu8 M8266WIFI_SPI_Config_STA_StaticIpAddr(char* ip_addr, char* gw_addr, char* netmask, u8 saved, u16* status);
N//below macro used to keep compatible with previous API
N#define M8266WIFI_SPI_Config_STA_Static_IP_Addr(ip_addr, gw_addr, netmask, status)  M8266WIFI_SPI_Config_STA_StaticIpAddr(ip_addr,gw_addr,netmask,0,status)
N
N/***********************************************************************************
N * M8266WIFI_SPI_Query_STA_Dhcpc         	                                         *
N * .Description:                                                                   *
N *     To query whether the dhcpc enabled or not of the module STA via SPI         *
N * .Parameter(s)                                                                   *
N *     1. enable: pointer to return whether diabled or not           				       *
N *             = 0, dhcpc disabled                                                 *
N *             = 1, dhcpc enabled                                                  *
N *     2. status  : pointer to return errcode(LSB) and status(MSB) upon error      *
N *                  Use NULL if you don't expect them returned                     *
N * .Return value:                                                                  *
N *     =1, success                                                                 *
N *     =0, has error(s)                                                            *
N ***********************************************************************************/
Nu8 M8266WIFI_SPI_Query_STA_Dhcpc(u8* enabled, u16* status);
N
N/***********************************************************************************
N * M8266WIFI_SPI_Enable_STA_Dhcpc       	                                         *
N * .Description:                                                                   *
N *     To enable or diable the dhcpc of the module STA via SPI                     *
N * .Parameter(s)                                                                   *
N *     1. enable                                                     				       *
N *             = 0,      disable the dhcpc, and module uses static ip address      *
N *             = others, enable  the dhcpc, and mdule uses ip address via dhcp     *
N *     2  saved                                                                    *
N *             = 0,      config not saved, only this time valid                    *
N *             = others, config be saved, and valid upon next boot                 *
N *               kindly reminded that:                                             *
N *               - if saved=1 with enable=1, module bootup with dhcp enabled       *
N *               - if saved=1 with enable=0, module bootup with dhcp disabled      *
N *                 and using previous stored static ip address by                  *
N *                 M8266WIFI_SPI_Config_STA_StaticIpAddr with saved != 0           *
N *                 So, make sure an valid static ip address stored before          *
N *               -  PLEASE DO NOT CALL IT EACH TIME OF BOOTUP WITH SAVED != 0      *
N *                  OR, THE FLASH ON MODULE MIGHT GO TO FAILURE DUE TO LIFT CYCLE  *
N *                  OF WRITE                                                       *
N *     3. status  : pointer to return errcode(LSB) and status(MSB) upon error      *
N *                  Use NULL if you don't expect them returned                     *
N * .Return value:                                                                  *
N *     =1, success                                                                 *
N *     =0, has error(s)                                                            *
N ***********************************************************************************/
N u8 M8266WIFI_SPI_Enable_STA_Dhcpc(u8 enable, u8 saved, u16* status);
N
N/***********************************************************************************
N * M8266WIFI_SPI_Get_STA_Connection_Status                                         *
N * .Description:                                                                   *
N *     To get the connecting status of M8266WIFI STA to AP or routers via SPI      *
N * .Parameter(s)                                                                   *
N *     1. connection_status :  the connection status returned                      *
N *          =0, if station is in idle                                              *
N *          =1, if station is connecting to an AP                                  *
N *          =2, if station is to connect to an AP but with an wrong password       *
N *          =3, if station is to connect to an AP which is not found               *
N *          =4, if station failed to connect to the AP                             *
N *          =5, if station is connected to the AP and has got the IP successfully  *
N *          =255, if the module is in AP-only mode                                 *
N *     2. status  : pointer to return errcode(LSB) and status(MSB) upon error      *
N *                  Use NULL if you don't expect them returned                     *
N * .Return value:                                                                  *
N *     =1, success                                                                 *
N *     =0, has error(s)                                                            *
N ***********************************************************************************/
Nu8 M8266WIFI_SPI_Get_STA_Connection_Status(u8* connection_status, u16* status);
Ntypedef enum{
N	STA_AP_STATUS_IDLE = 0,
N	STA_AP_STATUS_CONNECTING = 1,
N	STA_AP_STATUS_PASSWORD = 2,
N	STA_AP_STATUS_FOUND = 3,
N	STA_AP_STATUS_FAILED = 4,
N	STA_AP_STATUS_CONNECTED = 5,
N}STA_AP_STATUS;
N
N/***********************************************************************************
N * M8266WIFI_SPI_Get_STA_IP_Addr                                                   *
N * .Description:                                                                   *
N *     To get ip address of M8266WIFI STA via SPI                                  *
N * .Parameter(s)                                                                   *
N *     1. sta_ip :  the sta ip address returned if successful                      *
N *                  "0.0.0.0" returned if in AP-only mode or ip not achieved       *
N *     2. status  : pointer to return errcode(LSB) and status(MSB) upon error      *
N *                  Use NULL if you don't expect them returned                     *
N * .Return value:                                                                  *
N *     =1, success                                                                 *
N *     =0, has error(s)                                                            *
N ***********************************************************************************/
Nu8 M8266WIFI_SPI_Get_STA_IP_Addr(char* sta_ip , u16* status);
N
N/***********************************************************************************
N * M8266WIFI_SPI_STA_Query_Current_SSID_And_RSSI                                   *
N * .Description:                                                                   *
N *     To get current AP info (SSID and RSSI) M8266WIFI STA connected to           *
N * .Parameter(s)                                                                   *
N *     1. ssid    : the current SSID returned which m8266wifi sta connected to     *
N *     2. rssi    : the rssi of current connected ssid. 31 if error                *
N *     3. status  : pointer to return errcode(LSB) and status(MSB) upon error      *
N *                  Use NULL if you don't expect them returned                     *
N * .Return value:                                                                  *
N *     =1, success                                                                 *
N *     =0, has error(s)                                                            *
N ***********************************************************************************/
Nu8 M8266WIFI_SPI_STA_Query_Current_SSID_And_RSSI(char* ssid, s8* rssi, u16* status);
N
N/***********************************************************************************
N * M8266WIFI_SPI_STA_Scan_Signals                                                  *
N * .Description:                                                                   *
N *     To perform a scanning procedure, the scanned signals sorted by rssi         *
N * .Parameter(s)                                                                   *
N *     1. scanned_signals : the return signals after scanning                      *
N *     2. max_signals     : max counts of signals to scan                          *
N *     3. channel         : channel to scan. USE 0xFF to scan all channles         *
N *     4. timeout_in_s    : time out in seconds                                    *
N *     5. status  : pointer to return errcode(LSB) and status(MSB) upon error      *
N *                  Use NULL if you don't expect them returned                     *
N *                  Upon failure with status!=NULL:                                *
N *                  errcode(LSB)=0x3E, if start scan failed                        *
N *                              =0x27, if last scan result has failure             *
N *                              =0x28, if scan timeout                             *
N *                              =0x29, other failure                               *
N * .Return value:                                                                  *
N *    !=0, signal numbers scanned succesfully                                      *
N *     =0, has error(s)                                                            *
N ***********************************************************************************/
N struct ScannedSigs{
N	char ssid[32];
N	u8   channel;
N	u8   authmode;
N	s8   rssi;
N};
Nu8 M8266WIFI_SPI_STA_Scan_Signals(struct ScannedSigs scanned_signals[], u8 max_signals, 
N																  u8 channel, u8 timeout_in_s, u16* status);
N
N/***********************************************************************************
N * M8266WIFI_SPI_STA_Fetch_Last_Scanned_Signals                                    *
N * .Description:                                                                   *
N *     To Fetch the signals last scanned if not fetched before                     *
N * .Parameter(s)                                                                   *
N *     1. scanned_signals : the return signals after scanning                      *
N *     2. max_signals     : max counts of signals to scan                          *
N *     3. status  : pointer to return errcode(LSB) and status(MSB) upon error      *
N *                  Use NULL if you don't expect them returned                     *
N *                  Upon failure with status!=NULL:                                *
N *                  errcode(LSB)=0x25, if not start scan before                    *
N *                              =0x26, if currently module is scanning             *
N *                              =0x27, if last scan result has failure             *
N *                              =0x29, other failure                               *
N * .Return value:                                                                  *
N *    !=0, signal numbers fetched succesfully                                      *
N *     =0, has error(s)                                                            *
N ***********************************************************************************/
Nu8 M8266WIFI_SPI_STA_Fetch_Last_Scanned_Signals(struct ScannedSigs scanned_signals[], u8 max_signals, u16* status);
N
N/**********************************************************************************
N * M8266WIFI_SPI_Get_STA_Hostname								                                  *
N * .Description:																																	*
N *     To get the hostname of the STA via SPI                                     *
N *     Note: Will return failure if module in AP-Only Mode                        *
N * .Parameter(s)																																	*
N *     1. hostbame 		: the hostame to get  		       														*
N *     2. status  		: pointer to the status upon failure												*
N * .Return value:																																	*
N *     =1, success																																*
N *     =0, has error(s)																														*
N **********************************************************************************/
Nu8 M8266WIFI_SPI_Get_STA_Hostname(char hostname[28+1], u16* status);
N
N/**********************************************************************************
N * M8266WIFI_SPI_Set_STA_Hostname								                                  *
N * .Description:																																	*
N *     To set up the hostname of the STA via SPI                                  *
N *     Note: Will return failure if module in AP-Only Mode                        *
N * .Parameter(s)																																	*
N *     1. hostbame 		: the hostame to setup		       														*
N *     2. status  		: pointer to the status upon failure												*
N * .Return value:																																	*
N *     =1, success																																*
N *     =0, has error(s)																														*
N **********************************************************************************/
Nu8 M8266WIFI_SPI_Set_STA_Hostname(char hostname[28+1], u16* status);
N
N/***********************************************************************************
N * M8266WIFI_SPI_Query_STA_Param                                                   *
N * .Description:                                                                   *
N *     To query a parameter of the module STA via SPI                              *
N * .Parameter(s)                                                                   *
N *     1. param_type : the parame type to set, enum of STA_PARAM_TYPE      				 *
N *                      STA_PARAM_TYPE_SSID					= 0,                           *
N *                      STA_PARAM_TYPE_PASSWORD			= 1,                           *
N *                      STA_PARAM_TYPE_CHANNEL			= 2,                           *
N *                      STA_PARAM_TYPE_HOSTNAME			= 3,                           *
N *										 	STA_PARAM_TYPE_USE_BSSID		= 4,													 *
N *                      STA_PARAM_TYPE_BSSID				= 5,													 *
N *											STA_PARAM_TYPE_RSSI					= 6,													 *
N *											STA_PARAM_TYPE_IP_ADDR			= 7,													 *
N *                      STA_PARAM_TYPE_GATEWAY_ADDR	= 8,                           *
N *                      STA_PARAM_TYPE_NETMASK_ADDR	= 9,                           * 
N *                     	STA_PARAM_TYPE_MAC					= 11,                          *
N *     2. param      : pointer to the param value returned                         *
N *     3. param_len  : pointer to length the param, unit in bytes                  *
N *     4. status  : pointer to return errcode(LSB) and status(MSB) upon error      *
N *                  Use NULL if you don't expect them returned                     *
N * .Return value:                                                                  *
N *     =1, success                                                                 *
N *     =0, has error(s)                                                            *
N ***********************************************************************************/
Ntypedef enum{
N	STA_PARAM_TYPE_SSID						= 0,
N	STA_PARAM_TYPE_PASSWORD				= 1,
N	STA_PARAM_TYPE_CHANNEL				= 2,
N	STA_PARAM_TYPE_HOSTNAME				= 3,
N	STA_PARAM_TYPE_USE_BSSID			= 4,
N	STA_PARAM_TYPE_BSSID					= 5,
N	STA_PARAM_TYPE_RSSI						= 6,
N	STA_PARAM_TYPE_IP_ADDR				= 7,
N	STA_PARAM_TYPE_GATEWAY_ADDR		= 8,
N	STA_PARAM_TYPE_NETMASK_ADDR		= 9,
N	STA_PARAM_TYPE_DHCPC					= 10,
N	STA_PARAM_TYPE_MAC						= 11,
N}STA_PARAM_TYPE;
Nu8 M8266WIFI_SPI_Query_STA_Param(STA_PARAM_TYPE param_type, u8* param, u8* param_len, u16* status);
N
N/***********************************************************************************
N * M8266WIFI_SPI_Config_AP                                                         *
N * .Description:                                                                   *
N *     To config the module AP via SPI                                             *
N * .Parameter(s)                                                                   *
N *     1. ssid    : the ssid of AP, Max Size=13 Bytes                              *
N *     2. password: the passowrd of AP, Max Size=13 Bytes                          *
N *     3. enc     : authorisation mode, valid value is 0~4                         *
N *                  = 0, OPEN                                                      *
N *                  = 1, WEP                                                       *
N *                  = 2, WPA_PSK                                                   *
N *                  = 3, WPA2_PSK                                                  *
N *                  = 4, WPA_WPA2_PSK                                              *
N *                  = others, OPEN                                                 *
N *     4. channel: the channel of AP, valid value is 1~13.                         *
N *        - Value other than 1~13 will set to channel 6                            *
N *     5. saved   : to save the ssid and password into flash the opmode or not     *
N *        =0,       not saved, i.e. after reboot setting will restore to previous  *
N *        =others,  saved, i.e. after reboot, the saved setting will be loaded     *
N *                  PLEASE DO NOT CALL IT EACH TIME OF BOOTUP WITH SAVED != 0      *
N *                  OR, THE FLASH ON MODULE MIGHT GO TO FAILURE DUE TO LIFT CYCLE  *
N *                  OF WRITE                                                       *
N *     6. status  : pointer to return errcode(LSB) and status(MSB) upon error      *
N *                  Use NULL if you don't expect them returned                     *
N * .Return value:                                                                  *
N *     =1, success                                                                 *
N *     =0, has error(s)                                                            *
N ***********************************************************************************/
Nu8 M8266WIFI_SPI_Config_AP(u8 ssid[13+1], u8 password[13+1], u8 enc, u8 channel, u8 saved, u16* status);
N
Ntypedef enum{
N	AP_PARAM_TYPE_SSID 						= 0,
N	AP_PARAM_TYPE_PASSWORD 				= 1,
N	AP_PARAM_TYPE_CHANNEL 				= 2,
N	AP_PARAM_TYPE_AUTHMODE 				= 3,
N	AP_PARAM_TYPE_SSID_HIDDEN 		= 4,
N	AP_PARAM_TYPE_MAX_CONNECT 		= 5,
N	AP_PARAM_TYPE_BEACON_INTERVAL = 6,	
N	AP_PARAM_TYPE_IP_ADDR					= 7,
N  AP_PARAM_TYPE_GATEWAY_ADDR	  = 8,
N  AP_PARAM_TYPE_NETMASK_ADDR	  = 9,
N  AP_PARAM_TYPE_PHY_MODE			  = 10,
N  AP_PARAM_TYPE_MAC						  = 11
N}AP_PARAM_TYPE; 
N/***********************************************************************************
N * M8266WIFI_SPI_Query_AP_Param                                                    *
N * .Description:                                                                   *
N *     To query a parameter of the module AP via SPI                               *
N * .Parameter(s)                                                                   *
N *     1. param_type : the parame type to set, enum of AP_PARAM_TYPE       				 *
N *                      AP_PARAM_TYPE_SSID 						= 0,												 *
N *                      AP_PARAM_TYPE_PASSWORD 				= 1,												 *
N *                      AP_PARAM_TYPE_CHANNEL 				= 2,												 *
N *                      AP_PARAM_TYPE_AUTHMODE 				= 3,												 *
N *                      AP_PARAM_TYPE_SSID_HIDDEN 		= 4,												 *
N *                      AP_PARAM_TYPE_MAX_CONNECT 		= 5,												 *
N *                      AP_PARAM_TYPE_BEACON_INTERVAL = 6,												 *
N *                      AP_PARAM_TYPE_IP_ADDR					= 7,											   *
N *                      AP_PARAM_TYPE_GATEWAY_ADDR	  = 8,                         *
N *                      AP_PARAM_TYPE_NETMASK_ADDR	  = 9,                         *
N *                      AP_PARAM_TYPE_PHY_MODE			  = 10,												 *
N *                      AP_PARAM_TYPE_MAC						  = 11												 *
N *     2. param      : pointer to the param value returned                         *
N *     3. param_len  : pointer to length the param, unit in bytes                  *
N *     4. status  : pointer to return errcode(LSB) and status(MSB) upon error      *
N *                  Use NULL if you don't expect them returned                     *
N * .Return value:                                                                  *
N *     =1, success                                                                 *
N *     =0, has error(s)                                                            *
N ***********************************************************************************/
Nu8 M8266WIFI_SPI_Query_AP_Param(AP_PARAM_TYPE param_type, u8* param, u8* param_len, u16* status);
N
N/***********************************************************************************
N * M8266WIFI_SPI_Config_AP_Param                                                   *
N * .Description:                                                                   *
N *     To config a parameter of the module AP via SPI                              *
N * .Parameter(s)                                                                   *
N *     1. param_type : the parame type to set, enum of AP_PARAM_TYPE       				 *
N *                      AP_PARAM_TYPE_SSID 						= 0,												 *
N *                      AP_PARAM_TYPE_PASSWORD 				= 1,												 *
N *                      AP_PARAM_TYPE_CHANNEL 				= 2,												 *
N *                      AP_PARAM_TYPE_AUTHMODE 				= 3,												 *
N *                      AP_PARAM_TYPE_SSID_HIDDEN 		= 4,												 *
N *                      AP_PARAM_TYPE_MAX_CONNECT 		= 5,												 *
N *                      AP_PARAM_TYPE_BEACON_INTERVAL = 6,												 *
N *                      AP_PARAM_TYPE_IP_ADDR					= 7												   *
N *                      AP_PARAM_TYPE_GATEWAY_ADDR	  = 8,                         *
N *                      AP_PARAM_TYPE_NETMASK_ADDR	  = 9,                         * 
N *     2. param      : pointer to the param value                                  *
N *     3. param_len  : length the param, unit in bytes                             *
N *     4. saved   : to save the param into flash or not												     *
N *        =0,       not saved, i.e. after reboot setting will restore to previous  *
N *        =others,  saved, i.e. after reboot, the saved setting will be loaded     *
N *                  PLEASE DO NOT CALL IT EACH TIME OF BOOTUP WITH SAVED != 0      *
N *                  OR, THE FLASH ON MODULE MIGHT GO TO FAILURE DUE TO LIFT CYCLE  *
N *                  OF WRITE                                                       *
N *     5. status  : pointer to return errcode(LSB) and status(MSB) upon error      *
N *                  Use NULL if you don't expect them returned                     *
N * .Return value:                                                                  *
N *     =1, success                                                                 *
N *     =0, has error(s)                                                            *
N ***********************************************************************************/
Nu8 M8266WIFI_SPI_Config_AP_Param(AP_PARAM_TYPE param_type, u8* param, u8 param_len, u8 saved, u16* status);
N
N/***********************************************************************************
N * M8266WIFI_SPI_AP_List_STAs_Info                                                 *
N * .Description:                                                                   *
N *     To list the STAs connected to the moduel AP                                 *
N * .Parameter(s)                                                                   *
N *     1. sta_list   : pointer to the array of struct CONNECTED_STATION_INFO       *
N *                     which will store the returned station infos                 *
N *     2. stas       : sum of return stations                                      *
N *     3. max_states : max number of stations to returned                          *
N *     4. status     : pointer to return errcode(LSB) and status(MSB) upon error   *
N *                     Use NULL if you don't expect them returned                  *
N *                      - LSB = 0x2A: module does not include ap mode              *
N*                             = 0x2C: other failures                               *
N * .Return value:                                                                  *
N *     =1, success                                                                 *
N *     =0, has error(s)                                                            *
N ***********************************************************************************/
Nstruct CONNECTED_STATION_INFO{
N	u8 bssid[6];
N	u8 ipaddr[4];
N};
Nu8 M8266WIFI_SPI_AP_List_STAs_Info(struct CONNECTED_STATION_INFO* sta_list, u8* stas, u8 max_stas, u16* status);
N
N////////////////////////////////////////////////////////////////////////////////////
N////////////////////////////////////////////////////////////////////////////////////
N//   3. APIs releated to Module WIFI TCP/UDP Connection Operations via SPI        //
N//       - M8266WIFI_SPI_Setup_Connection                                4.3.1    //
N//       - M8266WIFI_SPI_DisConnect_Connection                           4.3.2    //
N//       - M8266WIFI_SPI_Delete_Connection                               4.3.3    //
N//       - M8266WIFI_SPI_Query_Connection                                4.3.4    //
N
N//       - M8266WIFI_SPI_Op_Multicuast_Group														 4.3.5    //
N//                                                                                //
N//       - M8266WIFI_SPI_Set_TcpServer_Auto_Discon_Timeout               4.3.6    //
N//       - M8266WIFI_SPI_Query_Max_Clients_Allowed_To_A_Tcp_Server       4.3.7    //
N//       - M8266WIFI_SPI_Config_Max_Clients_Allowed_To_A_Tcp_Server      4.3.8    //
N//       - M8266WIFI_SPI_List_Clients_On_A_TCP_Server                    4.3.9    //
N//       - M8266WIFI_SPI_Disconnect_TcpClient                            4.3.10   //
N
N//       - M8266WIFI_SPI_Query_Last_Tcp_Disconnect_Cause                 4.3.11   //
N//       - M8266WIFI_SPI_Query_Tcp_Send_Retry_Max                        4.3.12   //
N//       - M8266WIFI_SPI_Config_Tcp_Retran_Max                           4.3.13   //
N//       - M8266WIFI_SPI_Query_Tcp_Mss                                   4.3.14   //
N//       - M8266WIFI_SPI_Query_Tcp_Window_num                            4.3.15   //
N//       - M8266WIFI_SPI_Config_Tcp_Window_num                           4.3.16   //
N//                                                                                //
N//       - SPI_STA_Get_HostIP_by_HostName                                4.3.17   //
N//
N////////////////////////////////////////////////////////////////////////////////////
N////////////////////////////////////////////////////////////////////////////////////
N/***********************************************************************************
N * M8266WIFI_SPI_Setup_Connection                                                  *
N * .Description:                                                                   *
N *     To setup a UDP connection or an TCP client connection via SPI               *
N * .Parameter(s)                                                                   *
N *     1. tcp_udp      : connection type                                           *
N *                       =0, udp                                                   *
N *                       =1, tcp client                                            *
N *                       =2, tcp server                                            *
N *     2. local_port   : local_port specified                                      *
N *                       =0, M8266WIFI module will generate a random local port    *
N *                      !=0, the local_port specified here will be used            *
N *     3. remote_addr  : string of ip or dns address of the remote connection      *
N *     4. remote_port  : port of remote connection                                 *
N *     5. link_no      : the number of link used for multiple links. Max 4         *
N *     6. timeout_in_s : the max timeout connecting to a remote, unit in seconds   *
N *     7. status  : pointer to return errcode(LSB) and status(MSB) upon error      *
N *                  Use NULL if you don't expect them returned                     *
N * .Return value:                                                                  *
N *     =1, success                                                                 *
N *     =0, has error(s)                                                            *
N ***********************************************************************************/
Nu8 M8266WIFI_SPI_Setup_Connection(u8 tcp_udp, u16 local_port, 
N																	char* remote_addr, u16 remote_port, 
N																	u8 link_no, u8 timeout_in_s, u16* status);
N																	
N/***********************************************************************************
N * M8266WIFI_SPI_Disconnect_Connection                                             *
N * .Description:                                                                   *
N *     To disconnect the connections on M8266WIFI TCP server via SPI               *
N * .Parameter(s)                                                                   *
N *     1. link_no : the number of link to be deleted/disconnected                  *
N *     2. status  : pointer to the status upon failure                             *
N *     3. status  : pointer to return errcode(LSB) and status(MSB) upon error      *
N *                  Use NULL if you don't expect them returned                     *
N *                  errcode(LSB)                                                   *
N *                    = 0x54, disconnect a socket not present                      *
N *                    = 0x55, disconnect a TCP socket when busy in receiving       *
N *                    = 0x56, disconnect a TCP socket when busy in reading         *
N *                    = 0x57, no need to disconnect the sockets since it is        *
N *                            - UDP, using M8266WIFI_SPI_Delete_Connection, or     *
N *                            - TCP Server without clients connecting to, or       *
N *                            - TCP Client already disconnected                    *
N * .Return value:                                                                  *
N *     =1, success                                                                 *
N *     =0, has error(s)                                                            *
N ***********************************************************************************/
Nu8 M8266WIFI_SPI_Disconnect_Connection(u8 link_no, u16* status);
N
N/***********************************************************************************
N * M8266WIFI_SPI_Delete_Connection                                                 *
N * .Description:                                                                   *
N *     To disconnect and delete a client connection on M8266WIFI via SPI           *
N * .Parameter(s)                                                                   *
N *     1. link_no : the number of link to be deleted/disconnected                  *
N *     2. status  : pointer to the status upon failure                             *
N *     3. status  : pointer to return errcode(LSB) and status(MSB) upon error      *
N *                  Use NULL if you don't expect them returned                     *
N *                  errcode(LSB)                                                   *
N *                    = 0x54, delete a socket not present                          *
N *                    = 0x55, delete a socket when busy in receiving               *
N *                    = 0x56, delete a socket when busy in reading                 *
N * .Return value:                                                                  *
N *     =1, success                                                                 *
N *     =0, has error(s)                                                            *
N ***********************************************************************************/
N u8 M8266WIFI_SPI_Delete_Connection(u8 link_no, u16* status);
N
N/***********************************************************************************
N * M8266WIFI_SPI_Query_Connection                                                  *
N * .Description:                                                                   *
N *     To Query the information about a connection on M8266WIFI via SPI            *
N *     including connection type, state, local port, remote_ip and port, etc       *
N * .Parameter(s)                                                                   *
N *     1. link_no 				: the number of link to query                            *
N *     2. connection_type	:	pointer to the connection type returned                *
N *                          If you don't expected this value returned, use NULL    *
N *                          = 0, udp                                               *
N *                          = 1, tcp Client                                        *
N *                          = 2, tcp Server                                        *
N *                          = others, invalid                                      *
N *                          Use NULL if you don't expect it returned               *
N *     3. connection_state:	pointer to the connection state returned               *
N *                          = 0, invalid                                           *
N *                          = 1, wait                                              *
N *                          = 2, listen                                            *
N *                          = 3, connect                                           *
N *                          = 4, write                                             *
N *                          = 5, read                                              *
N *                          = 6, close                                             *
N *                          = others, invalid                                      *
N *                          Use NULL if you don't expect it returned               *
N *     4. local_port      : pointer to the local port returned                     *
N *                          Use NULL if you don't expect it returned               *
N *     5. remote_ip       : pointer to the remote ip returned,                     *
N *                          - String like "192.168.4.2"                            *
N *                          - Use NULL if you don't expect it returned             *
N *     6. remote_port     : pointer to the remote port returned                    *
N *                          Use NULL if you don't expect it returned               *
N *     7. status  : pointer to return errcode(LSB) and status(MSB) upon error      *
N *                  Use NULL if you don't expect them returned                     *
N * .Return value:                                                                  *
N *     =1, success                                                                 *
N *     =0, has error(s)                                                            *
N ***********************************************************************************/
Nu8 M8266WIFI_SPI_Query_Connection(u8 link_no, u8* connection_type, u8* connection_state,
N												u16* local_port, u8* remote_ip, u16* remote_port, u16* status);
Ntypedef enum{
N		ANYLINKIN_WIFI_LINK_CONNECTION_STATE_INVALID	=	0,
N		ANYLINKIN_WIFI_LINK_CONNECTION_STATE_WAIT	    =	1,
N		ANYLINKIN_WIFI_LINK_CONNECTION_STATE_LISTEN	  =	2,
N		ANYLINKIN_WIFI_LINK_CONNECTION_STATE_CONNECT  =	3,
N	  ANYLINKIN_WIFI_LINK_CONNECTION_STATE_WRITE    =	4,
N	  ANYLINKIN_WIFI_LINK_CONNECTION_STATE_READ     =	5,
N	  ANYLINKIN_WIFI_LINK_CONNECTION_STATE_CLOSE    =	6
N} ANYLINKIN_WIFI_LINK_CONNECTION_STATES;
N
N/***********************************************************************************
N * M8266WIFI_SPI_Op_Multicuast_Group                                               *
N * .Description:                                                                   *
N *     To join or leave a multicuast groupo AP via SPI                             *
N *     The module should be in STA or STA+AP mode and have connected               *
N *     to a routers before call this API                                           *
N * .Parameter(s)                                                                   *
N *     1. join_not_leave : join or leave the multicuast groud       				       *
N *        =1, join                                          											 *
N *        =0, leave                                          											 *
N *     2. multicust_group_ip : the ip address of a multicuast groud       				 *
N *        e.g. "224.6.6.6".                                                        *
N *     3. status  : pointer to return errcode(LSB) and status(MSB) upon error      *
N *                  Use NULL if you don't expect them returned                     *
N * .Return value:                                                                  *
N *     =1, success                                                                 *
N *     =0, has error(s)                                                            *
N ***********************************************************************************/
Nu8 M8266WIFI_SPI_Op_Multicuast_Group(u8 join_not_leave, char multicust_group_ip[15+1], u16* status);
N
N/**********************************************************************************
N * M8266WIFI_SPI_Set_TcpServer_Auto_Discon_Timeout                                *
N * .Description:																																	*
N *     To set up the tcp server's auto-disconnection timeout time 								*
N *     when no communication from clients via SPI																	*
N * .Parameter(s)																																	*
N *     1. link_no 		: the number of link to setup																*
N *     2. timeout_in_s: the timeout in seconds the tcp server will auto 					*
N *                      disconnect the connection when no communication						*
N *										  from clients																							*
N *     2. status  		: pointer to the status upon failure												*
N * .Return value:																																	*
N *     =1, success																																*
N *     =0, has error(s)																														*
N **********************************************************************************/
Nu8 M8266WIFI_SPI_Set_TcpServer_Auto_Discon_Timeout(u8 link_no, u16 timeout_in_s, u16* status);
N
N/**********************************************************************************
N * M8266WIFI_SPI_Query_Max_Clients_Allowed_To_A_Tcp_Server                        *
N * .Description:																																	*
N *     To query the max tcp clients could be accepted simutenoeously to           *
N *     this tcp server                                           					  			*
N * .Parameter(s)																																	*
N *     1. server_link_no: the number of tcp server link to query		  						*
N *     2. max_allowed   : pointer to max allowed                                  *
N *     3. status    		: pointer to the status upon failure											*
N * .Return value:																																	*
N *     =1, success																																*
N *     =0, has error(s)																														*
N **********************************************************************************/
N u8 M8266WIFI_SPI_Query_Max_Clients_Allowed_To_A_Tcp_Server(u8 server_link_no, u8* max_allowed, u16* status);
N 
N/**********************************************************************************
N * M8266WIFI_SPI_Config_Max_Clients_Allowed_To_A_Tcp_Server                       *
N * .Description:																																	*
N *     To Config the max tcp clients could be accepted simutenoeously to          *
N *     this tcp server                                           					  			*
N * .Parameter(s)																																	*
N *     1. server_link_no: the number of tcp server link to config		  						*
N *     2. max_allowed   : max allowed, range 1~15                                 *
N *     3. status    		: pointer to the status upon failure											*
N * .Return value:																																	*
N *     =1, success																																*
N *     =0, has error(s)																														*
N **********************************************************************************/
N u8 M8266WIFI_SPI_Config_Max_Clients_Allowed_To_A_Tcp_Server(u8 server_link_no, u8 max_allowed, u16* status);
N
Ntypedef struct {
N	  u8  connection_state;
N	  u8  remote_ip[4];
N	  u16 remote_port;
N }ClientInfo;
N/***********************************************************************************
N * M8266WIFI_SPI_List_Clients_On_A_TCP_Server                                      *
N * .Description:                                                                   *
N *     To Query the information of clients on a link of tcp server of M8266WIFI    *
N * .Parameter(s)                                                                   *
N *     1. server_link_no  : the link number of a tcp server to query               *
N *     2. clients        	:	pointer to sum of clients listed                       *
N *                          value range: 0~15                                      *
N *     3. pRemoteClients  :	array of struct clients_info the clients returned      *
N *     4. status          : pointer to return errcode(LSB) and status(MSB)         *
N *                          upon exception(s) of error(s)                          *
N *                          Use NULL if you don't expect them returned             *
N * .Return value:                                                                  *
N *     =1, success                                                                 *
N *     =0, has error(s)                                                            *
N ***********************************************************************************/
N u8 M8266WIFI_SPI_List_Clients_On_A_TCP_Server(u8 server_link_no, u8* clients, 
N																					ClientInfo RemoteClients[], u16* status);
N
N/***********************************************************************************
N * M8266WIFI_SPI_Disconnect_TcpClient                                              *
N * .Description:                                                                   *
N *     To disconnect a client connections on M8266WIFI TCP server via SPI          *
N * .Parameter(s)                                                                   *
N *     1. link_no     : the number of link to be deleted/disconnected              *
N *     2. client_info : pointer to the remote tcp client info to disconnect        *
N *                      use NULL to disconnect all the remote clients if any       *
N *     3. status      : pointer to return errcode(LSB) and status(MSB) upon error  *
N *                      Use NULL if you don't expect them returned                 *
N *                      errcode(LSB)                                               *
N *                      = 0x54, disconnect a tcp client socket not present         *
N *                      = 0x55, disconnect a TCP socket when busy in receiving     *
N *                      = 0x56, disconnect a TCP socket when busy in reading       *
N *                      = 0x57, no need to disconnect the sockets since it is      *
N *                            - UDP, use M8266WIFI_SPI_Delete_Connection. OR       *
N *                            - TCP Server without clients connecting to. OR       *
N *                            - TCP Client already disconnected                    *
N * .Return value:                                                                  *
N *     =1, success                                                                 *
N *     =0, has error(s)                                                            *
N ***********************************************************************************/
Nu8 M8266WIFI_SPI_Disconnect_TcpClient(u8 link_no, ClientInfo *client_info, u16* status);
N 
N
N/**********************************************************************************
N * M8266WIFI_SPI_Query_Last_Tcp_Disconnect_Cause                                  *
N * .Description:																																	*
N *     To query the cause of last tcp disconnect                 					  			*
N * .Parameter(s)																																	*
N *     1. link_no 			: the number of link to query															*
N *     2. discon_cause  : pointer to the last disconnect cause                    *
N *                        -3, if sending timeout                                  *
N *                        -9, if reset request by remote peer reset               *
N *                        -20,if disconnected by remote peer                      *
N *                        -21,if diconnected by the local                         *
N *                        -22,if deleted by the local                             *
N *     3. status  		  : pointer to the status upon failure											*
N * .Return value:																																	*
N *     =1, success																																*
N *     =0, has error(s)																														*
N **********************************************************************************/
Nu8 M8266WIFI_SPI_Query_Last_Tcp_Disconnect_Cause(u8 link_no, s8* disconnect_cause, u16* status);
N
N
Nu8 M8266WIFI_SPI_Disconnect_TcpClient(u8 link_no, ClientInfo *client_info, u16* status);
N
N/**********************************************************************************
N * M8266WIFI_SPI_Query_Tcp_Retran_Max                                             *
N * .Description:																																	*
N *     To query the tcp max retransmission                  					       			*
N * .Parameter(s)																																	*
N *     1. link_no 			: the number of link to query															*
N *     2. max_retran    : pointer to max retransimision                           *
N *     3. status  		  : pointer to the status upon failure											*
N * .Return value:																																	*
N *     =1, success																																*
N *     =0, has error(s)																														*
N **********************************************************************************/
N u8 M8266WIFI_SPI_Query_Tcp_Retran_Max(u8 link_no, u8* max_retran, u16* status);
N 
N/**********************************************************************************
N * M8266WIFI_SPI_Config_Tcp_Retran_Max                                            *
N * .Description:																																	*
N *     To config the tcp max retransmission                 					       			*
N * .Parameter(s)																																	*
N *     1. link_no 			: the number of link to query															*
N *     2. max_retran    : value of max retransimision, range 1-12                 *
N *                        if <1,  then use 1                                      * 
N *                        if >12, then use 12                                     * 
N *     3. status  		  : pointer to the status upon failure											*
N * .Return value:																																	*
N *     =1, success																																*
N *     =0, has error(s)																														*
N **********************************************************************************/
N u8 M8266WIFI_SPI_Config_Tcp_Retran_Max(u8 link_no, u8 max_retran, u16* status);
N 
N/**********************************************************************************
N * M8266WIFI_SPI_Query_Tcp_Mss                                                    *
N * .Description:																																	*
N *     To query the tcp mss value                           					       			*
N * .Parameter(s)																																	*
N *     1. link_no 			: the number of link to query															*
N *     2. remote_ip     : remote_ip like "192.168.1.101" to differentiate multiple*
N *                        remote e.g. multiple clients.                           *
N *                        USE NULL if only one remote(e.g. wifi module is a tcp   *
N *                        Client) or check current access remote                  *
N *     3. remote_port   : remote_ip like 4321 if remote_ip!=NULL*                 *
N *     4. tcp_mss       : pointer to returned mss                                 *
N *     5. status  		  : pointer to the status upon failure											*
N * .Return value:																																	*
N *     =1, success																																*
N *     =0, has error(s)																														*
N **********************************************************************************/
N u8 M8266WIFI_SPI_Query_Tcp_Mss(u8 link_no, char* remote_ip, u16 remote_port, u16* tcp_mss, u16* status);
N
N/**********************************************************************************
N * M8266WIFI_SPI_Query_Tcp_Window_num                                             *
N * .Description:																																	*
N *     To query the tcp window num                           					       			*
N * .Parameter(s)																																	*
N *     1. link_no 			: the number of link to query															*
N *     2. tcp_wnd_num   : number of tcp windows                                   *
N *     3. status  		  : pointer to the status upon failure											*
N * .Return value:																																	*
N *     =1, success																																*
N *     =0, has error(s)																														*
N **********************************************************************************/
N u8 M8266WIFI_SPI_Query_Tcp_Window_num(u8 link_no, u8* tcp_wnd_num, u16* status);
N 
N /**********************************************************************************
N * M8266WIFI_SPI_Config_Tcp_Window_num                                            *
N * .Description:																																	*
N *     To config the tcp max retransmission                 					       			*
N * .Parameter(s)																																	*
N *     1. link_no 			: the number of link to query															*
N *     2. tcp_wnd_num   : numbers of tcp windows, range 1-15                      *
N *                        if <1,  then use 1                                      * 
N *                        if >15, then use 15                                     * 
N *     3. status  		: pointer to the status upon failure												*
N * .Return value:																																	*
N *     =1, success																																*
N *     =0, has error(s)																														*
N **********************************************************************************/
N u8 M8266WIFI_SPI_Config_Tcp_Window_num(u8 link_no, u8 tcp_wnd_num, u16* status);
N
N/***********************************************************************************
N * M8266WIFI_SPI_STA_Get_HostIP_by_HostName                                        *
N * .Description:                                                                   *
N *     To get the host ip_addr by hostName                                         *
N * .Parameter(s)                                                                   *
N *     1. hostIp      : the host ip_addr returned                                  *
N *     2. hostName    : the host name to get ip, max 255 Bytes                     *
N *     3. timeout_in_s: timeout in seconds                                         *
N *     4. status  : pointer to return errcode(LSB) and status(MSB) upon error      *
N *                  Use NULL if you don't expect them returned                     *
N * .Return value:                                                                  *
N *     =1, success                                                                 *
N *     =0, has error(s)                                                            *
N ***********************************************************************************/
N u8 M8266WIFI_SPI_STA_Get_HostIP_by_HostName(char* hostIp, char* hostName, u8 timeout_in_s, u16* status);
N //Macro for the compaibility with previous versions
N #define SPI_STA_Get_HostIP_by_HostName(hostIp,hostName,timeout_in_s,status) M8266WIFI_SPI_STA_Get_HostIP_by_HostName(hostIp,hostName,timeout_in_s,status) 
N
N////////////////////////////////////////////////////////////////////////////////////
N////////////////////////////////////////////////////////////////////////////////////
N//   4. APIs releated to TCP/UDP Packets TXD and RXD via SPI                      //
N//       - M8266WIFI_SPI_Send_Data                                       4.4.1    //
N//       - M8266WIFI_SPI_Send_BlockData                                  4.4.2    //
N//       - M8266WIFI_SPI_Send_Udp_Data                                   4.4.3    //
N//       - M8266WIFI_SPI_Send_Data_to_TcpClient                          4.4.4    //
N
N//       - M8266WIFI_SPI_Has_DataReceived                                4.4.5    //
N//       - M8266WIFI_SPI_RecvData                                        4.4.6    //
N//       - M8266WIFI_SPI_RecvData_ex                                     4.4.7    //
N////////////////////////////////////////////////////////////////////////////////////
N////////////////////////////////////////////////////////////////////////////////////
N
N/***********************************************************************************
N * M8266WIFI_SPI_Send_Data                                                         *
N * .Description:                                                                   *
N *     To send Data to WIFI via M8266 module SPI                                   *
N * .Parameters                                                                     *
N *     1. Data   : the pointer to the Data buffer to be sent                       *
N *     2. len    : the length the Data buffer to be sent                           *
N *     3. link_no: the wifi service link number sent to                            *
N *     4. pointer to return errcode(LSB) and status(MSB) when error encountered    *
N *        use NULL if you don't expect errcode and status                          *
N *        errcode:                                                                 *
N *            = 0x10: timeout when wait Module spi rxd Buffer ready                *
N *            = 0x11: timeout when wait wifi to send data                          *
N *            = 0x12: Module Sending Buffer full                                   *
N *              Module Buffer full defined as                                      *
N *              - If total size of packets waiting to send via WIFI > 5*1024, or   *
N *              - If counts     of packets waiting to send via WIFI > 8            *
N *            = 0x13: Wrong link_no used                                           *
N *            = 0x14: connection by link_no not present                            *
N *            = 0x15: connection by link_no closed                                 *
N *            = 0x18: No clients connecting to this TCP server                     *
N *            = 0x1F: Other errors                                                 *
N * .Return value:                                                                  *
N *     Actually length that has been sent successfuuly                             *
N ***********************************************************************************/
Nu16 M8266WIFI_SPI_Send_Data(u8 Data[], u16 Data_len, u8 link_no, u16* status);
N
N/***********************************************************************************
N * M8266WIFI_SPI_Send_BlockData                                                    *
N * .Description:                                                                   *
N *     To send Block Data to WIFI via M8266 module SPI                             *
N * .Parameters                                                                     *
N *     1. Data    				: the pointer to the Data buffer to be sent              *
N *     2. Data_len				: the length the Data buffer to be sent                  *
N *     3. link_no 				: the wifi service link number sent to                   *
N *     4. max_loops       : max loops to repeate send if blocked or failed during  *
N *                          transimission to avoid dead-loops, use 1000 as default *
N *     4. max_loops       : max loops to repeate send if blocked or failed during  *
N *     5. remote_ip       : remote_ip like "192.168.1.101" to differentiate        *
N *                          multiple remote e.g. multiple clients.                 *
N *                          USE NULL if only one remote(e.g. wifi module is a tcp  *
N *                          Client) or send to latest access/connected remote      *
N *     6. remote_port     : remote_ip like 4321 if remote_ip!=NULL                 *
N *                          use 0 if remote_ip==NULL                               *
N *     7. pointer to return errcode(LSB) and status(MSB) when error encountered    *
N *        use NULL if you don't expect errcode and status                          *
N *        errcode:                                                                 *
N *            = 0x13: Wrong link_no used                                           *
N *            = 0x14: connection by link_no not present                            *
N *            = 0x15: connection by link_no closed                                 *
N *            = 0x18: No clients connecting to this TCP server                     *
N *            = 0x1E: too many errors ecountered during sending can not fixed      *
N *            = 0x1F: Other errors                                                 *
N * .Return value:                                                                  *
N *     Actually length that has been sent successfuuly                             *
N ***********************************************************************************/
Nu32 M8266WIFI_SPI_Send_BlockData(u8 Data[], u32 Data_len, u16 max_loops, u8 link_no, char* remote_ip, u16 remote_port, u16* status);															
N//Belo macro is used to be compatible with code with lagacy APIs. Try to Use M8266WIFI_SPI_Send_BlockData other than M8266WIFI_SPI_Send_Data_Block.
N#define M8266WIFI_SPI_Send_Data_Block(Data, Data_len, tcp_packet_size, link_no, status)  M8266WIFI_SPI_Send_BlockData(Data[], Data_len, 10000, link_no, NULL, 0, status)
N
N/***********************************************************************************
N * M8266WIFI_SPI_Send_Udp_Data                                                     *
N * .Description:                                                                   *
N *     .To send Udp Data to WIFI via M8266 module SPI especially suitable for      *
N *      those UDP transmission requiring frequently changing destination           *
N *     .If the UDP transission does not need update dest, please use               *
N *       M8266WIFI_SPI_Send_Data above for better efficiency                       *
N * .Parameters                                                                     *
N *     1. Data   : the pointer to the Data buffer to be sent                       *
N *     2. len    : the length the Data buffer to be sent                           *
N *     3. link_no: the wifi service link number sent to                            *
N *     4. udp_dest_addr: string of ip or dns address of the remote connection      *
N *     5. udp_dest_port: port of remote connection                                 *
N *     6. pointer to return errcode(LSB) and status(MSB) when error encountered    *
N *        use NULL if you don't expect errcode and status                          *
N *        errcode:                                                                 *
N *            = 0x10: timeout when wait Module spi rxd Buffer ready                *
N *            = 0x11: timeout when wait wifi to send data                          *
N *            = 0x12: Module Sending Buffer full                                   *
N *              Module Buffer full defined as                                      *
N *              - If total size of packets waiting to send via WIFI > 5*1024, or   *
N *              - If counts     of packets waiting to send via WIFI > 8            *
N *            = 0x13: Wrong link_no used                                           *
N *            = 0x14: connection by link_no not present                            *
N *            = 0x15: connection by link_no closed                                 *
N *            = 0x19: this link is not a UDP service                               *
N *            = 0x1A: try to point to a new udp dest but failed                    *
N *            = 0x1F: Other errors                                                 *
N * .Return value:                                                                  *
N *     Actually length that has been sent successfuuly                             *
N ***********************************************************************************/
Nu16 M8266WIFI_SPI_Send_Udp_Data(u8 Data[], u16 Data_len, u8 link_no, char* udp_dest_addr, u16 udp_dest_port, u16* status);
N
N/***********************************************************************************
N * M8266WIFI_SPI_Send_Data_to_TcpClient                                               *
N * .Description:                                                                   *
N *     .To send tcp Data to a tcp client from this  M8266 tcp server               *
N *       especially suitable for scenarios of multiple clients for                 *
N *     .If the tcp server has only one client, please use                          *
N *       M8266WIFI_SPI_Send_Data above for better efficiency                       *
N * .Parameters                                                                     *
N *     1. Data   : the pointer to the Data buffer to be sent                       *
N *     2. len    : the length the Data buffer to be sent                           *
N *     3. link_no: the tcp server link number sent to                              *
N *     4. tcp_client_dest_addr: string of ip or dns address of the remote client   *
N *     5. tcp_client_dest_port: port of remote cleint                              *
N *     6. pointer to return errcode(LSB) and status(MSB) when error encountered    *
N *        use NULL if you don't expect errcode and status                          *
N *        errcode:                                                                 *
N *            = 0x10: timeout when wait Module spi rxd Buffer ready                *
N *            = 0x11: timeout when wait wifi to send data                          *
N *            = 0x12: Module Sending Buffer full                                   *
N *              Module Buffer full defined as                                      *
N *              - If total size of packets waiting to send via WIFI > 5*1024, or   *
N *              - If counts     of packets waiting to send via WIFI > 8            *
N *            = 0x13: Wrong link_no used                                           *
N *            = 0x14: connection by link_no not present                            *
N *            = 0x15: connection by link_no closed                                 *
N *            = 0x19: this link is not a TCP Server                                *
N *            = 0x1A: try to point to a client but failed. no this client          *
N *            = 0x1F: Other errors                                                 *
N * .Return value:                                                                  *
N *     Actually length that has been sent successfuuly                             *
N ***********************************************************************************/
N u16 M8266WIFI_SPI_Send_Data_to_TcpClient(u8 Data[], u16 Data_len, u8 server_link_no, 
N																				char* tcp_client_dest_addr, u16 tcp_client_dest_port, 
N																				u16* status);
N
N
N/***********************************************************************************
N * M8266WIFI_SPI_Has_DataReceived                                                  *
N * .Description:                                                                   *
N *     To check whether the M8266WIFI module has received data awaiting master     *
N *     to fetch away                                                               *
N * .Parameters                                                                     *
N *     None                                                                        *
N * .Return value:                                                                  *
N *     1, if the M8266WIFI module has received data from wifi                      *
N *     0, if the M8266WIFI module has not received data from wifi                  *
N ***********************************************************************************/
Nu8 M8266WIFI_SPI_Has_DataReceived(void);
N
N/***********************************************************************************
N * M8266WIFI_SPI_RcvData                                                           *
N * .Description:                                                                   *
N *     To receive the wifi data from M8266WIFI                                     *
N * .Parameters                                                                     *
N *     1. Data           - the buffer to contained the received Data               *
N *     2. max_len        - the max length of Data to fetech                        *
N *     3. max_wait_in_ms - the max timeout to wait for the Data                    *
N *     4. link_no        - pointer to return the link_no that current wifi Data    *
N *                         come from. use NULL if you don't expect it returned     *
N *     5. status         - pointer to return errcode(LSB) and status(MSB)          *
N *                         when error encountered. Use NULL if you don't expect    *
N *                         them returned                                           *
N *        errcode:                                                                 *
N *            = 0x20: timeout when wait module has received data via WIFI          *
N *            = 0x22: no date in Module wifi receive buffer                        *
N *            = 0x23: Read data from the left of last packets in Module wifi       *
N *                    receive buffer                                               *
N *            = 0x24: The packet in the Module wifi receive buffer is larger       *
N *                    in size than the max_len specified here. Only part of        *
N *                    the packet received                                          *
N *            = 0x2F: Other errors                                                 *
N * .Return value:                                                                  *
N *     - the size of larger packet first in the Module wifi receive buffer         *
N *       if errcode = 0x24                                                         *
N *     - the actual length of wifi packet received successfully                    *
N *       if others                                                                 *
N ***********************************************************************************/
Nu16 M8266WIFI_SPI_RecvData(u8 Data[], u16 max_len, uint16_t max_wait_in_ms, 
N												   u8* link_no, u16* status);
N
N/***********************************************************************************
N * M8266WIFI_SPI_RcvData_ex                                                        *
N * .Description:                                                                   *
N *     To receive the wifi data from M8266WIFI, extended                           *
N *     Compared with M8266WIFI_SPI_RcvData(), this function also return the        *
N *     source remote_ip and remote_port meanwhile                                  *
N * .Parameters                                                                     *
N *     1. Data           - the buffer to contained the received Data               *
N *     2. max_len        - the max length of Data to fetech                        *
N *     3. max_wait_in_ms - the max timeout to wait for the Data                    *
N *     4. link_no        - pointer to return the link_no that current wifi Data    *
N *                         come from. use NULL if you don't expect it returned     *
N *     5. remote_ip      - array[4] to return the remote_ip that current wifi Data *
N *                         come from. use NULL if you don't expect it returned     *
N *                         e.g. if remote ip is "192.168.4.2", then remote_ip will *
N *                         return with remote_ip[0]=192, remote_ip[1]=168,         *
N *                         remote_ip[2]=4, and remote_ip[3]=2                      *
N *     6. remote_ip      - pointer to return the remote_port that current wifi Data*
N *                         come from. use NULL if you don't expect it returned     *
N *     7. status         - pointer to return errcode(LSB) and status(MSB)          *
N *                         when error encountered. Use NULL if you don't expect    *
N *                         them returned                                           *
N *        errcode:                                                                 *
N *            = 0x20: timeout when wait module has received data via WIFI          *
N *            = 0x22: no date in Module wifi receive buffer                        *
N *            = 0x23: Read data from the left of last packets in Module wifi       *
N *                    receive buffer                                               *
N *            = 0x24: The packet in the Module wifi receive buffer is larger       *
N *                    in size than the max_len specified here. Only part of        *
N *                    the packet received                                          *
N *            = 0x2F: Other errors                                                 *
N * .Return value:                                                                  *
N *     - the size of larger packet first in the Module wifi receive buffer         *
N *       if errcode = 0x24                                                         *
N *     - the actual length of wifi packet received successfully                    *
N *       if others                                                                 *
N ***********************************************************************************/
Nu16 M8266WIFI_SPI_RecvData_ex(u8 Data[], u16 max_len, uint16_t max_wait_in_ms, 
N															u8* link_no, u8 remote_ip[4], u16* remote_port, u16* status);
N
N////////////////////////////////////////////////////////////////////////////////////
N////////////////////////////////////////////////////////////////////////////////////
N//   5. APIs releated to Smart Config via SPI                                     //
N//       - M8266WIFI_SPI_Module_SmartConfig                              4.5.1    //
N//       - M8266WIFI_SPI_StartWpsConfig                                  4.5.2    //
N//                                                                                //
N////////////////////////////////////////////////////////////////////////////////////
N////////////////////////////////////////////////////////////////////////////////////
N
N/***********************************************************************************
N * u8 M8266WIFI_SPI_Module_SmartConfig                                             *
N * .Description:                                                                   *
N *     To perform an SmartConfig procedure to wifi module via SPI                  *
N * .Parameter(s)                                                                   *
N *     1. timeout_in_s  : timeout for an smartconfig procedure                     *
N *     2. smartconfig_type   : pointer to smartconfig type returned                *
N *                    use NULL if you don't expect this param returned             *
N *                    = 0, if type is ESPTOUCH                                     *
N *                    = 1, if type is AIRKISS                                      *
N *                    =-1, if invalid or unknown                                   *
N *     3. smartconfig_phone_ip :                                                   *
N *                   - the ip of the phone or smart device                         *
N *                     that runs smartconfig app to broadcust ssid/password        *
N *                     e.g. "192.168.143.121"                                      *
N *                   - It should be a buffer at least of 16Bytes                   *
N *                   - use NULL if you don't expect this param returned            *
N *                   - Airkiss does not response ip addrsss of smart devices,      *
N *                     so smartconfig_phone_ip[0] will be 0 if airkiss             *
N *     4. status  : pointer to return errcode(LSB) upon error                      *
N *                  Use NULL if you don't expect them returned                     *
N *                  == 0x0000  success                                             *
N *                  != 0x0000  failed                                              *
N *                     (1) failed to start smartconfig if MSB(8) = 0x68            *
N *                     (2) failed during smartconfig   if MSB(8) = 0x6A            *
N *                          - failed to find channel           if LSB(8) = 0x00    *
N *                          - failed to get ssid/password      if LSB(8) = 0x01    *
N *                          - failed to connect the ap/routers if LSB(8) = 0x02/03 *
N * .Return value:                                                                  *
N *     =1, success                                                                 *
N *     =0, has error(s)                                                            *
N ***********************************************************************************/
N u8 M8266WIFI_SPI_Module_SmartConfig(u8 timeout_in_s, u8* smartconfig_type, char smartconfig_phone_ip[15+1], u16* status);
N 
N/***********************************************************************************
N * M8266WIFI_SPI_StartSmartConfig                                                  *
N * .Description:                                                                   *
N *     To start/stop smart config of M8266WIFI via SPI                             *
N *     Once enter the smartconfig mode, either smartlinkin or airkiss be adapted   * 
N *     After perform a start operation, the M8266WIFI will be set in STA mode      *
N * .Parameter(s)                                                                   *
N *     1. en      : to start or stop                                               *
N *                  =0, to stop                                                    *
N *                  others, to start                                               *
N *     2. status  : pointer to return errcode(LSB) and status(MSB) upon error      *
N *                  Use NULL if you don't expect them returned                     *
N * .Return value:                                                                  *
N *     =1, success                                                                 *
N *     =0, has error(s)                                                            *
N ***********************************************************************************/
Nu8 M8266WIFI_SPI_StartSmartConfig(u8 en, u16* status);
N
N/***********************************************************************************
N * M8266WIFI_SPI_StartWpsConfig                                                    *
N * .Description:                                                                   *
N *     To start/stop wps config of M8266WIFI via SPI                               *
N *     After perform a start operation, the M8266WIFI will be set in STA mode      *
N * .Parameter(s)                                                                   *
N *     1. en      : to start or stop                                               *
N *                  =0, to stop                                                    *
N *                  others, to start                                               *
N *     2. status  : pointer to return errcode(LSB) and status(MSB) upon error      *
N *                  Use NULL if you don't expect them returned                     *
N * .Return value:                                                                  *
N *     =1, success                                                                 *
N *     =0, has error(s)                                                            *
N ***********************************************************************************/
Nu8 M8266WIFI_SPI_StartWpsConfig(u8 en, u16* status);
N
N
N////////////////////////////////////////////////////////////////////////////////////
N////////////////////////////////////////////////////////////////////////////////////
N//   6. APIs releated to on-module web operations via SPI                         //
N//       - M8266WIFI_SPI_Set_WebServer                                   4.6.1    //
N////////////////////////////////////////////////////////////////////////////////////
N////////////////////////////////////////////////////////////////////////////////////
N
N/***********************************************************************************
N * M8266WIFI_SPI_Set_WebServer                                                     *
N * .Description:                                                                   *
N *     To set the web server via SPI, with option save or not                      *
N * .Parameter(s)                                                                   *
N *     1. open_not_shutdown  : to start or shutdown the local web server           *
N *            =0,      to shutdown the webserver if it is running                  *
N *            =others, to (re-)start the webserver                                 *
N *     2. server_port : the port used for web_server                               *
N *            - Only valid when open_not_shutdown!=0.                              *
N *            - When open_not_shutdown !=0, and server_port=0, then default        *
N *              port = 80 will be used                                             *
N *     3. saved: to save the setting or not.                                       *
N *            - saved == 1, the setting will be saved and valid on module bootup   *
N *              e.g. if you start a web server with saved=1, upon next bootup      *
N *              the web server on module will startup automatically                *
N *              e.g. if you stop a web server with saved1=1, upon next booup       *
N *              the web server on the module will not start-up                     *
N *            - saved == 0, the setting will not be saved and valid only currently *
N *              And after reboot, the settings will restore to previous default    *
N *            - when called with saved=1, the API will write the FL:ASH on module. *
N *                  PLEASE DO NOT CALL IT EACH TIME OF BOOTUP WITH SAVED != 0      *
N *                  OR, THE FLASH ON MODULE MIGHT GO TO FAILURE DUE TO LIFT CYCLE  *
N *                  OF WRITE                                                       *
N *     4. status  : pointer to return errcode(LSB) and status(MSB) upon error      *
N *                  Use NULL if you don't expect them returned                     *
N * .Return value:                                                                  *
N *     =1, success                                                                 *
N *     =0, has error(s)                                                            *
N ***********************************************************************************/
N u8 M8266WIFI_SPI_Set_WebServer(u8 open_not_shutdown, u16 server_port, u8 saved, u16* status);
N
N //u8 M8266WIFI_SPI_Set_Web_Server(u8 open_not_shutdown, u16 server_port, u16* status);
N //below macro used to keep compatible with previous API
N #define SPI_Set_Web_Server(open_not_shutdown, server_port, status)  M8266WIFI_SPI_Set_WebServer(open_not_shutdown, server_port, 0, status)
N
N/***********************************************************************************
N * M8266WIFI_SPI_QueryDns                                             *
N * .Description:                                                                   *
N *     To query the dns server info via SPI                                        *
N * .Parameter(s)                                                                   *
N *     1. start_on_boot   : pointer to whether start on boot                       *
N *        use NULL if you don't expect it                                          *
N *     2. current_running : pointer to whether dns is now running                  *
N *        use NULL if you don't expect it                                          *
N *     3. status  : pointer to return errcode(LSB) and status(MSB) upon error      *
N *                  Use NULL if you don't expect them returned                     *
N * .Return value:                                                                  *
N *     =1, success                                                                 *
N *     =0, has error(s)                                                            *
N ***********************************************************************************/
N u8 M8266WIFI_SPI_QueryDns(u8* start_on_bootup, u8* current_running, u16* status);
N 
N  /***********************************************************************************
N * M8266WIFI_SPI_StartDns                                                          *
N * .Description:                                                                   *
N *     To start or shutdonw the local DNS on module                                *
N * .Parameter(s)                                                                   *
N *     1. start_not_shutdown  : to start or shutdown the local dns server          *
N *            =0,      to shutdown the webserver if it is running                  *
N *            =others, to (re-)start the webserver                                 *
N *     2. saved: to save the setting or not.                                       *
N *            - saved == 1, the setting will be saved and valid on module bootup   *
N *              e.g. if you start a dns server with saved=1, upon next bootup      *
N *              the dns server on module will startup automatically                *
N *              e.g. if you stop a dns server with saved1=1, upon next booup       *
N *              the dns server on the module will not start-up                     *
N *            - saved == 0, the setting will not be saved and valid only currently *
N *              And after reboot, the settings will restore to previous default    *
N *            - when called with saved=1, the API will write the FL:ASH on module. *
N *                  PLEASE DO NOT CALL IT EACH TIME OF BOOTUP WITH SAVED != 0      *
N *                  OR, THE FLASH ON MODULE MIGHT GO TO FAILURE DUE TO LIFT CYCLE  *
N *                  OF WRITE                                                       *
N *     3. status  : pointer to return errcode(LSB) and status(MSB) upon error      *
N *                  Use NULL if you don't expect them returned                     *
N * .Return value:                                                                  *
N *     =1, success                                                                 *
N *     =0, has error(s)                                                            *
N ***********************************************************************************/
N u8 M8266WIFI_SPI_StartDns(u8 start_not_shutdown, u8 save, u16* status);
N
N
N////////////////////////////////////////////////////////////////////////////////////
N////////////////////////////////////////////////////////////////////////////////////
N//   7. APIs releated to module low power operations via SPI                      //
N//       - M8266WIFI_SPI_Set_Tx_Max_Power                                4.7.1    //
N//       - M8266WIFI_SPI_Sleep_Module                                    4.7.2    //
N////////////////////////////////////////////////////////////////////////////////////
N////////////////////////////////////////////////////////////////////////////////////
N
N/***********************************************************************************
N * M8266WIFI_SPI_Set_Tx_Max_Power                                                  *
N * .Description:                                                                   *
N *     To set the RF Tx Max Power via SPI comannd                                  *
N * .Parameter(s)                                                                   *
N *     1. tx_max_power : the max tx power in 0.25 dBm.                             *
N *                       range = 0~82, i.e. 0~20.5dBm, or 1mW~112mW                *
N *                               tx_max_power  dBm        P/mW                     *
N *                                 0            0          1.0                     *
N *                                 4            1          1.3                     *
N *                                12            3          2.0                     *
N *                                28            7          5.0                     *
N *                                40           10         10.0                     *
N *                                52           13         20.0                     *
N *                                68           17         50.0                     *
N *                                80           20        100.0                     *
N *                                82           20.5      112.20                    *
N *        upon bootup default, tx_max_power = 82, i.e. 20.5dBm or 112.20mW         *
N *                                                                                 *
N *     2. status  : pointer to return errcode(LSB) and status(MSB) upon error      *
N *                  Use NULL if you don't expect them returned                     *
N * .Return value:                                                                  *
N *     =1, success                                                                 *
N *     =0, has error(s)                                                            *
N ***********************************************************************************/
N u8 M8266WIFI_SPI_Set_Tx_Max_Power(u8 tx_max_power, u16 *status);
N
N/**********************************************************************************
N * M8266WIFI_SPI_Sleep_Module                                                      *
N * .Description:                                                                   *
N *     To bring the M8266WIFI module into sleep mode via SPI comannd               *
N * .Parameter(s)                                                                   *
N *     1. sleep_type : the type of sleep                                           *
N *        = 0      :  reserved                                                     *
N *        = 1      :  reserved                                                     *
N *        = 2      :  reserved                                                     *
N *        = 3      :  deep sleep                                                   *
N *        = others :  reserved                                                     *
N *     2. time_to_wakeup_in_ms : time to wakeup from sleep, unit in ms             *
N *        - max value 4294967 ms (about 1.19hour).                                 *
N *          if a value exceed this provided, then 4294967ms will be used           *
N *        - use 0 if expect to sleep for ever without automatic wakeup             *
N *     2. status  : pointer to return errcode(LSB) and status(MSB) upon error      *
N *                  Use NULL if you don't expect them returned                     *
N * Note:                                                                           *
N *     1. The nCS should be pulled low before exit sleep and release after bootup  *
N *        from sleep if reset_type=3 in order for a normal bootup from extern flash*
N *     2. after a call of this function, normally the module should be re init     *
N *        via functions such as M8266WIFI_Module_Init_Via_SPI(), and the connection*
N *        should be re-established as well.                                        *
N * .Return value:                                                                  *
N *     =1, success                                                                 *
N *     =0, has error(s)                                                            *
N ***********************************************************************************/
N u8 M8266WIFI_SPI_Sleep_Module(u8 sleep_type, u32 time_to_wakeup_in_ms, u16 *status);
N  
N/***********************************************************************************
N * M8266WIFI_SPI_Reset_Module                                                      *
N * .Description:                                                                   *
N *     To reset the M8266WIFI module at once via SPI comannd                       *
N * .Parameter(s)                                                                   *
N *     1. reset_type : the type of reset                                           *
N *        = 0 :  to perform a software reset to the module,                        *
N *               boot-mode of last power on will be kept                           *
N *        = 1 :  to perform a hardware reset via chip_EN                           *
N *               boot-mode will be sampled again.                                  *
N * Note:                                                                           *
N *     1. after a call of this function, normally the module should be re init     *
N *        via functions such as M8266WIFI_Module_Init_Via_SPI(), and the connection*
N *        should be re-established as well.                                        *
N * .Return value:                                                                  *
N *     =1, success                                                                 *
N *     =0, has error(s)                                                            *
N ***********************************************************************************/
N u8 M8266WIFI_SPI_Reset_Module(u8 reset_type, u16* status);
N
N/**********************************************************************************
N * M8266WIFI_SPI_Restore_Module_to_Default                                         *
N * .Description:                                                                   *
N *     To restore the ALK8266WIFI module to factory default and then reboot module *
N *     via SPI comannd.                                                            *
N *     After calling this API, all the saved paramters will be restored to         *
N *     manufacture default and module will be in AP+STA mode                       *
N * .Parameter(s)                                                                   *
N *     1. status  : pointer to return errcode(LSB) and status(MSB) upon error      *
N *                  Use NULL if you don't expect them returned                     *
N * .Return value:                                                                  *
N *     =1, success                                                                 *
N *     =0, has error(s)                                                            *
N ***********************************************************************************/
N u8 M8266WIFI_SPI_Restore_Module_to_Default(u16* status);
N
N////////////////////////////////////////////////////////////////////////////////////
N////////////////////////////////////////////////////////////////////////////////////
N//   8. APIs releated to module resources operations via SPI                      //
N//       - M8266WIFI_SPI_Query_Module_Gpio_Mode                          4.8.1    //
N//       - M8266WIFI_SPI_Config_Module_Gpio_Mode                         4.8.2    //
N//       - M8266WIFI_SPI_Read_Module_Gpio                                4.8.3    //
N//       - M8266WIFI_SPI_Write_Module_Gpio                               4.8.4    //
N//       - M8266WIFI_SPI_Read_Module_Adc                                 4.8.5    //
N////////////////////////////////////////////////////////////////////////////////////
N////////////////////////////////////////////////////////////////////////////////////
Ntypedef enum{
N	 M8266WIFI_MODULE_GPIO_MODES_INPUT_NOPULL 	= 0,
N	 M8266WIFI_MODULE_GPIO_MODES_INPUT_PULLUP		= 1,
N	 M8266WIFI_MODULE_GPIO_MODES_OUTPUT_NORMAL	= 2,
N	 M8266WIFI_MODULE_GPIO_MODES_OUTPUT_OD			= 3,
N	 M8266WIFI_MODULE_GPIO_MODES_ALTERNATIIVE		= 4,
N }M8266WIFI_MODULE_GPIO_MODES;
N 
N /**********************************************************************************
N * M8266WIFI_SPI_Query_Module_Gpio_Mode                                            *
N * .Description:                                                                   *
N *     To query the on-module gpios whether as input or output                     *
N * .Parameter(s)                                                                   *
N *     1. io_no        : the number of on-module GPIO                              *
N *     2. io_mode      : mode to get                                               *
N *                       =0, input  without pull                                   *
N *                       =1, input  with    pullup                                 *
N *                       =2, output normal                                         *
N *                       =3, output open drain                                     *
N *     3. status       : pointer to return errcode(LSB) and status(MSB) upon error *
N *                       Use NULL if you don't expect them returned                *
N * .Return value:                                                                  *
N *     =1, success                                                                 *
N *     =0, has error(s)                                                            *
N ***********************************************************************************/
N u8 M8266WIFI_SPI_Query_Module_Gpio_Mode(u8 io_no, M8266WIFI_MODULE_GPIO_MODES *io_mode, u16* status);
N
N /**********************************************************************************
N * M8266WIFI_SPI_Config_Module_Gpio_Mode                                           *
N * .Description:                                                                   *
N *     To config the on-module gpios as input or output                            *
N * .Parameter(s)                                                                   *
N *     1. io_no        : the number of on-module GPIO                              *
N *     2. io_mode      : mode to set                                               *
N *                       =0, input  without pull                                   *
N *                       =1, input  with    pullup                                 *
N *                       =2, output normal                                         *
N *                       =3, output open drain                                     *
N *     3. status       : pointer to return errcode(LSB) and status(MSB) upon error *
N *                       Use NULL if you don't expect them returned                *
N * .Return value:                                                                  *
N *     =1, success                                                                 *
N *     =0, has error(s)                                                            *
N ***********************************************************************************/
N u8 M8266WIFI_SPI_Config_Module_Gpio_Mode(u8 io_no, M8266WIFI_MODULE_GPIO_MODES io_mode, u16* status);
N 
N /**********************************************************************************
N * M8266WIFI_SPI_Read_Module_Gpio                                                  *
N * .Description:                                                                   *
N *     To read the gpios level                                                     *
N * .Parameter(s)                                                                   *
N *     1. io_no        : the number of on-module GPIO                              *
N *     2. level        : pointer of the level read back                            *
N *     3. status       : pointer to return errcode(LSB) and status(MSB) upon error *
N *                       Use NULL if you don't expect them returned                *
N * .Return value:                                                                  *
N *     =1, success                                                                 *
N *     =0, has error(s)                                                            *
N ***********************************************************************************/
N u8 M8266WIFI_SPI_Read_Module_Gpio(u8 io_no, u8* level, u16* status);
N
N/**********************************************************************************
N * M8266WIFI_SPI_Write_Module_Gpio                                                 *
N * .Description:                                                                   *
N *     To write the on-module gpios as output                                      *
N * .Parameter(s)                                                                   *
N *     1. io_no        : the number of on-module GPIO                              *
N *     2. level        : pointer of the level read back                            *
N *     3. status       : pointer to return errcode(LSB) and status(MSB) upon error *
N *                       Use NULL if you don't expect them returned                *
N * .Return value:                                                                  *
N *     =1, success                                                                 *
N *     =0, has error(s)                                                            *
N ***********************************************************************************/
N u8 M8266WIFI_SPI_Write_Module_Gpio(u8 io_no, u8 level, u16* status);
N
N /**********************************************************************************
N * M8266WIFI_SPI_Read_Module_Adc                                                   *
N * .Description:                                                                   *
N *     To write on-module gpios as output                                          *
N * .Parameter(s)                                                                   *
N *     1. adc          : pointer to the adc value                                  *
N *     2. status       : pointer to return errcode(LSB) and status(MSB) upon error *
N *                       Use NULL if you don't expect them returned                *
N * .Return value:                                                                  *
N *     =1, success                                                                 *
N *     =0, has error(s)                                                            *
N ***********************************************************************************/
N u8 M8266WIFI_SPI_Read_Module_Adc(u16* adc, u16* status);
N 
N////////////////////////////////////////////////////////////////////////////////////
N////////////////////////////////////////////////////////////////////////////////////
N//   9. APIs releated to module information                                       //
N//       - M8266WIFI_SPI_Get_Module_Info                                 4.9.1    //
N//       - M8266WIFI_SPI_Get_Driver_Info                                 4.9.2    //
N////////////////////////////////////////////////////////////////////////////////////
N////////////////////////////////////////////////////////////////////////////////////
N
N/**********************************************************************************
N * M8266WIFI_SPI_Get_Module_Info                                                   *
N * .Description:                                                                   *
N *     To get the M8266WIFI module information, such as ESP8266_ID,                *
N *     Flash Size, Firmware Version                                                *
N * .Parameter(s)                                                                   *
N *     1. esp8266_id: the pointer to the returned esp8266_id                       *
N *                    Use NULL if you don't expect it returned                     *
N *     2. flash_size: the pointer to the returned flash_size                       *
N *                    returned value                                               *
N *                      = 0, if 512KB                                              *
N *                      = 1, if 1MB                                                *
N *                      = 2, if 2MB                                                *
N *                      = 3, if 4MB                                                *
N *                      = others, invalid                                          *
N *                    Use NULL if you don't expect it returned                     *
N *     3. fw_ver    : the pointer to the returned firmware version                 *
N *                    buffer size should be no less than 16 bytes                  *
N *                    returned value e.g. "1.1.4-4"                                *
N *                    Use NULL if you don't expect it returned                     *
N *     4. status    : pointer to return errcode(LSB) and status(MSB) upon error    *
N *                    Use NULL if you don't expect them returned                   *
N * .Return value:                                                                  *
N *     =1, success                                                                 *
N *     =0, has error(s)                                                            *
N ***********************************************************************************/
N u8 M8266WIFI_SPI_Get_Module_Info(u32* esp8266_id, u8* flash_size, char* fw_ver, u16* status);
N
N/***********************************************************************************
N * M8266WIFI_SPI_Get_Driver_Info                                                   *
N * .Description:                                                                   *
N *     To get the M8266WIFI driver information                                     *
N * .Parameter(s)                                                                   *
N *     1. drv_info: the pointer to the returned driver information buffer.         *
N *                  buffer size should be no less than 64 Bytes                    *
N *                  e.g. "ANYLINKIN M8266WIFI SPI DRIVER VV1.1.8-G, 20181218"      *
N * .Return value                                                                   *
N *     driver_info: the pointer to the returned driver information                 *
N ***********************************************************************************/
Nchar* M8266WIFI_SPI_Get_Driver_Info(char* drv_info);
N
N
N////////////////////////////////////////////////////////////////////////////////////
N////////////////////////////////////////////////////////////////////////////////////
N//   Below specifications are required by M8266WIFIDrv.lib                        //
N//   And should be implemented according to the hardware in M8266HostIf.c         //
N//   Put here kust for purpose ofheader specification                             //
N////////////////////////////////////////////////////////////////////////////////////
N////////////////////////////////////////////////////////////////////////////////////
Nvoid M8266HostIf_Set_nRESET_Pin(u8 level);
Nvoid M8266HostIf_Set_SPI_nCS_Pin(u8 level);
Nvoid M8266HostIf_delay_us(u8 nus);
Nu8   M8266HostIf_SPI_ReadWriteByte(u8 byte); // Not required for most platforms.
N
N#endif
L 20 "..\..\User\main.c" 2
N#include "M8266HostIf.h"
L 1 "..\..\User\M8266WIFI\M8266HostIf.h" 1
N/********************************************************************
N * M8266HostIf.h
N * .Description
N *     header file of M8266WIFI Host Interface 
N * .Copyright(c) Anylinkin Technology 2015.5-
N *     IoT@anylinkin.com
N *     http://www.anylinkin.com
N *     http://anylinkin.taobao.com
N *  Author
N *     wzuo
N *  Date
N *  Version
N ********************************************************************/
N#ifndef _M8266_HOST_IF_H_
N#define _M8266_HOST_IF_H_
N#include "stm32f10x.h"
N
N	 #define TEST_M8266WIFI_TYPE    1	     //           1 = Repeative Sending, 2 = Repeative Reception, 3 = Echo  4 = multi-clients transimission test
N	                                       // (Chinese: 1=Ä£×éÏòÍâ²»Í£µØ·¢ËÍÊý¾Ý 2=Ä£×é²»Í£µØ½ÓÊÕÊý¾Ý 3= Ä£×é½«½ÓÊÕµ½µÄÊý¾Ý·¢ËÍ¸ø·¢ËÍ·½ 4=¶à¿Í»§¶Ë²âÊÔ) 
N
N	 /////////////
N   ////	 Macros for Socket Connection Type (Chinese£ºÌ×½Ó×ÖÀàÐÍµÄºê¶¨Òå) 
N	 #define TEST_CONNECTION_TYPE   1
N	 #define TEST_REMOTE_ADDR    	 	"183.230.40.39"  // "onenet"
N   #define TEST_REMOTE_PORT  	    876						// 80
W "..\..\User\M8266WIFI\M8266HostIf.h" 26 11 incompatible redefinition of macro "REV_OK"  (declared at line 57 of "..\..\User\device\inc\esp8266.h")
N	 #define REV_OK		1	//½ÓÊÕÍê³É±êÖ¾
W "..\..\User\M8266WIFI\M8266HostIf.h" 27 12 incompatible redefinition of macro "REV_WAIT"  (declared at line 58 of "..\..\User\device\inc\esp8266.h")
N   #define REV_WAIT	0	//½ÓÊÕÎ´Íê³É±êÖ¾
N	 
N	 enum net_status{Conneted=0,Closed,Lost,Error};
N
N
N
N 
Nvoid M8266HostIf_Init(void);
N
Nvoid M8266HostIf_SPI_SetSpeed(u32 SPI_BaudRatePrescaler);
N
Nvoid M8266HostIf_usart_txd_data(char* data, u16 len);
Nvoid M8266HostIf_usart_txd_string(char* str);
Nvoid M8266HostIf_USART_Reset_RX_BUFFER(void);
Nu16 M8266HostIf_USART_RX_BUFFER_Data_count(void);
Nu16 M8266HostIf_USART_get_data(u8* data, u16 len);
Nvoid M8266_init(void);
N
N
N
Nunsigned char *M8266_GetIPD(unsigned short timeOut);
Nu8 M8266_WaitRecive(void);
Nvoid M8266_Clear(void);
Nunsigned char M8266_NetCheck(void);
Nvoid M8266_ReLink(u8 status );
N
N
N
N#endif
N
L 21 "..\..\User\main.c" 2
N#include "M8266WIFI_ops.h"
L 1 "..\..\User\M8266WIFI\M8266WIFI_ops.h" 1
N/********************************************************************
N * M8266WIFI_ops.h
N * .Description
N *     header file of M8266WIFI HAL operations
N * .Copyright(c) Anylinkin Technology 2015.5-
N *     IoT@anylinkin.com
N *     http://www.anylinkin.com
N *     http://anylinkin.taobao.com
N *  Author
N *     wzuo
N *  Date
N *  Version
N ********************************************************************/
N 
N#ifndef _M8266WIFI_OPS_H_ 
N#define _M8266WIFI_OPS_H_
N
Nvoid M8266WIFI_Module_delay_ms(u16 nms);
N
N////////////////////////////////////////////////////////////////////////////////////
N////////////////////////////////////////////////////////////////////////////////////
N/////// BELOW FUNCTIONS ARE QUERYING OR CONFIGURATION VIA UART
N////////////////////////////////////////////////////////////////////////////////////
N////////////////////////////////////////////////////////////////////////////////////
Nu8 M8266WIFI_wait_response_ok(u8* ack, u16 wait_time_in_10ms);
Nu8 M8266WIFI_running_ok(void);
Nu8 M8266WIFI_Reboot_And_Config_Connection(u8 udp_tcp, u16 local_port, u8* remote_ip, u16 remote_port, u8 link_no);
Nu8 M8266WIFI_get_sta_ap_mode(void);
Nu8 M8266WIFI_SPI_wait_sta_connecting_to_ap_and_get_ip(char* sta_ip, u8 max_wait_time_in_s);
Nu8 M8266WIFI_Module_Init_Via_USART(void);
Nu8 M8266WIFI_Config_Connection_via_USART(u8 tcp_udp, u16 local_port, u8* remote_ip, u16 remote_port, u8 link_no);
Nu8 M8266WIFI_SmartConfig(void);
Nu8 M8266WIFI_WpsConfig(void);
Nu8 M8266WIFI_set_led(u8 led_no, u8 on);
N////////////////////////////////////////////////////////////////////////////////////
N////////////////////////////////////////////////////////////////////////////////////
N/////// BELOW FUNCTIONS ARE QUERYING OR CONFIGURATION VIA SPI
N/////// MORE TO BE FOUND IN M8266WIFIDrv.h
N////////////////////////////////////////////////////////////////////////////////////
N////////////////////////////////////////////////////////////////////////////////////
Nu8 M8266WIFI_Module_Init_Via_SPI(void);
Nu8 M8266WIFI_Config_Connection_via_SPI(u8 tcp_udp, u16 local_port, char* remote_addr, u16 remote_port, u8 link_no);
N
Nu8 M8266WIFI_Sleep_module_for_some_time_and_then_wakeup_automatically(u16 time_to_wakeup_in_ms);
Nu8 M8266WIFI_Sleep_Module(void);
Nu8 M8266WIFI_Wakeup_Module(void);
N
N#endif
L 22 "..\..\User\main.c" 2
N//Ó²¼þÇý¶¯
N#include "delay.h"
N#include "hwtimer.h"
L 1 "..\..\User\hwtimer\hwtimer.h" 1
N#ifndef __HWTIMER_H
N#define __HWTIMER_H
N#include "stm32f10x.h"
N#include "stm32f10x_it.h"
L 1 "..\..\User\stm32f10x_it.h" 1
N/**
N  ******************************************************************************
N  * @file    Project/STM32F10x_StdPeriph_Template/stm32f10x_it.h 
N  * @author  MCD Application Team
N  * @version V3.5.0
N  * @date    08-April-2011
N  * @brief   This file contains the headers of the interrupt handlers.
N  ******************************************************************************
N  * @attention
N  *
N  * THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
N  * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE
N  * TIME. AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY
N  * DIRECT, INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING
N  * FROM THE CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE
N  * CODING INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
N  *
N  * <h2><center>&copy; COPYRIGHT 2011 STMicroelectronics</center></h2>
N  ******************************************************************************
N  */ 
N
N/* Define to prevent recursive inclusion -------------------------------------*/
N#ifndef __STM32F10x_IT_H
N#define __STM32F10x_IT_H
N
N#ifdef __cplusplus
S extern "C" {
N#endif 
N
N/* Includes ------------------------------------------------------------------*/
N#include "stm32f10x.h"
N
N/* Exported types ------------------------------------------------------------*/
N/* Exported constants --------------------------------------------------------*/
N/* Exported macro ------------------------------------------------------------*/
N/* Exported functions ------------------------------------------------------- */
N
Nvoid NMI_Handler(void);
Nvoid HardFault_Handler(void);
Nvoid MemManage_Handler(void);
Nvoid BusFault_Handler(void);
Nvoid UsageFault_Handler(void);
Nvoid SVC_Handler(void);
Nvoid DebugMon_Handler(void);
Nvoid SysTick_Handler(void);
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif /* __STM32F10x_IT_H */
N
N/******************* (C) COPYRIGHT 2011 STMicroelectronics *****END OF FILE****/
L 5 "..\..\User\hwtimer\hwtimer.h" 2
N
Nvoid NVIC_con(void);
Nvoid gpio_Con(void);
Nvoid TIM2_con(void);
Nvoid TIM_IRQHandler(void);
Nvoid Tim2_init(void);
Nvoid uDelay(uint32_t time);
N
N
N
N
N#endif
L 25 "..\..\User\main.c" 2
N#include "warning.h"
L 1 "..\..\User\warning\warning.h" 1
N#ifndef __WARNING_H_
N#define __WARNING_H_
N
N#include "stm32f10x.h"
N#include "./led/bsp_led.h"   
N#include "beep.h"
L 1 "..\..\User\beep\beep.h" 1
N#ifndef _BEEP_H_
N#define _BEEP_H_
N
N
N#include "stm32f10x.h"
N
N
N/************************** BEEP Êý¾ÝÀàÐÍ¶¨Òå********************************/
Ntypedef struct
N{
N	_Bool beep_status;
N}BEEP_INFO;
N
N
N/************************** BEEP º¯Êýºê¶¨Òå********************************/
N#define BEEP_ON		1
N#define BEEP_OFF	0
N
N
N/************************** BEEP ½á¹¹Ìå¶¨Òå********************************/
Nextern BEEP_INFO beepInfo;
N
N
N/************************** BEEP º¯Êýºê¶¨Òå********************************/
Nvoid Beep_Init(void);
Nvoid Beep_Set(_Bool status);
N
N
N#endif
L 7 "..\..\User\warning\warning.h" 2
N#include "dht11.h"
L 1 "..\..\User\dht11\dht11.h" 1
N#ifndef __DHT11_H
N#define	__DHT11_H
N
N
N#include "stm32f10x.h"
N
N
N/************************** DHT11 Êý¾ÝÀàÐÍ¶¨Òå********************************/
Ntypedef struct
N{
N	uint8_t humi_int;		//Êª¶ÈµÄÕûÊý²¿·Ö
N	uint8_t humi_deci;   //Êª¶ÈµÄÐ¡Êý²¿·Ö
N	uint8_t temp_int;    //ÎÂ¶ÈµÄÕûÊý²¿·Ö
N	uint8_t temp_deci;   //ÎÂ¶ÈµÄÐ¡Êý²¿·Ö
N	uint8_t check_sum;   //Ð£ÑéºÍ
N}DHT11_Data_TypeDef;
N
N
N/************************** DHT11 º¯Êýºê¶¨Òå********************************/
N#define DHT11_Dout_0	GPIO_ResetBits(GPIOE, GPIO_Pin_6) 
N#define DHT11_Dout_1	GPIO_SetBits(GPIOE, GPIO_Pin_6) 
N
N#define DHT11_Dout_IN	GPIO_ReadInputDataBit(GPIOE, GPIO_Pin_6) 
N
N
N/************************** DHT11 º¯ÊýÉùÃ÷ ********************************/
Nvoid DHT11_Init(void);
Nuint8_t DHT11_Read_TempAndHumidity(DHT11_Data_TypeDef *DHT11_Data);
Nvoid DHT11_GPIO_Config(void);
Nvoid DHT11_Mode_IPU(void);
Nvoid DHT11_Mode_Out_PP(void);
Nuint8_t DHT11_ReadByte(void);
N
N#endif
L 8 "..\..\User\warning\warning.h" 2
N#include "adc.h"
L 1 "..\..\User\adc\adc.h" 1
N#ifndef __ADC_H
N#define	__ADC_H
N
N
N#include "stm32f10x.h"
N
N
N// Ë«Ä£Ê½Ê±£¬ADC1ºÍADC2×ª»»µÄÊý¾Ý¶¼´æ·ÅÔÚADC1µÄÊý¾Ý¼Ä´æÆ÷£¬
N// ADC1µÄÔÚµÍÊ®ÁùÎ»£¬ADC2µÄÔÚ¸ßÊ®ÁùÎ»
N// Ë«ADCÄ£Ê½µÄµÚÒ»¸öADC£¬±ØÐëÊÇADC1
N#define ADCx_1							ADC1
N#define ADCx_1_APBxClock_FUN			RCC_APB2PeriphClockCmd
N#define ADCx_1_CLK						RCC_APB2Periph_ADC1
N
N#define ADCx_1_GPIO_APBxClock_FUN		RCC_APB2PeriphClockCmd
N#define ADCx_1_GPIO_CLK					RCC_APB2Periph_GPIOC  
N#define ADCx_1_PORT						GPIOC
N#define ADCx_1_PIN						GPIO_Pin_1
N#define ADCx_1_CHANNEL					ADC_Channel_11
N
N// Ë«ADCÄ£Ê½µÄµÚ¶þ¸öADC£¬±ØÐëÊÇADC2
N#define ADCx_2							ADC2
N#define ADCx_2_APBxClock_FUN			RCC_APB2PeriphClockCmd
N#define ADCx_2_CLK						RCC_APB2Periph_ADC2
N
N#define ADCx_2_GPIO_APBxClock_FUN		RCC_APB2PeriphClockCmd
N#define ADCx_2_GPIO_CLK					RCC_APB2Periph_GPIOC  
N#define ADCx_2_PORT						GPIOC
N#define ADCx_2_PIN						GPIO_Pin_0
N#define ADCx_2_CHANNEL					ADC_Channel_10
N
N#define NOFCHANEL						1
N
N// ADC1 ¶ÔÓ¦ DMA1Í¨µÀ1£¬ADC3¶ÔÓ¦DMA2Í¨µÀ5£¬ADC2Ã»ÓÐDMA¹¦ÄÜ
N#define ADC_DMA_CHANNEL					DMA1_Channel1
N
N
Nvoid ADCx_Init(void);
N
N
N#endif
L 9 "..\..\User\warning\warning.h" 2
N#include "flame.h"
L 1 "..\..\User\flame\flame.h" 1
N#ifndef __FLAME_H
N#define	__FLAME_H
N
N#include "stm32f10x.h"
N
N
N#define FIRE_Dout_0		GPIO_ResetBits(GPIODE, GPIO_Pin_5)
N#define FIRE_Dout_1		GPIO_SetBits(GPIOE, GPIO_Pin_5) 
N#define FIRE_Data_IN()	GPIO_ReadInputDataBit(GPIOE, GPIO_Pin_5)
N
N
Nvoid Fire_Init(void);
N
N#endif 
L 10 "..\..\User\warning\warning.h" 2
N#include "./usart/bsp_usart.h"
N#include "onenet.h"
N#include <stdlib.h>
N#include <string.h>
N
N
N
Nvoid WARNING(uint8_t flag);		//MQ135¡¢DHT11¡¢LIGHT½ÓÊÜÊý¾Ýºó¶ÔLEDµÆºÍ·äÃùÆ÷½øÐÐ´¦Àí¿ØÖÆ
Nvoid DHT11_Check(DHT11_Data_TypeDef *DHT11_Data, int16_t temp_max, int16_t temp_min, uint16_t humi_max, uint16_t humi_min);
Nvoid Fire_Check(u8 *fire);
Nvoid Check_sensor(volatile data_Stream *data_stram);
N#endif
L 26 "..\..\User\main.c" 2
N#include "flame.h"
N#include "dht11.h"
N#include "beep.h"
N#include "iic.h"
L 1 "..\..\User\IIC\iic.h" 1
N#ifndef _IIC_H
N#define	_IIC_H
N
N#include <inttypes.h>
L 1 "F:\Keil_v5\ARM\ARMCC\Bin\..\include\inttypes.h" 1
N/* Copyright (C) ARM Ltd., 1999,2014 */
N/* All rights reserved */
N
N/*
N * RCS $Revision$
N * Checkin $Date$
N * Revising $Author: agrant $
N */
N
N/* Based on WG14/N843 (C9X) Committee Draft August 3, 1998 */
N
N#ifndef __inttypes_h
N#define __inttypes_h
N#define __ARMCLIB_VERSION 5060037
N
N#define _ARMABI __declspec(__nothrow)
N#define _ARMABI_PURE __declspec(__nothrow) __attribute__((const))
N
N#include <stdint.h>
N
N#if !defined(__cplusplus) || defined(__STDC_FORMAT_MACROS) || 201103L <= __cplusplus
X#if !0L || 0L || 201103L <= __cplusplus
N
N#ifdef __LP64__
S  #define __PRISCN64 "l" /* 'int64_t' is 'long' */
N#else
N  #define __PRISCN64 "ll" /* 'int64_t' is 'long long' */
N#endif
N#if __sizeof_ptr == 8
X#if 4 == 8
S  #define __PRISCNPTR __PRISCN64 /* 'intptr_t' is 64-bits */
N#else
N  #define __PRISCNPTR /*nothing*/ /* 'intptr_t' is 'int' */
N#endif
N
N
N    /* 7.8.1 */
N
N#define PRId8         "d"
N#define PRId16        "d"
N#define PRId32        "d"
N#define PRId64      __PRISCN64 "d"
N#define PRIdLEAST8    "d"
N#define PRIdLEAST16   "d"
N#define PRIdLEAST32   "d"
N#define PRIdLEAST64 __PRISCN64 "d"
N#define PRIdFAST8     "d"
N#define PRIdFAST16    "d"
N#define PRIdFAST32    "d"
N#define PRIdFAST64  __PRISCN64 "d"
N#define PRIdMAX      "jd"
N#define PRIdPTR     __PRISCNPTR "d"
N
N#define PRIi8         "i"
N#define PRIi16        "i"
N#define PRIi32        "i"
N#define PRIi64      __PRISCN64 "i"
N#define PRIiLEAST8    "i"
N#define PRIiLEAST16   "i"
N#define PRIiLEAST32   "i"
N#define PRIiLEAST64 __PRISCN64 "i"
N#define PRIiFAST8     "i"
N#define PRIiFAST16    "i"
N#define PRIiFAST32    "i"
N#define PRIiFAST64  __PRISCN64 "i"
N#define PRIiMAX      "ji"
N#define PRIiPTR     __PRISCNPTR "i"
N
N#define PRIo8         "o"
N#define PRIo16        "o"
N#define PRIo32        "o"
N#define PRIo64      __PRISCN64 "o"
N#define PRIoLEAST8    "o"
N#define PRIoLEAST16   "o"
N#define PRIoLEAST32   "o"
N#define PRIoLEAST64 __PRISCN64 "o"
N#define PRIoFAST8     "o"
N#define PRIoFAST16    "o"
N#define PRIoFAST32    "o"
N#define PRIoFAST64  __PRISCN64 "o"
N#define PRIoMAX      "jo"
N#define PRIoPTR     __PRISCNPTR "o"
N
N#define PRIu8         "d"
N#define PRIu16        "d"
N#define PRIu32        "u"
N#define PRIu64      __PRISCN64 "u"
N#define PRIuLEAST8    "d"
N#define PRIuLEAST16   "d"
N#define PRIuLEAST32   "u"
N#define PRIuLEAST64 __PRISCN64 "u"
N#define PRIuFAST8     "u"
N#define PRIuFAST16    "u"
N#define PRIuFAST32    "u"
N#define PRIuFAST64  __PRISCN64 "u"
N#define PRIuMAX      "ju"
N#define PRIuPTR     __PRISCNPTR "u"
N
N#define PRIx8         "x"
N#define PRIx16        "x"
N#define PRIx32        "x"
N#define PRIx64      __PRISCN64 "x"
N#define PRIxLEAST8    "x"
N#define PRIxLEAST16   "x"
N#define PRIxLEAST32   "x"
N#define PRIxLEAST64 __PRISCN64 "x"
N#define PRIxFAST8     "x"
N#define PRIxFAST16    "x"
N#define PRIxFAST32    "x"
N#define PRIxFAST64  __PRISCN64 "x"
N#define PRIxMAX      "jx"
N#define PRIxPTR     __PRISCNPTR "x"
N
N#define PRIX8         "X"
N#define PRIX16        "X"
N#define PRIX32        "X"
N#define PRIX64      __PRISCN64 "X"
N#define PRIXLEAST8    "X"
N#define PRIXLEAST16   "X"
N#define PRIXLEAST32   "X"
N#define PRIXLEAST64 __PRISCN64 "X"
N#define PRIXFAST8     "X"
N#define PRIXFAST16    "X"
N#define PRIXFAST32    "X"
N#define PRIXFAST64  __PRISCN64 "X"
N#define PRIXMAX      "jX"
N#define PRIXPTR     __PRISCNPTR "X"
N
N#define SCNd8       "hhd"
N#define SCNd16       "hd"
N#define SCNd32        "d"
N#define SCNd64      __PRISCN64 "d"
N#define SCNdLEAST8  "hhd"
N#define SCNdLEAST16  "hd"
N#define SCNdLEAST32   "d"
N#define SCNdLEAST64 __PRISCN64 "d"
N#define SCNdFAST8     "d"
N#define SCNdFAST16    "d"
N#define SCNdFAST32    "d"
N#define SCNdFAST64  __PRISCN64 "d"
N#define SCNdMAX      "jd"
N#define SCNdPTR     __PRISCNPTR "d"
N
N#define SCNi8       "hhd"
N#define SCNi16       "hi"
N#define SCNi32        "i"
N#define SCNi64      __PRISCN64 "i"
N#define SCNiLEAST8  "hhi"
N#define SCNiLEAST16  "hi"
N#define SCNiLEAST32   "i"
N#define SCNiLEAST64 __PRISCN64 "i"
N#define SCNiFAST8     "i"
N#define SCNiFAST16    "i"
N#define SCNiFAST32    "i"
N#define SCNiFAST64  __PRISCN64 "i"
N#define SCNiMAX      "ji"
N#define SCNiPTR     __PRISCNPTR "i"
N
N#define SCNo8       "hho"
N#define SCNo16       "ho"
N#define SCNo32        "o"
N#define SCNo64      __PRISCN64 "o"
N#define SCNoLEAST8  "hho"
N#define SCNoLEAST16  "ho"
N#define SCNoLEAST32   "o"
N#define SCNoLEAST64 __PRISCN64 "o"
N#define SCNoFAST8     "o"
N#define SCNoFAST16    "o"
N#define SCNoFAST32    "o"
N#define SCNoFAST64  __PRISCN64 "o"
N#define SCNoMAX      "jo"
N#define SCNoPTR     __PRISCNPTR "o"
N
N#define SCNu8       "hhu"
N#define SCNu16       "hu"
N#define SCNu32        "u"
N#define SCNu64      __PRISCN64 "u"
N#define SCNuLEAST8  "hhu"
N#define SCNuLEAST16  "hu"
N#define SCNuLEAST32   "u"
N#define SCNuLEAST64 __PRISCN64 "u"
N#define SCNuFAST8     "u"
N#define SCNuFAST16    "u"
N#define SCNuFAST32    "u"
N#define SCNuFAST64  __PRISCN64 "u"
N#define SCNuMAX      "ju"
N#define SCNuPTR     __PRISCNPTR "u"
N
N#define SCNx8       "hhx"
N#define SCNx16       "hx"
N#define SCNx32        "x"
N#define SCNx64      __PRISCN64 "x"
N#define SCNxLEAST8  "hhx"
N#define SCNxLEAST16  "hx"
N#define SCNxLEAST32   "x"
N#define SCNxLEAST64 __PRISCN64 "x"
N#define SCNxFAST8     "x"
N#define SCNxFAST16    "x"
N#define SCNxFAST32    "x"
N#define SCNxFAST64  __PRISCN64 "x"
N#define SCNxMAX      "jx"
N#define SCNxPTR     __PRISCNPTR "x"
N
N#endif /* __STDC_FORMAT_MACROS */
N
N#ifndef __cplusplus  /* wchar_t is a builtin type for C++ */
N  #if !defined(__STRICT_ANSI__)
X  #if !0L
N   /* unconditional in non-strict C for consistency of debug info */
N    #if defined(__WCHAR32) || (defined(__ARM_SIZEOF_WCHAR_T) && __ARM_SIZEOF_WCHAR_T == 4)
X    #if 0L || (0L && __ARM_SIZEOF_WCHAR_T == 4)
S      typedef unsigned int wchar_t; /* see <stddef.h> */
N    #else
N      typedef unsigned short wchar_t; /* see <stddef.h> */
N    #endif
N  #elif !defined(__wchar_t)
S    #define __wchar_t 1
S    #if defined(__WCHAR32) || (defined(__ARM_SIZEOF_WCHAR_T) && __ARM_SIZEOF_WCHAR_T == 4)
S      typedef unsigned int wchar_t; /* see <stddef.h> */
S    #else
S      typedef unsigned short wchar_t; /* see <stddef.h> */
S    #endif
N  #endif
N#endif
N
Ntypedef struct imaxdiv_t { intmax_t quot, rem; } imaxdiv_t;
N   /* type of the value returned by the imaxdiv function. */
N
N#ifdef __cplusplus
Sextern "C" {
N#endif
N
N_ARMABI intmax_t strtoimax(const char * __restrict /*nptr*/,
X__declspec(__nothrow) intmax_t strtoimax(const char * __restrict  ,
N                   char ** __restrict /*endptr*/, int /*base*/) __attribute__((__nonnull__(1)));
N    /* as for strtol */
N_ARMABI uintmax_t strtoumax(const char * __restrict /*nptr*/,
X__declspec(__nothrow) uintmax_t strtoumax(const char * __restrict  ,
N                    char ** __restrict /*endptr*/, int /*base*/) __attribute__((__nonnull__(1)));
N    /* as for strtoul */
N
N_ARMABI intmax_t wcstoimax(const wchar_t * __restrict /*nptr*/,
X__declspec(__nothrow) intmax_t wcstoimax(const wchar_t * __restrict  ,
N                   wchar_t ** __restrict /*endptr*/, int /*base*/) __attribute__((__nonnull__(1)));
N_ARMABI uintmax_t wcstoumax(const wchar_t * __restrict /*nptr*/,
X__declspec(__nothrow) uintmax_t wcstoumax(const wchar_t * __restrict  ,
N                    wchar_t ** __restrict /*endptr*/, int /*base*/) __attribute__((__nonnull__(1)));
N
Nextern _ARMABI_PURE intmax_t imaxabs(intmax_t /*j*/);
Xextern __declspec(__nothrow) __attribute__((const)) intmax_t imaxabs(intmax_t  );
N   /*
N    * computes the absolute value of an intmax_t j. If the result cannot be
N    * represented, the behaviour is undefined.
N    * Returns: the absolute value.
N    */
Nextern _ARMABI_PURE imaxdiv_t imaxdiv(intmax_t /*numer*/, intmax_t /*denom*/);
Xextern __declspec(__nothrow) __attribute__((const)) imaxdiv_t imaxdiv(intmax_t  , intmax_t  );
N   /*
N    * computes the quotient and remainder of the division of the numerator
N    * numer by the denominator denom. If the division is inexact, the sign of
N    * the resulting quotient is that of the algebraic quotient, and the
N    * magnitude of the resulting quotient is the largest integer less than the
N    * magnitude of the algebraic quotient. If the result cannot be represented,
N    * the behaviour is undefined; otherwise, quot * denom + rem shall equal
N    * numer.
N    * Returns: a structure of type imaxdiv_t, comprising both the quotient and
N    *          the remainder. the structure shall contain the following
N    *          members, in either order.
N    *          intmax_t quot; intmax_t rem;
N    */
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif /* __inttypes_h */
N
N/* end of inttypes.h */
N
L 5 "..\..\User\IIC\iic.h" 2
N
N#include "stm32f10x.h"
N	#define EEPROM_I2C_WR	0		/* Ð´¿ØÖÆbit */
N#define EEPROM_I2C_RD	1		/* ¶Á¿ØÖÆbit */
N
N
N/* ¶¨ÒåI2C×ÜÏßÁ¬½ÓµÄGPIO¶Ë¿Ú, ÓÃ»§Ö»ÐèÒªÐÞ¸ÄÏÂÃæ4ÐÐ´úÂë¼´¿ÉÈÎÒâ¸Ä±äSCLºÍSDAµÄÒý½Å */
N#define EEPROM_GPIO_PORT_I2C	GPIOB			/* GPIO¶Ë¿Ú */
N#define EEPROM_RCC_I2C_PORT 	RCC_APB2Periph_GPIOB		/* GPIO¶Ë¿ÚÊ±ÖÓ */
N#define EEPROM_I2C_SCL_PIN		GPIO_Pin_6			/* Á¬½Óµ½SCLÊ±ÖÓÏßµÄGPIO */
N#define EEPROM_I2C_SDA_PIN		GPIO_Pin_7			/* Á¬½Óµ½SDAÊý¾ÝÏßµÄGPIO */
N	#define EEPROM_I2C_SCL_1()  EEPROM_GPIO_PORT_I2C->BSRR = EEPROM_I2C_SCL_PIN				/* SCL = 1 */
N	#define EEPROM_I2C_SCL_0()  EEPROM_GPIO_PORT_I2C->BRR = EEPROM_I2C_SCL_PIN				/* SCL = 0 */
N	
N	#define EEPROM_I2C_SDA_1()  EEPROM_GPIO_PORT_I2C->BSRR = EEPROM_I2C_SDA_PIN				/* SDA = 1 */
N	#define EEPROM_I2C_SDA_0()  EEPROM_GPIO_PORT_I2C->BRR = EEPROM_I2C_SDA_PIN				/* SDA = 0 */
N	
N	#define EEPROM_I2C_SDA_READ()  ((EEPROM_GPIO_PORT_I2C->IDR & EEPROM_I2C_SDA_PIN) != 0)	/* ¶ÁSDA¿ÚÏß×´Ì¬ */
N/* 
N * AT24C02 2kb = 2048bit = 2048/8 B = 256 B
N * 32 pages of 8 bytes each
N *
N * Device Address
N * 1 0 1 0 A2 A1 A0 R/W
N * 1 0 1 0 0  0  0  0 = 0XA0
N * 1 0 1 0 0  0  0  1 = 0XA1 
N */
N
N/* AT24C01/02Ã¿Ò³ÓÐ8¸ö×Ö½Ú 
N * AT24C04/08A/16AÃ¿Ò³ÓÐ16¸ö×Ö½Ú 
N */
N	
N
N#define EEPROM_DEV_ADDR			0xA0		/* 24xx02µÄÉè±¸µØÖ· */
N#define EEPROM_PAGE_SIZE		  8			  /* 24xx02µÄÒ³Ãæ´óÐ¡ */
N#define EEPROM_SIZE				  4			  /* 24xx02×ÜÈÝÁ¿ */
N void i2c_CfgGpio(void);
Nvoid i2c_Start(void);
Nvoid i2c_Stop(void);
Nvoid i2c_SendByte(uint8_t _ucByte);
Nuint8_t i2c_ReadByte(void);
Nuint8_t i2c_WaitAck(void);
Nvoid i2c_Ack(void);
Nvoid i2c_NAck(void);
N
Nuint8_t i2c_CheckDevice(uint8_t _Address);
Nuint8_t ee_CheckOk(void);
Nuint8_t ee_ReadBytes(uint8_t *_pReadBuf, uint16_t _usAddress, uint16_t _usSize);
Nuint8_t ee_WriteBytes( uint8_t data,uint16_t _usAddress);
Nvoid ee_Erase(void);
Nuint8_t Read_LIMDATA(void );
Nvoid ee_Delay(__IO uint32_t nCount );
Xvoid ee_Delay(volatile uint32_t nCount );
N
N
N#endif /* __I2C_EE_H */
L 30 "..\..\User\main.c" 2
N#include "iwdg.h"
L 1 "..\..\User\IWDG\iwdg.h" 1
N#ifndef _IWDG_H
N#define _IWDG_H
N#include <stm32f10x.h>
N#include <inttypes.h>
N#include "stm32f10x_iwdg.h"
W "..\..\User\IWDG\iwdg.h" 6 6 Deprecated declaration Feed - give arg types
Nvoid Feed();
Nvoid IWDG_Config(uint16_t prv,uint16_t rlv);
N
N
N
N
N
N
W "..\..\User\IWDG\iwdg.h" 14 7 last line of file ends without a newline
N#endif
L 31 "..\..\User\main.c" 2
N#include "light_moto.h"
L 1 "..\..\User\light_moto\light_moto.h" 1
N#ifndef _LIGT_MOTO_H_
N#define _LIGT_MOTO_H_
N#include "stm32f10x_gpio.h"
N#include "stm32f10x.h"
N#include "delay.h"
N
N
N#define dir_S 0
N#define dir_N 1
N
N#define Pin_1 GPIO_Pin_7
N#define Pin_2 GPIO_Pin_8
N#define Pin_3 GPIO_Pin_9
N#define Pin_4 GPIO_Pin_10
N
N
Nvoid Shadding(void);
Nvoid  Shelter_GPIOEonfig(void);
Nvoid  UnShadding(void);
Nvoid Rotating(u16 angle,u8 dir);
N
N
N
N
N
N#endif
N
L 32 "..\..\User\main.c" 2
N#include "timer.h"
L 1 "..\..\User\TIMER\timer.h" 1
N#ifndef __TIMER_H
N#define __TIMER_H
N#include "stm32f10x.h"
N
N
W "..\..\User\TIMER\timer.h" 6 6 Deprecated declaration TIM4_PWM_Init - give arg types
Nvoid TIM4_PWM_Init();
Nvoid GPIO(void);
Nvoid Set_angle(_Bool dir,u8 angle);
N
W "..\..\User\TIMER\timer.h" 10 7 last line of file ends without a newline
N#endif
L 33 "..\..\User\main.c" 2
N
N//rtos
N#include "FreeRTOS.h"
L 1 "..\..\Freee-RTOS\include\FreeRTOS.h" 1
N/*
N    FreeRTOS V9.0.0 - Copyright (C) 2016 Real Time Engineers Ltd.
N    All rights reserved
N
N    VISIT http://www.FreeRTOS.org TO ENSURE YOU ARE USING THE LATEST VERSION.
N
N    This file is part of the FreeRTOS distribution.
N
N    FreeRTOS is free software; you can redistribute it and/or modify it under
N    the terms of the GNU General Public License (version 2) as published by the
N    Free Software Foundation >>>> AND MODIFIED BY <<<< the FreeRTOS exception.
N
N    ***************************************************************************
N    >>!   NOTE: The modification to the GPL is included to allow you to     !<<
N    >>!   distribute a combined work that includes FreeRTOS without being   !<<
N    >>!   obliged to provide the source code for proprietary components     !<<
N    >>!   outside of the FreeRTOS kernel.                                   !<<
N    ***************************************************************************
N
N    FreeRTOS is distributed in the hope that it will be useful, but WITHOUT ANY
N    WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
N    FOR A PARTICULAR PURPOSE.  Full license text is available on the following
N    link: http://www.freertos.org/a00114.html
N
N    ***************************************************************************
N     *                                                                       *
N     *    FreeRTOS provides completely free yet professionally developed,    *
N     *    robust, strictly quality controlled, supported, and cross          *
N     *    platform software that is more than just the market leader, it     *
N     *    is the industry's de facto standard.                               *
N     *                                                                       *
N     *    Help yourself get started quickly while simultaneously helping     *
N     *    to support the FreeRTOS project by purchasing a FreeRTOS           *
N     *    tutorial book, reference manual, or both:                          *
N     *    http://www.FreeRTOS.org/Documentation                              *
N     *                                                                       *
N    ***************************************************************************
N
N    http://www.FreeRTOS.org/FAQHelp.html - Having a problem?  Start by reading
N    the FAQ page "My application does not run, what could be wrong?".  Have you
N    defined configASSERT()?
N
N    http://www.FreeRTOS.org/support - In return for receiving this top quality
N    embedded software for free we request you assist our global community by
N    participating in the support forum.
N
N    http://www.FreeRTOS.org/training - Investing in training allows your team to
N    be as productive as possible as early as possible.  Now you can receive
N    FreeRTOS training directly from Richard Barry, CEO of Real Time Engineers
N    Ltd, and the world's leading authority on the world's leading RTOS.
N
N    http://www.FreeRTOS.org/plus - A selection of FreeRTOS ecosystem products,
N    including FreeRTOS+Trace - an indispensable productivity tool, a DOS
N    compatible FAT file system, and our tiny thread aware UDP/IP stack.
N
N    http://www.FreeRTOS.org/labs - Where new FreeRTOS products go to incubate.
N    Come and try FreeRTOS+TCP, our new open source TCP/IP stack for FreeRTOS.
N
N    http://www.OpenRTOS.com - Real Time Engineers ltd. license FreeRTOS to High
N    Integrity Systems ltd. to sell under the OpenRTOS brand.  Low cost OpenRTOS
N    licenses offer ticketed support, indemnification and commercial middleware.
N
N    http://www.SafeRTOS.com - High Integrity Systems also provide a safety
N    engineered and independently SIL3 certified version for use in safety and
N    mission critical applications that require provable dependability.
N
N    1 tab == 4 spaces!
N*/
N
N#ifndef INC_FREERTOS_H
N#define INC_FREERTOS_H
N
N/*
N * Include the generic headers required for the FreeRTOS port being used.
N */
N#include <stddef.h>
L 1 "F:\Keil_v5\ARM\ARMCC\Bin\..\include\stddef.h" 1
N/* stddef.h: ANSI 'C' (X3J11 Oct 88) library header, section 4.1.4 */
N
N/* Copyright (C) ARM Ltd., 1999
N * All rights reserved
N * RCS $Revision$
N * Checkin $Date$
N * Revising $Author: agrant $
N */
N
N/* Copyright (C) Codemist Ltd., 1988                            */
N/* Copyright 1991 ARM Limited. All rights reserved.             */
N/* version 0.05 */
N
N/*
N * The following types and macros are defined in several headers referred to in
N * the descriptions of the functions declared in that header. They are also
N * defined in this header file.
N */
N
N#ifndef __stddef_h
N#define __stddef_h
N#define __ARMCLIB_VERSION 5060037
N
N  #ifndef __STDDEF_DECLS
N  #define __STDDEF_DECLS
N    #undef __CLIBNS
N    #ifdef __cplusplus
S        namespace std {
S        #define __CLIBNS ::std::
S        extern "C" {
N    #else
N      #define __CLIBNS
N    #endif  /* __cplusplus */
N
N#if __sizeof_ptr == 8
X#if 4 == 8
S  typedef signed long ptrdiff_t;
N#else
N  typedef signed int ptrdiff_t;
N#endif
N
N#if defined(__cplusplus) || !defined(__STRICT_ANSI__)
X#if 0L || !0L
N /* unconditional in C++ and non-strict C for consistency of debug info */
N  #if __sizeof_ptr == 8
X  #if 4 == 8
S    typedef unsigned long size_t;   /* see <stddef.h> */
N  #else
N    typedef unsigned int size_t;   /* see <stddef.h> */
N  #endif
N#elif !defined(__size_t)
S  #define __size_t 1
S  #if __sizeof_ptr == 8
S    typedef unsigned long size_t;   /* see <stddef.h> */
S  #else
S    typedef unsigned int size_t;   /* see <stddef.h> */
S  #endif
S   /* the unsigned integral type of the result of the sizeof operator. */
N#endif
N
N#ifndef __cplusplus  /* wchar_t is a builtin type for C++ */
N  #if !defined(__STRICT_ANSI__)
X  #if !0L
N  /* unconditional in non-strict C for consistency of debug info */
N    #if defined(__WCHAR32) || (defined(__ARM_SIZEOF_WCHAR_T) && __ARM_SIZEOF_WCHAR_T == 4)
X    #if 0L || (0L && __ARM_SIZEOF_WCHAR_T == 4)
S      typedef unsigned int wchar_t; /* also in <stdlib.h> and <inttypes.h> */
N    #else
N      typedef unsigned short wchar_t; /* also in <stdlib.h> and <inttypes.h> */
N    #endif
N  #elif !defined(__wchar_t)
S    #define __wchar_t 1
S    #if defined(__WCHAR32) || (defined(__ARM_SIZEOF_WCHAR_T) && __ARM_SIZEOF_WCHAR_T == 4)
S      typedef unsigned int wchar_t; /* also in <stdlib.h> and <inttypes.h> */
S    #else
S      typedef unsigned short wchar_t; /* also in <stdlib.h> and <inttypes.h> */
S    #endif
S   /*
S    * An integral type whose range of values can represent distinct codes for
S    * all members of the largest extended character set specified among the
S    * supported locales; the null character shall have the code value zero and
S    * each member of the basic character set shall have a code value when used
S    * as the lone character in an integer character constant.
S    */
N  #endif
N#endif
N
N#undef NULL  /* others (e.g. <stdio.h>) also define */
N#define NULL 0
N   /* null pointer constant. */
N
N#ifdef __clang__
S  #define offsetof(t, d) __builtin_offsetof(t, d)
N#else
N  /* EDG uses __INTADDR__ to avoid errors when strict */
N  #define offsetof(t, memb) ((__CLIBNS size_t)__INTADDR__(&(((t *)0)->memb)))
N#endif
N
N#if !defined(__STRICT_ANSI__) || (defined(__STDC_VERSION__) && 201112L <= __STDC_VERSION__) || (defined(__cplusplus) && 201103L <= __cplusplus)
X#if !0L || (1L && 201112L <= 199901L) || (0L && 201103L <= __cplusplus)
N  typedef long double max_align_t;
N#endif
N
N    #ifdef __cplusplus
S         }  /* extern "C" */
S      }  /* namespace std */
N    #endif /* __cplusplus */
N  #endif /* __STDDEF_DECLS */
N
N
N  #ifdef __cplusplus
S    #ifndef __STDDEF_NO_EXPORTS
S      using ::std::size_t;
S      using ::std::ptrdiff_t;
S      #if !defined(__STRICT_ANSI__) || (defined(__cplusplus) && 201103L <= __cplusplus)
S        using ::std::max_align_t;
S      #endif
S    #endif 
N  #endif /* __cplusplus */
N
N#endif
N
N/* end of stddef.h */
N
L 77 "..\..\Freee-RTOS\include\FreeRTOS.h" 2
N
N/*
N * If stdint.h cannot be located then:
N *   + If using GCC ensure the -nostdint options is *not* being used.
N *   + Ensure the project's include path includes the directory in which your
N *     compiler stores stdint.h.
N *   + Set any compiler options necessary for it to support C99, as technically
N *     stdint.h is only mandatory with C99 (FreeRTOS does not require C99 in any
N *     other way).
N *   + The FreeRTOS download includes a simple stdint.h definition that can be
N *     used in cases where none is provided by the compiler.  The files only
N *     contains the typedefs required to build FreeRTOS.  Read the instructions
N *     in FreeRTOS/source/stdint.readme for more information.
N */
N#include <stdint.h> /* READ COMMENT ABOVE. */
N
N#ifdef __cplusplus
Sextern "C" {
N#endif
N
N/* Application specific configuration options. */
N#include "FreeRTOSConfig.h"
L 1 "..\..\Freee-RTOS\include\FreeRTOSConfig.h" 1
N/*
N    FreeRTOS V9.0.0 - Copyright (C) 2016 Real Time Engineers Ltd.
N    All rights reserved
N
N    VISIT http://www.FreeRTOS.org TO ENSURE YOU ARE USING THE LATEST VERSION.
N
N    This file is part of the FreeRTOS distribution.
N
N    FreeRTOS is free software; you can redistribute it and/or modify it under
N    the terms of the GNU General Public License (version 2) as published by the
N    Free Software Foundation >>>> AND MODIFIED BY <<<< the FreeRTOS exception.
N
N    ***************************************************************************
N    >>!   NOTE: The modification to the GPL is included to allow you to     !<<
N    >>!   distribute a combined work that includes FreeRTOS without being   !<<
N    >>!   obliged to provide the source code for proprietary components     !<<
N    >>!   outside of the FreeRTOS kernel.                                   !<<
N    ***************************************************************************
N
N    FreeRTOS is distributed in the hope that it will be useful, but WITHOUT ANY
N    WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
N    FOR A PARTICULAR PURPOSE.  Full license text is available on the following
N    link: http://www.freertos.org/a00114.html
N
N    ***************************************************************************
N     *                                                                       *
N     *    FreeRTOS provides completely free yet professionally developed,    *
N     *    robust, strictly quality controlled, supported, and cross          *
N     *    platform software that is more than just the market leader, it     *
N     *    is the industry's de facto standard.                               *
N     *                                                                       *
N     *    Help yourself get started quickly while simultaneously helping     *
N     *    to support the FreeRTOS project by purchasing a FreeRTOS           *
N     *    tutorial book, reference manual, or both:                          *
N     *    http://www.FreeRTOS.org/Documentation                              *
N     *                                                                       *
N    ***************************************************************************
N
N    http://www.FreeRTOS.org/FAQHelp.html - Having a problem?  Start by reading
N    the FAQ page "My application does not run, what could be wrong?".  Have you
N    defined configASSERT()?
N
N    http://www.FreeRTOS.org/support - In return for receiving this top quality
N    embedded software for free we request you assist our global community by
N    participating in the support forum.
N
N    http://www.FreeRTOS.org/training - Investing in training allows your team to
N    be as productive as possible as early as possible.  Now you can receive
N    FreeRTOS training directly from Richard Barry, CEO of Real Time Engineers
N    Ltd, and the world's leading authority on the world's leading RTOS.
N
N    http://www.FreeRTOS.org/plus - A selection of FreeRTOS ecosystem products,
N    including FreeRTOS+Trace - an indispensable productivity tool, a DOS
N    compatible FAT file system, and our tiny thread aware UDP/IP stack.
N
N    http://www.FreeRTOS.org/labs - Where new FreeRTOS products go to incubate.
N    Come and try FreeRTOS+TCP, our new open source TCP/IP stack for FreeRTOS.
N
N    http://www.OpenRTOS.com - Real Time Engineers ltd. license FreeRTOS to High
N    Integrity Systems ltd. to sell under the OpenRTOS brand.  Low cost OpenRTOS
N    licenses offer ticketed support, indemnification and commercial middleware.
N
N    http://www.SafeRTOS.com - High Integrity Systems also provide a safety
N    engineered and independently SIL3 certified version for use in safety and
N    mission critical applications that require provable dependability.
N
N    1 tab == 4 spaces!
N*/
N
N#ifndef FREERTOS_CONFIG_H
N#define FREERTOS_CONFIG_H
N
N/*-----------------------------------------------------------
N * Application specific definitions.
N *
N * These definitions should be adjusted for your particular hardware and
N * application requirements.
N *
N * THESE PARAMETERS ARE DESCRIBED WITHIN THE 'CONFIGURATION' SECTION OF THE
N * FreeRTOS API DOCUMENTATION AVAILABLE ON THE FreeRTOS.org WEB SITE. 
N *
N * See http://www.freertos.org/a00110.html.
N *----------------------------------------------------------*/
N
N#define xPortPendSVHandler 	PendSV_Handler
N#define vPortSVCHandler 	SVC_Handler
N#define configUSE_PREEMPTION		0
N#define configUSE_IDLE_HOOK			0
N#define configUSE_TICK_HOOK			0
N#define configCPU_CLOCK_HZ			( ( unsigned long ) 72000000 )	
N#define configTICK_RATE_HZ			( ( TickType_t ) 1000 )
N#define configMAX_PRIORITIES		( 5 )
N#define configMINIMAL_STACK_SIZE	( ( unsigned short ) 128 )
N#define configTOTAL_HEAP_SIZE		( ( size_t ) ( 12*  1024 ) )
N#define INCLUDE_uxTaskGetStackHighWaterMark 1
N#define configMAX_TASK_NAME_LEN		( 16 )
N#define configUSE_TRACE_FACILITY	0
N#define configUSE_16_BIT_TICKS		0
N#define configIDLE_SHOULD_YIELD		1
N
N/* Co-routine definitions. */
N#define configUSE_CO_ROUTINES 		0
N#define configMAX_CO_ROUTINE_PRIORITIES ( 2 )
N
N/* Set the following definitions to 1 to include the API function, or zero
Nto exclude the API function. */
N
N#define INCLUDE_vTaskPrioritySet		1
N#define INCLUDE_uxTaskPriorityGet		1
N#define INCLUDE_vTaskDelete				1
N#define INCLUDE_vTaskCleanUpResources	0
N#define INCLUDE_vTaskSuspend			1
N#define INCLUDE_vTaskDelayUntil			1
N#define INCLUDE_vTaskDelay				1
N#define INCLUDE_xTaskGetSchedulerState  1
N#define INCLUDE_eTaskGetState 1
N
N/* This is the raw value as per the Cortex-M3 NVIC.  Values can be 255
N(lowest) to 0 (1?) (highest). */
N#define configKERNEL_INTERRUPT_PRIORITY 	15
N/* !!!! configMAX_SYSCALL_INTERRUPT_PRIORITY must not be set to zero !!!!
NSee http://www.FreeRTOS.org/RTOS-Cortex-M3-M4.html. */
N#define configMAX_SYSCALL_INTERRUPT_PRIORITY 5 /* equivalent to 0xb0, or priority 11. */
N
N
N/* This is the value being used as per the ST library which permits 16
Npriority values, 0 to 15.  This must correspond to the
NconfigKERNEL_INTERRUPT_PRIORITY setting.  Here 15 corresponds to the lowest
NNVIC value of 255. */
N#define configLIBRARY_KERNEL_INTERRUPT_PRIORITY	15
N
N
N
N
N
N
N#endif /* FREERTOS_CONFIG_H */
N
L 99 "..\..\Freee-RTOS\include\FreeRTOS.h" 2
N
N/* Basic FreeRTOS definitions. */
N#include "projdefs.h"
L 1 "..\..\Freee-RTOS\include\projdefs.h" 1
N/*
N    FreeRTOS V9.0.0 - Copyright (C) 2016 Real Time Engineers Ltd.
N    All rights reserved
N
N    VISIT http://www.FreeRTOS.org TO ENSURE YOU ARE USING THE LATEST VERSION.
N
N    This file is part of the FreeRTOS distribution.
N
N    FreeRTOS is free software; you can redistribute it and/or modify it under
N    the terms of the GNU General Public License (version 2) as published by the
N    Free Software Foundation >>>> AND MODIFIED BY <<<< the FreeRTOS exception.
N
N    ***************************************************************************
N    >>!   NOTE: The modification to the GPL is included to allow you to     !<<
N    >>!   distribute a combined work that includes FreeRTOS without being   !<<
N    >>!   obliged to provide the source code for proprietary components     !<<
N    >>!   outside of the FreeRTOS kernel.                                   !<<
N    ***************************************************************************
N
N    FreeRTOS is distributed in the hope that it will be useful, but WITHOUT ANY
N    WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
N    FOR A PARTICULAR PURPOSE.  Full license text is available on the following
N    link: http://www.freertos.org/a00114.html
N
N    ***************************************************************************
N     *                                                                       *
N     *    FreeRTOS provides completely free yet professionally developed,    *
N     *    robust, strictly quality controlled, supported, and cross          *
N     *    platform software that is more than just the market leader, it     *
N     *    is the industry's de facto standard.                               *
N     *                                                                       *
N     *    Help yourself get started quickly while simultaneously helping     *
N     *    to support the FreeRTOS project by purchasing a FreeRTOS           *
N     *    tutorial book, reference manual, or both:                          *
N     *    http://www.FreeRTOS.org/Documentation                              *
N     *                                                                       *
N    ***************************************************************************
N
N    http://www.FreeRTOS.org/FAQHelp.html - Having a problem?  Start by reading
N    the FAQ page "My application does not run, what could be wrong?".  Have you
N    defined configASSERT()?
N
N    http://www.FreeRTOS.org/support - In return for receiving this top quality
N    embedded software for free we request you assist our global community by
N    participating in the support forum.
N
N    http://www.FreeRTOS.org/training - Investing in training allows your team to
N    be as productive as possible as early as possible.  Now you can receive
N    FreeRTOS training directly from Richard Barry, CEO of Real Time Engineers
N    Ltd, and the world's leading authority on the world's leading RTOS.
N
N    http://www.FreeRTOS.org/plus - A selection of FreeRTOS ecosystem products,
N    including FreeRTOS+Trace - an indispensable productivity tool, a DOS
N    compatible FAT file system, and our tiny thread aware UDP/IP stack.
N
N    http://www.FreeRTOS.org/labs - Where new FreeRTOS products go to incubate.
N    Come and try FreeRTOS+TCP, our new open source TCP/IP stack for FreeRTOS.
N
N    http://www.OpenRTOS.com - Real Time Engineers ltd. license FreeRTOS to High
N    Integrity Systems ltd. to sell under the OpenRTOS brand.  Low cost OpenRTOS
N    licenses offer ticketed support, indemnification and commercial middleware.
N
N    http://www.SafeRTOS.com - High Integrity Systems also provide a safety
N    engineered and independently SIL3 certified version for use in safety and
N    mission critical applications that require provable dependability.
N
N    1 tab == 4 spaces!
N*/
N
N#ifndef PROJDEFS_H
N#define PROJDEFS_H
N
N/*
N * Defines the prototype to which task functions must conform.  Defined in this
N * file to ensure the type is known before portable.h is included.
N */
Ntypedef void (*TaskFunction_t)( void * );
N
N/* Converts a time in milliseconds to a time in ticks.  This macro can be
Noverridden by a macro of the same name defined in FreeRTOSConfig.h in case the
Ndefinition here is not suitable for your application. */
N#ifndef pdMS_TO_TICKS
N	#define pdMS_TO_TICKS( xTimeInMs ) ( ( TickType_t ) ( ( ( TickType_t ) ( xTimeInMs ) * ( TickType_t ) configTICK_RATE_HZ ) / ( TickType_t ) 1000 ) )
N#endif
N
N#define pdFALSE			( ( BaseType_t ) 0 )
N#define pdTRUE			( ( BaseType_t ) 1 )
N
N#define pdPASS			( pdTRUE )
N#define pdFAIL			( pdFALSE )
N#define errQUEUE_EMPTY	( ( BaseType_t ) 0 )
N#define errQUEUE_FULL	( ( BaseType_t ) 0 )
N
N/* FreeRTOS error definitions. */
N#define errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY	( -1 )
N#define errQUEUE_BLOCKED						( -4 )
N#define errQUEUE_YIELD							( -5 )
N
N/* Macros used for basic data corruption checks. */
N#ifndef configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES
N	#define configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES 0
N#endif
N
N#if( configUSE_16_BIT_TICKS == 1 )
X#if( 0 == 1 )
S	#define pdINTEGRITY_CHECK_VALUE 0x5a5a
N#else
N	#define pdINTEGRITY_CHECK_VALUE 0x5a5a5a5aUL
N#endif
N
N/* The following errno values are used by FreeRTOS+ components, not FreeRTOS
Nitself. */
N#define pdFREERTOS_ERRNO_NONE			0	/* No errors */
N#define	pdFREERTOS_ERRNO_ENOENT			2	/* No such file or directory */
N#define	pdFREERTOS_ERRNO_EINTR			4	/* Interrupted system call */
N#define	pdFREERTOS_ERRNO_EIO			5	/* I/O error */
N#define	pdFREERTOS_ERRNO_ENXIO			6	/* No such device or address */
N#define	pdFREERTOS_ERRNO_EBADF			9	/* Bad file number */
N#define	pdFREERTOS_ERRNO_EAGAIN			11	/* No more processes */
N#define	pdFREERTOS_ERRNO_EWOULDBLOCK	11	/* Operation would block */
N#define	pdFREERTOS_ERRNO_ENOMEM			12	/* Not enough memory */
N#define	pdFREERTOS_ERRNO_EACCES			13	/* Permission denied */
N#define	pdFREERTOS_ERRNO_EFAULT			14	/* Bad address */
N#define	pdFREERTOS_ERRNO_EBUSY			16	/* Mount device busy */
N#define	pdFREERTOS_ERRNO_EEXIST			17	/* File exists */
N#define	pdFREERTOS_ERRNO_EXDEV			18	/* Cross-device link */
N#define	pdFREERTOS_ERRNO_ENODEV			19	/* No such device */
N#define	pdFREERTOS_ERRNO_ENOTDIR		20	/* Not a directory */
N#define	pdFREERTOS_ERRNO_EISDIR			21	/* Is a directory */
N#define	pdFREERTOS_ERRNO_EINVAL			22	/* Invalid argument */
N#define	pdFREERTOS_ERRNO_ENOSPC			28	/* No space left on device */
N#define	pdFREERTOS_ERRNO_ESPIPE			29	/* Illegal seek */
N#define	pdFREERTOS_ERRNO_EROFS			30	/* Read only file system */
N#define	pdFREERTOS_ERRNO_EUNATCH		42	/* Protocol driver not attached */
N#define	pdFREERTOS_ERRNO_EBADE			50	/* Invalid exchange */
N#define	pdFREERTOS_ERRNO_EFTYPE			79	/* Inappropriate file type or format */
N#define	pdFREERTOS_ERRNO_ENMFILE		89	/* No more files */
N#define	pdFREERTOS_ERRNO_ENOTEMPTY		90	/* Directory not empty */
N#define	pdFREERTOS_ERRNO_ENAMETOOLONG 	91	/* File or path name too long */
N#define	pdFREERTOS_ERRNO_EOPNOTSUPP		95	/* Operation not supported on transport endpoint */
N#define	pdFREERTOS_ERRNO_ENOBUFS		105	/* No buffer space available */
N#define	pdFREERTOS_ERRNO_ENOPROTOOPT	109	/* Protocol not available */
N#define	pdFREERTOS_ERRNO_EADDRINUSE		112	/* Address already in use */
N#define	pdFREERTOS_ERRNO_ETIMEDOUT		116	/* Connection timed out */
N#define	pdFREERTOS_ERRNO_EINPROGRESS	119	/* Connection already in progress */
N#define	pdFREERTOS_ERRNO_EALREADY		120	/* Socket already connected */
N#define	pdFREERTOS_ERRNO_EADDRNOTAVAIL 	125	/* Address not available */
N#define	pdFREERTOS_ERRNO_EISCONN		127	/* Socket is already connected */
N#define	pdFREERTOS_ERRNO_ENOTCONN		128	/* Socket is not connected */
N#define	pdFREERTOS_ERRNO_ENOMEDIUM		135	/* No medium inserted */
N#define	pdFREERTOS_ERRNO_EILSEQ			138	/* An invalid UTF-16 sequence was encountered. */
N#define	pdFREERTOS_ERRNO_ECANCELED		140	/* Operation canceled. */
N
N/* The following endian values are used by FreeRTOS+ components, not FreeRTOS
Nitself. */
N#define pdFREERTOS_LITTLE_ENDIAN	0
N#define pdFREERTOS_BIG_ENDIAN		1
N
N#endif /* PROJDEFS_H */
N
N
N
L 102 "..\..\Freee-RTOS\include\FreeRTOS.h" 2
N
N/* Definitions specific to the port being used. */
N#include "portable.h"
L 1 "..\..\Freee-RTOS\include\portable.h" 1
N/*
N    FreeRTOS V9.0.0 - Copyright (C) 2016 Real Time Engineers Ltd.
N    All rights reserved
N
N    VISIT http://www.FreeRTOS.org TO ENSURE YOU ARE USING THE LATEST VERSION.
N
N    This file is part of the FreeRTOS distribution.
N
N    FreeRTOS is free software; you can redistribute it and/or modify it under
N    the terms of the GNU General Public License (version 2) as published by the
N    Free Software Foundation >>>> AND MODIFIED BY <<<< the FreeRTOS exception.
N
N    ***************************************************************************
N    >>!   NOTE: The modification to the GPL is included to allow you to     !<<
N    >>!   distribute a combined work that includes FreeRTOS without being   !<<
N    >>!   obliged to provide the source code for proprietary components     !<<
N    >>!   outside of the FreeRTOS kernel.                                   !<<
N    ***************************************************************************
N
N    FreeRTOS is distributed in the hope that it will be useful, but WITHOUT ANY
N    WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
N    FOR A PARTICULAR PURPOSE.  Full license text is available on the following
N    link: http://www.freertos.org/a00114.html
N
N    ***************************************************************************
N     *                                                                       *
N     *    FreeRTOS provides completely free yet professionally developed,    *
N     *    robust, strictly quality controlled, supported, and cross          *
N     *    platform software that is more than just the market leader, it     *
N     *    is the industry's de facto standard.                               *
N     *                                                                       *
N     *    Help yourself get started quickly while simultaneously helping     *
N     *    to support the FreeRTOS project by purchasing a FreeRTOS           *
N     *    tutorial book, reference manual, or both:                          *
N     *    http://www.FreeRTOS.org/Documentation                              *
N     *                                                                       *
N    ***************************************************************************
N
N    http://www.FreeRTOS.org/FAQHelp.html - Having a problem?  Start by reading
N    the FAQ page "My application does not run, what could be wrong?".  Have you
N    defined configASSERT()?
N
N    http://www.FreeRTOS.org/support - In return for receiving this top quality
N    embedded software for free we request you assist our global community by
N    participating in the support forum.
N
N    http://www.FreeRTOS.org/training - Investing in training allows your team to
N    be as productive as possible as early as possible.  Now you can receive
N    FreeRTOS training directly from Richard Barry, CEO of Real Time Engineers
N    Ltd, and the world's leading authority on the world's leading RTOS.
N
N    http://www.FreeRTOS.org/plus - A selection of FreeRTOS ecosystem products,
N    including FreeRTOS+Trace - an indispensable productivity tool, a DOS
N    compatible FAT file system, and our tiny thread aware UDP/IP stack.
N
N    http://www.FreeRTOS.org/labs - Where new FreeRTOS products go to incubate.
N    Come and try FreeRTOS+TCP, our new open source TCP/IP stack for FreeRTOS.
N
N    http://www.OpenRTOS.com - Real Time Engineers ltd. license FreeRTOS to High
N    Integrity Systems ltd. to sell under the OpenRTOS brand.  Low cost OpenRTOS
N    licenses offer ticketed support, indemnification and commercial middleware.
N
N    http://www.SafeRTOS.com - High Integrity Systems also provide a safety
N    engineered and independently SIL3 certified version for use in safety and
N    mission critical applications that require provable dependability.
N
N    1 tab == 4 spaces!
N*/
N
N/*-----------------------------------------------------------
N * Portable layer API.  Each function must be defined for each port.
N *----------------------------------------------------------*/
N
N#ifndef PORTABLE_H
N#define PORTABLE_H
N
N/* Each FreeRTOS port has a unique portmacro.h header file.  Originally a
Npre-processor definition was used to ensure the pre-processor found the correct
Nportmacro.h file for the port being used.  That scheme was deprecated in favour
Nof setting the compiler's include path such that it found the correct
Nportmacro.h file - removing the need for the constant and allowing the
Nportmacro.h file to be located anywhere in relation to the port being used.
NPurely for reasons of backward compatibility the old method is still valid, but
Nto make it clear that new projects should not use it, support for the port
Nspecific constants has been moved into the deprecated_definitions.h header
Nfile. */
N#include "deprecated_definitions.h"
L 1 "..\..\Freee-RTOS\include\deprecated_definitions.h" 1
N/*
N    FreeRTOS V9.0.0 - Copyright (C) 2016 Real Time Engineers Ltd.
N    All rights reserved
N
N    VISIT http://www.FreeRTOS.org TO ENSURE YOU ARE USING THE LATEST VERSION.
N
N    This file is part of the FreeRTOS distribution.
N
N    FreeRTOS is free software; you can redistribute it and/or modify it under
N    the terms of the GNU General Public License (version 2) as published by the
N    Free Software Foundation >>>> AND MODIFIED BY <<<< the FreeRTOS exception.
N
N    ***************************************************************************
N    >>!   NOTE: The modification to the GPL is included to allow you to     !<<
N    >>!   distribute a combined work that includes FreeRTOS without being   !<<
N    >>!   obliged to provide the source code for proprietary components     !<<
N    >>!   outside of the FreeRTOS kernel.                                   !<<
N    ***************************************************************************
N
N    FreeRTOS is distributed in the hope that it will be useful, but WITHOUT ANY
N    WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
N    FOR A PARTICULAR PURPOSE.  Full license text is available on the following
N    link: http://www.freertos.org/a00114.html
N
N    ***************************************************************************
N     *                                                                       *
N     *    FreeRTOS provides completely free yet professionally developed,    *
N     *    robust, strictly quality controlled, supported, and cross          *
N     *    platform software that is more than just the market leader, it     *
N     *    is the industry's de facto standard.                               *
N     *                                                                       *
N     *    Help yourself get started quickly while simultaneously helping     *
N     *    to support the FreeRTOS project by purchasing a FreeRTOS           *
N     *    tutorial book, reference manual, or both:                          *
N     *    http://www.FreeRTOS.org/Documentation                              *
N     *                                                                       *
N    ***************************************************************************
N
N    http://www.FreeRTOS.org/FAQHelp.html - Having a problem?  Start by reading
N    the FAQ page "My application does not run, what could be wrong?".  Have you
N    defined configASSERT()?
N
N    http://www.FreeRTOS.org/support - In return for receiving this top quality
N    embedded software for free we request you assist our global community by
N    participating in the support forum.
N
N    http://www.FreeRTOS.org/training - Investing in training allows your team to
N    be as productive as possible as early as possible.  Now you can receive
N    FreeRTOS training directly from Richard Barry, CEO of Real Time Engineers
N    Ltd, and the world's leading authority on the world's leading RTOS.
N
N    http://www.FreeRTOS.org/plus - A selection of FreeRTOS ecosystem products,
N    including FreeRTOS+Trace - an indispensable productivity tool, a DOS
N    compatible FAT file system, and our tiny thread aware UDP/IP stack.
N
N    http://www.FreeRTOS.org/labs - Where new FreeRTOS products go to incubate.
N    Come and try FreeRTOS+TCP, our new open source TCP/IP stack for FreeRTOS.
N
N    http://www.OpenRTOS.com - Real Time Engineers ltd. license FreeRTOS to High
N    Integrity Systems ltd. to sell under the OpenRTOS brand.  Low cost OpenRTOS
N    licenses offer ticketed support, indemnification and commercial middleware.
N
N    http://www.SafeRTOS.com - High Integrity Systems also provide a safety
N    engineered and independently SIL3 certified version for use in safety and
N    mission critical applications that require provable dependability.
N
N    1 tab == 4 spaces!
N*/
N
N#ifndef DEPRECATED_DEFINITIONS_H
N#define DEPRECATED_DEFINITIONS_H
N
N
N/* Each FreeRTOS port has a unique portmacro.h header file.  Originally a
Npre-processor definition was used to ensure the pre-processor found the correct
Nportmacro.h file for the port being used.  That scheme was deprecated in favour
Nof setting the compiler's include path such that it found the correct
Nportmacro.h file - removing the need for the constant and allowing the
Nportmacro.h file to be located anywhere in relation to the port being used.  The
Ndefinitions below remain in the code for backward compatibility only.  New
Nprojects should not use them. */
N
N#ifdef OPEN_WATCOM_INDUSTRIAL_PC_PORT
S	#include "..\..\Source\portable\owatcom\16bitdos\pc\portmacro.h"
S	typedef void ( __interrupt __far *pxISR )();
N#endif
N
N#ifdef OPEN_WATCOM_FLASH_LITE_186_PORT
S	#include "..\..\Source\portable\owatcom\16bitdos\flsh186\portmacro.h"
S	typedef void ( __interrupt __far *pxISR )();
N#endif
N
N#ifdef GCC_MEGA_AVR
S	#include "../portable/GCC/ATMega323/portmacro.h"
N#endif
N
N#ifdef IAR_MEGA_AVR
S	#include "../portable/IAR/ATMega323/portmacro.h"
N#endif
N
N#ifdef MPLAB_PIC24_PORT
S	#include "../../Source/portable/MPLAB/PIC24_dsPIC/portmacro.h"
N#endif
N
N#ifdef MPLAB_DSPIC_PORT
S	#include "../../Source/portable/MPLAB/PIC24_dsPIC/portmacro.h"
N#endif
N
N#ifdef MPLAB_PIC18F_PORT
S	#include "../../Source/portable/MPLAB/PIC18F/portmacro.h"
N#endif
N
N#ifdef MPLAB_PIC32MX_PORT
S	#include "../../Source/portable/MPLAB/PIC32MX/portmacro.h"
N#endif
N
N#ifdef _FEDPICC
S	#include "libFreeRTOS/Include/portmacro.h"
N#endif
N
N#ifdef SDCC_CYGNAL
S	#include "../../Source/portable/SDCC/Cygnal/portmacro.h"
N#endif
N
N#ifdef GCC_ARM7
S	#include "../../Source/portable/GCC/ARM7_LPC2000/portmacro.h"
N#endif
N
N#ifdef GCC_ARM7_ECLIPSE
S	#include "portmacro.h"
N#endif
N
N#ifdef ROWLEY_LPC23xx
S	#include "../../Source/portable/GCC/ARM7_LPC23xx/portmacro.h"
N#endif
N
N#ifdef IAR_MSP430
S	#include "..\..\Source\portable\IAR\MSP430\portmacro.h"
N#endif
N
N#ifdef GCC_MSP430
S	#include "../../Source/portable/GCC/MSP430F449/portmacro.h"
N#endif
N
N#ifdef ROWLEY_MSP430
S	#include "../../Source/portable/Rowley/MSP430F449/portmacro.h"
N#endif
N
N#ifdef ARM7_LPC21xx_KEIL_RVDS
S	#include "..\..\Source\portable\RVDS\ARM7_LPC21xx\portmacro.h"
N#endif
N
N#ifdef SAM7_GCC
S	#include "../../Source/portable/GCC/ARM7_AT91SAM7S/portmacro.h"
N#endif
N
N#ifdef SAM7_IAR
S	#include "..\..\Source\portable\IAR\AtmelSAM7S64\portmacro.h"
N#endif
N
N#ifdef SAM9XE_IAR
S	#include "..\..\Source\portable\IAR\AtmelSAM9XE\portmacro.h"
N#endif
N
N#ifdef LPC2000_IAR
S	#include "..\..\Source\portable\IAR\LPC2000\portmacro.h"
N#endif
N
N#ifdef STR71X_IAR
S	#include "..\..\Source\portable\IAR\STR71x\portmacro.h"
N#endif
N
N#ifdef STR75X_IAR
S	#include "..\..\Source\portable\IAR\STR75x\portmacro.h"
N#endif
N
N#ifdef STR75X_GCC
S	#include "..\..\Source\portable\GCC\STR75x\portmacro.h"
N#endif
N
N#ifdef STR91X_IAR
S	#include "..\..\Source\portable\IAR\STR91x\portmacro.h"
N#endif
N
N#ifdef GCC_H8S
S	#include "../../Source/portable/GCC/H8S2329/portmacro.h"
N#endif
N
N#ifdef GCC_AT91FR40008
S	#include "../../Source/portable/GCC/ARM7_AT91FR40008/portmacro.h"
N#endif
N
N#ifdef RVDS_ARMCM3_LM3S102
S	#include "../../Source/portable/RVDS/ARM_CM3/portmacro.h"
N#endif
N
N#ifdef GCC_ARMCM3_LM3S102
S	#include "../../Source/portable/GCC/ARM_CM3/portmacro.h"
N#endif
N
N#ifdef GCC_ARMCM3
S	#include "../../Source/portable/GCC/ARM_CM3/portmacro.h"
N#endif
N
N#ifdef IAR_ARM_CM3
S	#include "../../Source/portable/IAR/ARM_CM3/portmacro.h"
N#endif
N
N#ifdef IAR_ARMCM3_LM
S	#include "../../Source/portable/IAR/ARM_CM3/portmacro.h"
N#endif
N
N#ifdef HCS12_CODE_WARRIOR
S	#include "../../Source/portable/CodeWarrior/HCS12/portmacro.h"
N#endif
N
N#ifdef MICROBLAZE_GCC
S	#include "../../Source/portable/GCC/MicroBlaze/portmacro.h"
N#endif
N
N#ifdef TERN_EE
S	#include "..\..\Source\portable\Paradigm\Tern_EE\small\portmacro.h"
N#endif
N
N#ifdef GCC_HCS12
S	#include "../../Source/portable/GCC/HCS12/portmacro.h"
N#endif
N
N#ifdef GCC_MCF5235
S    #include "../../Source/portable/GCC/MCF5235/portmacro.h"
N#endif
N
N#ifdef COLDFIRE_V2_GCC
S	#include "../../../Source/portable/GCC/ColdFire_V2/portmacro.h"
N#endif
N
N#ifdef COLDFIRE_V2_CODEWARRIOR
S	#include "../../Source/portable/CodeWarrior/ColdFire_V2/portmacro.h"
N#endif
N
N#ifdef GCC_PPC405
S	#include "../../Source/portable/GCC/PPC405_Xilinx/portmacro.h"
N#endif
N
N#ifdef GCC_PPC440
S	#include "../../Source/portable/GCC/PPC440_Xilinx/portmacro.h"
N#endif
N
N#ifdef _16FX_SOFTUNE
S	#include "..\..\Source\portable\Softune\MB96340\portmacro.h"
N#endif
N
N#ifdef BCC_INDUSTRIAL_PC_PORT
S	/* A short file name has to be used in place of the normal
S	FreeRTOSConfig.h when using the Borland compiler. */
S	#include "frconfig.h"
S	#include "..\portable\BCC\16BitDOS\PC\prtmacro.h"
S    typedef void ( __interrupt __far *pxISR )();
N#endif
N
N#ifdef BCC_FLASH_LITE_186_PORT
S	/* A short file name has to be used in place of the normal
S	FreeRTOSConfig.h when using the Borland compiler. */
S	#include "frconfig.h"
S	#include "..\portable\BCC\16BitDOS\flsh186\prtmacro.h"
S    typedef void ( __interrupt __far *pxISR )();
N#endif
N
N#ifdef __GNUC__
S   #ifdef __AVR32_AVR32A__
S	   #include "portmacro.h"
S   #endif
N#endif
N
N#ifdef __ICCAVR32__
S   #ifdef __CORE__
S      #if __CORE__ == __AVR32A__
S	      #include "portmacro.h"
S      #endif
S   #endif
N#endif
N
N#ifdef __91467D
S	#include "portmacro.h"
N#endif
N
N#ifdef __96340
S	#include "portmacro.h"
N#endif
N
N
N#ifdef __IAR_V850ES_Fx3__
S	#include "../../Source/portable/IAR/V850ES/portmacro.h"
N#endif
N
N#ifdef __IAR_V850ES_Jx3__
S	#include "../../Source/portable/IAR/V850ES/portmacro.h"
N#endif
N
N#ifdef __IAR_V850ES_Jx3_L__
S	#include "../../Source/portable/IAR/V850ES/portmacro.h"
N#endif
N
N#ifdef __IAR_V850ES_Jx2__
S	#include "../../Source/portable/IAR/V850ES/portmacro.h"
N#endif
N
N#ifdef __IAR_V850ES_Hx2__
S	#include "../../Source/portable/IAR/V850ES/portmacro.h"
N#endif
N
N#ifdef __IAR_78K0R_Kx3__
S	#include "../../Source/portable/IAR/78K0R/portmacro.h"
N#endif
N
N#ifdef __IAR_78K0R_Kx3L__
S	#include "../../Source/portable/IAR/78K0R/portmacro.h"
N#endif
N
N#endif /* DEPRECATED_DEFINITIONS_H */
N
L 88 "..\..\Freee-RTOS\include\portable.h" 2
N
N/* If portENTER_CRITICAL is not defined then including deprecated_definitions.h
Ndid not result in a portmacro.h header file being included - and it should be
Nincluded here.  In this case the path to the correct portmacro.h header file
Nmust be set in the compiler's include path. */
N#ifndef portENTER_CRITICAL
N	#include "portmacro.h"
L 1 "..\..\Freee-RTOS\include\portmacro.h" 1
N/*
N    FreeRTOS V9.0.0 - Copyright (C) 2016 Real Time Engineers Ltd.
N    All rights reserved
N
N    VISIT http://www.FreeRTOS.org TO ENSURE YOU ARE USING THE LATEST VERSION.
N
N    This file is part of the FreeRTOS distribution.
N
N    FreeRTOS is free software; you can redistribute it and/or modify it under
N    the terms of the GNU General Public License (version 2) as published by the
N    Free Software Foundation >>>> AND MODIFIED BY <<<< the FreeRTOS exception.
N
N    ***************************************************************************
N    >>!   NOTE: The modification to the GPL is included to allow you to     !<<
N    >>!   distribute a combined work that includes FreeRTOS without being   !<<
N    >>!   obliged to provide the source code for proprietary components     !<<
N    >>!   outside of the FreeRTOS kernel.                                   !<<
N    ***************************************************************************
N
N    FreeRTOS is distributed in the hope that it will be useful, but WITHOUT ANY
N    WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
N    FOR A PARTICULAR PURPOSE.  Full license text is available on the following
N    link: http://www.freertos.org/a00114.html
N
N    ***************************************************************************
N     *                                                                       *
N     *    FreeRTOS provides completely free yet professionally developed,    *
N     *    robust, strictly quality controlled, supported, and cross          *
N     *    platform software that is more than just the market leader, it     *
N     *    is the industry's de facto standard.                               *
N     *                                                                       *
N     *    Help yourself get started quickly while simultaneously helping     *
N     *    to support the FreeRTOS project by purchasing a FreeRTOS           *
N     *    tutorial book, reference manual, or both:                          *
N     *    http://www.FreeRTOS.org/Documentation                              *
N     *                                                                       *
N    ***************************************************************************
N
N    http://www.FreeRTOS.org/FAQHelp.html - Having a problem?  Start by reading
N    the FAQ page "My application does not run, what could be wrong?".  Have you
N    defined configASSERT()?
N
N    http://www.FreeRTOS.org/support - In return for receiving this top quality
N    embedded software for free we request you assist our global community by
N    participating in the support forum.
N
N    http://www.FreeRTOS.org/training - Investing in training allows your team to
N    be as productive as possible as early as possible.  Now you can receive
N    FreeRTOS training directly from Richard Barry, CEO of Real Time Engineers
N    Ltd, and the world's leading authority on the world's leading RTOS.
N
N    http://www.FreeRTOS.org/plus - A selection of FreeRTOS ecosystem products,
N    including FreeRTOS+Trace - an indispensable productivity tool, a DOS
N    compatible FAT file system, and our tiny thread aware UDP/IP stack.
N
N    http://www.FreeRTOS.org/labs - Where new FreeRTOS products go to incubate.
N    Come and try FreeRTOS+TCP, our new open source TCP/IP stack for FreeRTOS.
N
N    http://www.OpenRTOS.com - Real Time Engineers ltd. license FreeRTOS to High
N    Integrity Systems ltd. to sell under the OpenRTOS brand.  Low cost OpenRTOS
N    licenses offer ticketed support, indemnification and commercial middleware.
N
N    http://www.SafeRTOS.com - High Integrity Systems also provide a safety
N    engineered and independently SIL3 certified version for use in safety and
N    mission critical applications that require provable dependability.
N
N    1 tab == 4 spaces!
N*/
N
N
N#ifndef PORTMACRO_H
N#define PORTMACRO_H
N
N#ifdef __cplusplus
Sextern "C" {
N#endif
N
N/*-----------------------------------------------------------
N * Port specific definitions.
N *
N * The settings in this file configure FreeRTOS correctly for the
N * given hardware and compiler.
N *
N * These settings should not be altered.
N *-----------------------------------------------------------
N */
N
N/* Type definitions. */
N#define portCHAR		char
N#define portFLOAT		float
N#define portDOUBLE		double
N#define portLONG		long
N#define portSHORT		short
N#define portSTACK_TYPE	uint32_t
N#define portBASE_TYPE	long
N
Ntypedef portSTACK_TYPE StackType_t;
Xtypedef uint32_t StackType_t;
Ntypedef long BaseType_t;
Ntypedef unsigned long UBaseType_t;
N
N#if( configUSE_16_BIT_TICKS == 1 )
X#if( 0 == 1 )
S	typedef uint16_t TickType_t;
S	#define portMAX_DELAY ( TickType_t ) 0xffff
N#else
N	typedef uint32_t TickType_t;
N	#define portMAX_DELAY ( TickType_t ) 0xffffffffUL
N
N	/* 32-bit tick type on a 32-bit architecture, so reads of the tick count do
N	not need to be guarded with a critical section. */
N	#define portTICK_TYPE_IS_ATOMIC 1
N#endif
N/*-----------------------------------------------------------*/
N
N/* Architecture specifics. */
N#define portSTACK_GROWTH			( -1 )
N#define portTICK_PERIOD_MS			( ( TickType_t ) 1000 / configTICK_RATE_HZ )
N#define portBYTE_ALIGNMENT			8
N
N/* Constants used with memory barrier intrinsics. */
N#define portSY_FULL_READ_WRITE		( 15 )
N
N/*-----------------------------------------------------------*/
N
N/* Scheduler utilities. */
N#define portYIELD()																\
N{																				\
N	/* Set a PendSV to request a context switch. */								\
N	portNVIC_INT_CTRL_REG = portNVIC_PENDSVSET_BIT;								\
N																				\
N	/* Barriers are normally not required but do ensure the code is completely	\
N	within the specified behaviour for the architecture. */						\
N	__dsb( portSY_FULL_READ_WRITE );											\
N	__isb( portSY_FULL_READ_WRITE );											\
N}
X#define portYIELD()																{																					 									portNVIC_INT_CTRL_REG = portNVIC_PENDSVSET_BIT;																													 							__dsb( portSY_FULL_READ_WRITE );												__isb( portSY_FULL_READ_WRITE );											}
N/*-----------------------------------------------------------*/
N
N#define portNVIC_INT_CTRL_REG		( * ( ( volatile uint32_t * ) 0xe000ed04 ) )
N#define portNVIC_PENDSVSET_BIT		( 1UL << 28UL )
N#define portEND_SWITCHING_ISR( xSwitchRequired ) if( xSwitchRequired != pdFALSE ) portYIELD()
N#define portYIELD_FROM_ISR( x ) portEND_SWITCHING_ISR( x )
N/*-----------------------------------------------------------*/
N
N/* Critical section management. */
Nextern void vPortEnterCritical( void );
Nextern void vPortExitCritical( void );
N
N#define portDISABLE_INTERRUPTS()				vPortRaiseBASEPRI()
N#define portENABLE_INTERRUPTS()					vPortSetBASEPRI( 0 )
N#define portENTER_CRITICAL()					vPortEnterCritical()
N#define portEXIT_CRITICAL()						vPortExitCritical()
N#define portSET_INTERRUPT_MASK_FROM_ISR()		ulPortRaiseBASEPRI()
N#define portCLEAR_INTERRUPT_MASK_FROM_ISR(x)	vPortSetBASEPRI(x)
N
N/*-----------------------------------------------------------*/
N
N/* Tickless idle/low power functionality. */
N#ifndef portSUPPRESS_TICKS_AND_SLEEP
N	extern void vPortSuppressTicksAndSleep( TickType_t xExpectedIdleTime );
N	#define portSUPPRESS_TICKS_AND_SLEEP( xExpectedIdleTime ) vPortSuppressTicksAndSleep( xExpectedIdleTime )
N#endif
N/*-----------------------------------------------------------*/
N
N/* Port specific optimisations. */
N#ifndef configUSE_PORT_OPTIMISED_TASK_SELECTION
N	#define configUSE_PORT_OPTIMISED_TASK_SELECTION 1
N#endif
N
N#if configUSE_PORT_OPTIMISED_TASK_SELECTION == 1
X#if 1 == 1
N
N	/* Check the configuration. */
N	#if( configMAX_PRIORITIES > 32 )
X	#if( ( 5 ) > 32 )
S		#error configUSE_PORT_OPTIMISED_TASK_SELECTION can only be set to 1 when configMAX_PRIORITIES is less than or equal to 32.  It is very rare that a system requires more than 10 to 15 difference priorities as tasks that share a priority will time slice.
N	#endif
N
N	/* Store/clear the ready priorities in a bit map. */
N	#define portRECORD_READY_PRIORITY( uxPriority, uxReadyPriorities ) ( uxReadyPriorities ) |= ( 1UL << ( uxPriority ) )
N	#define portRESET_READY_PRIORITY( uxPriority, uxReadyPriorities ) ( uxReadyPriorities ) &= ~( 1UL << ( uxPriority ) )
N
N	/*-----------------------------------------------------------*/
N
N	#define portGET_HIGHEST_PRIORITY( uxTopPriority, uxReadyPriorities ) uxTopPriority = ( 31UL - ( uint32_t ) __clz( ( uxReadyPriorities ) ) )
N
N#endif /* taskRECORD_READY_PRIORITY */
N/*-----------------------------------------------------------*/
N
N/* Task function macros as described on the FreeRTOS.org WEB site.  These are
Nnot necessary for to use this port.  They are defined so the common demo files
N(which build with all the ports) will build. */
N#define portTASK_FUNCTION_PROTO( vFunction, pvParameters ) void vFunction( void *pvParameters )
N#define portTASK_FUNCTION( vFunction, pvParameters ) void vFunction( void *pvParameters )
N/*-----------------------------------------------------------*/
N
N#ifdef configASSERT
S	void vPortValidateInterruptPriority( void );
S	#define portASSERT_IF_INTERRUPT_PRIORITY_INVALID() 	vPortValidateInterruptPriority()
N#endif
N
N/* portNOP() is not required by this port. */
N#define portNOP()
N
N#define portINLINE __inline
N
N#ifndef portFORCE_INLINE
N	#define portFORCE_INLINE __forceinline
N#endif
N
N/*-----------------------------------------------------------*/
N
Nstatic portFORCE_INLINE void vPortSetBASEPRI( uint32_t ulBASEPRI )
Xstatic __forceinline void vPortSetBASEPRI( uint32_t ulBASEPRI )
N{
N	__asm
N	{
N		/* Barrier instructions are not used as this function is only used to
N		lower the BASEPRI value. */
N		msr basepri, ulBASEPRI
N	}
N}
N/*-----------------------------------------------------------*/
N
Nstatic portFORCE_INLINE void vPortRaiseBASEPRI( void )
Xstatic __forceinline void vPortRaiseBASEPRI( void )
N{
Nuint32_t ulNewBASEPRI = configMAX_SYSCALL_INTERRUPT_PRIORITY;
Xuint32_t ulNewBASEPRI = 5;
N
N	__asm
N	{
N		/* Set BASEPRI to the max syscall priority to effect a critical
N		section. */
N		msr basepri, ulNewBASEPRI
N		dsb
N		isb
N	}
N}
N/*-----------------------------------------------------------*/
N
Nstatic portFORCE_INLINE void vPortClearBASEPRIFromISR( void )
Xstatic __forceinline void vPortClearBASEPRIFromISR( void )
N{
N	__asm
N	{
N		/* Set BASEPRI to 0 so no interrupts are masked.  This function is only
N		used to lower the mask in an interrupt, so memory barriers are not 
N		used. */
N		msr basepri, #0
N	}
N}
N/*-----------------------------------------------------------*/
N
Nstatic portFORCE_INLINE uint32_t ulPortRaiseBASEPRI( void )
Xstatic __forceinline uint32_t ulPortRaiseBASEPRI( void )
N{
Nuint32_t ulReturn, ulNewBASEPRI = configMAX_SYSCALL_INTERRUPT_PRIORITY;
Xuint32_t ulReturn, ulNewBASEPRI = 5;
N
N	__asm
N	{
N		/* Set BASEPRI to the max syscall priority to effect a critical
N		section. */
N		mrs ulReturn, basepri
N		msr basepri, ulNewBASEPRI
N		dsb
N		isb
N	}
N
N	return ulReturn;
N}
N/*-----------------------------------------------------------*/
N
Nstatic portFORCE_INLINE BaseType_t xPortIsInsideInterrupt( void )
Xstatic __forceinline BaseType_t xPortIsInsideInterrupt( void )
N{
Nuint32_t ulCurrentInterrupt;
NBaseType_t xReturn;
N
N	/* Obtain the number of the currently executing interrupt. */
N	__asm
N	{
N		mrs ulCurrentInterrupt, ipsr
N	}
N
N	if( ulCurrentInterrupt == 0 )
N	{
N		xReturn = pdFALSE;
X		xReturn = ( ( BaseType_t ) 0 );
N	}
N	else
N	{
N		xReturn = pdTRUE;
X		xReturn = ( ( BaseType_t ) 1 );
N	}
N
N	return xReturn;
N}
N
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif /* PORTMACRO_H */
N
L 95 "..\..\Freee-RTOS\include\portable.h" 2
N#endif
N
N#if portBYTE_ALIGNMENT == 32
X#if 8 == 32
S	#define portBYTE_ALIGNMENT_MASK ( 0x001f )
N#endif
N
N#if portBYTE_ALIGNMENT == 16
X#if 8 == 16
S	#define portBYTE_ALIGNMENT_MASK ( 0x000f )
N#endif
N
N#if portBYTE_ALIGNMENT == 8
X#if 8 == 8
N	#define portBYTE_ALIGNMENT_MASK ( 0x0007 )
N#endif
N
N#if portBYTE_ALIGNMENT == 4
X#if 8 == 4
S	#define portBYTE_ALIGNMENT_MASK	( 0x0003 )
N#endif
N
N#if portBYTE_ALIGNMENT == 2
X#if 8 == 2
S	#define portBYTE_ALIGNMENT_MASK	( 0x0001 )
N#endif
N
N#if portBYTE_ALIGNMENT == 1
X#if 8 == 1
S	#define portBYTE_ALIGNMENT_MASK	( 0x0000 )
N#endif
N
N#ifndef portBYTE_ALIGNMENT_MASK
S	#error "Invalid portBYTE_ALIGNMENT definition"
N#endif
N
N#ifndef portNUM_CONFIGURABLE_REGIONS
N	#define portNUM_CONFIGURABLE_REGIONS 1
N#endif
N
N#ifdef __cplusplus
Sextern "C" {
N#endif
N
N#include "mpu_wrappers.h"
L 1 "..\..\Freee-RTOS\include\mpu_wrappers.h" 1
N/*
N    FreeRTOS V9.0.0 - Copyright (C) 2016 Real Time Engineers Ltd.
N    All rights reserved
N
N    VISIT http://www.FreeRTOS.org TO ENSURE YOU ARE USING THE LATEST VERSION.
N
N    This file is part of the FreeRTOS distribution.
N
N    FreeRTOS is free software; you can redistribute it and/or modify it under
N    the terms of the GNU General Public License (version 2) as published by the
N    Free Software Foundation >>>> AND MODIFIED BY <<<< the FreeRTOS exception.
N
N    ***************************************************************************
N    >>!   NOTE: The modification to the GPL is included to allow you to     !<<
N    >>!   distribute a combined work that includes FreeRTOS without being   !<<
N    >>!   obliged to provide the source code for proprietary components     !<<
N    >>!   outside of the FreeRTOS kernel.                                   !<<
N    ***************************************************************************
N
N    FreeRTOS is distributed in the hope that it will be useful, but WITHOUT ANY
N    WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
N    FOR A PARTICULAR PURPOSE.  Full license text is available on the following
N    link: http://www.freertos.org/a00114.html
N
N    ***************************************************************************
N     *                                                                       *
N     *    FreeRTOS provides completely free yet professionally developed,    *
N     *    robust, strictly quality controlled, supported, and cross          *
N     *    platform software that is more than just the market leader, it     *
N     *    is the industry's de facto standard.                               *
N     *                                                                       *
N     *    Help yourself get started quickly while simultaneously helping     *
N     *    to support the FreeRTOS project by purchasing a FreeRTOS           *
N     *    tutorial book, reference manual, or both:                          *
N     *    http://www.FreeRTOS.org/Documentation                              *
N     *                                                                       *
N    ***************************************************************************
N
N    http://www.FreeRTOS.org/FAQHelp.html - Having a problem?  Start by reading
N    the FAQ page "My application does not run, what could be wrong?".  Have you
N    defined configASSERT()?
N
N    http://www.FreeRTOS.org/support - In return for receiving this top quality
N    embedded software for free we request you assist our global community by
N    participating in the support forum.
N
N    http://www.FreeRTOS.org/training - Investing in training allows your team to
N    be as productive as possible as early as possible.  Now you can receive
N    FreeRTOS training directly from Richard Barry, CEO of Real Time Engineers
N    Ltd, and the world's leading authority on the world's leading RTOS.
N
N    http://www.FreeRTOS.org/plus - A selection of FreeRTOS ecosystem products,
N    including FreeRTOS+Trace - an indispensable productivity tool, a DOS
N    compatible FAT file system, and our tiny thread aware UDP/IP stack.
N
N    http://www.FreeRTOS.org/labs - Where new FreeRTOS products go to incubate.
N    Come and try FreeRTOS+TCP, our new open source TCP/IP stack for FreeRTOS.
N
N    http://www.OpenRTOS.com - Real Time Engineers ltd. license FreeRTOS to High
N    Integrity Systems ltd. to sell under the OpenRTOS brand.  Low cost OpenRTOS
N    licenses offer ticketed support, indemnification and commercial middleware.
N
N    http://www.SafeRTOS.com - High Integrity Systems also provide a safety
N    engineered and independently SIL3 certified version for use in safety and
N    mission critical applications that require provable dependability.
N
N    1 tab == 4 spaces!
N*/
N
N#ifndef MPU_WRAPPERS_H
N#define MPU_WRAPPERS_H
N
N/* This file redefines API functions to be called through a wrapper macro, but
Nonly for ports that are using the MPU. */
N#ifdef portUSING_MPU_WRAPPERS
S
S	/* MPU_WRAPPERS_INCLUDED_FROM_API_FILE will be defined when this file is
S	included from queue.c or task.c to prevent it from having an effect within
S	those files. */
S	#ifndef MPU_WRAPPERS_INCLUDED_FROM_API_FILE
S
S		/*
S		 * Map standard (non MPU) API functions to equivalents that start
S		 * "MPU_".  This will cause the application code to call the MPU_
S		 * version, which wraps the non-MPU version with privilege promoting
S		 * then demoting code, so the kernel code always runs will full
S		 * privileges.
S		 */
S
S		/* Map standard tasks.h API functions to the MPU equivalents. */
S		#define xTaskCreate								MPU_xTaskCreate
S		#define xTaskCreateStatic						MPU_xTaskCreateStatic
S		#define xTaskCreateRestricted					MPU_xTaskCreateRestricted
S		#define vTaskAllocateMPURegions					MPU_vTaskAllocateMPURegions
S		#define vTaskDelete								MPU_vTaskDelete
S		#define vTaskDelay								MPU_vTaskDelay
S		#define vTaskDelayUntil							MPU_vTaskDelayUntil
S		#define xTaskAbortDelay							MPU_xTaskAbortDelay
S		#define uxTaskPriorityGet						MPU_uxTaskPriorityGet
S		#define eTaskGetState							MPU_eTaskGetState
S		#define vTaskGetInfo							MPU_vTaskGetInfo
S		#define vTaskPrioritySet						MPU_vTaskPrioritySet
S		#define vTaskSuspend							MPU_vTaskSuspend
S		#define vTaskResume								MPU_vTaskResume
S		#define vTaskSuspendAll							MPU_vTaskSuspendAll
S		#define xTaskResumeAll							MPU_xTaskResumeAll
S		#define xTaskGetTickCount						MPU_xTaskGetTickCount
S		#define uxTaskGetNumberOfTasks					MPU_uxTaskGetNumberOfTasks
S		#define pcTaskGetName							MPU_pcTaskGetName
S		#define xTaskGetHandle							MPU_xTaskGetHandle
S		#define uxTaskGetStackHighWaterMark				MPU_uxTaskGetStackHighWaterMark
S		#define vTaskSetApplicationTaskTag				MPU_vTaskSetApplicationTaskTag
S		#define xTaskGetApplicationTaskTag				MPU_xTaskGetApplicationTaskTag
S		#define vTaskSetThreadLocalStoragePointer		MPU_vTaskSetThreadLocalStoragePointer
S		#define pvTaskGetThreadLocalStoragePointer		MPU_pvTaskGetThreadLocalStoragePointer
S		#define xTaskCallApplicationTaskHook			MPU_xTaskCallApplicationTaskHook
S		#define xTaskGetIdleTaskHandle					MPU_xTaskGetIdleTaskHandle
S		#define uxTaskGetSystemState					MPU_uxTaskGetSystemState
S		#define vTaskList								MPU_vTaskList
S		#define vTaskGetRunTimeStats					MPU_vTaskGetRunTimeStats
S		#define xTaskGenericNotify						MPU_xTaskGenericNotify
S		#define xTaskNotifyWait							MPU_xTaskNotifyWait
S		#define ulTaskNotifyTake						MPU_ulTaskNotifyTake
S		#define xTaskNotifyStateClear					MPU_xTaskNotifyStateClear
S
S		#define xTaskGetCurrentTaskHandle				MPU_xTaskGetCurrentTaskHandle
S		#define vTaskSetTimeOutState					MPU_vTaskSetTimeOutState
S		#define xTaskCheckForTimeOut					MPU_xTaskCheckForTimeOut
S		#define xTaskGetSchedulerState					MPU_xTaskGetSchedulerState
S
S		/* Map standard queue.h API functions to the MPU equivalents. */
S		#define xQueueGenericSend						MPU_xQueueGenericSend
S		#define xQueueGenericReceive					MPU_xQueueGenericReceive
S		#define uxQueueMessagesWaiting					MPU_uxQueueMessagesWaiting
S		#define uxQueueSpacesAvailable					MPU_uxQueueSpacesAvailable
S		#define vQueueDelete							MPU_vQueueDelete
S		#define xQueueCreateMutex						MPU_xQueueCreateMutex
S		#define xQueueCreateMutexStatic					MPU_xQueueCreateMutexStatic
S		#define xQueueCreateCountingSemaphore			MPU_xQueueCreateCountingSemaphore
S		#define xQueueCreateCountingSemaphoreStatic		MPU_xQueueCreateCountingSemaphoreStatic
S		#define xQueueGetMutexHolder					MPU_xQueueGetMutexHolder
S		#define xQueueTakeMutexRecursive				MPU_xQueueTakeMutexRecursive
S		#define xQueueGiveMutexRecursive				MPU_xQueueGiveMutexRecursive
S		#define xQueueGenericCreate						MPU_xQueueGenericCreate
S		#define xQueueGenericCreateStatic				MPU_xQueueGenericCreateStatic
S		#define xQueueCreateSet							MPU_xQueueCreateSet
S		#define xQueueAddToSet							MPU_xQueueAddToSet
S		#define xQueueRemoveFromSet						MPU_xQueueRemoveFromSet
S		#define xQueueSelectFromSet						MPU_xQueueSelectFromSet
S		#define xQueueGenericReset						MPU_xQueueGenericReset
S
S		#if( configQUEUE_REGISTRY_SIZE > 0 )
S			#define vQueueAddToRegistry						MPU_vQueueAddToRegistry
S			#define vQueueUnregisterQueue					MPU_vQueueUnregisterQueue
S			#define pcQueueGetName							MPU_pcQueueGetName
S		#endif
S
S		/* Map standard timer.h API functions to the MPU equivalents. */
S		#define xTimerCreate							MPU_xTimerCreate
S		#define xTimerCreateStatic						MPU_xTimerCreateStatic
S		#define pvTimerGetTimerID						MPU_pvTimerGetTimerID
S		#define vTimerSetTimerID						MPU_vTimerSetTimerID
S		#define xTimerIsTimerActive						MPU_xTimerIsTimerActive
S		#define xTimerGetTimerDaemonTaskHandle			MPU_xTimerGetTimerDaemonTaskHandle
S		#define xTimerPendFunctionCall					MPU_xTimerPendFunctionCall
S		#define pcTimerGetName							MPU_pcTimerGetName
S		#define xTimerGetPeriod							MPU_xTimerGetPeriod
S		#define xTimerGetExpiryTime						MPU_xTimerGetExpiryTime
S		#define xTimerGenericCommand					MPU_xTimerGenericCommand
S
S		/* Map standard event_group.h API functions to the MPU equivalents. */
S		#define xEventGroupCreate						MPU_xEventGroupCreate
S		#define xEventGroupCreateStatic					MPU_xEventGroupCreateStatic
S		#define xEventGroupWaitBits						MPU_xEventGroupWaitBits
S		#define xEventGroupClearBits					MPU_xEventGroupClearBits
S		#define xEventGroupSetBits						MPU_xEventGroupSetBits
S		#define xEventGroupSync							MPU_xEventGroupSync
S		#define vEventGroupDelete						MPU_vEventGroupDelete
S
S		/* Remove the privileged function macro. */
S		#define PRIVILEGED_FUNCTION
S
S	#else /* MPU_WRAPPERS_INCLUDED_FROM_API_FILE */
S
S		/* Ensure API functions go in the privileged execution section. */
S		#define PRIVILEGED_FUNCTION __attribute__((section("privileged_functions")))
S		#define PRIVILEGED_DATA __attribute__((section("privileged_data")))
S
S	#endif /* MPU_WRAPPERS_INCLUDED_FROM_API_FILE */
S
N#else /* portUSING_MPU_WRAPPERS */
N
N	#define PRIVILEGED_FUNCTION
N	#define PRIVILEGED_DATA
N	#define portUSING_MPU_WRAPPERS 0
N
N#endif /* portUSING_MPU_WRAPPERS */
N
N
N#endif /* MPU_WRAPPERS_H */
N
L 134 "..\..\Freee-RTOS\include\portable.h" 2
N
N/*
N * Setup the stack of a new task so it is ready to be placed under the
N * scheduler control.  The registers have to be placed on the stack in
N * the order that the port expects to find them.
N *
N */
N#if( portUSING_MPU_WRAPPERS == 1 )
X#if( 0 == 1 )
S	StackType_t *pxPortInitialiseStack( StackType_t *pxTopOfStack, TaskFunction_t pxCode, void *pvParameters, BaseType_t xRunPrivileged ) PRIVILEGED_FUNCTION;
N#else
N	StackType_t *pxPortInitialiseStack( StackType_t *pxTopOfStack, TaskFunction_t pxCode, void *pvParameters ) PRIVILEGED_FUNCTION;
X	StackType_t *pxPortInitialiseStack( StackType_t *pxTopOfStack, TaskFunction_t pxCode, void *pvParameters ) ;
N#endif
N
N/* Used by heap_5.c. */
Ntypedef struct HeapRegion
N{
N	uint8_t *pucStartAddress;
N	size_t xSizeInBytes;
N} HeapRegion_t;
N
N/*
N * Used to define multiple heap regions for use by heap_5.c.  This function
N * must be called before any calls to pvPortMalloc() - not creating a task,
N * queue, semaphore, mutex, software timer, event group, etc. will result in
N * pvPortMalloc being called.
N *
N * pxHeapRegions passes in an array of HeapRegion_t structures - each of which
N * defines a region of memory that can be used as the heap.  The array is
N * terminated by a HeapRegions_t structure that has a size of 0.  The region
N * with the lowest start address must appear first in the array.
N */
Nvoid vPortDefineHeapRegions( const HeapRegion_t * const pxHeapRegions ) PRIVILEGED_FUNCTION;
Xvoid vPortDefineHeapRegions( const HeapRegion_t * const pxHeapRegions ) ;
N
N
N/*
N * Map to the memory management routines required for the port.
N */
Nvoid *pvPortMalloc( size_t xSize ) PRIVILEGED_FUNCTION;
Xvoid *pvPortMalloc( size_t xSize ) ;
Nvoid vPortFree( void *pv ) PRIVILEGED_FUNCTION;
Xvoid vPortFree( void *pv ) ;
Nvoid vPortInitialiseBlocks( void ) PRIVILEGED_FUNCTION;
Xvoid vPortInitialiseBlocks( void ) ;
Nsize_t xPortGetFreeHeapSize( void ) PRIVILEGED_FUNCTION;
Xsize_t xPortGetFreeHeapSize( void ) ;
Nsize_t xPortGetMinimumEverFreeHeapSize( void ) PRIVILEGED_FUNCTION;
Xsize_t xPortGetMinimumEverFreeHeapSize( void ) ;
N
N/*
N * Setup the hardware ready for the scheduler to take control.  This generally
N * sets up a tick interrupt and sets timers for the correct tick frequency.
N */
NBaseType_t xPortStartScheduler( void ) PRIVILEGED_FUNCTION;
XBaseType_t xPortStartScheduler( void ) ;
N
N/*
N * Undo any hardware/ISR setup that was performed by xPortStartScheduler() so
N * the hardware is left in its original condition after the scheduler stops
N * executing.
N */
Nvoid vPortEndScheduler( void ) PRIVILEGED_FUNCTION;
Xvoid vPortEndScheduler( void ) ;
N
N/*
N * The structures and methods of manipulating the MPU are contained within the
N * port layer.
N *
N * Fills the xMPUSettings structure with the memory region information
N * contained in xRegions.
N */
N#if( portUSING_MPU_WRAPPERS == 1 )
X#if( 0 == 1 )
S	struct xMEMORY_REGION;
S	void vPortStoreTaskMPUSettings( xMPU_SETTINGS *xMPUSettings, const struct xMEMORY_REGION * const xRegions, StackType_t *pxBottomOfStack, uint32_t ulStackDepth ) PRIVILEGED_FUNCTION;
N#endif
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif /* PORTABLE_H */
N
L 105 "..\..\Freee-RTOS\include\FreeRTOS.h" 2
N
N/* Must be defaulted before configUSE_NEWLIB_REENTRANT is used below. */
N#ifndef configUSE_NEWLIB_REENTRANT
N	#define configUSE_NEWLIB_REENTRANT 0
N#endif
N
N/* Required if struct _reent is used. */
N#if ( configUSE_NEWLIB_REENTRANT == 1 )
X#if ( 0 == 1 )
S	#include <reent.h>
N#endif
N/*
N * Check all the required application specific macros have been defined.
N * These macros are application specific and (as downloaded) are defined
N * within FreeRTOSConfig.h.
N */
N
N#ifndef configMINIMAL_STACK_SIZE
S	#error Missing definition:  configMINIMAL_STACK_SIZE must be defined in FreeRTOSConfig.h.  configMINIMAL_STACK_SIZE defines the size (in words) of the stack allocated to the idle task.  Refer to the demo project provided for your port for a suitable value.
N#endif
N
N#ifndef configMAX_PRIORITIES
S	#error Missing definition:  configMAX_PRIORITIES must be defined in FreeRTOSConfig.h.  See the Configuration section of the FreeRTOS API documentation for details.
N#endif
N
N#ifndef configUSE_PREEMPTION
S	#error Missing definition:  configUSE_PREEMPTION must be defined in FreeRTOSConfig.h as either 1 or 0.  See the Configuration section of the FreeRTOS API documentation for details.
N#endif
N
N#ifndef configUSE_IDLE_HOOK
S	#error Missing definition:  configUSE_IDLE_HOOK must be defined in FreeRTOSConfig.h as either 1 or 0.  See the Configuration section of the FreeRTOS API documentation for details.
N#endif
N
N#ifndef configUSE_TICK_HOOK
S	#error Missing definition:  configUSE_TICK_HOOK must be defined in FreeRTOSConfig.h as either 1 or 0.  See the Configuration section of the FreeRTOS API documentation for details.
N#endif
N
N#ifndef configUSE_16_BIT_TICKS
S	#error Missing definition:  configUSE_16_BIT_TICKS must be defined in FreeRTOSConfig.h as either 1 or 0.  See the Configuration section of the FreeRTOS API documentation for details.
N#endif
N
N#ifndef configMAX_PRIORITIES
S	#error configMAX_PRIORITIES must be defined to be greater than or equal to 1.
N#endif
N
N#ifndef configUSE_CO_ROUTINES
S	#define configUSE_CO_ROUTINES 0
N#endif
N
N#ifndef INCLUDE_vTaskPrioritySet
S	#define INCLUDE_vTaskPrioritySet 0
N#endif
N
N#ifndef INCLUDE_uxTaskPriorityGet
S	#define INCLUDE_uxTaskPriorityGet 0
N#endif
N
N#ifndef INCLUDE_vTaskDelete
S	#define INCLUDE_vTaskDelete 0
N#endif
N
N#ifndef INCLUDE_vTaskSuspend
S	#define INCLUDE_vTaskSuspend 0
N#endif
N
N#ifndef INCLUDE_vTaskDelayUntil
S	#define INCLUDE_vTaskDelayUntil 0
N#endif
N
N#ifndef INCLUDE_vTaskDelay
S	#define INCLUDE_vTaskDelay 0
N#endif
N
N#ifndef INCLUDE_xTaskGetIdleTaskHandle
N	#define INCLUDE_xTaskGetIdleTaskHandle 0
N#endif
N
N#ifndef INCLUDE_xTaskAbortDelay
N	#define INCLUDE_xTaskAbortDelay 0
N#endif
N
N#ifndef INCLUDE_xQueueGetMutexHolder
N	#define INCLUDE_xQueueGetMutexHolder 0
N#endif
N
N#ifndef INCLUDE_xSemaphoreGetMutexHolder
N	#define INCLUDE_xSemaphoreGetMutexHolder INCLUDE_xQueueGetMutexHolder
N#endif
N
N#ifndef INCLUDE_xTaskGetHandle
N	#define INCLUDE_xTaskGetHandle 0
N#endif
N
N#ifndef INCLUDE_uxTaskGetStackHighWaterMark
S	#define INCLUDE_uxTaskGetStackHighWaterMark 0
N#endif
N
N#ifndef INCLUDE_eTaskGetState
S	#define INCLUDE_eTaskGetState 0
N#endif
N
N#ifndef INCLUDE_xTaskResumeFromISR
N	#define INCLUDE_xTaskResumeFromISR 1
N#endif
N
N#ifndef INCLUDE_xTimerPendFunctionCall
N	#define INCLUDE_xTimerPendFunctionCall 0
N#endif
N
N#ifndef INCLUDE_xTaskGetSchedulerState
S	#define INCLUDE_xTaskGetSchedulerState 1
N#endif
N
N#ifndef INCLUDE_xTaskGetCurrentTaskHandle
N	#define INCLUDE_xTaskGetCurrentTaskHandle 1
N#endif
N
N#if configUSE_CO_ROUTINES != 0
X#if 0 != 0
S	#ifndef configMAX_CO_ROUTINE_PRIORITIES
S		#error configMAX_CO_ROUTINE_PRIORITIES must be greater than or equal to 1.
S	#endif
N#endif
N
N#ifndef configUSE_DAEMON_TASK_STARTUP_HOOK
N	#define configUSE_DAEMON_TASK_STARTUP_HOOK 0
N#endif
N
N#ifndef configUSE_APPLICATION_TASK_TAG
N	#define configUSE_APPLICATION_TASK_TAG 0
N#endif
N
N#ifndef configNUM_THREAD_LOCAL_STORAGE_POINTERS
N	#define configNUM_THREAD_LOCAL_STORAGE_POINTERS 0
N#endif
N
N#ifndef configUSE_RECURSIVE_MUTEXES
N	#define configUSE_RECURSIVE_MUTEXES 0
N#endif
N
N#ifndef configUSE_MUTEXES
N	#define configUSE_MUTEXES 1
N#endif
N
N#ifndef configUSE_TIMERS
N	#define configUSE_TIMERS 0
N#endif
N
N#ifndef configUSE_COUNTING_SEMAPHORES
N	#define configUSE_COUNTING_SEMAPHORES 1
N#endif
N
N#ifndef configUSE_ALTERNATIVE_API
N	#define configUSE_ALTERNATIVE_API 0
N#endif
N
N#ifndef portCRITICAL_NESTING_IN_TCB
N	#define portCRITICAL_NESTING_IN_TCB 0
N#endif
N
N#ifndef configMAX_TASK_NAME_LEN
S	#define configMAX_TASK_NAME_LEN 16
N#endif
N
N#ifndef configIDLE_SHOULD_YIELD
S	#define configIDLE_SHOULD_YIELD		1
N#endif
N
N#if configMAX_TASK_NAME_LEN < 1
X#if ( 16 ) < 1
S	#error configMAX_TASK_NAME_LEN must be set to a minimum of 1 in FreeRTOSConfig.h
N#endif
N
N#ifndef configASSERT
N	#define configASSERT( x )
N	#define configASSERT_DEFINED 0
N#else
S	#define configASSERT_DEFINED 1
N#endif
N
N/* The timers module relies on xTaskGetSchedulerState(). */
N#if configUSE_TIMERS == 1
X#if 0 == 1
S
S	#ifndef configTIMER_TASK_PRIORITY
S		#error If configUSE_TIMERS is set to 1 then configTIMER_TASK_PRIORITY must also be defined.
S	#endif /* configTIMER_TASK_PRIORITY */
S
S	#ifndef configTIMER_QUEUE_LENGTH
S		#error If configUSE_TIMERS is set to 1 then configTIMER_QUEUE_LENGTH must also be defined.
S	#endif /* configTIMER_QUEUE_LENGTH */
S
S	#ifndef configTIMER_TASK_STACK_DEPTH
S		#error If configUSE_TIMERS is set to 1 then configTIMER_TASK_STACK_DEPTH must also be defined.
S	#endif /* configTIMER_TASK_STACK_DEPTH */
S
N#endif /* configUSE_TIMERS */
N
N#ifndef portSET_INTERRUPT_MASK_FROM_ISR
S	#define portSET_INTERRUPT_MASK_FROM_ISR() 0
N#endif
N
N#ifndef portCLEAR_INTERRUPT_MASK_FROM_ISR
S	#define portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedStatusValue ) ( void ) uxSavedStatusValue
N#endif
N
N#ifndef portCLEAN_UP_TCB
N	#define portCLEAN_UP_TCB( pxTCB ) ( void ) pxTCB
N#endif
N
N#ifndef portPRE_TASK_DELETE_HOOK
N	#define portPRE_TASK_DELETE_HOOK( pvTaskToDelete, pxYieldPending )
N#endif
N
N#ifndef portSETUP_TCB
N	#define portSETUP_TCB( pxTCB ) ( void ) pxTCB
N#endif
N
N#ifndef configQUEUE_REGISTRY_SIZE
N	#define configQUEUE_REGISTRY_SIZE 0U
N#endif
N
N#if ( configQUEUE_REGISTRY_SIZE < 1 )
X#if ( 0U < 1 )
N	#define vQueueAddToRegistry( xQueue, pcName )
N	#define vQueueUnregisterQueue( xQueue )
N	#define pcQueueGetName( xQueue )
N#endif
N
N#ifndef portPOINTER_SIZE_TYPE
N	#define portPOINTER_SIZE_TYPE uint32_t
N#endif
N
N/* Remove any unused trace macros. */
N#ifndef traceSTART
N	/* Used to perform any necessary initialisation - for example, open a file
N	into which trace is to be written. */
N	#define traceSTART()
N#endif
N
N#ifndef traceEND
N	/* Use to close a trace, for example close a file into which trace has been
N	written. */
N	#define traceEND()
N#endif
N
N#ifndef traceTASK_SWITCHED_IN
N	/* Called after a task has been selected to run.  pxCurrentTCB holds a pointer
N	to the task control block of the selected task. */
N	#define traceTASK_SWITCHED_IN()
N#endif
N
N#ifndef traceINCREASE_TICK_COUNT
N	/* Called before stepping the tick count after waking from tickless idle
N	sleep. */
N	#define traceINCREASE_TICK_COUNT( x )
N#endif
N
N#ifndef traceLOW_POWER_IDLE_BEGIN
N	/* Called immediately before entering tickless idle. */
N	#define traceLOW_POWER_IDLE_BEGIN()
N#endif
N
N#ifndef	traceLOW_POWER_IDLE_END
N	/* Called when returning to the Idle task after a tickless idle. */
N	#define traceLOW_POWER_IDLE_END()
N#endif
N
N#ifndef traceTASK_SWITCHED_OUT
N	/* Called before a task has been selected to run.  pxCurrentTCB holds a pointer
N	to the task control block of the task being switched out. */
N	#define traceTASK_SWITCHED_OUT()
N#endif
N
N#ifndef traceTASK_PRIORITY_INHERIT
N	/* Called when a task attempts to take a mutex that is already held by a
N	lower priority task.  pxTCBOfMutexHolder is a pointer to the TCB of the task
N	that holds the mutex.  uxInheritedPriority is the priority the mutex holder
N	will inherit (the priority of the task that is attempting to obtain the
N	muted. */
N	#define traceTASK_PRIORITY_INHERIT( pxTCBOfMutexHolder, uxInheritedPriority )
N#endif
N
N#ifndef traceTASK_PRIORITY_DISINHERIT
N	/* Called when a task releases a mutex, the holding of which had resulted in
N	the task inheriting the priority of a higher priority task.
N	pxTCBOfMutexHolder is a pointer to the TCB of the task that is releasing the
N	mutex.  uxOriginalPriority is the task's configured (base) priority. */
N	#define traceTASK_PRIORITY_DISINHERIT( pxTCBOfMutexHolder, uxOriginalPriority )
N#endif
N
N#ifndef traceBLOCKING_ON_QUEUE_RECEIVE
N	/* Task is about to block because it cannot read from a
N	queue/mutex/semaphore.  pxQueue is a pointer to the queue/mutex/semaphore
N	upon which the read was attempted.  pxCurrentTCB points to the TCB of the
N	task that attempted the read. */
N	#define traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue )
N#endif
N
N#ifndef traceBLOCKING_ON_QUEUE_SEND
N	/* Task is about to block because it cannot write to a
N	queue/mutex/semaphore.  pxQueue is a pointer to the queue/mutex/semaphore
N	upon which the write was attempted.  pxCurrentTCB points to the TCB of the
N	task that attempted the write. */
N	#define traceBLOCKING_ON_QUEUE_SEND( pxQueue )
N#endif
N
N#ifndef configCHECK_FOR_STACK_OVERFLOW
N	#define configCHECK_FOR_STACK_OVERFLOW 0
N#endif
N
N/* The following event macros are embedded in the kernel API calls. */
N
N#ifndef traceMOVED_TASK_TO_READY_STATE
N	#define traceMOVED_TASK_TO_READY_STATE( pxTCB )
N#endif
N
N#ifndef tracePOST_MOVED_TASK_TO_READY_STATE
N	#define tracePOST_MOVED_TASK_TO_READY_STATE( pxTCB )
N#endif
N
N#ifndef traceQUEUE_CREATE
N	#define traceQUEUE_CREATE( pxNewQueue )
N#endif
N
N#ifndef traceQUEUE_CREATE_FAILED
N	#define traceQUEUE_CREATE_FAILED( ucQueueType )
N#endif
N
N#ifndef traceCREATE_MUTEX
N	#define traceCREATE_MUTEX( pxNewQueue )
N#endif
N
N#ifndef traceCREATE_MUTEX_FAILED
N	#define traceCREATE_MUTEX_FAILED()
N#endif
N
N#ifndef traceGIVE_MUTEX_RECURSIVE
N	#define traceGIVE_MUTEX_RECURSIVE( pxMutex )
N#endif
N
N#ifndef traceGIVE_MUTEX_RECURSIVE_FAILED
N	#define traceGIVE_MUTEX_RECURSIVE_FAILED( pxMutex )
N#endif
N
N#ifndef traceTAKE_MUTEX_RECURSIVE
N	#define traceTAKE_MUTEX_RECURSIVE( pxMutex )
N#endif
N
N#ifndef traceTAKE_MUTEX_RECURSIVE_FAILED
N	#define traceTAKE_MUTEX_RECURSIVE_FAILED( pxMutex )
N#endif
N
N#ifndef traceCREATE_COUNTING_SEMAPHORE
N	#define traceCREATE_COUNTING_SEMAPHORE()
N#endif
N
N#ifndef traceCREATE_COUNTING_SEMAPHORE_FAILED
N	#define traceCREATE_COUNTING_SEMAPHORE_FAILED()
N#endif
N
N#ifndef traceQUEUE_SEND
N	#define traceQUEUE_SEND( pxQueue )
N#endif
N
N#ifndef traceQUEUE_SEND_FAILED
N	#define traceQUEUE_SEND_FAILED( pxQueue )
N#endif
N
N#ifndef traceQUEUE_RECEIVE
N	#define traceQUEUE_RECEIVE( pxQueue )
N#endif
N
N#ifndef traceQUEUE_PEEK
N	#define traceQUEUE_PEEK( pxQueue )
N#endif
N
N#ifndef traceQUEUE_PEEK_FROM_ISR
N	#define traceQUEUE_PEEK_FROM_ISR( pxQueue )
N#endif
N
N#ifndef traceQUEUE_RECEIVE_FAILED
N	#define traceQUEUE_RECEIVE_FAILED( pxQueue )
N#endif
N
N#ifndef traceQUEUE_SEND_FROM_ISR
N	#define traceQUEUE_SEND_FROM_ISR( pxQueue )
N#endif
N
N#ifndef traceQUEUE_SEND_FROM_ISR_FAILED
N	#define traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue )
N#endif
N
N#ifndef traceQUEUE_RECEIVE_FROM_ISR
N	#define traceQUEUE_RECEIVE_FROM_ISR( pxQueue )
N#endif
N
N#ifndef traceQUEUE_RECEIVE_FROM_ISR_FAILED
N	#define traceQUEUE_RECEIVE_FROM_ISR_FAILED( pxQueue )
N#endif
N
N#ifndef traceQUEUE_PEEK_FROM_ISR_FAILED
N	#define traceQUEUE_PEEK_FROM_ISR_FAILED( pxQueue )
N#endif
N
N#ifndef traceQUEUE_DELETE
N	#define traceQUEUE_DELETE( pxQueue )
N#endif
N
N#ifndef traceTASK_CREATE
N	#define traceTASK_CREATE( pxNewTCB )
N#endif
N
N#ifndef traceTASK_CREATE_FAILED
N	#define traceTASK_CREATE_FAILED()
N#endif
N
N#ifndef traceTASK_DELETE
N	#define traceTASK_DELETE( pxTaskToDelete )
N#endif
N
N#ifndef traceTASK_DELAY_UNTIL
N	#define traceTASK_DELAY_UNTIL( x )
N#endif
N
N#ifndef traceTASK_DELAY
N	#define traceTASK_DELAY()
N#endif
N
N#ifndef traceTASK_PRIORITY_SET
N	#define traceTASK_PRIORITY_SET( pxTask, uxNewPriority )
N#endif
N
N#ifndef traceTASK_SUSPEND
N	#define traceTASK_SUSPEND( pxTaskToSuspend )
N#endif
N
N#ifndef traceTASK_RESUME
N	#define traceTASK_RESUME( pxTaskToResume )
N#endif
N
N#ifndef traceTASK_RESUME_FROM_ISR
N	#define traceTASK_RESUME_FROM_ISR( pxTaskToResume )
N#endif
N
N#ifndef traceTASK_INCREMENT_TICK
N	#define traceTASK_INCREMENT_TICK( xTickCount )
N#endif
N
N#ifndef traceTIMER_CREATE
N	#define traceTIMER_CREATE( pxNewTimer )
N#endif
N
N#ifndef traceTIMER_CREATE_FAILED
N	#define traceTIMER_CREATE_FAILED()
N#endif
N
N#ifndef traceTIMER_COMMAND_SEND
N	#define traceTIMER_COMMAND_SEND( xTimer, xMessageID, xMessageValueValue, xReturn )
N#endif
N
N#ifndef traceTIMER_EXPIRED
N	#define traceTIMER_EXPIRED( pxTimer )
N#endif
N
N#ifndef traceTIMER_COMMAND_RECEIVED
N	#define traceTIMER_COMMAND_RECEIVED( pxTimer, xMessageID, xMessageValue )
N#endif
N
N#ifndef traceMALLOC
N    #define traceMALLOC( pvAddress, uiSize )
N#endif
N
N#ifndef traceFREE
N    #define traceFREE( pvAddress, uiSize )
N#endif
N
N#ifndef traceEVENT_GROUP_CREATE
N	#define traceEVENT_GROUP_CREATE( xEventGroup )
N#endif
N
N#ifndef traceEVENT_GROUP_CREATE_FAILED
N	#define traceEVENT_GROUP_CREATE_FAILED()
N#endif
N
N#ifndef traceEVENT_GROUP_SYNC_BLOCK
N	#define traceEVENT_GROUP_SYNC_BLOCK( xEventGroup, uxBitsToSet, uxBitsToWaitFor )
N#endif
N
N#ifndef traceEVENT_GROUP_SYNC_END
N	#define traceEVENT_GROUP_SYNC_END( xEventGroup, uxBitsToSet, uxBitsToWaitFor, xTimeoutOccurred ) ( void ) xTimeoutOccurred
N#endif
N
N#ifndef traceEVENT_GROUP_WAIT_BITS_BLOCK
N	#define traceEVENT_GROUP_WAIT_BITS_BLOCK( xEventGroup, uxBitsToWaitFor )
N#endif
N
N#ifndef traceEVENT_GROUP_WAIT_BITS_END
N	#define traceEVENT_GROUP_WAIT_BITS_END( xEventGroup, uxBitsToWaitFor, xTimeoutOccurred ) ( void ) xTimeoutOccurred
N#endif
N
N#ifndef traceEVENT_GROUP_CLEAR_BITS
N	#define traceEVENT_GROUP_CLEAR_BITS( xEventGroup, uxBitsToClear )
N#endif
N
N#ifndef traceEVENT_GROUP_CLEAR_BITS_FROM_ISR
N	#define traceEVENT_GROUP_CLEAR_BITS_FROM_ISR( xEventGroup, uxBitsToClear )
N#endif
N
N#ifndef traceEVENT_GROUP_SET_BITS
N	#define traceEVENT_GROUP_SET_BITS( xEventGroup, uxBitsToSet )
N#endif
N
N#ifndef traceEVENT_GROUP_SET_BITS_FROM_ISR
N	#define traceEVENT_GROUP_SET_BITS_FROM_ISR( xEventGroup, uxBitsToSet )
N#endif
N
N#ifndef traceEVENT_GROUP_DELETE
N	#define traceEVENT_GROUP_DELETE( xEventGroup )
N#endif
N
N#ifndef tracePEND_FUNC_CALL
N	#define tracePEND_FUNC_CALL(xFunctionToPend, pvParameter1, ulParameter2, ret)
N#endif
N
N#ifndef tracePEND_FUNC_CALL_FROM_ISR
N	#define tracePEND_FUNC_CALL_FROM_ISR(xFunctionToPend, pvParameter1, ulParameter2, ret)
N#endif
N
N#ifndef traceQUEUE_REGISTRY_ADD
N	#define traceQUEUE_REGISTRY_ADD(xQueue, pcQueueName)
N#endif
N
N#ifndef traceTASK_NOTIFY_TAKE_BLOCK
N	#define traceTASK_NOTIFY_TAKE_BLOCK()
N#endif
N
N#ifndef traceTASK_NOTIFY_TAKE
N	#define traceTASK_NOTIFY_TAKE()
N#endif
N
N#ifndef traceTASK_NOTIFY_WAIT_BLOCK
N	#define traceTASK_NOTIFY_WAIT_BLOCK()
N#endif
N
N#ifndef traceTASK_NOTIFY_WAIT
N	#define traceTASK_NOTIFY_WAIT()
N#endif
N
N#ifndef traceTASK_NOTIFY
N	#define traceTASK_NOTIFY()
N#endif
N
N#ifndef traceTASK_NOTIFY_FROM_ISR
N	#define traceTASK_NOTIFY_FROM_ISR()
N#endif
N
N#ifndef traceTASK_NOTIFY_GIVE_FROM_ISR
N	#define traceTASK_NOTIFY_GIVE_FROM_ISR()
N#endif
N
N#ifndef configGENERATE_RUN_TIME_STATS
N	#define configGENERATE_RUN_TIME_STATS 0
N#endif
N
N#if ( configGENERATE_RUN_TIME_STATS == 1 )
X#if ( 0 == 1 )
S
S	#ifndef portCONFIGURE_TIMER_FOR_RUN_TIME_STATS
S		#error If configGENERATE_RUN_TIME_STATS is defined then portCONFIGURE_TIMER_FOR_RUN_TIME_STATS must also be defined.  portCONFIGURE_TIMER_FOR_RUN_TIME_STATS should call a port layer function to setup a peripheral timer/counter that can then be used as the run time counter time base.
S	#endif /* portCONFIGURE_TIMER_FOR_RUN_TIME_STATS */
S
S	#ifndef portGET_RUN_TIME_COUNTER_VALUE
S		#ifndef portALT_GET_RUN_TIME_COUNTER_VALUE
S			#error If configGENERATE_RUN_TIME_STATS is defined then either portGET_RUN_TIME_COUNTER_VALUE or portALT_GET_RUN_TIME_COUNTER_VALUE must also be defined.  See the examples provided and the FreeRTOS web site for more information.
S		#endif /* portALT_GET_RUN_TIME_COUNTER_VALUE */
S	#endif /* portGET_RUN_TIME_COUNTER_VALUE */
S
N#endif /* configGENERATE_RUN_TIME_STATS */
N
N#ifndef portCONFIGURE_TIMER_FOR_RUN_TIME_STATS
N	#define portCONFIGURE_TIMER_FOR_RUN_TIME_STATS()
N#endif
N
N#ifndef configUSE_MALLOC_FAILED_HOOK
N	#define configUSE_MALLOC_FAILED_HOOK 0
N#endif
N
N#ifndef portPRIVILEGE_BIT
N	#define portPRIVILEGE_BIT ( ( UBaseType_t ) 0x00 )
N#endif
N
N#ifndef portYIELD_WITHIN_API
N	#define portYIELD_WITHIN_API portYIELD
N#endif
N
N#ifndef portSUPPRESS_TICKS_AND_SLEEP
S	#define portSUPPRESS_TICKS_AND_SLEEP( xExpectedIdleTime )
N#endif
N
N#ifndef configEXPECTED_IDLE_TIME_BEFORE_SLEEP
N	#define configEXPECTED_IDLE_TIME_BEFORE_SLEEP 2
N#endif
N
N#if configEXPECTED_IDLE_TIME_BEFORE_SLEEP < 2
X#if 2 < 2
S	#error configEXPECTED_IDLE_TIME_BEFORE_SLEEP must not be less than 2
N#endif
N
N#ifndef configUSE_TICKLESS_IDLE
N	#define configUSE_TICKLESS_IDLE 0
N#endif
N
N#ifndef configPRE_SLEEP_PROCESSING
N	#define configPRE_SLEEP_PROCESSING( x )
N#endif
N
N#ifndef configPOST_SLEEP_PROCESSING
N	#define configPOST_SLEEP_PROCESSING( x )
N#endif
N
N#ifndef configUSE_QUEUE_SETS
N	#define configUSE_QUEUE_SETS 0
N#endif
N
N#ifndef portTASK_USES_FLOATING_POINT
N	#define portTASK_USES_FLOATING_POINT()
N#endif
N
N#ifndef configUSE_TIME_SLICING
N	#define configUSE_TIME_SLICING 1
N#endif
N
N#ifndef configINCLUDE_APPLICATION_DEFINED_PRIVILEGED_FUNCTIONS
N	#define configINCLUDE_APPLICATION_DEFINED_PRIVILEGED_FUNCTIONS 0
N#endif
N
N#ifndef configUSE_STATS_FORMATTING_FUNCTIONS
N	#define configUSE_STATS_FORMATTING_FUNCTIONS 0
N#endif
N
N#ifndef portASSERT_IF_INTERRUPT_PRIORITY_INVALID
N	#define portASSERT_IF_INTERRUPT_PRIORITY_INVALID()
N#endif
N
N#ifndef configUSE_TRACE_FACILITY
S	#define configUSE_TRACE_FACILITY 0
N#endif
N
N#ifndef mtCOVERAGE_TEST_MARKER
N	#define mtCOVERAGE_TEST_MARKER()
N#endif
N
N#ifndef mtCOVERAGE_TEST_DELAY
N	#define mtCOVERAGE_TEST_DELAY()
N#endif
N
N#ifndef portASSERT_IF_IN_ISR
N	#define portASSERT_IF_IN_ISR()
N#endif
N
N#ifndef configUSE_PORT_OPTIMISED_TASK_SELECTION
S	#define configUSE_PORT_OPTIMISED_TASK_SELECTION 0
N#endif
N
N#ifndef configAPPLICATION_ALLOCATED_HEAP
N	#define configAPPLICATION_ALLOCATED_HEAP 0
N#endif
N
N#ifndef configUSE_TASK_NOTIFICATIONS
N	#define configUSE_TASK_NOTIFICATIONS 1
N#endif
N
N#ifndef portTICK_TYPE_IS_ATOMIC
S	#define portTICK_TYPE_IS_ATOMIC 0
N#endif
N
N#ifndef configSUPPORT_STATIC_ALLOCATION
N	/* Defaults to 0 for backward compatibility. */
N	#define configSUPPORT_STATIC_ALLOCATION 0
N#endif
N
N#ifndef configSUPPORT_DYNAMIC_ALLOCATION
N	/* Defaults to 1 for backward compatibility. */
N	#define configSUPPORT_DYNAMIC_ALLOCATION 1
N#endif
N
N/* Sanity check the configuration. */
N#if( configUSE_TICKLESS_IDLE != 0 )
X#if( 0 != 0 )
S	#if( INCLUDE_vTaskSuspend != 1 )
S		#error INCLUDE_vTaskSuspend must be set to 1 if configUSE_TICKLESS_IDLE is not set to 0
S	#endif /* INCLUDE_vTaskSuspend */
N#endif /* configUSE_TICKLESS_IDLE */
N
N#if( ( configSUPPORT_STATIC_ALLOCATION == 0 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 0 ) )
X#if( ( 0 == 0 ) && ( 1 == 0 ) )
S	#error configSUPPORT_STATIC_ALLOCATION and configSUPPORT_DYNAMIC_ALLOCATION cannot both be 0, but can both be 1.
N#endif
N
N#if( ( configUSE_RECURSIVE_MUTEXES == 1 ) && ( configUSE_MUTEXES != 1 ) )
X#if( ( 0 == 1 ) && ( 1 != 1 ) )
S	#error configUSE_MUTEXES must be set to 1 to use recursive mutexes
N#endif
N
N#if( portTICK_TYPE_IS_ATOMIC == 0 )
X#if( 1 == 0 )
S	/* Either variables of tick type cannot be read atomically, or
S	portTICK_TYPE_IS_ATOMIC was not set - map the critical sections used when
S	the tick count is returned to the standard critical section macros. */
S	#define portTICK_TYPE_ENTER_CRITICAL() portENTER_CRITICAL()
S	#define portTICK_TYPE_EXIT_CRITICAL() portEXIT_CRITICAL()
S	#define portTICK_TYPE_SET_INTERRUPT_MASK_FROM_ISR() portSET_INTERRUPT_MASK_FROM_ISR()
S	#define portTICK_TYPE_CLEAR_INTERRUPT_MASK_FROM_ISR( x ) portCLEAR_INTERRUPT_MASK_FROM_ISR( ( x ) )
N#else
N	/* The tick type can be read atomically, so critical sections used when the
N	tick count is returned can be defined away. */
N	#define portTICK_TYPE_ENTER_CRITICAL()
N	#define portTICK_TYPE_EXIT_CRITICAL()
N	#define portTICK_TYPE_SET_INTERRUPT_MASK_FROM_ISR() 0
N	#define portTICK_TYPE_CLEAR_INTERRUPT_MASK_FROM_ISR( x ) ( void ) x
N#endif
N
N/* Definitions to allow backward compatibility with FreeRTOS versions prior to
NV8 if desired. */
N#ifndef configENABLE_BACKWARD_COMPATIBILITY
N	#define configENABLE_BACKWARD_COMPATIBILITY 1
N#endif
N
N#if configENABLE_BACKWARD_COMPATIBILITY == 1
X#if 1 == 1
N	#define eTaskStateGet eTaskGetState
N	#define portTickType TickType_t
N	#define xTaskHandle TaskHandle_t
N	#define xQueueHandle QueueHandle_t
N	#define xSemaphoreHandle SemaphoreHandle_t
N	#define xQueueSetHandle QueueSetHandle_t
N	#define xQueueSetMemberHandle QueueSetMemberHandle_t
N	#define xTimeOutType TimeOut_t
N	#define xMemoryRegion MemoryRegion_t
N	#define xTaskParameters TaskParameters_t
N	#define xTaskStatusType	TaskStatus_t
N	#define xTimerHandle TimerHandle_t
N	#define xCoRoutineHandle CoRoutineHandle_t
N	#define pdTASK_HOOK_CODE TaskHookFunction_t
N	#define portTICK_RATE_MS portTICK_PERIOD_MS
N	#define pcTaskGetTaskName pcTaskGetName
N	#define pcTimerGetTimerName pcTimerGetName
N	#define pcQueueGetQueueName pcQueueGetName
N	#define vTaskGetTaskInfo vTaskGetInfo
N
N	/* Backward compatibility within the scheduler code only - these definitions
N	are not really required but are included for completeness. */
N	#define tmrTIMER_CALLBACK TimerCallbackFunction_t
N	#define pdTASK_CODE TaskFunction_t
N	#define xListItem ListItem_t
N	#define xList List_t
N#endif /* configENABLE_BACKWARD_COMPATIBILITY */
N
N#if( configUSE_ALTERNATIVE_API != 0 )
X#if( 0 != 0 )
S	#error The alternative API was deprecated some time ago, and was removed in FreeRTOS V9.0 0
N#endif
N
N/* Set configUSE_TASK_FPU_SUPPORT to 0 to omit floating point support even
Nif floating point hardware is otherwise supported by the FreeRTOS port in use.
NThis constant is not supported by all FreeRTOS ports that include floating
Npoint support. */
N#ifndef configUSE_TASK_FPU_SUPPORT
N	#define configUSE_TASK_FPU_SUPPORT 1
N#endif
N
N/*
N * In line with software engineering best practice, FreeRTOS implements a strict
N * data hiding policy, so the real structures used by FreeRTOS to maintain the
N * state of tasks, queues, semaphores, etc. are not accessible to the application
N * code.  However, if the application writer wants to statically allocate such
N * an object then the size of the object needs to be know.  Dummy structures
N * that are guaranteed to have the same size and alignment requirements of the
N * real objects are used for this purpose.  The dummy list and list item
N * structures below are used for inclusion in such a dummy structure.
N */
Nstruct xSTATIC_LIST_ITEM
N{
N	TickType_t xDummy1;
N	void *pvDummy2[ 4 ];
N};
Ntypedef struct xSTATIC_LIST_ITEM StaticListItem_t;
N
N/* See the comments above the struct xSTATIC_LIST_ITEM definition. */
Nstruct xSTATIC_MINI_LIST_ITEM
N{
N	TickType_t xDummy1;
N	void *pvDummy2[ 2 ];
N};
Ntypedef struct xSTATIC_MINI_LIST_ITEM StaticMiniListItem_t;
N
N/* See the comments above the struct xSTATIC_LIST_ITEM definition. */
Ntypedef struct xSTATIC_LIST
N{
N	UBaseType_t uxDummy1;
N	void *pvDummy2;
N	StaticMiniListItem_t xDummy3;
N} StaticList_t;
N
N/*
N * In line with software engineering best practice, especially when supplying a
N * library that is likely to change in future versions, FreeRTOS implements a
N * strict data hiding policy.  This means the Task structure used internally by
N * FreeRTOS is not accessible to application code.  However, if the application
N * writer wants to statically allocate the memory required to create a task then
N * the size of the task object needs to be know.  The StaticTask_t structure
N * below is provided for this purpose.  Its sizes and alignment requirements are
N * guaranteed to match those of the genuine structure, no matter which
N * architecture is being used, and no matter how the values in FreeRTOSConfig.h
N * are set.  Its contents are somewhat obfuscated in the hope users will
N * recognise that it would be unwise to make direct use of the structure members.
N */
Ntypedef struct xSTATIC_TCB
N{
N	void				*pxDummy1;
N	#if ( portUSING_MPU_WRAPPERS == 1 )
X	#if ( 0 == 1 )
S		xMPU_SETTINGS	xDummy2;
N	#endif
N	StaticListItem_t	xDummy3[ 2 ];
N	UBaseType_t			uxDummy5;
N	void				*pxDummy6;
N	uint8_t				ucDummy7[ configMAX_TASK_NAME_LEN ];
X	uint8_t				ucDummy7[ ( 16 ) ];
N	#if ( portSTACK_GROWTH > 0 )
X	#if ( ( -1 ) > 0 )
S		void			*pxDummy8;
N	#endif
N	#if ( portCRITICAL_NESTING_IN_TCB == 1 )
X	#if ( 0 == 1 )
S		UBaseType_t		uxDummy9;
N	#endif
N	#if ( configUSE_TRACE_FACILITY == 1 )
X	#if ( 0 == 1 )
S		UBaseType_t		uxDummy10[ 2 ];
N	#endif
N	#if ( configUSE_MUTEXES == 1 )
X	#if ( 1 == 1 )
N		UBaseType_t		uxDummy12[ 2 ];
N	#endif
N	#if ( configUSE_APPLICATION_TASK_TAG == 1 )
X	#if ( 0 == 1 )
S		void			*pxDummy14;
N	#endif
N	#if( configNUM_THREAD_LOCAL_STORAGE_POINTERS > 0 )
X	#if( 0 > 0 )
S		void			*pvDummy15[ configNUM_THREAD_LOCAL_STORAGE_POINTERS ];
N	#endif
N	#if ( configGENERATE_RUN_TIME_STATS == 1 )
X	#if ( 0 == 1 )
S		uint32_t		ulDummy16;
N	#endif
N	#if ( configUSE_NEWLIB_REENTRANT == 1 )
X	#if ( 0 == 1 )
S		struct	_reent	xDummy17;
N	#endif
N	#if ( configUSE_TASK_NOTIFICATIONS == 1 )
X	#if ( 1 == 1 )
N		uint32_t 		ulDummy18;
N		uint8_t 		ucDummy19;
N	#endif
N	#if( ( configSUPPORT_STATIC_ALLOCATION == 1 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) )
X	#if( ( 0 == 1 ) && ( 1 == 1 ) )
S		uint8_t			uxDummy20;
N	#endif
N
N} StaticTask_t;
N
N/*
N * In line with software engineering best practice, especially when supplying a
N * library that is likely to change in future versions, FreeRTOS implements a
N * strict data hiding policy.  This means the Queue structure used internally by
N * FreeRTOS is not accessible to application code.  However, if the application
N * writer wants to statically allocate the memory required to create a queue
N * then the size of the queue object needs to be know.  The StaticQueue_t
N * structure below is provided for this purpose.  Its sizes and alignment
N * requirements are guaranteed to match those of the genuine structure, no
N * matter which architecture is being used, and no matter how the values in
N * FreeRTOSConfig.h are set.  Its contents are somewhat obfuscated in the hope
N * users will recognise that it would be unwise to make direct use of the
N * structure members.
N */
Ntypedef struct xSTATIC_QUEUE
N{
N	void *pvDummy1[ 3 ];
N
N	union
N	{
N		void *pvDummy2;
N		UBaseType_t uxDummy2;
N	} u;
N
N	StaticList_t xDummy3[ 2 ];
N	UBaseType_t uxDummy4[ 3 ];
N	uint8_t ucDummy5[ 2 ];
N
N	#if( ( configSUPPORT_STATIC_ALLOCATION == 1 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) )
X	#if( ( 0 == 1 ) && ( 1 == 1 ) )
S		uint8_t ucDummy6;
N	#endif
N
N	#if ( configUSE_QUEUE_SETS == 1 )
X	#if ( 0 == 1 )
S		void *pvDummy7;
N	#endif
N
N	#if ( configUSE_TRACE_FACILITY == 1 )
X	#if ( 0 == 1 )
S		UBaseType_t uxDummy8;
S		uint8_t ucDummy9;
N	#endif
N
N} StaticQueue_t;
Ntypedef StaticQueue_t StaticSemaphore_t;
N
N/*
N * In line with software engineering best practice, especially when supplying a
N * library that is likely to change in future versions, FreeRTOS implements a
N * strict data hiding policy.  This means the event group structure used
N * internally by FreeRTOS is not accessible to application code.  However, if
N * the application writer wants to statically allocate the memory required to
N * create an event group then the size of the event group object needs to be
N * know.  The StaticEventGroup_t structure below is provided for this purpose.
N * Its sizes and alignment requirements are guaranteed to match those of the
N * genuine structure, no matter which architecture is being used, and no matter
N * how the values in FreeRTOSConfig.h are set.  Its contents are somewhat
N * obfuscated in the hope users will recognise that it would be unwise to make
N * direct use of the structure members.
N */
Ntypedef struct xSTATIC_EVENT_GROUP
N{
N	TickType_t xDummy1;
N	StaticList_t xDummy2;
N
N	#if( configUSE_TRACE_FACILITY == 1 )
X	#if( 0 == 1 )
S		UBaseType_t uxDummy3;
N	#endif
N
N	#if( ( configSUPPORT_STATIC_ALLOCATION == 1 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) )
X	#if( ( 0 == 1 ) && ( 1 == 1 ) )
S			uint8_t ucDummy4;
N	#endif
N
N} StaticEventGroup_t;
N
N/*
N * In line with software engineering best practice, especially when supplying a
N * library that is likely to change in future versions, FreeRTOS implements a
N * strict data hiding policy.  This means the software timer structure used
N * internally by FreeRTOS is not accessible to application code.  However, if
N * the application writer wants to statically allocate the memory required to
N * create a software timer then the size of the queue object needs to be know.
N * The StaticTimer_t structure below is provided for this purpose.  Its sizes
N * and alignment requirements are guaranteed to match those of the genuine
N * structure, no matter which architecture is being used, and no matter how the
N * values in FreeRTOSConfig.h are set.  Its contents are somewhat obfuscated in
N * the hope users will recognise that it would be unwise to make direct use of
N * the structure members.
N */
Ntypedef struct xSTATIC_TIMER
N{
N	void				*pvDummy1;
N	StaticListItem_t	xDummy2;
N	TickType_t			xDummy3;
N	UBaseType_t			uxDummy4;
N	void 				*pvDummy5[ 2 ];
N	#if( configUSE_TRACE_FACILITY == 1 )
X	#if( 0 == 1 )
S		UBaseType_t		uxDummy6;
N	#endif
N
N	#if( ( configSUPPORT_STATIC_ALLOCATION == 1 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) )
X	#if( ( 0 == 1 ) && ( 1 == 1 ) )
S		uint8_t 		ucDummy7;
N	#endif
N
N} StaticTimer_t;
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif /* INC_FREERTOS_H */
N
L 36 "..\..\User\main.c" 2
N#include "queue.h"
L 1 "..\..\Freee-RTOS\include\queue.h" 1
N/*
N    FreeRTOS V9.0.0 - Copyright (C) 2016 Real Time Engineers Ltd.
N    All rights reserved
N
N    VISIT http://www.FreeRTOS.org TO ENSURE YOU ARE USING THE LATEST VERSION.
N
N    This file is part of the FreeRTOS distribution.
N
N    FreeRTOS is free software; you can redistribute it and/or modify it under
N    the terms of the GNU General Public License (version 2) as published by the
N    Free Software Foundation >>>> AND MODIFIED BY <<<< the FreeRTOS exception.
N
N    ***************************************************************************
N    >>!   NOTE: The modification to the GPL is included to allow you to     !<<
N    >>!   distribute a combined work that includes FreeRTOS without being   !<<
N    >>!   obliged to provide the source code for proprietary components     !<<
N    >>!   outside of the FreeRTOS kernel.                                   !<<
N    ***************************************************************************
N
N    FreeRTOS is distributed in the hope that it will be useful, but WITHOUT ANY
N    WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
N    FOR A PARTICULAR PURPOSE.  Full license text is available on the following
N    link: http://www.freertos.org/a00114.html
N
N    ***************************************************************************
N     *                                                                       *
N     *    FreeRTOS provides completely free yet professionally developed,    *
N     *    robust, strictly quality controlled, supported, and cross          *
N     *    platform software that is more than just the market leader, it     *
N     *    is the industry's de facto standard.                               *
N     *                                                                       *
N     *    Help yourself get started quickly while simultaneously helping     *
N     *    to support the FreeRTOS project by purchasing a FreeRTOS           *
N     *    tutorial book, reference manual, or both:                          *
N     *    http://www.FreeRTOS.org/Documentation                              *
N     *                                                                       *
N    ***************************************************************************
N
N    http://www.FreeRTOS.org/FAQHelp.html - Having a problem?  Start by reading
N    the FAQ page "My application does not run, what could be wrong?".  Have you
N    defined configASSERT()?
N
N    http://www.FreeRTOS.org/support - In return for receiving this top quality
N    embedded software for free we request you assist our global community by
N    participating in the support forum.
N
N    http://www.FreeRTOS.org/training - Investing in training allows your team to
N    be as productive as possible as early as possible.  Now you can receive
N    FreeRTOS training directly from Richard Barry, CEO of Real Time Engineers
N    Ltd, and the world's leading authority on the world's leading RTOS.
N
N    http://www.FreeRTOS.org/plus - A selection of FreeRTOS ecosystem products,
N    including FreeRTOS+Trace - an indispensable productivity tool, a DOS
N    compatible FAT file system, and our tiny thread aware UDP/IP stack.
N
N    http://www.FreeRTOS.org/labs - Where new FreeRTOS products go to incubate.
N    Come and try FreeRTOS+TCP, our new open source TCP/IP stack for FreeRTOS.
N
N    http://www.OpenRTOS.com - Real Time Engineers ltd. license FreeRTOS to High
N    Integrity Systems ltd. to sell under the OpenRTOS brand.  Low cost OpenRTOS
N    licenses offer ticketed support, indemnification and commercial middleware.
N
N    http://www.SafeRTOS.com - High Integrity Systems also provide a safety
N    engineered and independently SIL3 certified version for use in safety and
N    mission critical applications that require provable dependability.
N
N    1 tab == 4 spaces!
N*/
N
N
N#ifndef QUEUE_H
N#define QUEUE_H
N
N#ifndef INC_FREERTOS_H
S	#error "include FreeRTOS.h" must appear in source files before "include queue.h"
N#endif
N
N#ifdef __cplusplus
Sextern "C" {
N#endif
N
N
N/**
N * Type by which queues are referenced.  For example, a call to xQueueCreate()
N * returns an QueueHandle_t variable that can then be used as a parameter to
N * xQueueSend(), xQueueReceive(), etc.
N */
Ntypedef void * QueueHandle_t;
N
N/**
N * Type by which queue sets are referenced.  For example, a call to
N * xQueueCreateSet() returns an xQueueSet variable that can then be used as a
N * parameter to xQueueSelectFromSet(), xQueueAddToSet(), etc.
N */
Ntypedef void * QueueSetHandle_t;
N
N/**
N * Queue sets can contain both queues and semaphores, so the
N * QueueSetMemberHandle_t is defined as a type to be used where a parameter or
N * return value can be either an QueueHandle_t or an SemaphoreHandle_t.
N */
Ntypedef void * QueueSetMemberHandle_t;
N
N/* For internal use only. */
N#define	queueSEND_TO_BACK		( ( BaseType_t ) 0 )
N#define	queueSEND_TO_FRONT		( ( BaseType_t ) 1 )
N#define queueOVERWRITE			( ( BaseType_t ) 2 )
N
N/* For internal use only.  These definitions *must* match those in queue.c. */
N#define queueQUEUE_TYPE_BASE				( ( uint8_t ) 0U )
N#define queueQUEUE_TYPE_SET					( ( uint8_t ) 0U )
N#define queueQUEUE_TYPE_MUTEX 				( ( uint8_t ) 1U )
N#define queueQUEUE_TYPE_COUNTING_SEMAPHORE	( ( uint8_t ) 2U )
N#define queueQUEUE_TYPE_BINARY_SEMAPHORE	( ( uint8_t ) 3U )
N#define queueQUEUE_TYPE_RECURSIVE_MUTEX		( ( uint8_t ) 4U )
N
N/**
N * queue. h
N * <pre>
N QueueHandle_t xQueueCreate(
N							  UBaseType_t uxQueueLength,
N							  UBaseType_t uxItemSize
N						  );
N * </pre>
N *
N * Creates a new queue instance, and returns a handle by which the new queue
N * can be referenced.
N *
N * Internally, within the FreeRTOS implementation, queues use two blocks of
N * memory.  The first block is used to hold the queue's data structures.  The
N * second block is used to hold items placed into the queue.  If a queue is
N * created using xQueueCreate() then both blocks of memory are automatically
N * dynamically allocated inside the xQueueCreate() function.  (see
N * http://www.freertos.org/a00111.html).  If a queue is created using
N * xQueueCreateStatic() then the application writer must provide the memory that
N * will get used by the queue.  xQueueCreateStatic() therefore allows a queue to
N * be created without using any dynamic memory allocation.
N *
N * http://www.FreeRTOS.org/Embedded-RTOS-Queues.html
N *
N * @param uxQueueLength The maximum number of items that the queue can contain.
N *
N * @param uxItemSize The number of bytes each item in the queue will require.
N * Items are queued by copy, not by reference, so this is the number of bytes
N * that will be copied for each posted item.  Each item on the queue must be
N * the same size.
N *
N * @return If the queue is successfully create then a handle to the newly
N * created queue is returned.  If the queue cannot be created then 0 is
N * returned.
N *
N * Example usage:
N   <pre>
N struct AMessage
N {
N	char ucMessageID;
N	char ucData[ 20 ];
N };
N
N void vATask( void *pvParameters )
N {
N QueueHandle_t xQueue1, xQueue2;
N
N	// Create a queue capable of containing 10 uint32_t values.
N	xQueue1 = xQueueCreate( 10, sizeof( uint32_t ) );
N	if( xQueue1 == 0 )
N	{
N		// Queue was not created and must not be used.
N	}
N
N	// Create a queue capable of containing 10 pointers to AMessage structures.
N	// These should be passed by pointer as they contain a lot of data.
N	xQueue2 = xQueueCreate( 10, sizeof( struct AMessage * ) );
N	if( xQueue2 == 0 )
N	{
N		// Queue was not created and must not be used.
N	}
N
N	// ... Rest of task code.
N }
N </pre>
N * \defgroup xQueueCreate xQueueCreate
N * \ingroup QueueManagement
N */
N#if( configSUPPORT_DYNAMIC_ALLOCATION == 1 )
X#if( 1 == 1 )
N	#define xQueueCreate( uxQueueLength, uxItemSize ) xQueueGenericCreate( ( uxQueueLength ), ( uxItemSize ), ( queueQUEUE_TYPE_BASE ) )
N#endif
N
N/**
N * queue. h
N * <pre>
N QueueHandle_t xQueueCreateStatic(
N							  UBaseType_t uxQueueLength,
N							  UBaseType_t uxItemSize,
N							  uint8_t *pucQueueStorageBuffer,
N							  StaticQueue_t *pxQueueBuffer
N						  );
N * </pre>
N *
N * Creates a new queue instance, and returns a handle by which the new queue
N * can be referenced.
N *
N * Internally, within the FreeRTOS implementation, queues use two blocks of
N * memory.  The first block is used to hold the queue's data structures.  The
N * second block is used to hold items placed into the queue.  If a queue is
N * created using xQueueCreate() then both blocks of memory are automatically
N * dynamically allocated inside the xQueueCreate() function.  (see
N * http://www.freertos.org/a00111.html).  If a queue is created using
N * xQueueCreateStatic() then the application writer must provide the memory that
N * will get used by the queue.  xQueueCreateStatic() therefore allows a queue to
N * be created without using any dynamic memory allocation.
N *
N * http://www.FreeRTOS.org/Embedded-RTOS-Queues.html
N *
N * @param uxQueueLength The maximum number of items that the queue can contain.
N *
N * @param uxItemSize The number of bytes each item in the queue will require.
N * Items are queued by copy, not by reference, so this is the number of bytes
N * that will be copied for each posted item.  Each item on the queue must be
N * the same size.
N *
N * @param pucQueueStorageBuffer If uxItemSize is not zero then
N * pucQueueStorageBuffer must point to a uint8_t array that is at least large
N * enough to hold the maximum number of items that can be in the queue at any
N * one time - which is ( uxQueueLength * uxItemsSize ) bytes.  If uxItemSize is
N * zero then pucQueueStorageBuffer can be NULL.
N *
N * @param pxQueueBuffer Must point to a variable of type StaticQueue_t, which
N * will be used to hold the queue's data structure.
N *
N * @return If the queue is created then a handle to the created queue is
N * returned.  If pxQueueBuffer is NULL then NULL is returned.
N *
N * Example usage:
N   <pre>
N struct AMessage
N {
N	char ucMessageID;
N	char ucData[ 20 ];
N };
N
N #define QUEUE_LENGTH 10
N #define ITEM_SIZE sizeof( uint32_t )
N
N // xQueueBuffer will hold the queue structure.
N StaticQueue_t xQueueBuffer;
N
N // ucQueueStorage will hold the items posted to the queue.  Must be at least
N // [(queue length) * ( queue item size)] bytes long.
N uint8_t ucQueueStorage[ QUEUE_LENGTH * ITEM_SIZE ];
N
N void vATask( void *pvParameters )
N {
N QueueHandle_t xQueue1;
N
N	// Create a queue capable of containing 10 uint32_t values.
N	xQueue1 = xQueueCreate( QUEUE_LENGTH, // The number of items the queue can hold.
N							ITEM_SIZE	  // The size of each item in the queue
N							&( ucQueueStorage[ 0 ] ), // The buffer that will hold the items in the queue.
N							&xQueueBuffer ); // The buffer that will hold the queue structure.
N
N	// The queue is guaranteed to be created successfully as no dynamic memory
N	// allocation is used.  Therefore xQueue1 is now a handle to a valid queue.
N
N	// ... Rest of task code.
N }
N </pre>
N * \defgroup xQueueCreateStatic xQueueCreateStatic
N * \ingroup QueueManagement
N */
N#if( configSUPPORT_STATIC_ALLOCATION == 1 )
X#if( 0 == 1 )
S	#define xQueueCreateStatic( uxQueueLength, uxItemSize, pucQueueStorage, pxQueueBuffer ) xQueueGenericCreateStatic( ( uxQueueLength ), ( uxItemSize ), ( pucQueueStorage ), ( pxQueueBuffer ), ( queueQUEUE_TYPE_BASE ) )
N#endif /* configSUPPORT_STATIC_ALLOCATION */
N
N/**
N * queue. h
N * <pre>
N BaseType_t xQueueSendToToFront(
N								   QueueHandle_t	xQueue,
N								   const void		*pvItemToQueue,
N								   TickType_t		xTicksToWait
N							   );
N * </pre>
N *
N * This is a macro that calls xQueueGenericSend().
N *
N * Post an item to the front of a queue.  The item is queued by copy, not by
N * reference.  This function must not be called from an interrupt service
N * routine.  See xQueueSendFromISR () for an alternative which may be used
N * in an ISR.
N *
N * @param xQueue The handle to the queue on which the item is to be posted.
N *
N * @param pvItemToQueue A pointer to the item that is to be placed on the
N * queue.  The size of the items the queue will hold was defined when the
N * queue was created, so this many bytes will be copied from pvItemToQueue
N * into the queue storage area.
N *
N * @param xTicksToWait The maximum amount of time the task should block
N * waiting for space to become available on the queue, should it already
N * be full.  The call will return immediately if this is set to 0 and the
N * queue is full.  The time is defined in tick periods so the constant
N * portTICK_PERIOD_MS should be used to convert to real time if this is required.
N *
N * @return pdTRUE if the item was successfully posted, otherwise errQUEUE_FULL.
N *
N * Example usage:
N   <pre>
N struct AMessage
N {
N	char ucMessageID;
N	char ucData[ 20 ];
N } xMessage;
N
N uint32_t ulVar = 10UL;
N
N void vATask( void *pvParameters )
N {
N QueueHandle_t xQueue1, xQueue2;
N struct AMessage *pxMessage;
N
N	// Create a queue capable of containing 10 uint32_t values.
N	xQueue1 = xQueueCreate( 10, sizeof( uint32_t ) );
N
N	// Create a queue capable of containing 10 pointers to AMessage structures.
N	// These should be passed by pointer as they contain a lot of data.
N	xQueue2 = xQueueCreate( 10, sizeof( struct AMessage * ) );
N
N	// ...
N
N	if( xQueue1 != 0 )
N	{
N		// Send an uint32_t.  Wait for 10 ticks for space to become
N		// available if necessary.
N		if( xQueueSendToFront( xQueue1, ( void * ) &ulVar, ( TickType_t ) 10 ) != pdPASS )
N		{
N			// Failed to post the message, even after 10 ticks.
N		}
N	}
N
N	if( xQueue2 != 0 )
N	{
N		// Send a pointer to a struct AMessage object.  Don't block if the
N		// queue is already full.
N		pxMessage = & xMessage;
N		xQueueSendToFront( xQueue2, ( void * ) &pxMessage, ( TickType_t ) 0 );
N	}
N
N	// ... Rest of task code.
N }
N </pre>
N * \defgroup xQueueSend xQueueSend
N * \ingroup QueueManagement
N */
N#define xQueueSendToFront( xQueue, pvItemToQueue, xTicksToWait ) xQueueGenericSend( ( xQueue ), ( pvItemToQueue ), ( xTicksToWait ), queueSEND_TO_FRONT )
N
N/**
N * queue. h
N * <pre>
N BaseType_t xQueueSendToBack(
N								   QueueHandle_t	xQueue,
N								   const void		*pvItemToQueue,
N								   TickType_t		xTicksToWait
N							   );
N * </pre>
N *
N * This is a macro that calls xQueueGenericSend().
N *
N * Post an item to the back of a queue.  The item is queued by copy, not by
N * reference.  This function must not be called from an interrupt service
N * routine.  See xQueueSendFromISR () for an alternative which may be used
N * in an ISR.
N *
N * @param xQueue The handle to the queue on which the item is to be posted.
N *
N * @param pvItemToQueue A pointer to the item that is to be placed on the
N * queue.  The size of the items the queue will hold was defined when the
N * queue was created, so this many bytes will be copied from pvItemToQueue
N * into the queue storage area.
N *
N * @param xTicksToWait The maximum amount of time the task should block
N * waiting for space to become available on the queue, should it already
N * be full.  The call will return immediately if this is set to 0 and the queue
N * is full.  The  time is defined in tick periods so the constant
N * portTICK_PERIOD_MS should be used to convert to real time if this is required.
N *
N * @return pdTRUE if the item was successfully posted, otherwise errQUEUE_FULL.
N *
N * Example usage:
N   <pre>
N struct AMessage
N {
N	char ucMessageID;
N	char ucData[ 20 ];
N } xMessage;
N
N uint32_t ulVar = 10UL;
N
N void vATask( void *pvParameters )
N {
N QueueHandle_t xQueue1, xQueue2;
N struct AMessage *pxMessage;
N
N	// Create a queue capable of containing 10 uint32_t values.
N	xQueue1 = xQueueCreate( 10, sizeof( uint32_t ) );
N
N	// Create a queue capable of containing 10 pointers to AMessage structures.
N	// These should be passed by pointer as they contain a lot of data.
N	xQueue2 = xQueueCreate( 10, sizeof( struct AMessage * ) );
N
N	// ...
N
N	if( xQueue1 != 0 )
N	{
N		// Send an uint32_t.  Wait for 10 ticks for space to become
N		// available if necessary.
N		if( xQueueSendToBack( xQueue1, ( void * ) &ulVar, ( TickType_t ) 10 ) != pdPASS )
N		{
N			// Failed to post the message, even after 10 ticks.
N		}
N	}
N
N	if( xQueue2 != 0 )
N	{
N		// Send a pointer to a struct AMessage object.  Don't block if the
N		// queue is already full.
N		pxMessage = & xMessage;
N		xQueueSendToBack( xQueue2, ( void * ) &pxMessage, ( TickType_t ) 0 );
N	}
N
N	// ... Rest of task code.
N }
N </pre>
N * \defgroup xQueueSend xQueueSend
N * \ingroup QueueManagement
N */
N#define xQueueSendToBack( xQueue, pvItemToQueue, xTicksToWait ) xQueueGenericSend( ( xQueue ), ( pvItemToQueue ), ( xTicksToWait ), queueSEND_TO_BACK )
N
N/**
N * queue. h
N * <pre>
N BaseType_t xQueueSend(
N							  QueueHandle_t xQueue,
N							  const void * pvItemToQueue,
N							  TickType_t xTicksToWait
N						 );
N * </pre>
N *
N * This is a macro that calls xQueueGenericSend().  It is included for
N * backward compatibility with versions of FreeRTOS.org that did not
N * include the xQueueSendToFront() and xQueueSendToBack() macros.  It is
N * equivalent to xQueueSendToBack().
N *
N * Post an item on a queue.  The item is queued by copy, not by reference.
N * This function must not be called from an interrupt service routine.
N * See xQueueSendFromISR () for an alternative which may be used in an ISR.
N *
N * @param xQueue The handle to the queue on which the item is to be posted.
N *
N * @param pvItemToQueue A pointer to the item that is to be placed on the
N * queue.  The size of the items the queue will hold was defined when the
N * queue was created, so this many bytes will be copied from pvItemToQueue
N * into the queue storage area.
N *
N * @param xTicksToWait The maximum amount of time the task should block
N * waiting for space to become available on the queue, should it already
N * be full.  The call will return immediately if this is set to 0 and the
N * queue is full.  The time is defined in tick periods so the constant
N * portTICK_PERIOD_MS should be used to convert to real time if this is required.
N *
N * @return pdTRUE if the item was successfully posted, otherwise errQUEUE_FULL.
N *
N * Example usage:
N   <pre>
N struct AMessage
N {
N	char ucMessageID;
N	char ucData[ 20 ];
N } xMessage;
N
N uint32_t ulVar = 10UL;
N
N void vATask( void *pvParameters )
N {
N QueueHandle_t xQueue1, xQueue2;
N struct AMessage *pxMessage;
N
N	// Create a queue capable of containing 10 uint32_t values.
N	xQueue1 = xQueueCreate( 10, sizeof( uint32_t ) );
N
N	// Create a queue capable of containing 10 pointers to AMessage structures.
N	// These should be passed by pointer as they contain a lot of data.
N	xQueue2 = xQueueCreate( 10, sizeof( struct AMessage * ) );
N
N	// ...
N
N	if( xQueue1 != 0 )
N	{
N		// Send an uint32_t.  Wait for 10 ticks for space to become
N		// available if necessary.
N		if( xQueueSend( xQueue1, ( void * ) &ulVar, ( TickType_t ) 10 ) != pdPASS )
N		{
N			// Failed to post the message, even after 10 ticks.
N		}
N	}
N
N	if( xQueue2 != 0 )
N	{
N		// Send a pointer to a struct AMessage object.  Don't block if the
N		// queue is already full.
N		pxMessage = & xMessage;
N		xQueueSend( xQueue2, ( void * ) &pxMessage, ( TickType_t ) 0 );
N	}
N
N	// ... Rest of task code.
N }
N </pre>
N * \defgroup xQueueSend xQueueSend
N * \ingroup QueueManagement
N */
N#define xQueueSend( xQueue, pvItemToQueue, xTicksToWait ) xQueueGenericSend( ( xQueue ), ( pvItemToQueue ), ( xTicksToWait ), queueSEND_TO_BACK )
N
N/**
N * queue. h
N * <pre>
N BaseType_t xQueueOverwrite(
N							  QueueHandle_t xQueue,
N							  const void * pvItemToQueue
N						 );
N * </pre>
N *
N * Only for use with queues that have a length of one - so the queue is either
N * empty or full.
N *
N * Post an item on a queue.  If the queue is already full then overwrite the
N * value held in the queue.  The item is queued by copy, not by reference.
N *
N * This function must not be called from an interrupt service routine.
N * See xQueueOverwriteFromISR () for an alternative which may be used in an ISR.
N *
N * @param xQueue The handle of the queue to which the data is being sent.
N *
N * @param pvItemToQueue A pointer to the item that is to be placed on the
N * queue.  The size of the items the queue will hold was defined when the
N * queue was created, so this many bytes will be copied from pvItemToQueue
N * into the queue storage area.
N *
N * @return xQueueOverwrite() is a macro that calls xQueueGenericSend(), and
N * therefore has the same return values as xQueueSendToFront().  However, pdPASS
N * is the only value that can be returned because xQueueOverwrite() will write
N * to the queue even when the queue is already full.
N *
N * Example usage:
N   <pre>
N
N void vFunction( void *pvParameters )
N {
N QueueHandle_t xQueue;
N uint32_t ulVarToSend, ulValReceived;
N
N	// Create a queue to hold one uint32_t value.  It is strongly
N	// recommended *not* to use xQueueOverwrite() on queues that can
N	// contain more than one value, and doing so will trigger an assertion
N	// if configASSERT() is defined.
N	xQueue = xQueueCreate( 1, sizeof( uint32_t ) );
N
N	// Write the value 10 to the queue using xQueueOverwrite().
N	ulVarToSend = 10;
N	xQueueOverwrite( xQueue, &ulVarToSend );
N
N	// Peeking the queue should now return 10, but leave the value 10 in
N	// the queue.  A block time of zero is used as it is known that the
N	// queue holds a value.
N	ulValReceived = 0;
N	xQueuePeek( xQueue, &ulValReceived, 0 );
N
N	if( ulValReceived != 10 )
N	{
N		// Error unless the item was removed by a different task.
N	}
N
N	// The queue is still full.  Use xQueueOverwrite() to overwrite the
N	// value held in the queue with 100.
N	ulVarToSend = 100;
N	xQueueOverwrite( xQueue, &ulVarToSend );
N
N	// This time read from the queue, leaving the queue empty once more.
N	// A block time of 0 is used again.
N	xQueueReceive( xQueue, &ulValReceived, 0 );
N
N	// The value read should be the last value written, even though the
N	// queue was already full when the value was written.
N	if( ulValReceived != 100 )
N	{
N		// Error!
N	}
N
N	// ...
N}
N </pre>
N * \defgroup xQueueOverwrite xQueueOverwrite
N * \ingroup QueueManagement
N */
N#define xQueueOverwrite( xQueue, pvItemToQueue ) xQueueGenericSend( ( xQueue ), ( pvItemToQueue ), 0, queueOVERWRITE )
N
N
N/**
N * queue. h
N * <pre>
N BaseType_t xQueueGenericSend(
N									QueueHandle_t xQueue,
N									const void * pvItemToQueue,
N									TickType_t xTicksToWait
N									BaseType_t xCopyPosition
N								);
N * </pre>
N *
N * It is preferred that the macros xQueueSend(), xQueueSendToFront() and
N * xQueueSendToBack() are used in place of calling this function directly.
N *
N * Post an item on a queue.  The item is queued by copy, not by reference.
N * This function must not be called from an interrupt service routine.
N * See xQueueSendFromISR () for an alternative which may be used in an ISR.
N *
N * @param xQueue The handle to the queue on which the item is to be posted.
N *
N * @param pvItemToQueue A pointer to the item that is to be placed on the
N * queue.  The size of the items the queue will hold was defined when the
N * queue was created, so this many bytes will be copied from pvItemToQueue
N * into the queue storage area.
N *
N * @param xTicksToWait The maximum amount of time the task should block
N * waiting for space to become available on the queue, should it already
N * be full.  The call will return immediately if this is set to 0 and the
N * queue is full.  The time is defined in tick periods so the constant
N * portTICK_PERIOD_MS should be used to convert to real time if this is required.
N *
N * @param xCopyPosition Can take the value queueSEND_TO_BACK to place the
N * item at the back of the queue, or queueSEND_TO_FRONT to place the item
N * at the front of the queue (for high priority messages).
N *
N * @return pdTRUE if the item was successfully posted, otherwise errQUEUE_FULL.
N *
N * Example usage:
N   <pre>
N struct AMessage
N {
N	char ucMessageID;
N	char ucData[ 20 ];
N } xMessage;
N
N uint32_t ulVar = 10UL;
N
N void vATask( void *pvParameters )
N {
N QueueHandle_t xQueue1, xQueue2;
N struct AMessage *pxMessage;
N
N	// Create a queue capable of containing 10 uint32_t values.
N	xQueue1 = xQueueCreate( 10, sizeof( uint32_t ) );
N
N	// Create a queue capable of containing 10 pointers to AMessage structures.
N	// These should be passed by pointer as they contain a lot of data.
N	xQueue2 = xQueueCreate( 10, sizeof( struct AMessage * ) );
N
N	// ...
N
N	if( xQueue1 != 0 )
N	{
N		// Send an uint32_t.  Wait for 10 ticks for space to become
N		// available if necessary.
N		if( xQueueGenericSend( xQueue1, ( void * ) &ulVar, ( TickType_t ) 10, queueSEND_TO_BACK ) != pdPASS )
N		{
N			// Failed to post the message, even after 10 ticks.
N		}
N	}
N
N	if( xQueue2 != 0 )
N	{
N		// Send a pointer to a struct AMessage object.  Don't block if the
N		// queue is already full.
N		pxMessage = & xMessage;
N		xQueueGenericSend( xQueue2, ( void * ) &pxMessage, ( TickType_t ) 0, queueSEND_TO_BACK );
N	}
N
N	// ... Rest of task code.
N }
N </pre>
N * \defgroup xQueueSend xQueueSend
N * \ingroup QueueManagement
N */
NBaseType_t xQueueGenericSend( QueueHandle_t xQueue, const void * const pvItemToQueue, TickType_t xTicksToWait, const BaseType_t xCopyPosition ) PRIVILEGED_FUNCTION;
XBaseType_t xQueueGenericSend( QueueHandle_t xQueue, const void * const pvItemToQueue, TickType_t xTicksToWait, const BaseType_t xCopyPosition ) ;
N
N/**
N * queue. h
N * <pre>
N BaseType_t xQueuePeek(
N							 QueueHandle_t xQueue,
N							 void *pvBuffer,
N							 TickType_t xTicksToWait
N						 );</pre>
N *
N * This is a macro that calls the xQueueGenericReceive() function.
N *
N * Receive an item from a queue without removing the item from the queue.
N * The item is received by copy so a buffer of adequate size must be
N * provided.  The number of bytes copied into the buffer was defined when
N * the queue was created.
N *
N * Successfully received items remain on the queue so will be returned again
N * by the next call, or a call to xQueueReceive().
N *
N * This macro must not be used in an interrupt service routine.  See
N * xQueuePeekFromISR() for an alternative that can be called from an interrupt
N * service routine.
N *
N * @param xQueue The handle to the queue from which the item is to be
N * received.
N *
N * @param pvBuffer Pointer to the buffer into which the received item will
N * be copied.
N *
N * @param xTicksToWait The maximum amount of time the task should block
N * waiting for an item to receive should the queue be empty at the time
N * of the call.	 The time is defined in tick periods so the constant
N * portTICK_PERIOD_MS should be used to convert to real time if this is required.
N * xQueuePeek() will return immediately if xTicksToWait is 0 and the queue
N * is empty.
N *
N * @return pdTRUE if an item was successfully received from the queue,
N * otherwise pdFALSE.
N *
N * Example usage:
N   <pre>
N struct AMessage
N {
N	char ucMessageID;
N	char ucData[ 20 ];
N } xMessage;
N
N QueueHandle_t xQueue;
N
N // Task to create a queue and post a value.
N void vATask( void *pvParameters )
N {
N struct AMessage *pxMessage;
N
N	// Create a queue capable of containing 10 pointers to AMessage structures.
N	// These should be passed by pointer as they contain a lot of data.
N	xQueue = xQueueCreate( 10, sizeof( struct AMessage * ) );
N	if( xQueue == 0 )
N	{
N		// Failed to create the queue.
N	}
N
N	// ...
N
N	// Send a pointer to a struct AMessage object.  Don't block if the
N	// queue is already full.
N	pxMessage = & xMessage;
N	xQueueSend( xQueue, ( void * ) &pxMessage, ( TickType_t ) 0 );
N
N	// ... Rest of task code.
N }
N
N // Task to peek the data from the queue.
N void vADifferentTask( void *pvParameters )
N {
N struct AMessage *pxRxedMessage;
N
N	if( xQueue != 0 )
N	{
N		// Peek a message on the created queue.  Block for 10 ticks if a
N		// message is not immediately available.
N		if( xQueuePeek( xQueue, &( pxRxedMessage ), ( TickType_t ) 10 ) )
N		{
N			// pcRxedMessage now points to the struct AMessage variable posted
N			// by vATask, but the item still remains on the queue.
N		}
N	}
N
N	// ... Rest of task code.
N }
N </pre>
N * \defgroup xQueueReceive xQueueReceive
N * \ingroup QueueManagement
N */
N#define xQueuePeek( xQueue, pvBuffer, xTicksToWait ) xQueueGenericReceive( ( xQueue ), ( pvBuffer ), ( xTicksToWait ), pdTRUE )
N
N/**
N * queue. h
N * <pre>
N BaseType_t xQueuePeekFromISR(
N									QueueHandle_t xQueue,
N									void *pvBuffer,
N								);</pre>
N *
N * A version of xQueuePeek() that can be called from an interrupt service
N * routine (ISR).
N *
N * Receive an item from a queue without removing the item from the queue.
N * The item is received by copy so a buffer of adequate size must be
N * provided.  The number of bytes copied into the buffer was defined when
N * the queue was created.
N *
N * Successfully received items remain on the queue so will be returned again
N * by the next call, or a call to xQueueReceive().
N *
N * @param xQueue The handle to the queue from which the item is to be
N * received.
N *
N * @param pvBuffer Pointer to the buffer into which the received item will
N * be copied.
N *
N * @return pdTRUE if an item was successfully received from the queue,
N * otherwise pdFALSE.
N *
N * \defgroup xQueuePeekFromISR xQueuePeekFromISR
N * \ingroup QueueManagement
N */
NBaseType_t xQueuePeekFromISR( QueueHandle_t xQueue, void * const pvBuffer ) PRIVILEGED_FUNCTION;
XBaseType_t xQueuePeekFromISR( QueueHandle_t xQueue, void * const pvBuffer ) ;
N
N/**
N * queue. h
N * <pre>
N BaseType_t xQueueReceive(
N								 QueueHandle_t xQueue,
N								 void *pvBuffer,
N								 TickType_t xTicksToWait
N							);</pre>
N *
N * This is a macro that calls the xQueueGenericReceive() function.
N *
N * Receive an item from a queue.  The item is received by copy so a buffer of
N * adequate size must be provided.  The number of bytes copied into the buffer
N * was defined when the queue was created.
N *
N * Successfully received items are removed from the queue.
N *
N * This function must not be used in an interrupt service routine.  See
N * xQueueReceiveFromISR for an alternative that can.
N *
N * @param xQueue The handle to the queue from which the item is to be
N * received.
N *
N * @param pvBuffer Pointer to the buffer into which the received item will
N * be copied.
N *
N * @param xTicksToWait The maximum amount of time the task should block
N * waiting for an item to receive should the queue be empty at the time
N * of the call.	 xQueueReceive() will return immediately if xTicksToWait
N * is zero and the queue is empty.  The time is defined in tick periods so the
N * constant portTICK_PERIOD_MS should be used to convert to real time if this is
N * required.
N *
N * @return pdTRUE if an item was successfully received from the queue,
N * otherwise pdFALSE.
N *
N * Example usage:
N   <pre>
N struct AMessage
N {
N	char ucMessageID;
N	char ucData[ 20 ];
N } xMessage;
N
N QueueHandle_t xQueue;
N
N // Task to create a queue and post a value.
N void vATask( void *pvParameters )
N {
N struct AMessage *pxMessage;
N
N	// Create a queue capable of containing 10 pointers to AMessage structures.
N	// These should be passed by pointer as they contain a lot of data.
N	xQueue = xQueueCreate( 10, sizeof( struct AMessage * ) );
N	if( xQueue == 0 )
N	{
N		// Failed to create the queue.
N	}
N
N	// ...
N
N	// Send a pointer to a struct AMessage object.  Don't block if the
N	// queue is already full.
N	pxMessage = & xMessage;
N	xQueueSend( xQueue, ( void * ) &pxMessage, ( TickType_t ) 0 );
N
N	// ... Rest of task code.
N }
N
N // Task to receive from the queue.
N void vADifferentTask( void *pvParameters )
N {
N struct AMessage *pxRxedMessage;
N
N	if( xQueue != 0 )
N	{
N		// Receive a message on the created queue.  Block for 10 ticks if a
N		// message is not immediately available.
N		if( xQueueReceive( xQueue, &( pxRxedMessage ), ( TickType_t ) 10 ) )
N		{
N			// pcRxedMessage now points to the struct AMessage variable posted
N			// by vATask.
N		}
N	}
N
N	// ... Rest of task code.
N }
N </pre>
N * \defgroup xQueueReceive xQueueReceive
N * \ingroup QueueManagement
N */
N#define xQueueReceive( xQueue, pvBuffer, xTicksToWait ) xQueueGenericReceive( ( xQueue ), ( pvBuffer ), ( xTicksToWait ), pdFALSE )
N
N
N/**
N * queue. h
N * <pre>
N BaseType_t xQueueGenericReceive(
N									   QueueHandle_t	xQueue,
N									   void	*pvBuffer,
N									   TickType_t	xTicksToWait
N									   BaseType_t	xJustPeek
N									);</pre>
N *
N * It is preferred that the macro xQueueReceive() be used rather than calling
N * this function directly.
N *
N * Receive an item from a queue.  The item is received by copy so a buffer of
N * adequate size must be provided.  The number of bytes copied into the buffer
N * was defined when the queue was created.
N *
N * This function must not be used in an interrupt service routine.  See
N * xQueueReceiveFromISR for an alternative that can.
N *
N * @param xQueue The handle to the queue from which the item is to be
N * received.
N *
N * @param pvBuffer Pointer to the buffer into which the received item will
N * be copied.
N *
N * @param xTicksToWait The maximum amount of time the task should block
N * waiting for an item to receive should the queue be empty at the time
N * of the call.	 The time is defined in tick periods so the constant
N * portTICK_PERIOD_MS should be used to convert to real time if this is required.
N * xQueueGenericReceive() will return immediately if the queue is empty and
N * xTicksToWait is 0.
N *
N * @param xJustPeek When set to true, the item received from the queue is not
N * actually removed from the queue - meaning a subsequent call to
N * xQueueReceive() will return the same item.  When set to false, the item
N * being received from the queue is also removed from the queue.
N *
N * @return pdTRUE if an item was successfully received from the queue,
N * otherwise pdFALSE.
N *
N * Example usage:
N   <pre>
N struct AMessage
N {
N	char ucMessageID;
N	char ucData[ 20 ];
N } xMessage;
N
N QueueHandle_t xQueue;
N
N // Task to create a queue and post a value.
N void vATask( void *pvParameters )
N {
N struct AMessage *pxMessage;
N
N	// Create a queue capable of containing 10 pointers to AMessage structures.
N	// These should be passed by pointer as they contain a lot of data.
N	xQueue = xQueueCreate( 10, sizeof( struct AMessage * ) );
N	if( xQueue == 0 )
N	{
N		// Failed to create the queue.
N	}
N
N	// ...
N
N	// Send a pointer to a struct AMessage object.  Don't block if the
N	// queue is already full.
N	pxMessage = & xMessage;
N	xQueueSend( xQueue, ( void * ) &pxMessage, ( TickType_t ) 0 );
N
N	// ... Rest of task code.
N }
N
N // Task to receive from the queue.
N void vADifferentTask( void *pvParameters )
N {
N struct AMessage *pxRxedMessage;
N
N	if( xQueue != 0 )
N	{
N		// Receive a message on the created queue.  Block for 10 ticks if a
N		// message is not immediately available.
N		if( xQueueGenericReceive( xQueue, &( pxRxedMessage ), ( TickType_t ) 10 ) )
N		{
N			// pcRxedMessage now points to the struct AMessage variable posted
N			// by vATask.
N		}
N	}
N
N	// ... Rest of task code.
N }
N </pre>
N * \defgroup xQueueReceive xQueueReceive
N * \ingroup QueueManagement
N */
NBaseType_t xQueueGenericReceive( QueueHandle_t xQueue, void * const pvBuffer, TickType_t xTicksToWait, const BaseType_t xJustPeek ) PRIVILEGED_FUNCTION;
XBaseType_t xQueueGenericReceive( QueueHandle_t xQueue, void * const pvBuffer, TickType_t xTicksToWait, const BaseType_t xJustPeek ) ;
N
N/**
N * queue. h
N * <pre>UBaseType_t uxQueueMessagesWaiting( const QueueHandle_t xQueue );</pre>
N *
N * Return the number of messages stored in a queue.
N *
N * @param xQueue A handle to the queue being queried.
N *
N * @return The number of messages available in the queue.
N *
N * \defgroup uxQueueMessagesWaiting uxQueueMessagesWaiting
N * \ingroup QueueManagement
N */
NUBaseType_t uxQueueMessagesWaiting( const QueueHandle_t xQueue ) PRIVILEGED_FUNCTION;
XUBaseType_t uxQueueMessagesWaiting( const QueueHandle_t xQueue ) ;
N
N/**
N * queue. h
N * <pre>UBaseType_t uxQueueSpacesAvailable( const QueueHandle_t xQueue );</pre>
N *
N * Return the number of free spaces available in a queue.  This is equal to the
N * number of items that can be sent to the queue before the queue becomes full
N * if no items are removed.
N *
N * @param xQueue A handle to the queue being queried.
N *
N * @return The number of spaces available in the queue.
N *
N * \defgroup uxQueueMessagesWaiting uxQueueMessagesWaiting
N * \ingroup QueueManagement
N */
NUBaseType_t uxQueueSpacesAvailable( const QueueHandle_t xQueue ) PRIVILEGED_FUNCTION;
XUBaseType_t uxQueueSpacesAvailable( const QueueHandle_t xQueue ) ;
N
N/**
N * queue. h
N * <pre>void vQueueDelete( QueueHandle_t xQueue );</pre>
N *
N * Delete a queue - freeing all the memory allocated for storing of items
N * placed on the queue.
N *
N * @param xQueue A handle to the queue to be deleted.
N *
N * \defgroup vQueueDelete vQueueDelete
N * \ingroup QueueManagement
N */
Nvoid vQueueDelete( QueueHandle_t xQueue ) PRIVILEGED_FUNCTION;
Xvoid vQueueDelete( QueueHandle_t xQueue ) ;
N
N/**
N * queue. h
N * <pre>
N BaseType_t xQueueSendToFrontFromISR(
N										 QueueHandle_t xQueue,
N										 const void *pvItemToQueue,
N										 BaseType_t *pxHigherPriorityTaskWoken
N									  );
N </pre>
N *
N * This is a macro that calls xQueueGenericSendFromISR().
N *
N * Post an item to the front of a queue.  It is safe to use this macro from
N * within an interrupt service routine.
N *
N * Items are queued by copy not reference so it is preferable to only
N * queue small items, especially when called from an ISR.  In most cases
N * it would be preferable to store a pointer to the item being queued.
N *
N * @param xQueue The handle to the queue on which the item is to be posted.
N *
N * @param pvItemToQueue A pointer to the item that is to be placed on the
N * queue.  The size of the items the queue will hold was defined when the
N * queue was created, so this many bytes will be copied from pvItemToQueue
N * into the queue storage area.
N *
N * @param pxHigherPriorityTaskWoken xQueueSendToFrontFromISR() will set
N * *pxHigherPriorityTaskWoken to pdTRUE if sending to the queue caused a task
N * to unblock, and the unblocked task has a priority higher than the currently
N * running task.  If xQueueSendToFromFromISR() sets this value to pdTRUE then
N * a context switch should be requested before the interrupt is exited.
N *
N * @return pdTRUE if the data was successfully sent to the queue, otherwise
N * errQUEUE_FULL.
N *
N * Example usage for buffered IO (where the ISR can obtain more than one value
N * per call):
N   <pre>
N void vBufferISR( void )
N {
N char cIn;
N BaseType_t xHigherPrioritTaskWoken;
N
N	// We have not woken a task at the start of the ISR.
N	xHigherPriorityTaskWoken = pdFALSE;
N
N	// Loop until the buffer is empty.
N	do
N	{
N		// Obtain a byte from the buffer.
N		cIn = portINPUT_BYTE( RX_REGISTER_ADDRESS );
N
N		// Post the byte.
N		xQueueSendToFrontFromISR( xRxQueue, &cIn, &xHigherPriorityTaskWoken );
N
N	} while( portINPUT_BYTE( BUFFER_COUNT ) );
N
N	// Now the buffer is empty we can switch context if necessary.
N	if( xHigherPriorityTaskWoken )
N	{
N		taskYIELD ();
N	}
N }
N </pre>
N *
N * \defgroup xQueueSendFromISR xQueueSendFromISR
N * \ingroup QueueManagement
N */
N#define xQueueSendToFrontFromISR( xQueue, pvItemToQueue, pxHigherPriorityTaskWoken ) xQueueGenericSendFromISR( ( xQueue ), ( pvItemToQueue ), ( pxHigherPriorityTaskWoken ), queueSEND_TO_FRONT )
N
N
N/**
N * queue. h
N * <pre>
N BaseType_t xQueueSendToBackFromISR(
N										 QueueHandle_t xQueue,
N										 const void *pvItemToQueue,
N										 BaseType_t *pxHigherPriorityTaskWoken
N									  );
N </pre>
N *
N * This is a macro that calls xQueueGenericSendFromISR().
N *
N * Post an item to the back of a queue.  It is safe to use this macro from
N * within an interrupt service routine.
N *
N * Items are queued by copy not reference so it is preferable to only
N * queue small items, especially when called from an ISR.  In most cases
N * it would be preferable to store a pointer to the item being queued.
N *
N * @param xQueue The handle to the queue on which the item is to be posted.
N *
N * @param pvItemToQueue A pointer to the item that is to be placed on the
N * queue.  The size of the items the queue will hold was defined when the
N * queue was created, so this many bytes will be copied from pvItemToQueue
N * into the queue storage area.
N *
N * @param pxHigherPriorityTaskWoken xQueueSendToBackFromISR() will set
N * *pxHigherPriorityTaskWoken to pdTRUE if sending to the queue caused a task
N * to unblock, and the unblocked task has a priority higher than the currently
N * running task.  If xQueueSendToBackFromISR() sets this value to pdTRUE then
N * a context switch should be requested before the interrupt is exited.
N *
N * @return pdTRUE if the data was successfully sent to the queue, otherwise
N * errQUEUE_FULL.
N *
N * Example usage for buffered IO (where the ISR can obtain more than one value
N * per call):
N   <pre>
N void vBufferISR( void )
N {
N char cIn;
N BaseType_t xHigherPriorityTaskWoken;
N
N	// We have not woken a task at the start of the ISR.
N	xHigherPriorityTaskWoken = pdFALSE;
N
N	// Loop until the buffer is empty.
N	do
N	{
N		// Obtain a byte from the buffer.
N		cIn = portINPUT_BYTE( RX_REGISTER_ADDRESS );
N
N		// Post the byte.
N		xQueueSendToBackFromISR( xRxQueue, &cIn, &xHigherPriorityTaskWoken );
N
N	} while( portINPUT_BYTE( BUFFER_COUNT ) );
N
N	// Now the buffer is empty we can switch context if necessary.
N	if( xHigherPriorityTaskWoken )
N	{
N		taskYIELD ();
N	}
N }
N </pre>
N *
N * \defgroup xQueueSendFromISR xQueueSendFromISR
N * \ingroup QueueManagement
N */
N#define xQueueSendToBackFromISR( xQueue, pvItemToQueue, pxHigherPriorityTaskWoken ) xQueueGenericSendFromISR( ( xQueue ), ( pvItemToQueue ), ( pxHigherPriorityTaskWoken ), queueSEND_TO_BACK )
N
N/**
N * queue. h
N * <pre>
N BaseType_t xQueueOverwriteFromISR(
N							  QueueHandle_t xQueue,
N							  const void * pvItemToQueue,
N							  BaseType_t *pxHigherPriorityTaskWoken
N						 );
N * </pre>
N *
N * A version of xQueueOverwrite() that can be used in an interrupt service
N * routine (ISR).
N *
N * Only for use with queues that can hold a single item - so the queue is either
N * empty or full.
N *
N * Post an item on a queue.  If the queue is already full then overwrite the
N * value held in the queue.  The item is queued by copy, not by reference.
N *
N * @param xQueue The handle to the queue on which the item is to be posted.
N *
N * @param pvItemToQueue A pointer to the item that is to be placed on the
N * queue.  The size of the items the queue will hold was defined when the
N * queue was created, so this many bytes will be copied from pvItemToQueue
N * into the queue storage area.
N *
N * @param pxHigherPriorityTaskWoken xQueueOverwriteFromISR() will set
N * *pxHigherPriorityTaskWoken to pdTRUE if sending to the queue caused a task
N * to unblock, and the unblocked task has a priority higher than the currently
N * running task.  If xQueueOverwriteFromISR() sets this value to pdTRUE then
N * a context switch should be requested before the interrupt is exited.
N *
N * @return xQueueOverwriteFromISR() is a macro that calls
N * xQueueGenericSendFromISR(), and therefore has the same return values as
N * xQueueSendToFrontFromISR().  However, pdPASS is the only value that can be
N * returned because xQueueOverwriteFromISR() will write to the queue even when
N * the queue is already full.
N *
N * Example usage:
N   <pre>
N
N QueueHandle_t xQueue;
N
N void vFunction( void *pvParameters )
N {
N 	// Create a queue to hold one uint32_t value.  It is strongly
N	// recommended *not* to use xQueueOverwriteFromISR() on queues that can
N	// contain more than one value, and doing so will trigger an assertion
N	// if configASSERT() is defined.
N	xQueue = xQueueCreate( 1, sizeof( uint32_t ) );
N}
N
Nvoid vAnInterruptHandler( void )
N{
N// xHigherPriorityTaskWoken must be set to pdFALSE before it is used.
NBaseType_t xHigherPriorityTaskWoken = pdFALSE;
Nuint32_t ulVarToSend, ulValReceived;
N
N	// Write the value 10 to the queue using xQueueOverwriteFromISR().
N	ulVarToSend = 10;
N	xQueueOverwriteFromISR( xQueue, &ulVarToSend, &xHigherPriorityTaskWoken );
N
N	// The queue is full, but calling xQueueOverwriteFromISR() again will still
N	// pass because the value held in the queue will be overwritten with the
N	// new value.
N	ulVarToSend = 100;
N	xQueueOverwriteFromISR( xQueue, &ulVarToSend, &xHigherPriorityTaskWoken );
N
N	// Reading from the queue will now return 100.
N
N	// ...
N
N	if( xHigherPrioritytaskWoken == pdTRUE )
N	{
N		// Writing to the queue caused a task to unblock and the unblocked task
N		// has a priority higher than or equal to the priority of the currently
N		// executing task (the task this interrupt interrupted).  Perform a context
N		// switch so this interrupt returns directly to the unblocked task.
N		portYIELD_FROM_ISR(); // or portEND_SWITCHING_ISR() depending on the port.
N	}
N}
N </pre>
N * \defgroup xQueueOverwriteFromISR xQueueOverwriteFromISR
N * \ingroup QueueManagement
N */
N#define xQueueOverwriteFromISR( xQueue, pvItemToQueue, pxHigherPriorityTaskWoken ) xQueueGenericSendFromISR( ( xQueue ), ( pvItemToQueue ), ( pxHigherPriorityTaskWoken ), queueOVERWRITE )
N
N/**
N * queue. h
N * <pre>
N BaseType_t xQueueSendFromISR(
N									 QueueHandle_t xQueue,
N									 const void *pvItemToQueue,
N									 BaseType_t *pxHigherPriorityTaskWoken
N								);
N </pre>
N *
N * This is a macro that calls xQueueGenericSendFromISR().  It is included
N * for backward compatibility with versions of FreeRTOS.org that did not
N * include the xQueueSendToBackFromISR() and xQueueSendToFrontFromISR()
N * macros.
N *
N * Post an item to the back of a queue.  It is safe to use this function from
N * within an interrupt service routine.
N *
N * Items are queued by copy not reference so it is preferable to only
N * queue small items, especially when called from an ISR.  In most cases
N * it would be preferable to store a pointer to the item being queued.
N *
N * @param xQueue The handle to the queue on which the item is to be posted.
N *
N * @param pvItemToQueue A pointer to the item that is to be placed on the
N * queue.  The size of the items the queue will hold was defined when the
N * queue was created, so this many bytes will be copied from pvItemToQueue
N * into the queue storage area.
N *
N * @param pxHigherPriorityTaskWoken xQueueSendFromISR() will set
N * *pxHigherPriorityTaskWoken to pdTRUE if sending to the queue caused a task
N * to unblock, and the unblocked task has a priority higher than the currently
N * running task.  If xQueueSendFromISR() sets this value to pdTRUE then
N * a context switch should be requested before the interrupt is exited.
N *
N * @return pdTRUE if the data was successfully sent to the queue, otherwise
N * errQUEUE_FULL.
N *
N * Example usage for buffered IO (where the ISR can obtain more than one value
N * per call):
N   <pre>
N void vBufferISR( void )
N {
N char cIn;
N BaseType_t xHigherPriorityTaskWoken;
N
N	// We have not woken a task at the start of the ISR.
N	xHigherPriorityTaskWoken = pdFALSE;
N
N	// Loop until the buffer is empty.
N	do
N	{
N		// Obtain a byte from the buffer.
N		cIn = portINPUT_BYTE( RX_REGISTER_ADDRESS );
N
N		// Post the byte.
N		xQueueSendFromISR( xRxQueue, &cIn, &xHigherPriorityTaskWoken );
N
N	} while( portINPUT_BYTE( BUFFER_COUNT ) );
N
N	// Now the buffer is empty we can switch context if necessary.
N	if( xHigherPriorityTaskWoken )
N	{
N		// Actual macro used here is port specific.
N		portYIELD_FROM_ISR ();
N	}
N }
N </pre>
N *
N * \defgroup xQueueSendFromISR xQueueSendFromISR
N * \ingroup QueueManagement
N */
N#define xQueueSendFromISR( xQueue, pvItemToQueue, pxHigherPriorityTaskWoken ) xQueueGenericSendFromISR( ( xQueue ), ( pvItemToQueue ), ( pxHigherPriorityTaskWoken ), queueSEND_TO_BACK )
N
N/**
N * queue. h
N * <pre>
N BaseType_t xQueueGenericSendFromISR(
N										   QueueHandle_t		xQueue,
N										   const	void	*pvItemToQueue,
N										   BaseType_t	*pxHigherPriorityTaskWoken,
N										   BaseType_t	xCopyPosition
N									   );
N </pre>
N *
N * It is preferred that the macros xQueueSendFromISR(),
N * xQueueSendToFrontFromISR() and xQueueSendToBackFromISR() be used in place
N * of calling this function directly.  xQueueGiveFromISR() is an
N * equivalent for use by semaphores that don't actually copy any data.
N *
N * Post an item on a queue.  It is safe to use this function from within an
N * interrupt service routine.
N *
N * Items are queued by copy not reference so it is preferable to only
N * queue small items, especially when called from an ISR.  In most cases
N * it would be preferable to store a pointer to the item being queued.
N *
N * @param xQueue The handle to the queue on which the item is to be posted.
N *
N * @param pvItemToQueue A pointer to the item that is to be placed on the
N * queue.  The size of the items the queue will hold was defined when the
N * queue was created, so this many bytes will be copied from pvItemToQueue
N * into the queue storage area.
N *
N * @param pxHigherPriorityTaskWoken xQueueGenericSendFromISR() will set
N * *pxHigherPriorityTaskWoken to pdTRUE if sending to the queue caused a task
N * to unblock, and the unblocked task has a priority higher than the currently
N * running task.  If xQueueGenericSendFromISR() sets this value to pdTRUE then
N * a context switch should be requested before the interrupt is exited.
N *
N * @param xCopyPosition Can take the value queueSEND_TO_BACK to place the
N * item at the back of the queue, or queueSEND_TO_FRONT to place the item
N * at the front of the queue (for high priority messages).
N *
N * @return pdTRUE if the data was successfully sent to the queue, otherwise
N * errQUEUE_FULL.
N *
N * Example usage for buffered IO (where the ISR can obtain more than one value
N * per call):
N   <pre>
N void vBufferISR( void )
N {
N char cIn;
N BaseType_t xHigherPriorityTaskWokenByPost;
N
N	// We have not woken a task at the start of the ISR.
N	xHigherPriorityTaskWokenByPost = pdFALSE;
N
N	// Loop until the buffer is empty.
N	do
N	{
N		// Obtain a byte from the buffer.
N		cIn = portINPUT_BYTE( RX_REGISTER_ADDRESS );
N
N		// Post each byte.
N		xQueueGenericSendFromISR( xRxQueue, &cIn, &xHigherPriorityTaskWokenByPost, queueSEND_TO_BACK );
N
N	} while( portINPUT_BYTE( BUFFER_COUNT ) );
N
N	// Now the buffer is empty we can switch context if necessary.  Note that the
N	// name of the yield function required is port specific.
N	if( xHigherPriorityTaskWokenByPost )
N	{
N		taskYIELD_YIELD_FROM_ISR();
N	}
N }
N </pre>
N *
N * \defgroup xQueueSendFromISR xQueueSendFromISR
N * \ingroup QueueManagement
N */
NBaseType_t xQueueGenericSendFromISR( QueueHandle_t xQueue, const void * const pvItemToQueue, BaseType_t * const pxHigherPriorityTaskWoken, const BaseType_t xCopyPosition ) PRIVILEGED_FUNCTION;
XBaseType_t xQueueGenericSendFromISR( QueueHandle_t xQueue, const void * const pvItemToQueue, BaseType_t * const pxHigherPriorityTaskWoken, const BaseType_t xCopyPosition ) ;
NBaseType_t xQueueGiveFromISR( QueueHandle_t xQueue, BaseType_t * const pxHigherPriorityTaskWoken ) PRIVILEGED_FUNCTION;
XBaseType_t xQueueGiveFromISR( QueueHandle_t xQueue, BaseType_t * const pxHigherPriorityTaskWoken ) ;
N
N/**
N * queue. h
N * <pre>
N BaseType_t xQueueReceiveFromISR(
N									   QueueHandle_t	xQueue,
N									   void	*pvBuffer,
N									   BaseType_t *pxTaskWoken
N								   );
N * </pre>
N *
N * Receive an item from a queue.  It is safe to use this function from within an
N * interrupt service routine.
N *
N * @param xQueue The handle to the queue from which the item is to be
N * received.
N *
N * @param pvBuffer Pointer to the buffer into which the received item will
N * be copied.
N *
N * @param pxTaskWoken A task may be blocked waiting for space to become
N * available on the queue.  If xQueueReceiveFromISR causes such a task to
N * unblock *pxTaskWoken will get set to pdTRUE, otherwise *pxTaskWoken will
N * remain unchanged.
N *
N * @return pdTRUE if an item was successfully received from the queue,
N * otherwise pdFALSE.
N *
N * Example usage:
N   <pre>
N
N QueueHandle_t xQueue;
N
N // Function to create a queue and post some values.
N void vAFunction( void *pvParameters )
N {
N char cValueToPost;
N const TickType_t xTicksToWait = ( TickType_t )0xff;
N
N	// Create a queue capable of containing 10 characters.
N	xQueue = xQueueCreate( 10, sizeof( char ) );
N	if( xQueue == 0 )
N	{
N		// Failed to create the queue.
N	}
N
N	// ...
N
N	// Post some characters that will be used within an ISR.  If the queue
N	// is full then this task will block for xTicksToWait ticks.
N	cValueToPost = 'a';
N	xQueueSend( xQueue, ( void * ) &cValueToPost, xTicksToWait );
N	cValueToPost = 'b';
N	xQueueSend( xQueue, ( void * ) &cValueToPost, xTicksToWait );
N
N	// ... keep posting characters ... this task may block when the queue
N	// becomes full.
N
N	cValueToPost = 'c';
N	xQueueSend( xQueue, ( void * ) &cValueToPost, xTicksToWait );
N }
N
N // ISR that outputs all the characters received on the queue.
N void vISR_Routine( void )
N {
N BaseType_t xTaskWokenByReceive = pdFALSE;
N char cRxedChar;
N
N	while( xQueueReceiveFromISR( xQueue, ( void * ) &cRxedChar, &xTaskWokenByReceive) )
N	{
N		// A character was received.  Output the character now.
N		vOutputCharacter( cRxedChar );
N
N		// If removing the character from the queue woke the task that was
N		// posting onto the queue cTaskWokenByReceive will have been set to
N		// pdTRUE.  No matter how many times this loop iterates only one
N		// task will be woken.
N	}
N
N	if( cTaskWokenByPost != ( char ) pdFALSE;
N	{
N		taskYIELD ();
N	}
N }
N </pre>
N * \defgroup xQueueReceiveFromISR xQueueReceiveFromISR
N * \ingroup QueueManagement
N */
NBaseType_t xQueueReceiveFromISR( QueueHandle_t xQueue, void * const pvBuffer, BaseType_t * const pxHigherPriorityTaskWoken ) PRIVILEGED_FUNCTION;
XBaseType_t xQueueReceiveFromISR( QueueHandle_t xQueue, void * const pvBuffer, BaseType_t * const pxHigherPriorityTaskWoken ) ;
N
N/*
N * Utilities to query queues that are safe to use from an ISR.  These utilities
N * should be used only from witin an ISR, or within a critical section.
N */
NBaseType_t xQueueIsQueueEmptyFromISR( const QueueHandle_t xQueue ) PRIVILEGED_FUNCTION;
XBaseType_t xQueueIsQueueEmptyFromISR( const QueueHandle_t xQueue ) ;
NBaseType_t xQueueIsQueueFullFromISR( const QueueHandle_t xQueue ) PRIVILEGED_FUNCTION;
XBaseType_t xQueueIsQueueFullFromISR( const QueueHandle_t xQueue ) ;
NUBaseType_t uxQueueMessagesWaitingFromISR( const QueueHandle_t xQueue ) PRIVILEGED_FUNCTION;
XUBaseType_t uxQueueMessagesWaitingFromISR( const QueueHandle_t xQueue ) ;
N
N/*
N * The functions defined above are for passing data to and from tasks.  The
N * functions below are the equivalents for passing data to and from
N * co-routines.
N *
N * These functions are called from the co-routine macro implementation and
N * should not be called directly from application code.  Instead use the macro
N * wrappers defined within croutine.h.
N */
NBaseType_t xQueueCRSendFromISR( QueueHandle_t xQueue, const void *pvItemToQueue, BaseType_t xCoRoutinePreviouslyWoken );
NBaseType_t xQueueCRReceiveFromISR( QueueHandle_t xQueue, void *pvBuffer, BaseType_t *pxTaskWoken );
NBaseType_t xQueueCRSend( QueueHandle_t xQueue, const void *pvItemToQueue, TickType_t xTicksToWait );
NBaseType_t xQueueCRReceive( QueueHandle_t xQueue, void *pvBuffer, TickType_t xTicksToWait );
N
N/*
N * For internal use only.  Use xSemaphoreCreateMutex(),
N * xSemaphoreCreateCounting() or xSemaphoreGetMutexHolder() instead of calling
N * these functions directly.
N */
NQueueHandle_t xQueueCreateMutex( const uint8_t ucQueueType ) PRIVILEGED_FUNCTION;
XQueueHandle_t xQueueCreateMutex( const uint8_t ucQueueType ) ;
NQueueHandle_t xQueueCreateMutexStatic( const uint8_t ucQueueType, StaticQueue_t *pxStaticQueue ) PRIVILEGED_FUNCTION;
XQueueHandle_t xQueueCreateMutexStatic( const uint8_t ucQueueType, StaticQueue_t *pxStaticQueue ) ;
NQueueHandle_t xQueueCreateCountingSemaphore( const UBaseType_t uxMaxCount, const UBaseType_t uxInitialCount ) PRIVILEGED_FUNCTION;
XQueueHandle_t xQueueCreateCountingSemaphore( const UBaseType_t uxMaxCount, const UBaseType_t uxInitialCount ) ;
NQueueHandle_t xQueueCreateCountingSemaphoreStatic( const UBaseType_t uxMaxCount, const UBaseType_t uxInitialCount, StaticQueue_t *pxStaticQueue ) PRIVILEGED_FUNCTION;
XQueueHandle_t xQueueCreateCountingSemaphoreStatic( const UBaseType_t uxMaxCount, const UBaseType_t uxInitialCount, StaticQueue_t *pxStaticQueue ) ;
Nvoid* xQueueGetMutexHolder( QueueHandle_t xSemaphore ) PRIVILEGED_FUNCTION;
Xvoid* xQueueGetMutexHolder( QueueHandle_t xSemaphore ) ;
N
N/*
N * For internal use only.  Use xSemaphoreTakeMutexRecursive() or
N * xSemaphoreGiveMutexRecursive() instead of calling these functions directly.
N */
NBaseType_t xQueueTakeMutexRecursive( QueueHandle_t xMutex, TickType_t xTicksToWait ) PRIVILEGED_FUNCTION;
XBaseType_t xQueueTakeMutexRecursive( QueueHandle_t xMutex, TickType_t xTicksToWait ) ;
NBaseType_t xQueueGiveMutexRecursive( QueueHandle_t pxMutex ) PRIVILEGED_FUNCTION;
XBaseType_t xQueueGiveMutexRecursive( QueueHandle_t pxMutex ) ;
N
N/*
N * Reset a queue back to its original empty state.  The return value is now
N * obsolete and is always set to pdPASS.
N */
N#define xQueueReset( xQueue ) xQueueGenericReset( xQueue, pdFALSE )
N
N/*
N * The registry is provided as a means for kernel aware debuggers to
N * locate queues, semaphores and mutexes.  Call vQueueAddToRegistry() add
N * a queue, semaphore or mutex handle to the registry if you want the handle
N * to be available to a kernel aware debugger.  If you are not using a kernel
N * aware debugger then this function can be ignored.
N *
N * configQUEUE_REGISTRY_SIZE defines the maximum number of handles the
N * registry can hold.  configQUEUE_REGISTRY_SIZE must be greater than 0
N * within FreeRTOSConfig.h for the registry to be available.  Its value
N * does not effect the number of queues, semaphores and mutexes that can be
N * created - just the number that the registry can hold.
N *
N * @param xQueue The handle of the queue being added to the registry.  This
N * is the handle returned by a call to xQueueCreate().  Semaphore and mutex
N * handles can also be passed in here.
N *
N * @param pcName The name to be associated with the handle.  This is the
N * name that the kernel aware debugger will display.  The queue registry only
N * stores a pointer to the string - so the string must be persistent (global or
N * preferably in ROM/Flash), not on the stack.
N */
N#if( configQUEUE_REGISTRY_SIZE > 0 )
X#if( 0U > 0 )
S	void vQueueAddToRegistry( QueueHandle_t xQueue, const char *pcName ) PRIVILEGED_FUNCTION; /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
N#endif
N
N/*
N * The registry is provided as a means for kernel aware debuggers to
N * locate queues, semaphores and mutexes.  Call vQueueAddToRegistry() add
N * a queue, semaphore or mutex handle to the registry if you want the handle
N * to be available to a kernel aware debugger, and vQueueUnregisterQueue() to
N * remove the queue, semaphore or mutex from the register.  If you are not using
N * a kernel aware debugger then this function can be ignored.
N *
N * @param xQueue The handle of the queue being removed from the registry.
N */
N#if( configQUEUE_REGISTRY_SIZE > 0 )
X#if( 0U > 0 )
S	void vQueueUnregisterQueue( QueueHandle_t xQueue ) PRIVILEGED_FUNCTION;
N#endif
N
N/*
N * The queue registry is provided as a means for kernel aware debuggers to
N * locate queues, semaphores and mutexes.  Call pcQueueGetName() to look
N * up and return the name of a queue in the queue registry from the queue's
N * handle.
N *
N * @param xQueue The handle of the queue the name of which will be returned.
N * @return If the queue is in the registry then a pointer to the name of the
N * queue is returned.  If the queue is not in the registry then NULL is
N * returned.
N */
N#if( configQUEUE_REGISTRY_SIZE > 0 )
X#if( 0U > 0 )
S	const char *pcQueueGetName( QueueHandle_t xQueue ) PRIVILEGED_FUNCTION; /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
N#endif
N
N/*
N * Generic version of the function used to creaet a queue using dynamic memory
N * allocation.  This is called by other functions and macros that create other
N * RTOS objects that use the queue structure as their base.
N */
N#if( configSUPPORT_DYNAMIC_ALLOCATION == 1 )
X#if( 1 == 1 )
N	QueueHandle_t xQueueGenericCreate( const UBaseType_t uxQueueLength, const UBaseType_t uxItemSize, const uint8_t ucQueueType ) PRIVILEGED_FUNCTION;
X	QueueHandle_t xQueueGenericCreate( const UBaseType_t uxQueueLength, const UBaseType_t uxItemSize, const uint8_t ucQueueType ) ;
N#endif
N
N/*
N * Generic version of the function used to creaet a queue using dynamic memory
N * allocation.  This is called by other functions and macros that create other
N * RTOS objects that use the queue structure as their base.
N */
N#if( configSUPPORT_STATIC_ALLOCATION == 1 )
X#if( 0 == 1 )
S	QueueHandle_t xQueueGenericCreateStatic( const UBaseType_t uxQueueLength, const UBaseType_t uxItemSize, uint8_t *pucQueueStorage, StaticQueue_t *pxStaticQueue, const uint8_t ucQueueType ) PRIVILEGED_FUNCTION;
N#endif
N
N/*
N * Queue sets provide a mechanism to allow a task to block (pend) on a read
N * operation from multiple queues or semaphores simultaneously.
N *
N * See FreeRTOS/Source/Demo/Common/Minimal/QueueSet.c for an example using this
N * function.
N *
N * A queue set must be explicitly created using a call to xQueueCreateSet()
N * before it can be used.  Once created, standard FreeRTOS queues and semaphores
N * can be added to the set using calls to xQueueAddToSet().
N * xQueueSelectFromSet() is then used to determine which, if any, of the queues
N * or semaphores contained in the set is in a state where a queue read or
N * semaphore take operation would be successful.
N *
N * Note 1:  See the documentation on http://wwwFreeRTOS.org/RTOS-queue-sets.html
N * for reasons why queue sets are very rarely needed in practice as there are
N * simpler methods of blocking on multiple objects.
N *
N * Note 2:  Blocking on a queue set that contains a mutex will not cause the
N * mutex holder to inherit the priority of the blocked task.
N *
N * Note 3:  An additional 4 bytes of RAM is required for each space in a every
N * queue added to a queue set.  Therefore counting semaphores that have a high
N * maximum count value should not be added to a queue set.
N *
N * Note 4:  A receive (in the case of a queue) or take (in the case of a
N * semaphore) operation must not be performed on a member of a queue set unless
N * a call to xQueueSelectFromSet() has first returned a handle to that set member.
N *
N * @param uxEventQueueLength Queue sets store events that occur on
N * the queues and semaphores contained in the set.  uxEventQueueLength specifies
N * the maximum number of events that can be queued at once.  To be absolutely
N * certain that events are not lost uxEventQueueLength should be set to the
N * total sum of the length of the queues added to the set, where binary
N * semaphores and mutexes have a length of 1, and counting semaphores have a
N * length set by their maximum count value.  Examples:
N *  + If a queue set is to hold a queue of length 5, another queue of length 12,
N *    and a binary semaphore, then uxEventQueueLength should be set to
N *    (5 + 12 + 1), or 18.
N *  + If a queue set is to hold three binary semaphores then uxEventQueueLength
N *    should be set to (1 + 1 + 1 ), or 3.
N *  + If a queue set is to hold a counting semaphore that has a maximum count of
N *    5, and a counting semaphore that has a maximum count of 3, then
N *    uxEventQueueLength should be set to (5 + 3), or 8.
N *
N * @return If the queue set is created successfully then a handle to the created
N * queue set is returned.  Otherwise NULL is returned.
N */
NQueueSetHandle_t xQueueCreateSet( const UBaseType_t uxEventQueueLength ) PRIVILEGED_FUNCTION;
XQueueSetHandle_t xQueueCreateSet( const UBaseType_t uxEventQueueLength ) ;
N
N/*
N * Adds a queue or semaphore to a queue set that was previously created by a
N * call to xQueueCreateSet().
N *
N * See FreeRTOS/Source/Demo/Common/Minimal/QueueSet.c for an example using this
N * function.
N *
N * Note 1:  A receive (in the case of a queue) or take (in the case of a
N * semaphore) operation must not be performed on a member of a queue set unless
N * a call to xQueueSelectFromSet() has first returned a handle to that set member.
N *
N * @param xQueueOrSemaphore The handle of the queue or semaphore being added to
N * the queue set (cast to an QueueSetMemberHandle_t type).
N *
N * @param xQueueSet The handle of the queue set to which the queue or semaphore
N * is being added.
N *
N * @return If the queue or semaphore was successfully added to the queue set
N * then pdPASS is returned.  If the queue could not be successfully added to the
N * queue set because it is already a member of a different queue set then pdFAIL
N * is returned.
N */
NBaseType_t xQueueAddToSet( QueueSetMemberHandle_t xQueueOrSemaphore, QueueSetHandle_t xQueueSet ) PRIVILEGED_FUNCTION;
XBaseType_t xQueueAddToSet( QueueSetMemberHandle_t xQueueOrSemaphore, QueueSetHandle_t xQueueSet ) ;
N
N/*
N * Removes a queue or semaphore from a queue set.  A queue or semaphore can only
N * be removed from a set if the queue or semaphore is empty.
N *
N * See FreeRTOS/Source/Demo/Common/Minimal/QueueSet.c for an example using this
N * function.
N *
N * @param xQueueOrSemaphore The handle of the queue or semaphore being removed
N * from the queue set (cast to an QueueSetMemberHandle_t type).
N *
N * @param xQueueSet The handle of the queue set in which the queue or semaphore
N * is included.
N *
N * @return If the queue or semaphore was successfully removed from the queue set
N * then pdPASS is returned.  If the queue was not in the queue set, or the
N * queue (or semaphore) was not empty, then pdFAIL is returned.
N */
NBaseType_t xQueueRemoveFromSet( QueueSetMemberHandle_t xQueueOrSemaphore, QueueSetHandle_t xQueueSet ) PRIVILEGED_FUNCTION;
XBaseType_t xQueueRemoveFromSet( QueueSetMemberHandle_t xQueueOrSemaphore, QueueSetHandle_t xQueueSet ) ;
N
N/*
N * xQueueSelectFromSet() selects from the members of a queue set a queue or
N * semaphore that either contains data (in the case of a queue) or is available
N * to take (in the case of a semaphore).  xQueueSelectFromSet() effectively
N * allows a task to block (pend) on a read operation on all the queues and
N * semaphores in a queue set simultaneously.
N *
N * See FreeRTOS/Source/Demo/Common/Minimal/QueueSet.c for an example using this
N * function.
N *
N * Note 1:  See the documentation on http://wwwFreeRTOS.org/RTOS-queue-sets.html
N * for reasons why queue sets are very rarely needed in practice as there are
N * simpler methods of blocking on multiple objects.
N *
N * Note 2:  Blocking on a queue set that contains a mutex will not cause the
N * mutex holder to inherit the priority of the blocked task.
N *
N * Note 3:  A receive (in the case of a queue) or take (in the case of a
N * semaphore) operation must not be performed on a member of a queue set unless
N * a call to xQueueSelectFromSet() has first returned a handle to that set member.
N *
N * @param xQueueSet The queue set on which the task will (potentially) block.
N *
N * @param xTicksToWait The maximum time, in ticks, that the calling task will
N * remain in the Blocked state (with other tasks executing) to wait for a member
N * of the queue set to be ready for a successful queue read or semaphore take
N * operation.
N *
N * @return xQueueSelectFromSet() will return the handle of a queue (cast to
N * a QueueSetMemberHandle_t type) contained in the queue set that contains data,
N * or the handle of a semaphore (cast to a QueueSetMemberHandle_t type) contained
N * in the queue set that is available, or NULL if no such queue or semaphore
N * exists before before the specified block time expires.
N */
NQueueSetMemberHandle_t xQueueSelectFromSet( QueueSetHandle_t xQueueSet, const TickType_t xTicksToWait ) PRIVILEGED_FUNCTION;
XQueueSetMemberHandle_t xQueueSelectFromSet( QueueSetHandle_t xQueueSet, const TickType_t xTicksToWait ) ;
N
N/*
N * A version of xQueueSelectFromSet() that can be used from an ISR.
N */
NQueueSetMemberHandle_t xQueueSelectFromSetFromISR( QueueSetHandle_t xQueueSet ) PRIVILEGED_FUNCTION;
XQueueSetMemberHandle_t xQueueSelectFromSetFromISR( QueueSetHandle_t xQueueSet ) ;
N
N/* Not public API functions. */
Nvoid vQueueWaitForMessageRestricted( QueueHandle_t xQueue, TickType_t xTicksToWait, const BaseType_t xWaitIndefinitely ) PRIVILEGED_FUNCTION;
Xvoid vQueueWaitForMessageRestricted( QueueHandle_t xQueue, TickType_t xTicksToWait, const BaseType_t xWaitIndefinitely ) ;
NBaseType_t xQueueGenericReset( QueueHandle_t xQueue, BaseType_t xNewQueue ) PRIVILEGED_FUNCTION;
XBaseType_t xQueueGenericReset( QueueHandle_t xQueue, BaseType_t xNewQueue ) ;
Nvoid vQueueSetQueueNumber( QueueHandle_t xQueue, UBaseType_t uxQueueNumber ) PRIVILEGED_FUNCTION;
Xvoid vQueueSetQueueNumber( QueueHandle_t xQueue, UBaseType_t uxQueueNumber ) ;
NUBaseType_t uxQueueGetQueueNumber( QueueHandle_t xQueue ) PRIVILEGED_FUNCTION;
XUBaseType_t uxQueueGetQueueNumber( QueueHandle_t xQueue ) ;
Nuint8_t ucQueueGetQueueType( QueueHandle_t xQueue ) PRIVILEGED_FUNCTION;
Xuint8_t ucQueueGetQueueType( QueueHandle_t xQueue ) ;
N
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif /* QUEUE_H */
N
L 37 "..\..\User\main.c" 2
N#include "task.h"
L 1 "..\..\Freee-RTOS\include\task.h" 1
N/*
N    FreeRTOS V9.0.0 - Copyright (C) 2016 Real Time Engineers Ltd.
N    All rights reserved
N
N    VISIT http://www.FreeRTOS.org TO ENSURE YOU ARE USING THE LATEST VERSION.
N
N    This file is part of the FreeRTOS distribution.
N
N    FreeRTOS is free software; you can redistribute it and/or modify it under
N    the terms of the GNU General Public License (version 2) as published by the
N    Free Software Foundation >>>> AND MODIFIED BY <<<< the FreeRTOS exception.
N
N    ***************************************************************************
N    >>!   NOTE: The modification to the GPL is included to allow you to     !<<
N    >>!   distribute a combined work that includes FreeRTOS without being   !<<
N    >>!   obliged to provide the source code for proprietary components     !<<
N    >>!   outside of the FreeRTOS kernel.                                   !<<
N    ***************************************************************************
N
N    FreeRTOS is distributed in the hope that it will be useful, but WITHOUT ANY
N    WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
N    FOR A PARTICULAR PURPOSE.  Full license text is available on the following
N    link: http://www.freertos.org/a00114.html
N
N    ***************************************************************************
N     *                                                                       *
N     *    FreeRTOS provides completely free yet professionally developed,    *
N     *    robust, strictly quality controlled, supported, and cross          *
N     *    platform software that is more than just the market leader, it     *
N     *    is the industry's de facto standard.                               *
N     *                                                                       *
N     *    Help yourself get started quickly while simultaneously helping     *
N     *    to support the FreeRTOS project by purchasing a FreeRTOS           *
N     *    tutorial book, reference manual, or both:                          *
N     *    http://www.FreeRTOS.org/Documentation                              *
N     *                                                                       *
N    ***************************************************************************
N
N    http://www.FreeRTOS.org/FAQHelp.html - Having a problem?  Start by reading
N    the FAQ page "My application does not run, what could be wrong?".  Have you
N    defined configASSERT()?
N
N    http://www.FreeRTOS.org/support - In return for receiving this top quality
N    embedded software for free we request you assist our global community by
N    participating in the support forum.
N
N    http://www.FreeRTOS.org/training - Investing in training allows your team to
N    be as productive as possible as early as possible.  Now you can receive
N    FreeRTOS training directly from Richard Barry, CEO of Real Time Engineers
N    Ltd, and the world's leading authority on the world's leading RTOS.
N
N    http://www.FreeRTOS.org/plus - A selection of FreeRTOS ecosystem products,
N    including FreeRTOS+Trace - an indispensable productivity tool, a DOS
N    compatible FAT file system, and our tiny thread aware UDP/IP stack.
N
N    http://www.FreeRTOS.org/labs - Where new FreeRTOS products go to incubate.
N    Come and try FreeRTOS+TCP, our new open source TCP/IP stack for FreeRTOS.
N
N    http://www.OpenRTOS.com - Real Time Engineers ltd. license FreeRTOS to High
N    Integrity Systems ltd. to sell under the OpenRTOS brand.  Low cost OpenRTOS
N    licenses offer ticketed support, indemnification and commercial middleware.
N
N    http://www.SafeRTOS.com - High Integrity Systems also provide a safety
N    engineered and independently SIL3 certified version for use in safety and
N    mission critical applications that require provable dependability.
N
N    1 tab == 4 spaces!
N*/
N
N
N#ifndef INC_TASK_H
N#define INC_TASK_H
N
N#ifndef INC_FREERTOS_H
S	#error "include FreeRTOS.h must appear in source files before include task.h"
N#endif
N
N#include "list.h"
L 1 "..\..\Freee-RTOS\include\list.h" 1
N/*
N    FreeRTOS V9.0.0 - Copyright (C) 2016 Real Time Engineers Ltd.
N    All rights reserved
N
N    VISIT http://www.FreeRTOS.org TO ENSURE YOU ARE USING THE LATEST VERSION.
N
N    This file is part of the FreeRTOS distribution.
N
N    FreeRTOS is free software; you can redistribute it and/or modify it under
N    the terms of the GNU General Public License (version 2) as published by the
N    Free Software Foundation >>>> AND MODIFIED BY <<<< the FreeRTOS exception.
N
N    ***************************************************************************
N    >>!   NOTE: The modification to the GPL is included to allow you to     !<<
N    >>!   distribute a combined work that includes FreeRTOS without being   !<<
N    >>!   obliged to provide the source code for proprietary components     !<<
N    >>!   outside of the FreeRTOS kernel.                                   !<<
N    ***************************************************************************
N
N    FreeRTOS is distributed in the hope that it will be useful, but WITHOUT ANY
N    WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
N    FOR A PARTICULAR PURPOSE.  Full license text is available on the following
N    link: http://www.freertos.org/a00114.html
N
N    ***************************************************************************
N     *                                                                       *
N     *    FreeRTOS provides completely free yet professionally developed,    *
N     *    robust, strictly quality controlled, supported, and cross          *
N     *    platform software that is more than just the market leader, it     *
N     *    is the industry's de facto standard.                               *
N     *                                                                       *
N     *    Help yourself get started quickly while simultaneously helping     *
N     *    to support the FreeRTOS project by purchasing a FreeRTOS           *
N     *    tutorial book, reference manual, or both:                          *
N     *    http://www.FreeRTOS.org/Documentation                              *
N     *                                                                       *
N    ***************************************************************************
N
N    http://www.FreeRTOS.org/FAQHelp.html - Having a problem?  Start by reading
N    the FAQ page "My application does not run, what could be wrong?".  Have you
N    defined configASSERT()?
N
N    http://www.FreeRTOS.org/support - In return for receiving this top quality
N    embedded software for free we request you assist our global community by
N    participating in the support forum.
N
N    http://www.FreeRTOS.org/training - Investing in training allows your team to
N    be as productive as possible as early as possible.  Now you can receive
N    FreeRTOS training directly from Richard Barry, CEO of Real Time Engineers
N    Ltd, and the world's leading authority on the world's leading RTOS.
N
N    http://www.FreeRTOS.org/plus - A selection of FreeRTOS ecosystem products,
N    including FreeRTOS+Trace - an indispensable productivity tool, a DOS
N    compatible FAT file system, and our tiny thread aware UDP/IP stack.
N
N    http://www.FreeRTOS.org/labs - Where new FreeRTOS products go to incubate.
N    Come and try FreeRTOS+TCP, our new open source TCP/IP stack for FreeRTOS.
N
N    http://www.OpenRTOS.com - Real Time Engineers ltd. license FreeRTOS to High
N    Integrity Systems ltd. to sell under the OpenRTOS brand.  Low cost OpenRTOS
N    licenses offer ticketed support, indemnification and commercial middleware.
N
N    http://www.SafeRTOS.com - High Integrity Systems also provide a safety
N    engineered and independently SIL3 certified version for use in safety and
N    mission critical applications that require provable dependability.
N
N    1 tab == 4 spaces!
N*/
N
N/*
N * This is the list implementation used by the scheduler.  While it is tailored
N * heavily for the schedulers needs, it is also available for use by
N * application code.
N *
N * list_ts can only store pointers to list_item_ts.  Each ListItem_t contains a
N * numeric value (xItemValue).  Most of the time the lists are sorted in
N * descending item value order.
N *
N * Lists are created already containing one list item.  The value of this
N * item is the maximum possible that can be stored, it is therefore always at
N * the end of the list and acts as a marker.  The list member pxHead always
N * points to this marker - even though it is at the tail of the list.  This
N * is because the tail contains a wrap back pointer to the true head of
N * the list.
N *
N * In addition to it's value, each list item contains a pointer to the next
N * item in the list (pxNext), a pointer to the list it is in (pxContainer)
N * and a pointer to back to the object that contains it.  These later two
N * pointers are included for efficiency of list manipulation.  There is
N * effectively a two way link between the object containing the list item and
N * the list item itself.
N *
N *
N * \page ListIntroduction List Implementation
N * \ingroup FreeRTOSIntro
N */
N
N#ifndef INC_FREERTOS_H
S	#error FreeRTOS.h must be included before list.h
N#endif
N
N#ifndef LIST_H
N#define LIST_H
N
N/*
N * The list structure members are modified from within interrupts, and therefore
N * by rights should be declared volatile.  However, they are only modified in a
N * functionally atomic way (within critical sections of with the scheduler
N * suspended) and are either passed by reference into a function or indexed via
N * a volatile variable.  Therefore, in all use cases tested so far, the volatile
N * qualifier can be omitted in order to provide a moderate performance
N * improvement without adversely affecting functional behaviour.  The assembly
N * instructions generated by the IAR, ARM and GCC compilers when the respective
N * compiler's options were set for maximum optimisation has been inspected and
N * deemed to be as intended.  That said, as compiler technology advances, and
N * especially if aggressive cross module optimisation is used (a use case that
N * has not been exercised to any great extend) then it is feasible that the
N * volatile qualifier will be needed for correct optimisation.  It is expected
N * that a compiler removing essential code because, without the volatile
N * qualifier on the list structure members and with aggressive cross module
N * optimisation, the compiler deemed the code unnecessary will result in
N * complete and obvious failure of the scheduler.  If this is ever experienced
N * then the volatile qualifier can be inserted in the relevant places within the
N * list structures by simply defining configLIST_VOLATILE to volatile in
N * FreeRTOSConfig.h (as per the example at the bottom of this comment block).
N * If configLIST_VOLATILE is not defined then the preprocessor directives below
N * will simply #define configLIST_VOLATILE away completely.
N *
N * To use volatile list structure members then add the following line to
N * FreeRTOSConfig.h (without the quotes):
N * "#define configLIST_VOLATILE volatile"
N */
N#ifndef configLIST_VOLATILE
N	#define configLIST_VOLATILE
N#endif /* configSUPPORT_CROSS_MODULE_OPTIMISATION */
N
N#ifdef __cplusplus
Sextern "C" {
N#endif
N
N/* Macros that can be used to place known values within the list structures,
Nthen check that the known values do not get corrupted during the execution of
Nthe application.   These may catch the list data structures being overwritten in
Nmemory.  They will not catch data errors caused by incorrect configuration or
Nuse of FreeRTOS.*/
N#if( configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES == 0 )
X#if( 0 == 0 )
N	/* Define the macros to do nothing. */
N	#define listFIRST_LIST_ITEM_INTEGRITY_CHECK_VALUE
N	#define listSECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE
N	#define listFIRST_LIST_INTEGRITY_CHECK_VALUE
N	#define listSECOND_LIST_INTEGRITY_CHECK_VALUE
N	#define listSET_FIRST_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem )
N	#define listSET_SECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem )
N	#define listSET_LIST_INTEGRITY_CHECK_1_VALUE( pxList )
N	#define listSET_LIST_INTEGRITY_CHECK_2_VALUE( pxList )
N	#define listTEST_LIST_ITEM_INTEGRITY( pxItem )
N	#define listTEST_LIST_INTEGRITY( pxList )
N#else
S	/* Define macros that add new members into the list structures. */
S	#define listFIRST_LIST_ITEM_INTEGRITY_CHECK_VALUE				TickType_t xListItemIntegrityValue1;
S	#define listSECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE				TickType_t xListItemIntegrityValue2;
S	#define listFIRST_LIST_INTEGRITY_CHECK_VALUE					TickType_t xListIntegrityValue1;
S	#define listSECOND_LIST_INTEGRITY_CHECK_VALUE					TickType_t xListIntegrityValue2;
S
S	/* Define macros that set the new structure members to known values. */
S	#define listSET_FIRST_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem )		( pxItem )->xListItemIntegrityValue1 = pdINTEGRITY_CHECK_VALUE
S	#define listSET_SECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem )	( pxItem )->xListItemIntegrityValue2 = pdINTEGRITY_CHECK_VALUE
S	#define listSET_LIST_INTEGRITY_CHECK_1_VALUE( pxList )		( pxList )->xListIntegrityValue1 = pdINTEGRITY_CHECK_VALUE
S	#define listSET_LIST_INTEGRITY_CHECK_2_VALUE( pxList )		( pxList )->xListIntegrityValue2 = pdINTEGRITY_CHECK_VALUE
S
S	/* Define macros that will assert if one of the structure members does not
S	contain its expected value. */
S	#define listTEST_LIST_ITEM_INTEGRITY( pxItem )		configASSERT( ( ( pxItem )->xListItemIntegrityValue1 == pdINTEGRITY_CHECK_VALUE ) && ( ( pxItem )->xListItemIntegrityValue2 == pdINTEGRITY_CHECK_VALUE ) )
S	#define listTEST_LIST_INTEGRITY( pxList )			configASSERT( ( ( pxList )->xListIntegrityValue1 == pdINTEGRITY_CHECK_VALUE ) && ( ( pxList )->xListIntegrityValue2 == pdINTEGRITY_CHECK_VALUE ) )
N#endif /* configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES */
N
N
N/*
N * Definition of the only type of object that a list can contain.
N */
Nstruct xLIST_ITEM
N{
N	listFIRST_LIST_ITEM_INTEGRITY_CHECK_VALUE			/*< Set to a known value if configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */
X				 
N	configLIST_VOLATILE TickType_t xItemValue;			/*< The value being listed.  In most cases this is used to sort the list in descending order. */
X	 TickType_t xItemValue;			 
N	struct xLIST_ITEM * configLIST_VOLATILE pxNext;		/*< Pointer to the next ListItem_t in the list. */
X	struct xLIST_ITEM *  pxNext;		 
N	struct xLIST_ITEM * configLIST_VOLATILE pxPrevious;	/*< Pointer to the previous ListItem_t in the list. */
X	struct xLIST_ITEM *  pxPrevious;	 
N	void * pvOwner;										/*< Pointer to the object (normally a TCB) that contains the list item.  There is therefore a two way link between the object containing the list item and the list item itself. */
N	void * configLIST_VOLATILE pvContainer;				/*< Pointer to the list in which this list item is placed (if any). */
X	void *  pvContainer;				 
N	listSECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE			/*< Set to a known value if configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */
X				 
N};
Ntypedef struct xLIST_ITEM ListItem_t;					/* For some reason lint wants this as two separate definitions. */
N
Nstruct xMINI_LIST_ITEM
N{
N	listFIRST_LIST_ITEM_INTEGRITY_CHECK_VALUE			/*< Set to a known value if configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */
X				 
N	configLIST_VOLATILE TickType_t xItemValue;
X	 TickType_t xItemValue;
N	struct xLIST_ITEM * configLIST_VOLATILE pxNext;
X	struct xLIST_ITEM *  pxNext;
N	struct xLIST_ITEM * configLIST_VOLATILE pxPrevious;
X	struct xLIST_ITEM *  pxPrevious;
N};
Ntypedef struct xMINI_LIST_ITEM MiniListItem_t;
N
N/*
N * Definition of the type of queue used by the scheduler.
N */
Ntypedef struct xLIST
N{
N	listFIRST_LIST_INTEGRITY_CHECK_VALUE				/*< Set to a known value if configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */
X					 
N	configLIST_VOLATILE UBaseType_t uxNumberOfItems;
X	 UBaseType_t uxNumberOfItems;
N	ListItem_t * configLIST_VOLATILE pxIndex;			/*< Used to walk through the list.  Points to the last item returned by a call to listGET_OWNER_OF_NEXT_ENTRY (). */
X	ListItem_t *  pxIndex;			 
N	MiniListItem_t xListEnd;							/*< List item that contains the maximum possible item value meaning it is always at the end of the list and is therefore used as a marker. */
N	listSECOND_LIST_INTEGRITY_CHECK_VALUE				/*< Set to a known value if configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */
X					 
N} List_t;
N
N/*
N * Access macro to set the owner of a list item.  The owner of a list item
N * is the object (usually a TCB) that contains the list item.
N *
N * \page listSET_LIST_ITEM_OWNER listSET_LIST_ITEM_OWNER
N * \ingroup LinkedList
N */
N#define listSET_LIST_ITEM_OWNER( pxListItem, pxOwner )		( ( pxListItem )->pvOwner = ( void * ) ( pxOwner ) )
N
N/*
N * Access macro to get the owner of a list item.  The owner of a list item
N * is the object (usually a TCB) that contains the list item.
N *
N * \page listSET_LIST_ITEM_OWNER listSET_LIST_ITEM_OWNER
N * \ingroup LinkedList
N */
N#define listGET_LIST_ITEM_OWNER( pxListItem )	( ( pxListItem )->pvOwner )
N
N/*
N * Access macro to set the value of the list item.  In most cases the value is
N * used to sort the list in descending order.
N *
N * \page listSET_LIST_ITEM_VALUE listSET_LIST_ITEM_VALUE
N * \ingroup LinkedList
N */
N#define listSET_LIST_ITEM_VALUE( pxListItem, xValue )	( ( pxListItem )->xItemValue = ( xValue ) )
N
N/*
N * Access macro to retrieve the value of the list item.  The value can
N * represent anything - for example the priority of a task, or the time at
N * which a task should be unblocked.
N *
N * \page listGET_LIST_ITEM_VALUE listGET_LIST_ITEM_VALUE
N * \ingroup LinkedList
N */
N#define listGET_LIST_ITEM_VALUE( pxListItem )	( ( pxListItem )->xItemValue )
N
N/*
N * Access macro to retrieve the value of the list item at the head of a given
N * list.
N *
N * \page listGET_LIST_ITEM_VALUE listGET_LIST_ITEM_VALUE
N * \ingroup LinkedList
N */
N#define listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxList )	( ( ( pxList )->xListEnd ).pxNext->xItemValue )
N
N/*
N * Return the list item at the head of the list.
N *
N * \page listGET_HEAD_ENTRY listGET_HEAD_ENTRY
N * \ingroup LinkedList
N */
N#define listGET_HEAD_ENTRY( pxList )	( ( ( pxList )->xListEnd ).pxNext )
N
N/*
N * Return the list item at the head of the list.
N *
N * \page listGET_NEXT listGET_NEXT
N * \ingroup LinkedList
N */
N#define listGET_NEXT( pxListItem )	( ( pxListItem )->pxNext )
N
N/*
N * Return the list item that marks the end of the list
N *
N * \page listGET_END_MARKER listGET_END_MARKER
N * \ingroup LinkedList
N */
N#define listGET_END_MARKER( pxList )	( ( ListItem_t const * ) ( &( ( pxList )->xListEnd ) ) )
N
N/*
N * Access macro to determine if a list contains any items.  The macro will
N * only have the value true if the list is empty.
N *
N * \page listLIST_IS_EMPTY listLIST_IS_EMPTY
N * \ingroup LinkedList
N */
N#define listLIST_IS_EMPTY( pxList )	( ( BaseType_t ) ( ( pxList )->uxNumberOfItems == ( UBaseType_t ) 0 ) )
N
N/*
N * Access macro to return the number of items in the list.
N */
N#define listCURRENT_LIST_LENGTH( pxList )	( ( pxList )->uxNumberOfItems )
N
N/*
N * Access function to obtain the owner of the next entry in a list.
N *
N * The list member pxIndex is used to walk through a list.  Calling
N * listGET_OWNER_OF_NEXT_ENTRY increments pxIndex to the next item in the list
N * and returns that entry's pxOwner parameter.  Using multiple calls to this
N * function it is therefore possible to move through every item contained in
N * a list.
N *
N * The pxOwner parameter of a list item is a pointer to the object that owns
N * the list item.  In the scheduler this is normally a task control block.
N * The pxOwner parameter effectively creates a two way link between the list
N * item and its owner.
N *
N * @param pxTCB pxTCB is set to the address of the owner of the next list item.
N * @param pxList The list from which the next item owner is to be returned.
N *
N * \page listGET_OWNER_OF_NEXT_ENTRY listGET_OWNER_OF_NEXT_ENTRY
N * \ingroup LinkedList
N */
N#define listGET_OWNER_OF_NEXT_ENTRY( pxTCB, pxList )										\
N{																							\
NList_t * const pxConstList = ( pxList );													\
N	/* Increment the index to the next item and return the item, ensuring */				\
N	/* we don't return the marker used at the end of the list.  */							\
N	( pxConstList )->pxIndex = ( pxConstList )->pxIndex->pxNext;							\
N	if( ( void * ) ( pxConstList )->pxIndex == ( void * ) &( ( pxConstList )->xListEnd ) )	\
N	{																						\
N		( pxConstList )->pxIndex = ( pxConstList )->pxIndex->pxNext;						\
N	}																						\
N	( pxTCB ) = ( pxConstList )->pxIndex->pvOwner;											\
N}
X#define listGET_OWNER_OF_NEXT_ENTRY( pxTCB, pxList )										{																							List_t * const pxConstList = ( pxList );														 					 								( pxConstList )->pxIndex = ( pxConstList )->pxIndex->pxNext;								if( ( void * ) ( pxConstList )->pxIndex == ( void * ) &( ( pxConstList )->xListEnd ) )		{																								( pxConstList )->pxIndex = ( pxConstList )->pxIndex->pxNext;							}																							( pxTCB ) = ( pxConstList )->pxIndex->pvOwner;											}
N
N
N/*
N * Access function to obtain the owner of the first entry in a list.  Lists
N * are normally sorted in ascending item value order.
N *
N * This function returns the pxOwner member of the first item in the list.
N * The pxOwner parameter of a list item is a pointer to the object that owns
N * the list item.  In the scheduler this is normally a task control block.
N * The pxOwner parameter effectively creates a two way link between the list
N * item and its owner.
N *
N * @param pxList The list from which the owner of the head item is to be
N * returned.
N *
N * \page listGET_OWNER_OF_HEAD_ENTRY listGET_OWNER_OF_HEAD_ENTRY
N * \ingroup LinkedList
N */
N#define listGET_OWNER_OF_HEAD_ENTRY( pxList )  ( (&( ( pxList )->xListEnd ))->pxNext->pvOwner )
N
N/*
N * Check to see if a list item is within a list.  The list item maintains a
N * "container" pointer that points to the list it is in.  All this macro does
N * is check to see if the container and the list match.
N *
N * @param pxList The list we want to know if the list item is within.
N * @param pxListItem The list item we want to know if is in the list.
N * @return pdTRUE if the list item is in the list, otherwise pdFALSE.
N */
N#define listIS_CONTAINED_WITHIN( pxList, pxListItem ) ( ( BaseType_t ) ( ( pxListItem )->pvContainer == ( void * ) ( pxList ) ) )
N
N/*
N * Return the list a list item is contained within (referenced from).
N *
N * @param pxListItem The list item being queried.
N * @return A pointer to the List_t object that references the pxListItem
N */
N#define listLIST_ITEM_CONTAINER( pxListItem ) ( ( pxListItem )->pvContainer )
N
N/*
N * This provides a crude means of knowing if a list has been initialised, as
N * pxList->xListEnd.xItemValue is set to portMAX_DELAY by the vListInitialise()
N * function.
N */
N#define listLIST_IS_INITIALISED( pxList ) ( ( pxList )->xListEnd.xItemValue == portMAX_DELAY )
N
N/*
N * Must be called before a list is used!  This initialises all the members
N * of the list structure and inserts the xListEnd item into the list as a
N * marker to the back of the list.
N *
N * @param pxList Pointer to the list being initialised.
N *
N * \page vListInitialise vListInitialise
N * \ingroup LinkedList
N */
Nvoid vListInitialise( List_t * const pxList ) PRIVILEGED_FUNCTION;
Xvoid vListInitialise( List_t * const pxList ) ;
N
N/*
N * Must be called before a list item is used.  This sets the list container to
N * null so the item does not think that it is already contained in a list.
N *
N * @param pxItem Pointer to the list item being initialised.
N *
N * \page vListInitialiseItem vListInitialiseItem
N * \ingroup LinkedList
N */
Nvoid vListInitialiseItem( ListItem_t * const pxItem ) PRIVILEGED_FUNCTION;
Xvoid vListInitialiseItem( ListItem_t * const pxItem ) ;
N
N/*
N * Insert a list item into a list.  The item will be inserted into the list in
N * a position determined by its item value (descending item value order).
N *
N * @param pxList The list into which the item is to be inserted.
N *
N * @param pxNewListItem The item that is to be placed in the list.
N *
N * \page vListInsert vListInsert
N * \ingroup LinkedList
N */
Nvoid vListInsert( List_t * const pxList, ListItem_t * const pxNewListItem ) PRIVILEGED_FUNCTION;
Xvoid vListInsert( List_t * const pxList, ListItem_t * const pxNewListItem ) ;
N
N/*
N * Insert a list item into a list.  The item will be inserted in a position
N * such that it will be the last item within the list returned by multiple
N * calls to listGET_OWNER_OF_NEXT_ENTRY.
N *
N * The list member pxIndex is used to walk through a list.  Calling
N * listGET_OWNER_OF_NEXT_ENTRY increments pxIndex to the next item in the list.
N * Placing an item in a list using vListInsertEnd effectively places the item
N * in the list position pointed to by pxIndex.  This means that every other
N * item within the list will be returned by listGET_OWNER_OF_NEXT_ENTRY before
N * the pxIndex parameter again points to the item being inserted.
N *
N * @param pxList The list into which the item is to be inserted.
N *
N * @param pxNewListItem The list item to be inserted into the list.
N *
N * \page vListInsertEnd vListInsertEnd
N * \ingroup LinkedList
N */
Nvoid vListInsertEnd( List_t * const pxList, ListItem_t * const pxNewListItem ) PRIVILEGED_FUNCTION;
Xvoid vListInsertEnd( List_t * const pxList, ListItem_t * const pxNewListItem ) ;
N
N/*
N * Remove an item from a list.  The list item has a pointer to the list that
N * it is in, so only the list item need be passed into the function.
N *
N * @param uxListRemove The item to be removed.  The item will remove itself from
N * the list pointed to by it's pxContainer parameter.
N *
N * @return The number of items that remain in the list after the list item has
N * been removed.
N *
N * \page uxListRemove uxListRemove
N * \ingroup LinkedList
N */
NUBaseType_t uxListRemove( ListItem_t * const pxItemToRemove ) PRIVILEGED_FUNCTION;
XUBaseType_t uxListRemove( ListItem_t * const pxItemToRemove ) ;
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif
N
L 79 "..\..\Freee-RTOS\include\task.h" 2
N
N#ifdef __cplusplus
Sextern "C" {
N#endif
N
N/*-----------------------------------------------------------
N * MACROS AND DEFINITIONS
N *----------------------------------------------------------*/
N
N#define tskKERNEL_VERSION_NUMBER "V9.0.0"
N#define tskKERNEL_VERSION_MAJOR 9
N#define tskKERNEL_VERSION_MINOR 0
N#define tskKERNEL_VERSION_BUILD 0
N
N/**
N * task. h
N *
N * Type by which tasks are referenced.  For example, a call to xTaskCreate
N * returns (via a pointer parameter) an TaskHandle_t variable that can then
N * be used as a parameter to vTaskDelete to delete the task.
N *
N * \defgroup TaskHandle_t TaskHandle_t
N * \ingroup Tasks
N */
Ntypedef void * TaskHandle_t;
N
N/*
N * Defines the prototype to which the application task hook function must
N * conform.
N */
Ntypedef BaseType_t (*TaskHookFunction_t)( void * );
N
N/* Task states returned by eTaskGetState. */
Ntypedef enum
N{
N	eRunning = 0,	/* A task is querying the state of itself, so must be running. */
N	eReady,			/* The task being queried is in a read or pending ready list. */
N	eBlocked,		/* The task being queried is in the Blocked state. */
N	eSuspended,		/* The task being queried is in the Suspended state, or is in the Blocked state with an infinite time out. */
N	eDeleted,		/* The task being queried has been deleted, but its TCB has not yet been freed. */
N	eInvalid			/* Used as an 'invalid state' value. */
N} eTaskState;
N
N/* Actions that can be performed when vTaskNotify() is called. */
Ntypedef enum
N{
N	eNoAction = 0,				/* Notify the task without updating its notify value. */
N	eSetBits,					/* Set bits in the task's notification value. */
N	eIncrement,					/* Increment the task's notification value. */
N	eSetValueWithOverwrite,		/* Set the task's notification value to a specific value even if the previous value has not yet been read by the task. */
N	eSetValueWithoutOverwrite	/* Set the task's notification value if the previous value has been read by the task. */
N} eNotifyAction;
N
N/*
N * Used internally only.
N */
Ntypedef struct xTIME_OUT
N{
N	BaseType_t xOverflowCount;
N	TickType_t xTimeOnEntering;
N} TimeOut_t;
N
N/*
N * Defines the memory ranges allocated to the task when an MPU is used.
N */
Ntypedef struct xMEMORY_REGION
N{
N	void *pvBaseAddress;
N	uint32_t ulLengthInBytes;
N	uint32_t ulParameters;
N} MemoryRegion_t;
N
N/*
N * Parameters required to create an MPU protected task.
N */
Ntypedef struct xTASK_PARAMETERS
N{
N	TaskFunction_t pvTaskCode;
N	const char * const pcName;	/*lint !e971 Unqualified char types are allowed for strings and single characters only. */
N	uint16_t usStackDepth;
N	void *pvParameters;
N	UBaseType_t uxPriority;
N	StackType_t *puxStackBuffer;
N	MemoryRegion_t xRegions[ portNUM_CONFIGURABLE_REGIONS ];
X	MemoryRegion_t xRegions[ 1 ];
N} TaskParameters_t;
N
N/* Used with the uxTaskGetSystemState() function to return the state of each task
Nin the system. */
Ntypedef struct xTASK_STATUS
N{
N	TaskHandle_t xHandle;			/* The handle of the task to which the rest of the information in the structure relates. */
N	const char *pcTaskName;			/* A pointer to the task's name.  This value will be invalid if the task was deleted since the structure was populated! */ /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
N	UBaseType_t xTaskNumber;		/* A number unique to the task. */
N	eTaskState eCurrentState;		/* The state in which the task existed when the structure was populated. */
N	UBaseType_t uxCurrentPriority;	/* The priority at which the task was running (may be inherited) when the structure was populated. */
N	UBaseType_t uxBasePriority;		/* The priority to which the task will return if the task's current priority has been inherited to avoid unbounded priority inversion when obtaining a mutex.  Only valid if configUSE_MUTEXES is defined as 1 in FreeRTOSConfig.h. */
N	uint32_t ulRunTimeCounter;		/* The total run time allocated to the task so far, as defined by the run time stats clock.  See http://www.freertos.org/rtos-run-time-stats.html.  Only valid when configGENERATE_RUN_TIME_STATS is defined as 1 in FreeRTOSConfig.h. */
N	StackType_t *pxStackBase;		/* Points to the lowest address of the task's stack area. */
N	uint16_t usStackHighWaterMark;	/* The minimum amount of stack space that has remained for the task since the task was created.  The closer this value is to zero the closer the task has come to overflowing its stack. */
N} TaskStatus_t;
N
N/* Possible return values for eTaskConfirmSleepModeStatus(). */
Ntypedef enum
N{
N	eAbortSleep = 0,		/* A task has been made ready or a context switch pended since portSUPPORESS_TICKS_AND_SLEEP() was called - abort entering a sleep mode. */
N	eStandardSleep,			/* Enter a sleep mode that will not last any longer than the expected idle time. */
N	eNoTasksWaitingTimeout	/* No tasks are waiting for a timeout so it is safe to enter a sleep mode that can only be exited by an external interrupt. */
N} eSleepModeStatus;
N
N/**
N * Defines the priority used by the idle task.  This must not be modified.
N *
N * \ingroup TaskUtils
N */
N#define tskIDLE_PRIORITY			( ( UBaseType_t ) 0U )
N
N/**
N * task. h
N *
N * Macro for forcing a context switch.
N *
N * \defgroup taskYIELD taskYIELD
N * \ingroup SchedulerControl
N */
N#define taskYIELD()					portYIELD()
N
N/**
N * task. h
N *
N * Macro to mark the start of a critical code region.  Preemptive context
N * switches cannot occur when in a critical region.
N *
N * NOTE: This may alter the stack (depending on the portable implementation)
N * so must be used with care!
N *
N * \defgroup taskENTER_CRITICAL taskENTER_CRITICAL
N * \ingroup SchedulerControl
N */
N#define taskENTER_CRITICAL()		portENTER_CRITICAL()
N#define taskENTER_CRITICAL_FROM_ISR() portSET_INTERRUPT_MASK_FROM_ISR()
N
N/**
N * task. h
N *
N * Macro to mark the end of a critical code region.  Preemptive context
N * switches cannot occur when in a critical region.
N *
N * NOTE: This may alter the stack (depending on the portable implementation)
N * so must be used with care!
N *
N * \defgroup taskEXIT_CRITICAL taskEXIT_CRITICAL
N * \ingroup SchedulerControl
N */
N#define taskEXIT_CRITICAL()			portEXIT_CRITICAL()
N#define taskEXIT_CRITICAL_FROM_ISR( x ) portCLEAR_INTERRUPT_MASK_FROM_ISR( x )
N/**
N * task. h
N *
N * Macro to disable all maskable interrupts.
N *
N * \defgroup taskDISABLE_INTERRUPTS taskDISABLE_INTERRUPTS
N * \ingroup SchedulerControl
N */
N#define taskDISABLE_INTERRUPTS()	portDISABLE_INTERRUPTS()
N
N/**
N * task. h
N *
N * Macro to enable microcontroller interrupts.
N *
N * \defgroup taskENABLE_INTERRUPTS taskENABLE_INTERRUPTS
N * \ingroup SchedulerControl
N */
N#define taskENABLE_INTERRUPTS()		portENABLE_INTERRUPTS()
N
N/* Definitions returned by xTaskGetSchedulerState().  taskSCHEDULER_SUSPENDED is
N0 to generate more optimal code when configASSERT() is defined as the constant
Nis used in assert() statements. */
N#define taskSCHEDULER_SUSPENDED		( ( BaseType_t ) 0 )
N#define taskSCHEDULER_NOT_STARTED	( ( BaseType_t ) 1 )
N#define taskSCHEDULER_RUNNING		( ( BaseType_t ) 2 )
N
N
N/*-----------------------------------------------------------
N * TASK CREATION API
N *----------------------------------------------------------*/
N
N/**
N * task. h
N *<pre>
N BaseType_t xTaskCreate(
N							  TaskFunction_t pvTaskCode,
N							  const char * const pcName,
N							  uint16_t usStackDepth,
N							  void *pvParameters,
N							  UBaseType_t uxPriority,
N							  TaskHandle_t *pvCreatedTask
N						  );</pre>
N *
N * Create a new task and add it to the list of tasks that are ready to run.
N *
N * Internally, within the FreeRTOS implementation, tasks use two blocks of
N * memory.  The first block is used to hold the task's data structures.  The
N * second block is used by the task as its stack.  If a task is created using
N * xTaskCreate() then both blocks of memory are automatically dynamically
N * allocated inside the xTaskCreate() function.  (see
N * http://www.freertos.org/a00111.html).  If a task is created using
N * xTaskCreateStatic() then the application writer must provide the required
N * memory.  xTaskCreateStatic() therefore allows a task to be created without
N * using any dynamic memory allocation.
N *
N * See xTaskCreateStatic() for a version that does not use any dynamic memory
N * allocation.
N *
N * xTaskCreate() can only be used to create a task that has unrestricted
N * access to the entire microcontroller memory map.  Systems that include MPU
N * support can alternatively create an MPU constrained task using
N * xTaskCreateRestricted().
N *
N * @param pvTaskCode Pointer to the task entry function.  Tasks
N * must be implemented to never return (i.e. continuous loop).
N *
N * @param pcName A descriptive name for the task.  This is mainly used to
N * facilitate debugging.  Max length defined by configMAX_TASK_NAME_LEN - default
N * is 16.
N *
N * @param usStackDepth The size of the task stack specified as the number of
N * variables the stack can hold - not the number of bytes.  For example, if
N * the stack is 16 bits wide and usStackDepth is defined as 100, 200 bytes
N * will be allocated for stack storage.
N *
N * @param pvParameters Pointer that will be used as the parameter for the task
N * being created.
N *
N * @param uxPriority The priority at which the task should run.  Systems that
N * include MPU support can optionally create tasks in a privileged (system)
N * mode by setting bit portPRIVILEGE_BIT of the priority parameter.  For
N * example, to create a privileged task at priority 2 the uxPriority parameter
N * should be set to ( 2 | portPRIVILEGE_BIT ).
N *
N * @param pvCreatedTask Used to pass back a handle by which the created task
N * can be referenced.
N *
N * @return pdPASS if the task was successfully created and added to a ready
N * list, otherwise an error code defined in the file projdefs.h
N *
N * Example usage:
N   <pre>
N // Task to be created.
N void vTaskCode( void * pvParameters )
N {
N	 for( ;; )
N	 {
N		 // Task code goes here.
N	 }
N }
N
N // Function that creates a task.
N void vOtherFunction( void )
N {
N static uint8_t ucParameterToPass;
N TaskHandle_t xHandle = NULL;
N
N	 // Create the task, storing the handle.  Note that the passed parameter ucParameterToPass
N	 // must exist for the lifetime of the task, so in this case is declared static.  If it was just an
N	 // an automatic stack variable it might no longer exist, or at least have been corrupted, by the time
N	 // the new task attempts to access it.
N	 xTaskCreate( vTaskCode, "NAME", STACK_SIZE, &ucParameterToPass, tskIDLE_PRIORITY, &xHandle );
N     configASSERT( xHandle );
N
N	 // Use the handle to delete the task.
N     if( xHandle != NULL )
N     {
N	     vTaskDelete( xHandle );
N     }
N }
N   </pre>
N * \defgroup xTaskCreate xTaskCreate
N * \ingroup Tasks
N */
N#if( configSUPPORT_DYNAMIC_ALLOCATION == 1 )
X#if( 1 == 1 )
N	BaseType_t xTaskCreate(	TaskFunction_t pxTaskCode,
N							const char * const pcName,
N							const uint16_t usStackDepth,
N							void * const pvParameters,
N							UBaseType_t uxPriority,
N							TaskHandle_t * const pxCreatedTask ) PRIVILEGED_FUNCTION; /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
X							TaskHandle_t * const pxCreatedTask ) ;  
N#endif
N
N/**
N * task. h
N *<pre>
N TaskHandle_t xTaskCreateStatic( TaskFunction_t pvTaskCode,
N								 const char * const pcName,
N								 uint32_t ulStackDepth,
N								 void *pvParameters,
N								 UBaseType_t uxPriority,
N								 StackType_t *pxStackBuffer,
N								 StaticTask_t *pxTaskBuffer );</pre>
N *
N * Create a new task and add it to the list of tasks that are ready to run.
N *
N * Internally, within the FreeRTOS implementation, tasks use two blocks of
N * memory.  The first block is used to hold the task's data structures.  The
N * second block is used by the task as its stack.  If a task is created using
N * xTaskCreate() then both blocks of memory are automatically dynamically
N * allocated inside the xTaskCreate() function.  (see
N * http://www.freertos.org/a00111.html).  If a task is created using
N * xTaskCreateStatic() then the application writer must provide the required
N * memory.  xTaskCreateStatic() therefore allows a task to be created without
N * using any dynamic memory allocation.
N *
N * @param pvTaskCode Pointer to the task entry function.  Tasks
N * must be implemented to never return (i.e. continuous loop).
N *
N * @param pcName A descriptive name for the task.  This is mainly used to
N * facilitate debugging.  The maximum length of the string is defined by
N * configMAX_TASK_NAME_LEN in FreeRTOSConfig.h.
N *
N * @param ulStackDepth The size of the task stack specified as the number of
N * variables the stack can hold - not the number of bytes.  For example, if
N * the stack is 32-bits wide and ulStackDepth is defined as 100 then 400 bytes
N * will be allocated for stack storage.
N *
N * @param pvParameters Pointer that will be used as the parameter for the task
N * being created.
N *
N * @param uxPriority The priority at which the task will run.
N *
N * @param pxStackBuffer Must point to a StackType_t array that has at least
N * ulStackDepth indexes - the array will then be used as the task's stack,
N * removing the need for the stack to be allocated dynamically.
N *
N * @param pxTaskBuffer Must point to a variable of type StaticTask_t, which will
N * then be used to hold the task's data structures, removing the need for the
N * memory to be allocated dynamically.
N *
N * @return If neither pxStackBuffer or pxTaskBuffer are NULL, then the task will
N * be created and pdPASS is returned.  If either pxStackBuffer or pxTaskBuffer
N * are NULL then the task will not be created and
N * errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY is returned.
N *
N * Example usage:
N   <pre>
N
N    // Dimensions the buffer that the task being created will use as its stack.
N    // NOTE:  This is the number of words the stack will hold, not the number of
N    // bytes.  For example, if each stack item is 32-bits, and this is set to 100,
N    // then 400 bytes (100 * 32-bits) will be allocated.
N    #define STACK_SIZE 200
N
N    // Structure that will hold the TCB of the task being created.
N    StaticTask_t xTaskBuffer;
N
N    // Buffer that the task being created will use as its stack.  Note this is
N    // an array of StackType_t variables.  The size of StackType_t is dependent on
N    // the RTOS port.
N    StackType_t xStack[ STACK_SIZE ];
N
N    // Function that implements the task being created.
N    void vTaskCode( void * pvParameters )
N    {
N        // The parameter value is expected to be 1 as 1 is passed in the
N        // pvParameters value in the call to xTaskCreateStatic().
N        configASSERT( ( uint32_t ) pvParameters == 1UL );
N
N        for( ;; )
N        {
N            // Task code goes here.
N        }
N    }
N
N    // Function that creates a task.
N    void vOtherFunction( void )
N    {
N        TaskHandle_t xHandle = NULL;
N
N        // Create the task without using any dynamic memory allocation.
N        xHandle = xTaskCreateStatic(
N                      vTaskCode,       // Function that implements the task.
N                      "NAME",          // Text name for the task.
N                      STACK_SIZE,      // Stack size in words, not bytes.
N                      ( void * ) 1,    // Parameter passed into the task.
N                      tskIDLE_PRIORITY,// Priority at which the task is created.
N                      xStack,          // Array to use as the task's stack.
N                      &xTaskBuffer );  // Variable to hold the task's data structure.
N
N        // puxStackBuffer and pxTaskBuffer were not NULL, so the task will have
N        // been created, and xHandle will be the task's handle.  Use the handle
N        // to suspend the task.
N        vTaskSuspend( xHandle );
N    }
N   </pre>
N * \defgroup xTaskCreateStatic xTaskCreateStatic
N * \ingroup Tasks
N */
N
N#if( configSUPPORT_STATIC_ALLOCATION == 1 )
X#if( 0 == 1 )
S	TaskHandle_t xTaskCreateStatic(	TaskFunction_t pxTaskCode,
S									const char * const pcName,
S									const uint32_t ulStackDepth,
S									void * const pvParameters,
S									UBaseType_t uxPriority,
S									StackType_t * const puxStackBuffer,
S									StaticTask_t * const pxTaskBuffer ) PRIVILEGED_FUNCTION; /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
N#endif /* configSUPPORT_STATIC_ALLOCATION */
N
N/**
N * task. h
N *<pre>
N BaseType_t xTaskCreateRestricted( TaskParameters_t *pxTaskDefinition, TaskHandle_t *pxCreatedTask );</pre>
N *
N * xTaskCreateRestricted() should only be used in systems that include an MPU
N * implementation.
N *
N * Create a new task and add it to the list of tasks that are ready to run.
N * The function parameters define the memory regions and associated access
N * permissions allocated to the task.
N *
N * @param pxTaskDefinition Pointer to a structure that contains a member
N * for each of the normal xTaskCreate() parameters (see the xTaskCreate() API
N * documentation) plus an optional stack buffer and the memory region
N * definitions.
N *
N * @param pxCreatedTask Used to pass back a handle by which the created task
N * can be referenced.
N *
N * @return pdPASS if the task was successfully created and added to a ready
N * list, otherwise an error code defined in the file projdefs.h
N *
N * Example usage:
N   <pre>
N// Create an TaskParameters_t structure that defines the task to be created.
Nstatic const TaskParameters_t xCheckTaskParameters =
N{
N	vATask,		// pvTaskCode - the function that implements the task.
N	"ATask",	// pcName - just a text name for the task to assist debugging.
N	100,		// usStackDepth	- the stack size DEFINED IN WORDS.
N	NULL,		// pvParameters - passed into the task function as the function parameters.
N	( 1UL | portPRIVILEGE_BIT ),// uxPriority - task priority, set the portPRIVILEGE_BIT if the task should run in a privileged state.
N	cStackBuffer,// puxStackBuffer - the buffer to be used as the task stack.
N
N	// xRegions - Allocate up to three separate memory regions for access by
N	// the task, with appropriate access permissions.  Different processors have
N	// different memory alignment requirements - refer to the FreeRTOS documentation
N	// for full information.
N	{
N		// Base address					Length	Parameters
N        { cReadWriteArray,				32,		portMPU_REGION_READ_WRITE },
N        { cReadOnlyArray,				32,		portMPU_REGION_READ_ONLY },
N        { cPrivilegedOnlyAccessArray,	128,	portMPU_REGION_PRIVILEGED_READ_WRITE }
N	}
N};
N
Nint main( void )
N{
NTaskHandle_t xHandle;
N
N	// Create a task from the const structure defined above.  The task handle
N	// is requested (the second parameter is not NULL) but in this case just for
N	// demonstration purposes as its not actually used.
N	xTaskCreateRestricted( &xRegTest1Parameters, &xHandle );
N
N	// Start the scheduler.
N	vTaskStartScheduler();
N
N	// Will only get here if there was insufficient memory to create the idle
N	// and/or timer task.
N	for( ;; );
N}
N   </pre>
N * \defgroup xTaskCreateRestricted xTaskCreateRestricted
N * \ingroup Tasks
N */
N#if( portUSING_MPU_WRAPPERS == 1 )
X#if( 0 == 1 )
S	BaseType_t xTaskCreateRestricted( const TaskParameters_t * const pxTaskDefinition, TaskHandle_t *pxCreatedTask ) PRIVILEGED_FUNCTION;
N#endif
N
N/**
N * task. h
N *<pre>
N void vTaskAllocateMPURegions( TaskHandle_t xTask, const MemoryRegion_t * const pxRegions );</pre>
N *
N * Memory regions are assigned to a restricted task when the task is created by
N * a call to xTaskCreateRestricted().  These regions can be redefined using
N * vTaskAllocateMPURegions().
N *
N * @param xTask The handle of the task being updated.
N *
N * @param xRegions A pointer to an MemoryRegion_t structure that contains the
N * new memory region definitions.
N *
N * Example usage:
N   <pre>
N// Define an array of MemoryRegion_t structures that configures an MPU region
N// allowing read/write access for 1024 bytes starting at the beginning of the
N// ucOneKByte array.  The other two of the maximum 3 definable regions are
N// unused so set to zero.
Nstatic const MemoryRegion_t xAltRegions[ portNUM_CONFIGURABLE_REGIONS ] =
N{
N	// Base address		Length		Parameters
N	{ ucOneKByte,		1024,		portMPU_REGION_READ_WRITE },
N	{ 0,				0,			0 },
N	{ 0,				0,			0 }
N};
N
Nvoid vATask( void *pvParameters )
N{
N	// This task was created such that it has access to certain regions of
N	// memory as defined by the MPU configuration.  At some point it is
N	// desired that these MPU regions are replaced with that defined in the
N	// xAltRegions const struct above.  Use a call to vTaskAllocateMPURegions()
N	// for this purpose.  NULL is used as the task handle to indicate that this
N	// function should modify the MPU regions of the calling task.
N	vTaskAllocateMPURegions( NULL, xAltRegions );
N
N	// Now the task can continue its function, but from this point on can only
N	// access its stack and the ucOneKByte array (unless any other statically
N	// defined or shared regions have been declared elsewhere).
N}
N   </pre>
N * \defgroup xTaskCreateRestricted xTaskCreateRestricted
N * \ingroup Tasks
N */
Nvoid vTaskAllocateMPURegions( TaskHandle_t xTask, const MemoryRegion_t * const pxRegions ) PRIVILEGED_FUNCTION;
Xvoid vTaskAllocateMPURegions( TaskHandle_t xTask, const MemoryRegion_t * const pxRegions ) ;
N
N/**
N * task. h
N * <pre>void vTaskDelete( TaskHandle_t xTask );</pre>
N *
N * INCLUDE_vTaskDelete must be defined as 1 for this function to be available.
N * See the configuration section for more information.
N *
N * Remove a task from the RTOS real time kernel's management.  The task being
N * deleted will be removed from all ready, blocked, suspended and event lists.
N *
N * NOTE:  The idle task is responsible for freeing the kernel allocated
N * memory from tasks that have been deleted.  It is therefore important that
N * the idle task is not starved of microcontroller processing time if your
N * application makes any calls to vTaskDelete ().  Memory allocated by the
N * task code is not automatically freed, and should be freed before the task
N * is deleted.
N *
N * See the demo application file death.c for sample code that utilises
N * vTaskDelete ().
N *
N * @param xTask The handle of the task to be deleted.  Passing NULL will
N * cause the calling task to be deleted.
N *
N * Example usage:
N   <pre>
N void vOtherFunction( void )
N {
N TaskHandle_t xHandle;
N
N	 // Create the task, storing the handle.
N	 xTaskCreate( vTaskCode, "NAME", STACK_SIZE, NULL, tskIDLE_PRIORITY, &xHandle );
N
N	 // Use the handle to delete the task.
N	 vTaskDelete( xHandle );
N }
N   </pre>
N * \defgroup vTaskDelete vTaskDelete
N * \ingroup Tasks
N */
Nvoid vTaskDelete( TaskHandle_t xTaskToDelete ) PRIVILEGED_FUNCTION;
Xvoid vTaskDelete( TaskHandle_t xTaskToDelete ) ;
N
N/*-----------------------------------------------------------
N * TASK CONTROL API
N *----------------------------------------------------------*/
N
N/**
N * task. h
N * <pre>void vTaskDelay( const TickType_t xTicksToDelay );</pre>
N *
N * Delay a task for a given number of ticks.  The actual time that the
N * task remains blocked depends on the tick rate.  The constant
N * portTICK_PERIOD_MS can be used to calculate real time from the tick
N * rate - with the resolution of one tick period.
N *
N * INCLUDE_vTaskDelay must be defined as 1 for this function to be available.
N * See the configuration section for more information.
N *
N *
N * vTaskDelay() specifies a time at which the task wishes to unblock relative to
N * the time at which vTaskDelay() is called.  For example, specifying a block
N * period of 100 ticks will cause the task to unblock 100 ticks after
N * vTaskDelay() is called.  vTaskDelay() does not therefore provide a good method
N * of controlling the frequency of a periodic task as the path taken through the
N * code, as well as other task and interrupt activity, will effect the frequency
N * at which vTaskDelay() gets called and therefore the time at which the task
N * next executes.  See vTaskDelayUntil() for an alternative API function designed
N * to facilitate fixed frequency execution.  It does this by specifying an
N * absolute time (rather than a relative time) at which the calling task should
N * unblock.
N *
N * @param xTicksToDelay The amount of time, in tick periods, that
N * the calling task should block.
N *
N * Example usage:
N
N void vTaskFunction( void * pvParameters )
N {
N // Block for 500ms.
N const TickType_t xDelay = 500 / portTICK_PERIOD_MS;
N
N	 for( ;; )
N	 {
N		 // Simply toggle the LED every 500ms, blocking between each toggle.
N		 vToggleLED();
N		 vTaskDelay( xDelay );
N	 }
N }
N
N * \defgroup vTaskDelay vTaskDelay
N * \ingroup TaskCtrl
N */
Nvoid vTaskDelay( const TickType_t xTicksToDelay ) PRIVILEGED_FUNCTION;
Xvoid vTaskDelay( const TickType_t xTicksToDelay ) ;
N
N/**
N * task. h
N * <pre>void vTaskDelayUntil( TickType_t *pxPreviousWakeTime, const TickType_t xTimeIncrement );</pre>
N *
N * INCLUDE_vTaskDelayUntil must be defined as 1 for this function to be available.
N * See the configuration section for more information.
N *
N * Delay a task until a specified time.  This function can be used by periodic
N * tasks to ensure a constant execution frequency.
N *
N * This function differs from vTaskDelay () in one important aspect:  vTaskDelay () will
N * cause a task to block for the specified number of ticks from the time vTaskDelay () is
N * called.  It is therefore difficult to use vTaskDelay () by itself to generate a fixed
N * execution frequency as the time between a task starting to execute and that task
N * calling vTaskDelay () may not be fixed [the task may take a different path though the
N * code between calls, or may get interrupted or preempted a different number of times
N * each time it executes].
N *
N * Whereas vTaskDelay () specifies a wake time relative to the time at which the function
N * is called, vTaskDelayUntil () specifies the absolute (exact) time at which it wishes to
N * unblock.
N *
N * The constant portTICK_PERIOD_MS can be used to calculate real time from the tick
N * rate - with the resolution of one tick period.
N *
N * @param pxPreviousWakeTime Pointer to a variable that holds the time at which the
N * task was last unblocked.  The variable must be initialised with the current time
N * prior to its first use (see the example below).  Following this the variable is
N * automatically updated within vTaskDelayUntil ().
N *
N * @param xTimeIncrement The cycle time period.  The task will be unblocked at
N * time *pxPreviousWakeTime + xTimeIncrement.  Calling vTaskDelayUntil with the
N * same xTimeIncrement parameter value will cause the task to execute with
N * a fixed interface period.
N *
N * Example usage:
N   <pre>
N // Perform an action every 10 ticks.
N void vTaskFunction( void * pvParameters )
N {
N TickType_t xLastWakeTime;
N const TickType_t xFrequency = 10;
N
N	 // Initialise the xLastWakeTime variable with the current time.
N	 xLastWakeTime = xTaskGetTickCount ();
N	 for( ;; )
N	 {
N		 // Wait for the next cycle.
N		 vTaskDelayUntil( &xLastWakeTime, xFrequency );
N
N		 // Perform action here.
N	 }
N }
N   </pre>
N * \defgroup vTaskDelayUntil vTaskDelayUntil
N * \ingroup TaskCtrl
N */
Nvoid vTaskDelayUntil( TickType_t * const pxPreviousWakeTime, const TickType_t xTimeIncrement ) PRIVILEGED_FUNCTION;
Xvoid vTaskDelayUntil( TickType_t * const pxPreviousWakeTime, const TickType_t xTimeIncrement ) ;
N
N/**
N * task. h
N * <pre>BaseType_t xTaskAbortDelay( TaskHandle_t xTask );</pre>
N *
N * INCLUDE_xTaskAbortDelay must be defined as 1 in FreeRTOSConfig.h for this
N * function to be available.
N *
N * A task will enter the Blocked state when it is waiting for an event.  The
N * event it is waiting for can be a temporal event (waiting for a time), such
N * as when vTaskDelay() is called, or an event on an object, such as when
N * xQueueReceive() or ulTaskNotifyTake() is called.  If the handle of a task
N * that is in the Blocked state is used in a call to xTaskAbortDelay() then the
N * task will leave the Blocked state, and return from whichever function call
N * placed the task into the Blocked state.
N *
N * @param xTask The handle of the task to remove from the Blocked state.
N *
N * @return If the task referenced by xTask was not in the Blocked state then
N * pdFAIL is returned.  Otherwise pdPASS is returned.
N *
N * \defgroup xTaskAbortDelay xTaskAbortDelay
N * \ingroup TaskCtrl
N */
NBaseType_t xTaskAbortDelay( TaskHandle_t xTask ) PRIVILEGED_FUNCTION;
XBaseType_t xTaskAbortDelay( TaskHandle_t xTask ) ;
N
N/**
N * task. h
N * <pre>UBaseType_t uxTaskPriorityGet( TaskHandle_t xTask );</pre>
N *
N * INCLUDE_uxTaskPriorityGet must be defined as 1 for this function to be available.
N * See the configuration section for more information.
N *
N * Obtain the priority of any task.
N *
N * @param xTask Handle of the task to be queried.  Passing a NULL
N * handle results in the priority of the calling task being returned.
N *
N * @return The priority of xTask.
N *
N * Example usage:
N   <pre>
N void vAFunction( void )
N {
N TaskHandle_t xHandle;
N
N	 // Create a task, storing the handle.
N	 xTaskCreate( vTaskCode, "NAME", STACK_SIZE, NULL, tskIDLE_PRIORITY, &xHandle );
N
N	 // ...
N
N	 // Use the handle to obtain the priority of the created task.
N	 // It was created with tskIDLE_PRIORITY, but may have changed
N	 // it itself.
N	 if( uxTaskPriorityGet( xHandle ) != tskIDLE_PRIORITY )
N	 {
N		 // The task has changed it's priority.
N	 }
N
N	 // ...
N
N	 // Is our priority higher than the created task?
N	 if( uxTaskPriorityGet( xHandle ) < uxTaskPriorityGet( NULL ) )
N	 {
N		 // Our priority (obtained using NULL handle) is higher.
N	 }
N }
N   </pre>
N * \defgroup uxTaskPriorityGet uxTaskPriorityGet
N * \ingroup TaskCtrl
N */
NUBaseType_t uxTaskPriorityGet( TaskHandle_t xTask ) PRIVILEGED_FUNCTION;
XUBaseType_t uxTaskPriorityGet( TaskHandle_t xTask ) ;
N
N/**
N * task. h
N * <pre>UBaseType_t uxTaskPriorityGetFromISR( TaskHandle_t xTask );</pre>
N *
N * A version of uxTaskPriorityGet() that can be used from an ISR.
N */
NUBaseType_t uxTaskPriorityGetFromISR( TaskHandle_t xTask ) PRIVILEGED_FUNCTION;
XUBaseType_t uxTaskPriorityGetFromISR( TaskHandle_t xTask ) ;
N
N/**
N * task. h
N * <pre>eTaskState eTaskGetState( TaskHandle_t xTask );</pre>
N *
N * INCLUDE_eTaskGetState must be defined as 1 for this function to be available.
N * See the configuration section for more information.
N *
N * Obtain the state of any task.  States are encoded by the eTaskState
N * enumerated type.
N *
N * @param xTask Handle of the task to be queried.
N *
N * @return The state of xTask at the time the function was called.  Note the
N * state of the task might change between the function being called, and the
N * functions return value being tested by the calling task.
N */
NeTaskState eTaskGetState( TaskHandle_t xTask ) PRIVILEGED_FUNCTION;
XeTaskState eTaskGetState( TaskHandle_t xTask ) ;
N
N/**
N * task. h
N * <pre>void vTaskGetInfo( TaskHandle_t xTask, TaskStatus_t *pxTaskStatus, BaseType_t xGetFreeStackSpace, eTaskState eState );</pre>
N *
N * configUSE_TRACE_FACILITY must be defined as 1 for this function to be
N * available.  See the configuration section for more information.
N *
N * Populates a TaskStatus_t structure with information about a task.
N *
N * @param xTask Handle of the task being queried.  If xTask is NULL then
N * information will be returned about the calling task.
N *
N * @param pxTaskStatus A pointer to the TaskStatus_t structure that will be
N * filled with information about the task referenced by the handle passed using
N * the xTask parameter.
N *
N * @xGetFreeStackSpace The TaskStatus_t structure contains a member to report
N * the stack high water mark of the task being queried.  Calculating the stack
N * high water mark takes a relatively long time, and can make the system
N * temporarily unresponsive - so the xGetFreeStackSpace parameter is provided to
N * allow the high water mark checking to be skipped.  The high watermark value
N * will only be written to the TaskStatus_t structure if xGetFreeStackSpace is
N * not set to pdFALSE;
N *
N * @param eState The TaskStatus_t structure contains a member to report the
N * state of the task being queried.  Obtaining the task state is not as fast as
N * a simple assignment - so the eState parameter is provided to allow the state
N * information to be omitted from the TaskStatus_t structure.  To obtain state
N * information then set eState to eInvalid - otherwise the value passed in
N * eState will be reported as the task state in the TaskStatus_t structure.
N *
N * Example usage:
N   <pre>
N void vAFunction( void )
N {
N TaskHandle_t xHandle;
N TaskStatus_t xTaskDetails;
N
N    // Obtain the handle of a task from its name.
N    xHandle = xTaskGetHandle( "Task_Name" );
N
N    // Check the handle is not NULL.
N    configASSERT( xHandle );
N
N    // Use the handle to obtain further information about the task.
N    vTaskGetInfo( xHandle,
N                  &xTaskDetails,
N                  pdTRUE, // Include the high water mark in xTaskDetails.
N                  eInvalid ); // Include the task state in xTaskDetails.
N }
N   </pre>
N * \defgroup vTaskGetInfo vTaskGetInfo
N * \ingroup TaskCtrl
N */
Nvoid vTaskGetInfo( TaskHandle_t xTask, TaskStatus_t *pxTaskStatus, BaseType_t xGetFreeStackSpace, eTaskState eState ) PRIVILEGED_FUNCTION;
Xvoid vTaskGetInfo( TaskHandle_t xTask, TaskStatus_t *pxTaskStatus, BaseType_t xGetFreeStackSpace, eTaskState eState ) ;
N
N/**
N * task. h
N * <pre>void vTaskPrioritySet( TaskHandle_t xTask, UBaseType_t uxNewPriority );</pre>
N *
N * INCLUDE_vTaskPrioritySet must be defined as 1 for this function to be available.
N * See the configuration section for more information.
N *
N * Set the priority of any task.
N *
N * A context switch will occur before the function returns if the priority
N * being set is higher than the currently executing task.
N *
N * @param xTask Handle to the task for which the priority is being set.
N * Passing a NULL handle results in the priority of the calling task being set.
N *
N * @param uxNewPriority The priority to which the task will be set.
N *
N * Example usage:
N   <pre>
N void vAFunction( void )
N {
N TaskHandle_t xHandle;
N
N	 // Create a task, storing the handle.
N	 xTaskCreate( vTaskCode, "NAME", STACK_SIZE, NULL, tskIDLE_PRIORITY, &xHandle );
N
N	 // ...
N
N	 // Use the handle to raise the priority of the created task.
N	 vTaskPrioritySet( xHandle, tskIDLE_PRIORITY + 1 );
N
N	 // ...
N
N	 // Use a NULL handle to raise our priority to the same value.
N	 vTaskPrioritySet( NULL, tskIDLE_PRIORITY + 1 );
N }
N   </pre>
N * \defgroup vTaskPrioritySet vTaskPrioritySet
N * \ingroup TaskCtrl
N */
Nvoid vTaskPrioritySet( TaskHandle_t xTask, UBaseType_t uxNewPriority ) PRIVILEGED_FUNCTION;
Xvoid vTaskPrioritySet( TaskHandle_t xTask, UBaseType_t uxNewPriority ) ;
N
N/**
N * task. h
N * <pre>void vTaskSuspend( TaskHandle_t xTaskToSuspend );</pre>
N *
N * INCLUDE_vTaskSuspend must be defined as 1 for this function to be available.
N * See the configuration section for more information.
N *
N * Suspend any task.  When suspended a task will never get any microcontroller
N * processing time, no matter what its priority.
N *
N * Calls to vTaskSuspend are not accumulative -
N * i.e. calling vTaskSuspend () twice on the same task still only requires one
N * call to vTaskResume () to ready the suspended task.
N *
N * @param xTaskToSuspend Handle to the task being suspended.  Passing a NULL
N * handle will cause the calling task to be suspended.
N *
N * Example usage:
N   <pre>
N void vAFunction( void )
N {
N TaskHandle_t xHandle;
N
N	 // Create a task, storing the handle.
N	 xTaskCreate( vTaskCode, "NAME", STACK_SIZE, NULL, tskIDLE_PRIORITY, &xHandle );
N
N	 // ...
N
N	 // Use the handle to suspend the created task.
N	 vTaskSuspend( xHandle );
N
N	 // ...
N
N	 // The created task will not run during this period, unless
N	 // another task calls vTaskResume( xHandle ).
N
N	 //...
N
N
N	 // Suspend ourselves.
N	 vTaskSuspend( NULL );
N
N	 // We cannot get here unless another task calls vTaskResume
N	 // with our handle as the parameter.
N }
N   </pre>
N * \defgroup vTaskSuspend vTaskSuspend
N * \ingroup TaskCtrl
N */
Nvoid vTaskSuspend( TaskHandle_t xTaskToSuspend ) PRIVILEGED_FUNCTION;
Xvoid vTaskSuspend( TaskHandle_t xTaskToSuspend ) ;
N
N/**
N * task. h
N * <pre>void vTaskResume( TaskHandle_t xTaskToResume );</pre>
N *
N * INCLUDE_vTaskSuspend must be defined as 1 for this function to be available.
N * See the configuration section for more information.
N *
N * Resumes a suspended task.
N *
N * A task that has been suspended by one or more calls to vTaskSuspend ()
N * will be made available for running again by a single call to
N * vTaskResume ().
N *
N * @param xTaskToResume Handle to the task being readied.
N *
N * Example usage:
N   <pre>
N void vAFunction( void )
N {
N TaskHandle_t xHandle;
N
N	 // Create a task, storing the handle.
N	 xTaskCreate( vTaskCode, "NAME", STACK_SIZE, NULL, tskIDLE_PRIORITY, &xHandle );
N
N	 // ...
N
N	 // Use the handle to suspend the created task.
N	 vTaskSuspend( xHandle );
N
N	 // ...
N
N	 // The created task will not run during this period, unless
N	 // another task calls vTaskResume( xHandle ).
N
N	 //...
N
N
N	 // Resume the suspended task ourselves.
N	 vTaskResume( xHandle );
N
N	 // The created task will once again get microcontroller processing
N	 // time in accordance with its priority within the system.
N }
N   </pre>
N * \defgroup vTaskResume vTaskResume
N * \ingroup TaskCtrl
N */
Nvoid vTaskResume( TaskHandle_t xTaskToResume ) PRIVILEGED_FUNCTION;
Xvoid vTaskResume( TaskHandle_t xTaskToResume ) ;
N
N/**
N * task. h
N * <pre>void xTaskResumeFromISR( TaskHandle_t xTaskToResume );</pre>
N *
N * INCLUDE_xTaskResumeFromISR must be defined as 1 for this function to be
N * available.  See the configuration section for more information.
N *
N * An implementation of vTaskResume() that can be called from within an ISR.
N *
N * A task that has been suspended by one or more calls to vTaskSuspend ()
N * will be made available for running again by a single call to
N * xTaskResumeFromISR ().
N *
N * xTaskResumeFromISR() should not be used to synchronise a task with an
N * interrupt if there is a chance that the interrupt could arrive prior to the
N * task being suspended - as this can lead to interrupts being missed. Use of a
N * semaphore as a synchronisation mechanism would avoid this eventuality.
N *
N * @param xTaskToResume Handle to the task being readied.
N *
N * @return pdTRUE if resuming the task should result in a context switch,
N * otherwise pdFALSE. This is used by the ISR to determine if a context switch
N * may be required following the ISR.
N *
N * \defgroup vTaskResumeFromISR vTaskResumeFromISR
N * \ingroup TaskCtrl
N */
NBaseType_t xTaskResumeFromISR( TaskHandle_t xTaskToResume ) PRIVILEGED_FUNCTION;
XBaseType_t xTaskResumeFromISR( TaskHandle_t xTaskToResume ) ;
N
N/*-----------------------------------------------------------
N * SCHEDULER CONTROL
N *----------------------------------------------------------*/
N
N/**
N * task. h
N * <pre>void vTaskStartScheduler( void );</pre>
N *
N * Starts the real time kernel tick processing.  After calling the kernel
N * has control over which tasks are executed and when.
N *
N * See the demo application file main.c for an example of creating
N * tasks and starting the kernel.
N *
N * Example usage:
N   <pre>
N void vAFunction( void )
N {
N	 // Create at least one task before starting the kernel.
N	 xTaskCreate( vTaskCode, "NAME", STACK_SIZE, NULL, tskIDLE_PRIORITY, NULL );
N
N	 // Start the real time kernel with preemption.
N	 vTaskStartScheduler ();
N
N	 // Will not get here unless a task calls vTaskEndScheduler ()
N }
N   </pre>
N *
N * \defgroup vTaskStartScheduler vTaskStartScheduler
N * \ingroup SchedulerControl
N */
Nvoid vTaskStartScheduler( void ) PRIVILEGED_FUNCTION;
Xvoid vTaskStartScheduler( void ) ;
N
N/**
N * task. h
N * <pre>void vTaskEndScheduler( void );</pre>
N *
N * NOTE:  At the time of writing only the x86 real mode port, which runs on a PC
N * in place of DOS, implements this function.
N *
N * Stops the real time kernel tick.  All created tasks will be automatically
N * deleted and multitasking (either preemptive or cooperative) will
N * stop.  Execution then resumes from the point where vTaskStartScheduler ()
N * was called, as if vTaskStartScheduler () had just returned.
N *
N * See the demo application file main. c in the demo/PC directory for an
N * example that uses vTaskEndScheduler ().
N *
N * vTaskEndScheduler () requires an exit function to be defined within the
N * portable layer (see vPortEndScheduler () in port. c for the PC port).  This
N * performs hardware specific operations such as stopping the kernel tick.
N *
N * vTaskEndScheduler () will cause all of the resources allocated by the
N * kernel to be freed - but will not free resources allocated by application
N * tasks.
N *
N * Example usage:
N   <pre>
N void vTaskCode( void * pvParameters )
N {
N	 for( ;; )
N	 {
N		 // Task code goes here.
N
N		 // At some point we want to end the real time kernel processing
N		 // so call ...
N		 vTaskEndScheduler ();
N	 }
N }
N
N void vAFunction( void )
N {
N	 // Create at least one task before starting the kernel.
N	 xTaskCreate( vTaskCode, "NAME", STACK_SIZE, NULL, tskIDLE_PRIORITY, NULL );
N
N	 // Start the real time kernel with preemption.
N	 vTaskStartScheduler ();
N
N	 // Will only get here when the vTaskCode () task has called
N	 // vTaskEndScheduler ().  When we get here we are back to single task
N	 // execution.
N }
N   </pre>
N *
N * \defgroup vTaskEndScheduler vTaskEndScheduler
N * \ingroup SchedulerControl
N */
Nvoid vTaskEndScheduler( void ) PRIVILEGED_FUNCTION;
Xvoid vTaskEndScheduler( void ) ;
N
N/**
N * task. h
N * <pre>void vTaskSuspendAll( void );</pre>
N *
N * Suspends the scheduler without disabling interrupts.  Context switches will
N * not occur while the scheduler is suspended.
N *
N * After calling vTaskSuspendAll () the calling task will continue to execute
N * without risk of being swapped out until a call to xTaskResumeAll () has been
N * made.
N *
N * API functions that have the potential to cause a context switch (for example,
N * vTaskDelayUntil(), xQueueSend(), etc.) must not be called while the scheduler
N * is suspended.
N *
N * Example usage:
N   <pre>
N void vTask1( void * pvParameters )
N {
N	 for( ;; )
N	 {
N		 // Task code goes here.
N
N		 // ...
N
N		 // At some point the task wants to perform a long operation during
N		 // which it does not want to get swapped out.  It cannot use
N		 // taskENTER_CRITICAL ()/taskEXIT_CRITICAL () as the length of the
N		 // operation may cause interrupts to be missed - including the
N		 // ticks.
N
N		 // Prevent the real time kernel swapping out the task.
N		 vTaskSuspendAll ();
N
N		 // Perform the operation here.  There is no need to use critical
N		 // sections as we have all the microcontroller processing time.
N		 // During this time interrupts will still operate and the kernel
N		 // tick count will be maintained.
N
N		 // ...
N
N		 // The operation is complete.  Restart the kernel.
N		 xTaskResumeAll ();
N	 }
N }
N   </pre>
N * \defgroup vTaskSuspendAll vTaskSuspendAll
N * \ingroup SchedulerControl
N */
Nvoid vTaskSuspendAll( void ) PRIVILEGED_FUNCTION;
Xvoid vTaskSuspendAll( void ) ;
N
N/**
N * task. h
N * <pre>BaseType_t xTaskResumeAll( void );</pre>
N *
N * Resumes scheduler activity after it was suspended by a call to
N * vTaskSuspendAll().
N *
N * xTaskResumeAll() only resumes the scheduler.  It does not unsuspend tasks
N * that were previously suspended by a call to vTaskSuspend().
N *
N * @return If resuming the scheduler caused a context switch then pdTRUE is
N *		  returned, otherwise pdFALSE is returned.
N *
N * Example usage:
N   <pre>
N void vTask1( void * pvParameters )
N {
N	 for( ;; )
N	 {
N		 // Task code goes here.
N
N		 // ...
N
N		 // At some point the task wants to perform a long operation during
N		 // which it does not want to get swapped out.  It cannot use
N		 // taskENTER_CRITICAL ()/taskEXIT_CRITICAL () as the length of the
N		 // operation may cause interrupts to be missed - including the
N		 // ticks.
N
N		 // Prevent the real time kernel swapping out the task.
N		 vTaskSuspendAll ();
N
N		 // Perform the operation here.  There is no need to use critical
N		 // sections as we have all the microcontroller processing time.
N		 // During this time interrupts will still operate and the real
N		 // time kernel tick count will be maintained.
N
N		 // ...
N
N		 // The operation is complete.  Restart the kernel.  We want to force
N		 // a context switch - but there is no point if resuming the scheduler
N		 // caused a context switch already.
N		 if( !xTaskResumeAll () )
N		 {
N			  taskYIELD ();
N		 }
N	 }
N }
N   </pre>
N * \defgroup xTaskResumeAll xTaskResumeAll
N * \ingroup SchedulerControl
N */
NBaseType_t xTaskResumeAll( void ) PRIVILEGED_FUNCTION;
XBaseType_t xTaskResumeAll( void ) ;
N
N/*-----------------------------------------------------------
N * TASK UTILITIES
N *----------------------------------------------------------*/
N
N/**
N * task. h
N * <PRE>TickType_t xTaskGetTickCount( void );</PRE>
N *
N * @return The count of ticks since vTaskStartScheduler was called.
N *
N * \defgroup xTaskGetTickCount xTaskGetTickCount
N * \ingroup TaskUtils
N */
NTickType_t xTaskGetTickCount( void ) PRIVILEGED_FUNCTION;
XTickType_t xTaskGetTickCount( void ) ;
N
N/**
N * task. h
N * <PRE>TickType_t xTaskGetTickCountFromISR( void );</PRE>
N *
N * @return The count of ticks since vTaskStartScheduler was called.
N *
N * This is a version of xTaskGetTickCount() that is safe to be called from an
N * ISR - provided that TickType_t is the natural word size of the
N * microcontroller being used or interrupt nesting is either not supported or
N * not being used.
N *
N * \defgroup xTaskGetTickCountFromISR xTaskGetTickCountFromISR
N * \ingroup TaskUtils
N */
NTickType_t xTaskGetTickCountFromISR( void ) PRIVILEGED_FUNCTION;
XTickType_t xTaskGetTickCountFromISR( void ) ;
N
N/**
N * task. h
N * <PRE>uint16_t uxTaskGetNumberOfTasks( void );</PRE>
N *
N * @return The number of tasks that the real time kernel is currently managing.
N * This includes all ready, blocked and suspended tasks.  A task that
N * has been deleted but not yet freed by the idle task will also be
N * included in the count.
N *
N * \defgroup uxTaskGetNumberOfTasks uxTaskGetNumberOfTasks
N * \ingroup TaskUtils
N */
NUBaseType_t uxTaskGetNumberOfTasks( void ) PRIVILEGED_FUNCTION;
XUBaseType_t uxTaskGetNumberOfTasks( void ) ;
N
N/**
N * task. h
N * <PRE>char *pcTaskGetName( TaskHandle_t xTaskToQuery );</PRE>
N *
N * @return The text (human readable) name of the task referenced by the handle
N * xTaskToQuery.  A task can query its own name by either passing in its own
N * handle, or by setting xTaskToQuery to NULL.
N *
N * \defgroup pcTaskGetName pcTaskGetName
N * \ingroup TaskUtils
N */
Nchar *pcTaskGetName( TaskHandle_t xTaskToQuery ) PRIVILEGED_FUNCTION; /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
Xchar *pcTaskGetName( TaskHandle_t xTaskToQuery ) ;  
N
N/**
N * task. h
N * <PRE>TaskHandle_t xTaskGetHandle( const char *pcNameToQuery );</PRE>
N *
N * NOTE:  This function takes a relatively long time to complete and should be
N * used sparingly.
N *
N * @return The handle of the task that has the human readable name pcNameToQuery.
N * NULL is returned if no matching name is found.  INCLUDE_xTaskGetHandle
N * must be set to 1 in FreeRTOSConfig.h for pcTaskGetHandle() to be available.
N *
N * \defgroup pcTaskGetHandle pcTaskGetHandle
N * \ingroup TaskUtils
N */
NTaskHandle_t xTaskGetHandle( const char *pcNameToQuery ) PRIVILEGED_FUNCTION; /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
XTaskHandle_t xTaskGetHandle( const char *pcNameToQuery ) ;  
N
N/**
N * task.h
N * <PRE>UBaseType_t uxTaskGetStackHighWaterMark( TaskHandle_t xTask );</PRE>
N *
N * INCLUDE_uxTaskGetStackHighWaterMark must be set to 1 in FreeRTOSConfig.h for
N * this function to be available.
N *
N * Returns the high water mark of the stack associated with xTask.  That is,
N * the minimum free stack space there has been (in words, so on a 32 bit machine
N * a value of 1 means 4 bytes) since the task started.  The smaller the returned
N * number the closer the task has come to overflowing its stack.
N *
N * @param xTask Handle of the task associated with the stack to be checked.
N * Set xTask to NULL to check the stack of the calling task.
N *
N * @return The smallest amount of free stack space there has been (in words, so
N * actual spaces on the stack rather than bytes) since the task referenced by
N * xTask was created.
N */
NUBaseType_t uxTaskGetStackHighWaterMark( TaskHandle_t xTask ) PRIVILEGED_FUNCTION;
XUBaseType_t uxTaskGetStackHighWaterMark( TaskHandle_t xTask ) ;
N
N/* When using trace macros it is sometimes necessary to include task.h before
NFreeRTOS.h.  When this is done TaskHookFunction_t will not yet have been defined,
Nso the following two prototypes will cause a compilation error.  This can be
Nfixed by simply guarding against the inclusion of these two prototypes unless
Nthey are explicitly required by the configUSE_APPLICATION_TASK_TAG configuration
Nconstant. */
N#ifdef configUSE_APPLICATION_TASK_TAG
N	#if configUSE_APPLICATION_TASK_TAG == 1
X	#if 0 == 1
S		/**
S		 * task.h
S		 * <pre>void vTaskSetApplicationTaskTag( TaskHandle_t xTask, TaskHookFunction_t pxHookFunction );</pre>
S		 *
S		 * Sets pxHookFunction to be the task hook function used by the task xTask.
S		 * Passing xTask as NULL has the effect of setting the calling tasks hook
S		 * function.
S		 */
S		void vTaskSetApplicationTaskTag( TaskHandle_t xTask, TaskHookFunction_t pxHookFunction ) PRIVILEGED_FUNCTION;
S
S		/**
S		 * task.h
S		 * <pre>void xTaskGetApplicationTaskTag( TaskHandle_t xTask );</pre>
S		 *
S		 * Returns the pxHookFunction value assigned to the task xTask.
S		 */
S		TaskHookFunction_t xTaskGetApplicationTaskTag( TaskHandle_t xTask ) PRIVILEGED_FUNCTION;
N	#endif /* configUSE_APPLICATION_TASK_TAG ==1 */
N#endif /* ifdef configUSE_APPLICATION_TASK_TAG */
N
N#if( configNUM_THREAD_LOCAL_STORAGE_POINTERS > 0 )
X#if( 0 > 0 )
S
S	/* Each task contains an array of pointers that is dimensioned by the
S	configNUM_THREAD_LOCAL_STORAGE_POINTERS setting in FreeRTOSConfig.h.  The
S	kernel does not use the pointers itself, so the application writer can use
S	the pointers for any purpose they wish.  The following two functions are
S	used to set and query a pointer respectively. */
S	void vTaskSetThreadLocalStoragePointer( TaskHandle_t xTaskToSet, BaseType_t xIndex, void *pvValue ) PRIVILEGED_FUNCTION;
S	void *pvTaskGetThreadLocalStoragePointer( TaskHandle_t xTaskToQuery, BaseType_t xIndex ) PRIVILEGED_FUNCTION;
S
N#endif
N
N/**
N * task.h
N * <pre>BaseType_t xTaskCallApplicationTaskHook( TaskHandle_t xTask, void *pvParameter );</pre>
N *
N * Calls the hook function associated with xTask.  Passing xTask as NULL has
N * the effect of calling the Running tasks (the calling task) hook function.
N *
N * pvParameter is passed to the hook function for the task to interpret as it
N * wants.  The return value is the value returned by the task hook function
N * registered by the user.
N */
NBaseType_t xTaskCallApplicationTaskHook( TaskHandle_t xTask, void *pvParameter ) PRIVILEGED_FUNCTION;
XBaseType_t xTaskCallApplicationTaskHook( TaskHandle_t xTask, void *pvParameter ) ;
N
N/**
N * xTaskGetIdleTaskHandle() is only available if
N * INCLUDE_xTaskGetIdleTaskHandle is set to 1 in FreeRTOSConfig.h.
N *
N * Simply returns the handle of the idle task.  It is not valid to call
N * xTaskGetIdleTaskHandle() before the scheduler has been started.
N */
NTaskHandle_t xTaskGetIdleTaskHandle( void ) PRIVILEGED_FUNCTION;
XTaskHandle_t xTaskGetIdleTaskHandle( void ) ;
N
N/**
N * configUSE_TRACE_FACILITY must be defined as 1 in FreeRTOSConfig.h for
N * uxTaskGetSystemState() to be available.
N *
N * uxTaskGetSystemState() populates an TaskStatus_t structure for each task in
N * the system.  TaskStatus_t structures contain, among other things, members
N * for the task handle, task name, task priority, task state, and total amount
N * of run time consumed by the task.  See the TaskStatus_t structure
N * definition in this file for the full member list.
N *
N * NOTE:  This function is intended for debugging use only as its use results in
N * the scheduler remaining suspended for an extended period.
N *
N * @param pxTaskStatusArray A pointer to an array of TaskStatus_t structures.
N * The array must contain at least one TaskStatus_t structure for each task
N * that is under the control of the RTOS.  The number of tasks under the control
N * of the RTOS can be determined using the uxTaskGetNumberOfTasks() API function.
N *
N * @param uxArraySize The size of the array pointed to by the pxTaskStatusArray
N * parameter.  The size is specified as the number of indexes in the array, or
N * the number of TaskStatus_t structures contained in the array, not by the
N * number of bytes in the array.
N *
N * @param pulTotalRunTime If configGENERATE_RUN_TIME_STATS is set to 1 in
N * FreeRTOSConfig.h then *pulTotalRunTime is set by uxTaskGetSystemState() to the
N * total run time (as defined by the run time stats clock, see
N * http://www.freertos.org/rtos-run-time-stats.html) since the target booted.
N * pulTotalRunTime can be set to NULL to omit the total run time information.
N *
N * @return The number of TaskStatus_t structures that were populated by
N * uxTaskGetSystemState().  This should equal the number returned by the
N * uxTaskGetNumberOfTasks() API function, but will be zero if the value passed
N * in the uxArraySize parameter was too small.
N *
N * Example usage:
N   <pre>
N    // This example demonstrates how a human readable table of run time stats
N	// information is generated from raw data provided by uxTaskGetSystemState().
N	// The human readable table is written to pcWriteBuffer
N	void vTaskGetRunTimeStats( char *pcWriteBuffer )
N	{
N	TaskStatus_t *pxTaskStatusArray;
N	volatile UBaseType_t uxArraySize, x;
N	uint32_t ulTotalRunTime, ulStatsAsPercentage;
N
N		// Make sure the write buffer does not contain a string.
N		*pcWriteBuffer = 0x00;
N
N		// Take a snapshot of the number of tasks in case it changes while this
N		// function is executing.
N		uxArraySize = uxTaskGetNumberOfTasks();
N
N		// Allocate a TaskStatus_t structure for each task.  An array could be
N		// allocated statically at compile time.
N		pxTaskStatusArray = pvPortMalloc( uxArraySize * sizeof( TaskStatus_t ) );
N
N		if( pxTaskStatusArray != NULL )
N		{
N			// Generate raw status information about each task.
N			uxArraySize = uxTaskGetSystemState( pxTaskStatusArray, uxArraySize, &ulTotalRunTime );
N
N			// For percentage calculations.
N			ulTotalRunTime /= 100UL;
N
N			// Avoid divide by zero errors.
N			if( ulTotalRunTime > 0 )
N			{
N				// For each populated position in the pxTaskStatusArray array,
N				// format the raw data as human readable ASCII data
N				for( x = 0; x < uxArraySize; x++ )
N				{
N					// What percentage of the total run time has the task used?
N					// This will always be rounded down to the nearest integer.
N					// ulTotalRunTimeDiv100 has already been divided by 100.
N					ulStatsAsPercentage = pxTaskStatusArray[ x ].ulRunTimeCounter / ulTotalRunTime;
N
N					if( ulStatsAsPercentage > 0UL )
N					{
N						sprintf( pcWriteBuffer, "%s\t\t%lu\t\t%lu%%\r\n", pxTaskStatusArray[ x ].pcTaskName, pxTaskStatusArray[ x ].ulRunTimeCounter, ulStatsAsPercentage );
N					}
N					else
N					{
N						// If the percentage is zero here then the task has
N						// consumed less than 1% of the total run time.
N						sprintf( pcWriteBuffer, "%s\t\t%lu\t\t<1%%\r\n", pxTaskStatusArray[ x ].pcTaskName, pxTaskStatusArray[ x ].ulRunTimeCounter );
N					}
N
N					pcWriteBuffer += strlen( ( char * ) pcWriteBuffer );
N				}
N			}
N
N			// The array is no longer needed, free the memory it consumes.
N			vPortFree( pxTaskStatusArray );
N		}
N	}
N	</pre>
N */
NUBaseType_t uxTaskGetSystemState( TaskStatus_t * const pxTaskStatusArray, const UBaseType_t uxArraySize, uint32_t * const pulTotalRunTime ) PRIVILEGED_FUNCTION;
XUBaseType_t uxTaskGetSystemState( TaskStatus_t * const pxTaskStatusArray, const UBaseType_t uxArraySize, uint32_t * const pulTotalRunTime ) ;
N
N/**
N * task. h
N * <PRE>void vTaskList( char *pcWriteBuffer );</PRE>
N *
N * configUSE_TRACE_FACILITY and configUSE_STATS_FORMATTING_FUNCTIONS must
N * both be defined as 1 for this function to be available.  See the
N * configuration section of the FreeRTOS.org website for more information.
N *
N * NOTE 1: This function will disable interrupts for its duration.  It is
N * not intended for normal application runtime use but as a debug aid.
N *
N * Lists all the current tasks, along with their current state and stack
N * usage high water mark.
N *
N * Tasks are reported as blocked ('B'), ready ('R'), deleted ('D') or
N * suspended ('S').
N *
N * PLEASE NOTE:
N *
N * This function is provided for convenience only, and is used by many of the
N * demo applications.  Do not consider it to be part of the scheduler.
N *
N * vTaskList() calls uxTaskGetSystemState(), then formats part of the
N * uxTaskGetSystemState() output into a human readable table that displays task
N * names, states and stack usage.
N *
N * vTaskList() has a dependency on the sprintf() C library function that might
N * bloat the code size, use a lot of stack, and provide different results on
N * different platforms.  An alternative, tiny, third party, and limited
N * functionality implementation of sprintf() is provided in many of the
N * FreeRTOS/Demo sub-directories in a file called printf-stdarg.c (note
N * printf-stdarg.c does not provide a full snprintf() implementation!).
N *
N * It is recommended that production systems call uxTaskGetSystemState()
N * directly to get access to raw stats data, rather than indirectly through a
N * call to vTaskList().
N *
N * @param pcWriteBuffer A buffer into which the above mentioned details
N * will be written, in ASCII form.  This buffer is assumed to be large
N * enough to contain the generated report.  Approximately 40 bytes per
N * task should be sufficient.
N *
N * \defgroup vTaskList vTaskList
N * \ingroup TaskUtils
N */
Nvoid vTaskList( char * pcWriteBuffer ) PRIVILEGED_FUNCTION; /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
Xvoid vTaskList( char * pcWriteBuffer ) ;  
N
N/**
N * task. h
N * <PRE>void vTaskGetRunTimeStats( char *pcWriteBuffer );</PRE>
N *
N * configGENERATE_RUN_TIME_STATS and configUSE_STATS_FORMATTING_FUNCTIONS
N * must both be defined as 1 for this function to be available.  The application
N * must also then provide definitions for
N * portCONFIGURE_TIMER_FOR_RUN_TIME_STATS() and portGET_RUN_TIME_COUNTER_VALUE()
N * to configure a peripheral timer/counter and return the timers current count
N * value respectively.  The counter should be at least 10 times the frequency of
N * the tick count.
N *
N * NOTE 1: This function will disable interrupts for its duration.  It is
N * not intended for normal application runtime use but as a debug aid.
N *
N * Setting configGENERATE_RUN_TIME_STATS to 1 will result in a total
N * accumulated execution time being stored for each task.  The resolution
N * of the accumulated time value depends on the frequency of the timer
N * configured by the portCONFIGURE_TIMER_FOR_RUN_TIME_STATS() macro.
N * Calling vTaskGetRunTimeStats() writes the total execution time of each
N * task into a buffer, both as an absolute count value and as a percentage
N * of the total system execution time.
N *
N * NOTE 2:
N *
N * This function is provided for convenience only, and is used by many of the
N * demo applications.  Do not consider it to be part of the scheduler.
N *
N * vTaskGetRunTimeStats() calls uxTaskGetSystemState(), then formats part of the
N * uxTaskGetSystemState() output into a human readable table that displays the
N * amount of time each task has spent in the Running state in both absolute and
N * percentage terms.
N *
N * vTaskGetRunTimeStats() has a dependency on the sprintf() C library function
N * that might bloat the code size, use a lot of stack, and provide different
N * results on different platforms.  An alternative, tiny, third party, and
N * limited functionality implementation of sprintf() is provided in many of the
N * FreeRTOS/Demo sub-directories in a file called printf-stdarg.c (note
N * printf-stdarg.c does not provide a full snprintf() implementation!).
N *
N * It is recommended that production systems call uxTaskGetSystemState() directly
N * to get access to raw stats data, rather than indirectly through a call to
N * vTaskGetRunTimeStats().
N *
N * @param pcWriteBuffer A buffer into which the execution times will be
N * written, in ASCII form.  This buffer is assumed to be large enough to
N * contain the generated report.  Approximately 40 bytes per task should
N * be sufficient.
N *
N * \defgroup vTaskGetRunTimeStats vTaskGetRunTimeStats
N * \ingroup TaskUtils
N */
Nvoid vTaskGetRunTimeStats( char *pcWriteBuffer ) PRIVILEGED_FUNCTION; /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
Xvoid vTaskGetRunTimeStats( char *pcWriteBuffer ) ;  
N
N/**
N * task. h
N * <PRE>BaseType_t xTaskNotify( TaskHandle_t xTaskToNotify, uint32_t ulValue, eNotifyAction eAction );</PRE>
N *
N * configUSE_TASK_NOTIFICATIONS must be undefined or defined as 1 for this
N * function to be available.
N *
N * When configUSE_TASK_NOTIFICATIONS is set to one each task has its own private
N * "notification value", which is a 32-bit unsigned integer (uint32_t).
N *
N * Events can be sent to a task using an intermediary object.  Examples of such
N * objects are queues, semaphores, mutexes and event groups.  Task notifications
N * are a method of sending an event directly to a task without the need for such
N * an intermediary object.
N *
N * A notification sent to a task can optionally perform an action, such as
N * update, overwrite or increment the task's notification value.  In that way
N * task notifications can be used to send data to a task, or be used as light
N * weight and fast binary or counting semaphores.
N *
N * A notification sent to a task will remain pending until it is cleared by the
N * task calling xTaskNotifyWait() or ulTaskNotifyTake().  If the task was
N * already in the Blocked state to wait for a notification when the notification
N * arrives then the task will automatically be removed from the Blocked state
N * (unblocked) and the notification cleared.
N *
N * A task can use xTaskNotifyWait() to [optionally] block to wait for a
N * notification to be pending, or ulTaskNotifyTake() to [optionally] block
N * to wait for its notification value to have a non-zero value.  The task does
N * not consume any CPU time while it is in the Blocked state.
N *
N * See http://www.FreeRTOS.org/RTOS-task-notifications.html for details.
N *
N * @param xTaskToNotify The handle of the task being notified.  The handle to a
N * task can be returned from the xTaskCreate() API function used to create the
N * task, and the handle of the currently running task can be obtained by calling
N * xTaskGetCurrentTaskHandle().
N *
N * @param ulValue Data that can be sent with the notification.  How the data is
N * used depends on the value of the eAction parameter.
N *
N * @param eAction Specifies how the notification updates the task's notification
N * value, if at all.  Valid values for eAction are as follows:
N *
N * eSetBits -
N * The task's notification value is bitwise ORed with ulValue.  xTaskNofify()
N * always returns pdPASS in this case.
N *
N * eIncrement -
N * The task's notification value is incremented.  ulValue is not used and
N * xTaskNotify() always returns pdPASS in this case.
N *
N * eSetValueWithOverwrite -
N * The task's notification value is set to the value of ulValue, even if the
N * task being notified had not yet processed the previous notification (the
N * task already had a notification pending).  xTaskNotify() always returns
N * pdPASS in this case.
N *
N * eSetValueWithoutOverwrite -
N * If the task being notified did not already have a notification pending then
N * the task's notification value is set to ulValue and xTaskNotify() will
N * return pdPASS.  If the task being notified already had a notification
N * pending then no action is performed and pdFAIL is returned.
N *
N * eNoAction -
N * The task receives a notification without its notification value being
N * updated.  ulValue is not used and xTaskNotify() always returns pdPASS in
N * this case.
N *
N *  pulPreviousNotificationValue -
N *  Can be used to pass out the subject task's notification value before any
N *  bits are modified by the notify function.
N *
N * @return Dependent on the value of eAction.  See the description of the
N * eAction parameter.
N *
N * \defgroup xTaskNotify xTaskNotify
N * \ingroup TaskNotifications
N */
NBaseType_t xTaskGenericNotify( TaskHandle_t xTaskToNotify, uint32_t ulValue, eNotifyAction eAction, uint32_t *pulPreviousNotificationValue ) PRIVILEGED_FUNCTION;
XBaseType_t xTaskGenericNotify( TaskHandle_t xTaskToNotify, uint32_t ulValue, eNotifyAction eAction, uint32_t *pulPreviousNotificationValue ) ;
N#define xTaskNotify( xTaskToNotify, ulValue, eAction ) xTaskGenericNotify( ( xTaskToNotify ), ( ulValue ), ( eAction ), NULL )
N#define xTaskNotifyAndQuery( xTaskToNotify, ulValue, eAction, pulPreviousNotifyValue ) xTaskGenericNotify( ( xTaskToNotify ), ( ulValue ), ( eAction ), ( pulPreviousNotifyValue ) )
N
N/**
N * task. h
N * <PRE>BaseType_t xTaskNotifyFromISR( TaskHandle_t xTaskToNotify, uint32_t ulValue, eNotifyAction eAction, BaseType_t *pxHigherPriorityTaskWoken );</PRE>
N *
N * configUSE_TASK_NOTIFICATIONS must be undefined or defined as 1 for this
N * function to be available.
N *
N * When configUSE_TASK_NOTIFICATIONS is set to one each task has its own private
N * "notification value", which is a 32-bit unsigned integer (uint32_t).
N *
N * A version of xTaskNotify() that can be used from an interrupt service routine
N * (ISR).
N *
N * Events can be sent to a task using an intermediary object.  Examples of such
N * objects are queues, semaphores, mutexes and event groups.  Task notifications
N * are a method of sending an event directly to a task without the need for such
N * an intermediary object.
N *
N * A notification sent to a task can optionally perform an action, such as
N * update, overwrite or increment the task's notification value.  In that way
N * task notifications can be used to send data to a task, or be used as light
N * weight and fast binary or counting semaphores.
N *
N * A notification sent to a task will remain pending until it is cleared by the
N * task calling xTaskNotifyWait() or ulTaskNotifyTake().  If the task was
N * already in the Blocked state to wait for a notification when the notification
N * arrives then the task will automatically be removed from the Blocked state
N * (unblocked) and the notification cleared.
N *
N * A task can use xTaskNotifyWait() to [optionally] block to wait for a
N * notification to be pending, or ulTaskNotifyTake() to [optionally] block
N * to wait for its notification value to have a non-zero value.  The task does
N * not consume any CPU time while it is in the Blocked state.
N *
N * See http://www.FreeRTOS.org/RTOS-task-notifications.html for details.
N *
N * @param xTaskToNotify The handle of the task being notified.  The handle to a
N * task can be returned from the xTaskCreate() API function used to create the
N * task, and the handle of the currently running task can be obtained by calling
N * xTaskGetCurrentTaskHandle().
N *
N * @param ulValue Data that can be sent with the notification.  How the data is
N * used depends on the value of the eAction parameter.
N *
N * @param eAction Specifies how the notification updates the task's notification
N * value, if at all.  Valid values for eAction are as follows:
N *
N * eSetBits -
N * The task's notification value is bitwise ORed with ulValue.  xTaskNofify()
N * always returns pdPASS in this case.
N *
N * eIncrement -
N * The task's notification value is incremented.  ulValue is not used and
N * xTaskNotify() always returns pdPASS in this case.
N *
N * eSetValueWithOverwrite -
N * The task's notification value is set to the value of ulValue, even if the
N * task being notified had not yet processed the previous notification (the
N * task already had a notification pending).  xTaskNotify() always returns
N * pdPASS in this case.
N *
N * eSetValueWithoutOverwrite -
N * If the task being notified did not already have a notification pending then
N * the task's notification value is set to ulValue and xTaskNotify() will
N * return pdPASS.  If the task being notified already had a notification
N * pending then no action is performed and pdFAIL is returned.
N *
N * eNoAction -
N * The task receives a notification without its notification value being
N * updated.  ulValue is not used and xTaskNotify() always returns pdPASS in
N * this case.
N *
N * @param pxHigherPriorityTaskWoken  xTaskNotifyFromISR() will set
N * *pxHigherPriorityTaskWoken to pdTRUE if sending the notification caused the
N * task to which the notification was sent to leave the Blocked state, and the
N * unblocked task has a priority higher than the currently running task.  If
N * xTaskNotifyFromISR() sets this value to pdTRUE then a context switch should
N * be requested before the interrupt is exited.  How a context switch is
N * requested from an ISR is dependent on the port - see the documentation page
N * for the port in use.
N *
N * @return Dependent on the value of eAction.  See the description of the
N * eAction parameter.
N *
N * \defgroup xTaskNotify xTaskNotify
N * \ingroup TaskNotifications
N */
NBaseType_t xTaskGenericNotifyFromISR( TaskHandle_t xTaskToNotify, uint32_t ulValue, eNotifyAction eAction, uint32_t *pulPreviousNotificationValue, BaseType_t *pxHigherPriorityTaskWoken ) PRIVILEGED_FUNCTION;
XBaseType_t xTaskGenericNotifyFromISR( TaskHandle_t xTaskToNotify, uint32_t ulValue, eNotifyAction eAction, uint32_t *pulPreviousNotificationValue, BaseType_t *pxHigherPriorityTaskWoken ) ;
N#define xTaskNotifyFromISR( xTaskToNotify, ulValue, eAction, pxHigherPriorityTaskWoken ) xTaskGenericNotifyFromISR( ( xTaskToNotify ), ( ulValue ), ( eAction ), NULL, ( pxHigherPriorityTaskWoken ) )
N#define xTaskNotifyAndQueryFromISR( xTaskToNotify, ulValue, eAction, pulPreviousNotificationValue, pxHigherPriorityTaskWoken ) xTaskGenericNotifyFromISR( ( xTaskToNotify ), ( ulValue ), ( eAction ), ( pulPreviousNotificationValue ), ( pxHigherPriorityTaskWoken ) )
N
N/**
N * task. h
N * <PRE>BaseType_t xTaskNotifyWait( uint32_t ulBitsToClearOnEntry, uint32_t ulBitsToClearOnExit, uint32_t *pulNotificationValue, TickType_t xTicksToWait );</pre>
N *
N * configUSE_TASK_NOTIFICATIONS must be undefined or defined as 1 for this
N * function to be available.
N *
N * When configUSE_TASK_NOTIFICATIONS is set to one each task has its own private
N * "notification value", which is a 32-bit unsigned integer (uint32_t).
N *
N * Events can be sent to a task using an intermediary object.  Examples of such
N * objects are queues, semaphores, mutexes and event groups.  Task notifications
N * are a method of sending an event directly to a task without the need for such
N * an intermediary object.
N *
N * A notification sent to a task can optionally perform an action, such as
N * update, overwrite or increment the task's notification value.  In that way
N * task notifications can be used to send data to a task, or be used as light
N * weight and fast binary or counting semaphores.
N *
N * A notification sent to a task will remain pending until it is cleared by the
N * task calling xTaskNotifyWait() or ulTaskNotifyTake().  If the task was
N * already in the Blocked state to wait for a notification when the notification
N * arrives then the task will automatically be removed from the Blocked state
N * (unblocked) and the notification cleared.
N *
N * A task can use xTaskNotifyWait() to [optionally] block to wait for a
N * notification to be pending, or ulTaskNotifyTake() to [optionally] block
N * to wait for its notification value to have a non-zero value.  The task does
N * not consume any CPU time while it is in the Blocked state.
N *
N * See http://www.FreeRTOS.org/RTOS-task-notifications.html for details.
N *
N * @param ulBitsToClearOnEntry Bits that are set in ulBitsToClearOnEntry value
N * will be cleared in the calling task's notification value before the task
N * checks to see if any notifications are pending, and optionally blocks if no
N * notifications are pending.  Setting ulBitsToClearOnEntry to ULONG_MAX (if
N * limits.h is included) or 0xffffffffUL (if limits.h is not included) will have
N * the effect of resetting the task's notification value to 0.  Setting
N * ulBitsToClearOnEntry to 0 will leave the task's notification value unchanged.
N *
N * @param ulBitsToClearOnExit If a notification is pending or received before
N * the calling task exits the xTaskNotifyWait() function then the task's
N * notification value (see the xTaskNotify() API function) is passed out using
N * the pulNotificationValue parameter.  Then any bits that are set in
N * ulBitsToClearOnExit will be cleared in the task's notification value (note
N * *pulNotificationValue is set before any bits are cleared).  Setting
N * ulBitsToClearOnExit to ULONG_MAX (if limits.h is included) or 0xffffffffUL
N * (if limits.h is not included) will have the effect of resetting the task's
N * notification value to 0 before the function exits.  Setting
N * ulBitsToClearOnExit to 0 will leave the task's notification value unchanged
N * when the function exits (in which case the value passed out in
N * pulNotificationValue will match the task's notification value).
N *
N * @param pulNotificationValue Used to pass the task's notification value out
N * of the function.  Note the value passed out will not be effected by the
N * clearing of any bits caused by ulBitsToClearOnExit being non-zero.
N *
N * @param xTicksToWait The maximum amount of time that the task should wait in
N * the Blocked state for a notification to be received, should a notification
N * not already be pending when xTaskNotifyWait() was called.  The task
N * will not consume any processing time while it is in the Blocked state.  This
N * is specified in kernel ticks, the macro pdMS_TO_TICSK( value_in_ms ) can be
N * used to convert a time specified in milliseconds to a time specified in
N * ticks.
N *
N * @return If a notification was received (including notifications that were
N * already pending when xTaskNotifyWait was called) then pdPASS is
N * returned.  Otherwise pdFAIL is returned.
N *
N * \defgroup xTaskNotifyWait xTaskNotifyWait
N * \ingroup TaskNotifications
N */
NBaseType_t xTaskNotifyWait( uint32_t ulBitsToClearOnEntry, uint32_t ulBitsToClearOnExit, uint32_t *pulNotificationValue, TickType_t xTicksToWait ) PRIVILEGED_FUNCTION;
XBaseType_t xTaskNotifyWait( uint32_t ulBitsToClearOnEntry, uint32_t ulBitsToClearOnExit, uint32_t *pulNotificationValue, TickType_t xTicksToWait ) ;
N
N/**
N * task. h
N * <PRE>BaseType_t xTaskNotifyGive( TaskHandle_t xTaskToNotify );</PRE>
N *
N * configUSE_TASK_NOTIFICATIONS must be undefined or defined as 1 for this macro
N * to be available.
N *
N * When configUSE_TASK_NOTIFICATIONS is set to one each task has its own private
N * "notification value", which is a 32-bit unsigned integer (uint32_t).
N *
N * Events can be sent to a task using an intermediary object.  Examples of such
N * objects are queues, semaphores, mutexes and event groups.  Task notifications
N * are a method of sending an event directly to a task without the need for such
N * an intermediary object.
N *
N * A notification sent to a task can optionally perform an action, such as
N * update, overwrite or increment the task's notification value.  In that way
N * task notifications can be used to send data to a task, or be used as light
N * weight and fast binary or counting semaphores.
N *
N * xTaskNotifyGive() is a helper macro intended for use when task notifications
N * are used as light weight and faster binary or counting semaphore equivalents.
N * Actual FreeRTOS semaphores are given using the xSemaphoreGive() API function,
N * the equivalent action that instead uses a task notification is
N * xTaskNotifyGive().
N *
N * When task notifications are being used as a binary or counting semaphore
N * equivalent then the task being notified should wait for the notification
N * using the ulTaskNotificationTake() API function rather than the
N * xTaskNotifyWait() API function.
N *
N * See http://www.FreeRTOS.org/RTOS-task-notifications.html for more details.
N *
N * @param xTaskToNotify The handle of the task being notified.  The handle to a
N * task can be returned from the xTaskCreate() API function used to create the
N * task, and the handle of the currently running task can be obtained by calling
N * xTaskGetCurrentTaskHandle().
N *
N * @return xTaskNotifyGive() is a macro that calls xTaskNotify() with the
N * eAction parameter set to eIncrement - so pdPASS is always returned.
N *
N * \defgroup xTaskNotifyGive xTaskNotifyGive
N * \ingroup TaskNotifications
N */
N#define xTaskNotifyGive( xTaskToNotify ) xTaskGenericNotify( ( xTaskToNotify ), ( 0 ), eIncrement, NULL )
N
N/**
N * task. h
N * <PRE>void vTaskNotifyGiveFromISR( TaskHandle_t xTaskHandle, BaseType_t *pxHigherPriorityTaskWoken );
N *
N * configUSE_TASK_NOTIFICATIONS must be undefined or defined as 1 for this macro
N * to be available.
N *
N * When configUSE_TASK_NOTIFICATIONS is set to one each task has its own private
N * "notification value", which is a 32-bit unsigned integer (uint32_t).
N *
N * A version of xTaskNotifyGive() that can be called from an interrupt service
N * routine (ISR).
N *
N * Events can be sent to a task using an intermediary object.  Examples of such
N * objects are queues, semaphores, mutexes and event groups.  Task notifications
N * are a method of sending an event directly to a task without the need for such
N * an intermediary object.
N *
N * A notification sent to a task can optionally perform an action, such as
N * update, overwrite or increment the task's notification value.  In that way
N * task notifications can be used to send data to a task, or be used as light
N * weight and fast binary or counting semaphores.
N *
N * vTaskNotifyGiveFromISR() is intended for use when task notifications are
N * used as light weight and faster binary or counting semaphore equivalents.
N * Actual FreeRTOS semaphores are given from an ISR using the
N * xSemaphoreGiveFromISR() API function, the equivalent action that instead uses
N * a task notification is vTaskNotifyGiveFromISR().
N *
N * When task notifications are being used as a binary or counting semaphore
N * equivalent then the task being notified should wait for the notification
N * using the ulTaskNotificationTake() API function rather than the
N * xTaskNotifyWait() API function.
N *
N * See http://www.FreeRTOS.org/RTOS-task-notifications.html for more details.
N *
N * @param xTaskToNotify The handle of the task being notified.  The handle to a
N * task can be returned from the xTaskCreate() API function used to create the
N * task, and the handle of the currently running task can be obtained by calling
N * xTaskGetCurrentTaskHandle().
N *
N * @param pxHigherPriorityTaskWoken  vTaskNotifyGiveFromISR() will set
N * *pxHigherPriorityTaskWoken to pdTRUE if sending the notification caused the
N * task to which the notification was sent to leave the Blocked state, and the
N * unblocked task has a priority higher than the currently running task.  If
N * vTaskNotifyGiveFromISR() sets this value to pdTRUE then a context switch
N * should be requested before the interrupt is exited.  How a context switch is
N * requested from an ISR is dependent on the port - see the documentation page
N * for the port in use.
N *
N * \defgroup xTaskNotifyWait xTaskNotifyWait
N * \ingroup TaskNotifications
N */
Nvoid vTaskNotifyGiveFromISR( TaskHandle_t xTaskToNotify, BaseType_t *pxHigherPriorityTaskWoken ) PRIVILEGED_FUNCTION;
Xvoid vTaskNotifyGiveFromISR( TaskHandle_t xTaskToNotify, BaseType_t *pxHigherPriorityTaskWoken ) ;
N
N/**
N * task. h
N * <PRE>uint32_t ulTaskNotifyTake( BaseType_t xClearCountOnExit, TickType_t xTicksToWait );</pre>
N *
N * configUSE_TASK_NOTIFICATIONS must be undefined or defined as 1 for this
N * function to be available.
N *
N * When configUSE_TASK_NOTIFICATIONS is set to one each task has its own private
N * "notification value", which is a 32-bit unsigned integer (uint32_t).
N *
N * Events can be sent to a task using an intermediary object.  Examples of such
N * objects are queues, semaphores, mutexes and event groups.  Task notifications
N * are a method of sending an event directly to a task without the need for such
N * an intermediary object.
N *
N * A notification sent to a task can optionally perform an action, such as
N * update, overwrite or increment the task's notification value.  In that way
N * task notifications can be used to send data to a task, or be used as light
N * weight and fast binary or counting semaphores.
N *
N * ulTaskNotifyTake() is intended for use when a task notification is used as a
N * faster and lighter weight binary or counting semaphore alternative.  Actual
N * FreeRTOS semaphores are taken using the xSemaphoreTake() API function, the
N * equivalent action that instead uses a task notification is
N * ulTaskNotifyTake().
N *
N * When a task is using its notification value as a binary or counting semaphore
N * other tasks should send notifications to it using the xTaskNotifyGive()
N * macro, or xTaskNotify() function with the eAction parameter set to
N * eIncrement.
N *
N * ulTaskNotifyTake() can either clear the task's notification value to
N * zero on exit, in which case the notification value acts like a binary
N * semaphore, or decrement the task's notification value on exit, in which case
N * the notification value acts like a counting semaphore.
N *
N * A task can use ulTaskNotifyTake() to [optionally] block to wait for a
N * the task's notification value to be non-zero.  The task does not consume any
N * CPU time while it is in the Blocked state.
N *
N * Where as xTaskNotifyWait() will return when a notification is pending,
N * ulTaskNotifyTake() will return when the task's notification value is
N * not zero.
N *
N * See http://www.FreeRTOS.org/RTOS-task-notifications.html for details.
N *
N * @param xClearCountOnExit if xClearCountOnExit is pdFALSE then the task's
N * notification value is decremented when the function exits.  In this way the
N * notification value acts like a counting semaphore.  If xClearCountOnExit is
N * not pdFALSE then the task's notification value is cleared to zero when the
N * function exits.  In this way the notification value acts like a binary
N * semaphore.
N *
N * @param xTicksToWait The maximum amount of time that the task should wait in
N * the Blocked state for the task's notification value to be greater than zero,
N * should the count not already be greater than zero when
N * ulTaskNotifyTake() was called.  The task will not consume any processing
N * time while it is in the Blocked state.  This is specified in kernel ticks,
N * the macro pdMS_TO_TICSK( value_in_ms ) can be used to convert a time
N * specified in milliseconds to a time specified in ticks.
N *
N * @return The task's notification count before it is either cleared to zero or
N * decremented (see the xClearCountOnExit parameter).
N *
N * \defgroup ulTaskNotifyTake ulTaskNotifyTake
N * \ingroup TaskNotifications
N */
Nuint32_t ulTaskNotifyTake( BaseType_t xClearCountOnExit, TickType_t xTicksToWait ) PRIVILEGED_FUNCTION;
Xuint32_t ulTaskNotifyTake( BaseType_t xClearCountOnExit, TickType_t xTicksToWait ) ;
N
N/**
N * task. h
N * <PRE>BaseType_t xTaskNotifyStateClear( TaskHandle_t xTask );</pre>
N *
N * If the notification state of the task referenced by the handle xTask is
N * eNotified, then set the task's notification state to eNotWaitingNotification.
N * The task's notification value is not altered.  Set xTask to NULL to clear the
N * notification state of the calling task.
N *
N * @return pdTRUE if the task's notification state was set to
N * eNotWaitingNotification, otherwise pdFALSE.
N * \defgroup xTaskNotifyStateClear xTaskNotifyStateClear
N * \ingroup TaskNotifications
N */
NBaseType_t xTaskNotifyStateClear( TaskHandle_t xTask );
N
N/*-----------------------------------------------------------
N * SCHEDULER INTERNALS AVAILABLE FOR PORTING PURPOSES
N *----------------------------------------------------------*/
N
N/*
N * THIS FUNCTION MUST NOT BE USED FROM APPLICATION CODE.  IT IS ONLY
N * INTENDED FOR USE WHEN IMPLEMENTING A PORT OF THE SCHEDULER AND IS
N * AN INTERFACE WHICH IS FOR THE EXCLUSIVE USE OF THE SCHEDULER.
N *
N * Called from the real time kernel tick (either preemptive or cooperative),
N * this increments the tick count and checks if any tasks that are blocked
N * for a finite period required removing from a blocked list and placing on
N * a ready list.  If a non-zero value is returned then a context switch is
N * required because either:
N *   + A task was removed from a blocked list because its timeout had expired,
N *     or
N *   + Time slicing is in use and there is a task of equal priority to the
N *     currently running task.
N */
NBaseType_t xTaskIncrementTick( void ) PRIVILEGED_FUNCTION;
XBaseType_t xTaskIncrementTick( void ) ;
N
N/*
N * THIS FUNCTION MUST NOT BE USED FROM APPLICATION CODE.  IT IS AN
N * INTERFACE WHICH IS FOR THE EXCLUSIVE USE OF THE SCHEDULER.
N *
N * THIS FUNCTION MUST BE CALLED WITH INTERRUPTS DISABLED.
N *
N * Removes the calling task from the ready list and places it both
N * on the list of tasks waiting for a particular event, and the
N * list of delayed tasks.  The task will be removed from both lists
N * and replaced on the ready list should either the event occur (and
N * there be no higher priority tasks waiting on the same event) or
N * the delay period expires.
N *
N * The 'unordered' version replaces the event list item value with the
N * xItemValue value, and inserts the list item at the end of the list.
N *
N * The 'ordered' version uses the existing event list item value (which is the
N * owning tasks priority) to insert the list item into the event list is task
N * priority order.
N *
N * @param pxEventList The list containing tasks that are blocked waiting
N * for the event to occur.
N *
N * @param xItemValue The item value to use for the event list item when the
N * event list is not ordered by task priority.
N *
N * @param xTicksToWait The maximum amount of time that the task should wait
N * for the event to occur.  This is specified in kernel ticks,the constant
N * portTICK_PERIOD_MS can be used to convert kernel ticks into a real time
N * period.
N */
Nvoid vTaskPlaceOnEventList( List_t * const pxEventList, const TickType_t xTicksToWait ) PRIVILEGED_FUNCTION;
Xvoid vTaskPlaceOnEventList( List_t * const pxEventList, const TickType_t xTicksToWait ) ;
Nvoid vTaskPlaceOnUnorderedEventList( List_t * pxEventList, const TickType_t xItemValue, const TickType_t xTicksToWait ) PRIVILEGED_FUNCTION;
Xvoid vTaskPlaceOnUnorderedEventList( List_t * pxEventList, const TickType_t xItemValue, const TickType_t xTicksToWait ) ;
N
N/*
N * THIS FUNCTION MUST NOT BE USED FROM APPLICATION CODE.  IT IS AN
N * INTERFACE WHICH IS FOR THE EXCLUSIVE USE OF THE SCHEDULER.
N *
N * THIS FUNCTION MUST BE CALLED WITH INTERRUPTS DISABLED.
N *
N * This function performs nearly the same function as vTaskPlaceOnEventList().
N * The difference being that this function does not permit tasks to block
N * indefinitely, whereas vTaskPlaceOnEventList() does.
N *
N */
Nvoid vTaskPlaceOnEventListRestricted( List_t * const pxEventList, TickType_t xTicksToWait, const BaseType_t xWaitIndefinitely ) PRIVILEGED_FUNCTION;
Xvoid vTaskPlaceOnEventListRestricted( List_t * const pxEventList, TickType_t xTicksToWait, const BaseType_t xWaitIndefinitely ) ;
N
N/*
N * THIS FUNCTION MUST NOT BE USED FROM APPLICATION CODE.  IT IS AN
N * INTERFACE WHICH IS FOR THE EXCLUSIVE USE OF THE SCHEDULER.
N *
N * THIS FUNCTION MUST BE CALLED WITH INTERRUPTS DISABLED.
N *
N * Removes a task from both the specified event list and the list of blocked
N * tasks, and places it on a ready queue.
N *
N * xTaskRemoveFromEventList()/xTaskRemoveFromUnorderedEventList() will be called
N * if either an event occurs to unblock a task, or the block timeout period
N * expires.
N *
N * xTaskRemoveFromEventList() is used when the event list is in task priority
N * order.  It removes the list item from the head of the event list as that will
N * have the highest priority owning task of all the tasks on the event list.
N * xTaskRemoveFromUnorderedEventList() is used when the event list is not
N * ordered and the event list items hold something other than the owning tasks
N * priority.  In this case the event list item value is updated to the value
N * passed in the xItemValue parameter.
N *
N * @return pdTRUE if the task being removed has a higher priority than the task
N * making the call, otherwise pdFALSE.
N */
NBaseType_t xTaskRemoveFromEventList( const List_t * const pxEventList ) PRIVILEGED_FUNCTION;
XBaseType_t xTaskRemoveFromEventList( const List_t * const pxEventList ) ;
NBaseType_t xTaskRemoveFromUnorderedEventList( ListItem_t * pxEventListItem, const TickType_t xItemValue ) PRIVILEGED_FUNCTION;
XBaseType_t xTaskRemoveFromUnorderedEventList( ListItem_t * pxEventListItem, const TickType_t xItemValue ) ;
N
N/*
N * THIS FUNCTION MUST NOT BE USED FROM APPLICATION CODE.  IT IS ONLY
N * INTENDED FOR USE WHEN IMPLEMENTING A PORT OF THE SCHEDULER AND IS
N * AN INTERFACE WHICH IS FOR THE EXCLUSIVE USE OF THE SCHEDULER.
N *
N * Sets the pointer to the current TCB to the TCB of the highest priority task
N * that is ready to run.
N */
Nvoid vTaskSwitchContext( void ) PRIVILEGED_FUNCTION;
Xvoid vTaskSwitchContext( void ) ;
N
N/*
N * THESE FUNCTIONS MUST NOT BE USED FROM APPLICATION CODE.  THEY ARE USED BY
N * THE EVENT BITS MODULE.
N */
NTickType_t uxTaskResetEventItemValue( void ) PRIVILEGED_FUNCTION;
XTickType_t uxTaskResetEventItemValue( void ) ;
N
N/*
N * Return the handle of the calling task.
N */
NTaskHandle_t xTaskGetCurrentTaskHandle( void ) PRIVILEGED_FUNCTION;
XTaskHandle_t xTaskGetCurrentTaskHandle( void ) ;
N
N/*
N * Capture the current time status for future reference.
N */
Nvoid vTaskSetTimeOutState( TimeOut_t * const pxTimeOut ) PRIVILEGED_FUNCTION;
Xvoid vTaskSetTimeOutState( TimeOut_t * const pxTimeOut ) ;
N
N/*
N * Compare the time status now with that previously captured to see if the
N * timeout has expired.
N */
NBaseType_t xTaskCheckForTimeOut( TimeOut_t * const pxTimeOut, TickType_t * const pxTicksToWait ) PRIVILEGED_FUNCTION;
XBaseType_t xTaskCheckForTimeOut( TimeOut_t * const pxTimeOut, TickType_t * const pxTicksToWait ) ;
N
N/*
N * Shortcut used by the queue implementation to prevent unnecessary call to
N * taskYIELD();
N */
Nvoid vTaskMissedYield( void ) PRIVILEGED_FUNCTION;
Xvoid vTaskMissedYield( void ) ;
N
N/*
N * Returns the scheduler state as taskSCHEDULER_RUNNING,
N * taskSCHEDULER_NOT_STARTED or taskSCHEDULER_SUSPENDED.
N */
NBaseType_t xTaskGetSchedulerState( void ) PRIVILEGED_FUNCTION;
XBaseType_t xTaskGetSchedulerState( void ) ;
N
N/*
N * Raises the priority of the mutex holder to that of the calling task should
N * the mutex holder have a priority less than the calling task.
N */
Nvoid vTaskPriorityInherit( TaskHandle_t const pxMutexHolder ) PRIVILEGED_FUNCTION;
Xvoid vTaskPriorityInherit( TaskHandle_t const pxMutexHolder ) ;
N
N/*
N * Set the priority of a task back to its proper priority in the case that it
N * inherited a higher priority while it was holding a semaphore.
N */
NBaseType_t xTaskPriorityDisinherit( TaskHandle_t const pxMutexHolder ) PRIVILEGED_FUNCTION;
XBaseType_t xTaskPriorityDisinherit( TaskHandle_t const pxMutexHolder ) ;
N
N/*
N * Get the uxTCBNumber assigned to the task referenced by the xTask parameter.
N */
NUBaseType_t uxTaskGetTaskNumber( TaskHandle_t xTask ) PRIVILEGED_FUNCTION;
XUBaseType_t uxTaskGetTaskNumber( TaskHandle_t xTask ) ;
N
N/*
N * Set the uxTaskNumber of the task referenced by the xTask parameter to
N * uxHandle.
N */
Nvoid vTaskSetTaskNumber( TaskHandle_t xTask, const UBaseType_t uxHandle ) PRIVILEGED_FUNCTION;
Xvoid vTaskSetTaskNumber( TaskHandle_t xTask, const UBaseType_t uxHandle ) ;
N
N/*
N * Only available when configUSE_TICKLESS_IDLE is set to 1.
N * If tickless mode is being used, or a low power mode is implemented, then
N * the tick interrupt will not execute during idle periods.  When this is the
N * case, the tick count value maintained by the scheduler needs to be kept up
N * to date with the actual execution time by being skipped forward by a time
N * equal to the idle period.
N */
Nvoid vTaskStepTick( const TickType_t xTicksToJump ) PRIVILEGED_FUNCTION;
Xvoid vTaskStepTick( const TickType_t xTicksToJump ) ;
N
N/*
N * Only avilable when configUSE_TICKLESS_IDLE is set to 1.
N * Provided for use within portSUPPRESS_TICKS_AND_SLEEP() to allow the port
N * specific sleep function to determine if it is ok to proceed with the sleep,
N * and if it is ok to proceed, if it is ok to sleep indefinitely.
N *
N * This function is necessary because portSUPPRESS_TICKS_AND_SLEEP() is only
N * called with the scheduler suspended, not from within a critical section.  It
N * is therefore possible for an interrupt to request a context switch between
N * portSUPPRESS_TICKS_AND_SLEEP() and the low power mode actually being
N * entered.  eTaskConfirmSleepModeStatus() should be called from a short
N * critical section between the timer being stopped and the sleep mode being
N * entered to ensure it is ok to proceed into the sleep mode.
N */
NeSleepModeStatus eTaskConfirmSleepModeStatus( void ) PRIVILEGED_FUNCTION;
XeSleepModeStatus eTaskConfirmSleepModeStatus( void ) ;
N
N/*
N * For internal use only.  Increment the mutex held count when a mutex is
N * taken and return the handle of the task that has taken the mutex.
N */
Nvoid *pvTaskIncrementMutexHeldCount( void ) PRIVILEGED_FUNCTION;
Xvoid *pvTaskIncrementMutexHeldCount( void ) ;
N
N#ifdef __cplusplus
S}
N#endif
N#endif /* INC_TASK_H */
N
N
N
L 38 "..\..\User\main.c" 2
N#include "semphr.h"
L 1 "..\..\Freee-RTOS\include\semphr.h" 1
N/*
N    FreeRTOS V9.0.0 - Copyright (C) 2016 Real Time Engineers Ltd.
N    All rights reserved
N
N    VISIT http://www.FreeRTOS.org TO ENSURE YOU ARE USING THE LATEST VERSION.
N
N    This file is part of the FreeRTOS distribution.
N
N    FreeRTOS is free software; you can redistribute it and/or modify it under
N    the terms of the GNU General Public License (version 2) as published by the
N    Free Software Foundation >>>> AND MODIFIED BY <<<< the FreeRTOS exception.
N
N    ***************************************************************************
N    >>!   NOTE: The modification to the GPL is included to allow you to     !<<
N    >>!   distribute a combined work that includes FreeRTOS without being   !<<
N    >>!   obliged to provide the source code for proprietary components     !<<
N    >>!   outside of the FreeRTOS kernel.                                   !<<
N    ***************************************************************************
N
N    FreeRTOS is distributed in the hope that it will be useful, but WITHOUT ANY
N    WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
N    FOR A PARTICULAR PURPOSE.  Full license text is available on the following
N    link: http://www.freertos.org/a00114.html
N
N    ***************************************************************************
N     *                                                                       *
N     *    FreeRTOS provides completely free yet professionally developed,    *
N     *    robust, strictly quality controlled, supported, and cross          *
N     *    platform software that is more than just the market leader, it     *
N     *    is the industry's de facto standard.                               *
N     *                                                                       *
N     *    Help yourself get started quickly while simultaneously helping     *
N     *    to support the FreeRTOS project by purchasing a FreeRTOS           *
N     *    tutorial book, reference manual, or both:                          *
N     *    http://www.FreeRTOS.org/Documentation                              *
N     *                                                                       *
N    ***************************************************************************
N
N    http://www.FreeRTOS.org/FAQHelp.html - Having a problem?  Start by reading
N    the FAQ page "My application does not run, what could be wrong?".  Have you
N    defined configASSERT()?
N
N    http://www.FreeRTOS.org/support - In return for receiving this top quality
N    embedded software for free we request you assist our global community by
N    participating in the support forum.
N
N    http://www.FreeRTOS.org/training - Investing in training allows your team to
N    be as productive as possible as early as possible.  Now you can receive
N    FreeRTOS training directly from Richard Barry, CEO of Real Time Engineers
N    Ltd, and the world's leading authority on the world's leading RTOS.
N
N    http://www.FreeRTOS.org/plus - A selection of FreeRTOS ecosystem products,
N    including FreeRTOS+Trace - an indispensable productivity tool, a DOS
N    compatible FAT file system, and our tiny thread aware UDP/IP stack.
N
N    http://www.FreeRTOS.org/labs - Where new FreeRTOS products go to incubate.
N    Come and try FreeRTOS+TCP, our new open source TCP/IP stack for FreeRTOS.
N
N    http://www.OpenRTOS.com - Real Time Engineers ltd. license FreeRTOS to High
N    Integrity Systems ltd. to sell under the OpenRTOS brand.  Low cost OpenRTOS
N    licenses offer ticketed support, indemnification and commercial middleware.
N
N    http://www.SafeRTOS.com - High Integrity Systems also provide a safety
N    engineered and independently SIL3 certified version for use in safety and
N    mission critical applications that require provable dependability.
N
N    1 tab == 4 spaces!
N*/
N
N#ifndef SEMAPHORE_H
N#define SEMAPHORE_H
N
N#ifndef INC_FREERTOS_H
S	#error "include FreeRTOS.h" must appear in source files before "include semphr.h"
N#endif
N
N#include "queue.h"
N
Ntypedef QueueHandle_t SemaphoreHandle_t;
N
N#define semBINARY_SEMAPHORE_QUEUE_LENGTH	( ( uint8_t ) 1U )
N#define semSEMAPHORE_QUEUE_ITEM_LENGTH		( ( uint8_t ) 0U )
N#define semGIVE_BLOCK_TIME					( ( TickType_t ) 0U )
N
N
N/**
N * semphr. h
N * <pre>vSemaphoreCreateBinary( SemaphoreHandle_t xSemaphore )</pre>
N *
N * In many usage scenarios it is faster and more memory efficient to use a
N * direct to task notification in place of a binary semaphore!
N * http://www.freertos.org/RTOS-task-notifications.html
N *
N * This old vSemaphoreCreateBinary() macro is now deprecated in favour of the
N * xSemaphoreCreateBinary() function.  Note that binary semaphores created using
N * the vSemaphoreCreateBinary() macro are created in a state such that the
N * first call to 'take' the semaphore would pass, whereas binary semaphores
N * created using xSemaphoreCreateBinary() are created in a state such that the
N * the semaphore must first be 'given' before it can be 'taken'.
N *
N * <i>Macro</i> that implements a semaphore by using the existing queue mechanism.
N * The queue length is 1 as this is a binary semaphore.  The data size is 0
N * as we don't want to actually store any data - we just want to know if the
N * queue is empty or full.
N *
N * This type of semaphore can be used for pure synchronisation between tasks or
N * between an interrupt and a task.  The semaphore need not be given back once
N * obtained, so one task/interrupt can continuously 'give' the semaphore while
N * another continuously 'takes' the semaphore.  For this reason this type of
N * semaphore does not use a priority inheritance mechanism.  For an alternative
N * that does use priority inheritance see xSemaphoreCreateMutex().
N *
N * @param xSemaphore Handle to the created semaphore.  Should be of type SemaphoreHandle_t.
N *
N * Example usage:
N <pre>
N SemaphoreHandle_t xSemaphore = NULL;
N
N void vATask( void * pvParameters )
N {
N    // Semaphore cannot be used before a call to vSemaphoreCreateBinary ().
N    // This is a macro so pass the variable in directly.
N    vSemaphoreCreateBinary( xSemaphore );
N
N    if( xSemaphore != NULL )
N    {
N        // The semaphore was created successfully.
N        // The semaphore can now be used.
N    }
N }
N </pre>
N * \defgroup vSemaphoreCreateBinary vSemaphoreCreateBinary
N * \ingroup Semaphores
N */
N#if( configSUPPORT_DYNAMIC_ALLOCATION == 1)
X#if( 1 == 1)
N	#define vSemaphoreCreateBinary( xSemaphore )																							\
N		{																																	\
N			( xSemaphore ) = xQueueGenericCreate( ( UBaseType_t ) 1, semSEMAPHORE_QUEUE_ITEM_LENGTH, queueQUEUE_TYPE_BINARY_SEMAPHORE );	\
N			if( ( xSemaphore ) != NULL )																									\
N			{																																\
N				( void ) xSemaphoreGive( ( xSemaphore ) );																					\
N			}																																\
N		}
X	#define vSemaphoreCreateBinary( xSemaphore )																									{																																				( xSemaphore ) = xQueueGenericCreate( ( UBaseType_t ) 1, semSEMAPHORE_QUEUE_ITEM_LENGTH, queueQUEUE_TYPE_BINARY_SEMAPHORE );				if( ( xSemaphore ) != NULL )																												{																																				( void ) xSemaphoreGive( ( xSemaphore ) );																								}																																		}
N#endif
N
N/**
N * semphr. h
N * <pre>SemaphoreHandle_t xSemaphoreCreateBinary( void )</pre>
N *
N * Creates a new binary semaphore instance, and returns a handle by which the
N * new semaphore can be referenced.
N *
N * In many usage scenarios it is faster and more memory efficient to use a
N * direct to task notification in place of a binary semaphore!
N * http://www.freertos.org/RTOS-task-notifications.html
N *
N * Internally, within the FreeRTOS implementation, binary semaphores use a block
N * of memory, in which the semaphore structure is stored.  If a binary semaphore
N * is created using xSemaphoreCreateBinary() then the required memory is
N * automatically dynamically allocated inside the xSemaphoreCreateBinary()
N * function.  (see http://www.freertos.org/a00111.html).  If a binary semaphore
N * is created using xSemaphoreCreateBinaryStatic() then the application writer
N * must provide the memory.  xSemaphoreCreateBinaryStatic() therefore allows a
N * binary semaphore to be created without using any dynamic memory allocation.
N *
N * The old vSemaphoreCreateBinary() macro is now deprecated in favour of this
N * xSemaphoreCreateBinary() function.  Note that binary semaphores created using
N * the vSemaphoreCreateBinary() macro are created in a state such that the
N * first call to 'take' the semaphore would pass, whereas binary semaphores
N * created using xSemaphoreCreateBinary() are created in a state such that the
N * the semaphore must first be 'given' before it can be 'taken'.
N *
N * This type of semaphore can be used for pure synchronisation between tasks or
N * between an interrupt and a task.  The semaphore need not be given back once
N * obtained, so one task/interrupt can continuously 'give' the semaphore while
N * another continuously 'takes' the semaphore.  For this reason this type of
N * semaphore does not use a priority inheritance mechanism.  For an alternative
N * that does use priority inheritance see xSemaphoreCreateMutex().
N *
N * @return Handle to the created semaphore, or NULL if the memory required to
N * hold the semaphore's data structures could not be allocated.
N *
N * Example usage:
N <pre>
N SemaphoreHandle_t xSemaphore = NULL;
N
N void vATask( void * pvParameters )
N {
N    // Semaphore cannot be used before a call to xSemaphoreCreateBinary().
N    // This is a macro so pass the variable in directly.
N    xSemaphore = xSemaphoreCreateBinary();
N
N    if( xSemaphore != NULL )
N    {
N        // The semaphore was created successfully.
N        // The semaphore can now be used.
N    }
N }
N </pre>
N * \defgroup xSemaphoreCreateBinary xSemaphoreCreateBinary
N * \ingroup Semaphores
N */
N#if( configSUPPORT_DYNAMIC_ALLOCATION == 1 )
X#if( 1 == 1 )
N	#define xSemaphoreCreateBinary() xQueueGenericCreate( ( UBaseType_t ) 1, semSEMAPHORE_QUEUE_ITEM_LENGTH, queueQUEUE_TYPE_BINARY_SEMAPHORE )
N#endif
N
N/**
N * semphr. h
N * <pre>SemaphoreHandle_t xSemaphoreCreateBinaryStatic( StaticSemaphore_t *pxSemaphoreBuffer )</pre>
N *
N * Creates a new binary semaphore instance, and returns a handle by which the
N * new semaphore can be referenced.
N *
N * NOTE: In many usage scenarios it is faster and more memory efficient to use a
N * direct to task notification in place of a binary semaphore!
N * http://www.freertos.org/RTOS-task-notifications.html
N *
N * Internally, within the FreeRTOS implementation, binary semaphores use a block
N * of memory, in which the semaphore structure is stored.  If a binary semaphore
N * is created using xSemaphoreCreateBinary() then the required memory is
N * automatically dynamically allocated inside the xSemaphoreCreateBinary()
N * function.  (see http://www.freertos.org/a00111.html).  If a binary semaphore
N * is created using xSemaphoreCreateBinaryStatic() then the application writer
N * must provide the memory.  xSemaphoreCreateBinaryStatic() therefore allows a
N * binary semaphore to be created without using any dynamic memory allocation.
N *
N * This type of semaphore can be used for pure synchronisation between tasks or
N * between an interrupt and a task.  The semaphore need not be given back once
N * obtained, so one task/interrupt can continuously 'give' the semaphore while
N * another continuously 'takes' the semaphore.  For this reason this type of
N * semaphore does not use a priority inheritance mechanism.  For an alternative
N * that does use priority inheritance see xSemaphoreCreateMutex().
N *
N * @param pxSemaphoreBuffer Must point to a variable of type StaticSemaphore_t,
N * which will then be used to hold the semaphore's data structure, removing the
N * need for the memory to be allocated dynamically.
N *
N * @return If the semaphore is created then a handle to the created semaphore is
N * returned.  If pxSemaphoreBuffer is NULL then NULL is returned.
N *
N * Example usage:
N <pre>
N SemaphoreHandle_t xSemaphore = NULL;
N StaticSemaphore_t xSemaphoreBuffer;
N
N void vATask( void * pvParameters )
N {
N    // Semaphore cannot be used before a call to xSemaphoreCreateBinary().
N    // The semaphore's data structures will be placed in the xSemaphoreBuffer
N    // variable, the address of which is passed into the function.  The
N    // function's parameter is not NULL, so the function will not attempt any
N    // dynamic memory allocation, and therefore the function will not return
N    // return NULL.
N    xSemaphore = xSemaphoreCreateBinary( &xSemaphoreBuffer );
N
N    // Rest of task code goes here.
N }
N </pre>
N * \defgroup xSemaphoreCreateBinaryStatic xSemaphoreCreateBinaryStatic
N * \ingroup Semaphores
N */
N#if( configSUPPORT_STATIC_ALLOCATION == 1 )
X#if( 0 == 1 )
S	#define xSemaphoreCreateBinaryStatic( pxStaticSemaphore ) xQueueGenericCreateStatic( ( UBaseType_t ) 1, semSEMAPHORE_QUEUE_ITEM_LENGTH, NULL, pxStaticSemaphore, queueQUEUE_TYPE_BINARY_SEMAPHORE )
N#endif /* configSUPPORT_STATIC_ALLOCATION */
N
N/**
N * semphr. h
N * <pre>xSemaphoreTake(
N *                   SemaphoreHandle_t xSemaphore,
N *                   TickType_t xBlockTime
N *               )</pre>
N *
N * <i>Macro</i> to obtain a semaphore.  The semaphore must have previously been
N * created with a call to xSemaphoreCreateBinary(), xSemaphoreCreateMutex() or
N * xSemaphoreCreateCounting().
N *
N * @param xSemaphore A handle to the semaphore being taken - obtained when
N * the semaphore was created.
N *
N * @param xBlockTime The time in ticks to wait for the semaphore to become
N * available.  The macro portTICK_PERIOD_MS can be used to convert this to a
N * real time.  A block time of zero can be used to poll the semaphore.  A block
N * time of portMAX_DELAY can be used to block indefinitely (provided
N * INCLUDE_vTaskSuspend is set to 1 in FreeRTOSConfig.h).
N *
N * @return pdTRUE if the semaphore was obtained.  pdFALSE
N * if xBlockTime expired without the semaphore becoming available.
N *
N * Example usage:
N <pre>
N SemaphoreHandle_t xSemaphore = NULL;
N
N // A task that creates a semaphore.
N void vATask( void * pvParameters )
N {
N    // Create the semaphore to guard a shared resource.
N    xSemaphore = xSemaphoreCreateBinary();
N }
N
N // A task that uses the semaphore.
N void vAnotherTask( void * pvParameters )
N {
N    // ... Do other things.
N
N    if( xSemaphore != NULL )
N    {
N        // See if we can obtain the semaphore.  If the semaphore is not available
N        // wait 10 ticks to see if it becomes free.
N        if( xSemaphoreTake( xSemaphore, ( TickType_t ) 10 ) == pdTRUE )
N        {
N            // We were able to obtain the semaphore and can now access the
N            // shared resource.
N
N            // ...
N
N            // We have finished accessing the shared resource.  Release the
N            // semaphore.
N            xSemaphoreGive( xSemaphore );
N        }
N        else
N        {
N            // We could not obtain the semaphore and can therefore not access
N            // the shared resource safely.
N        }
N    }
N }
N </pre>
N * \defgroup xSemaphoreTake xSemaphoreTake
N * \ingroup Semaphores
N */
N#define xSemaphoreTake( xSemaphore, xBlockTime )		xQueueGenericReceive( ( QueueHandle_t ) ( xSemaphore ), NULL, ( xBlockTime ), pdFALSE )
N
N/**
N * semphr. h
N * xSemaphoreTakeRecursive(
N *                          SemaphoreHandle_t xMutex,
N *                          TickType_t xBlockTime
N *                        )
N *
N * <i>Macro</i> to recursively obtain, or 'take', a mutex type semaphore.
N * The mutex must have previously been created using a call to
N * xSemaphoreCreateRecursiveMutex();
N *
N * configUSE_RECURSIVE_MUTEXES must be set to 1 in FreeRTOSConfig.h for this
N * macro to be available.
N *
N * This macro must not be used on mutexes created using xSemaphoreCreateMutex().
N *
N * A mutex used recursively can be 'taken' repeatedly by the owner. The mutex
N * doesn't become available again until the owner has called
N * xSemaphoreGiveRecursive() for each successful 'take' request.  For example,
N * if a task successfully 'takes' the same mutex 5 times then the mutex will
N * not be available to any other task until it has also  'given' the mutex back
N * exactly five times.
N *
N * @param xMutex A handle to the mutex being obtained.  This is the
N * handle returned by xSemaphoreCreateRecursiveMutex();
N *
N * @param xBlockTime The time in ticks to wait for the semaphore to become
N * available.  The macro portTICK_PERIOD_MS can be used to convert this to a
N * real time.  A block time of zero can be used to poll the semaphore.  If
N * the task already owns the semaphore then xSemaphoreTakeRecursive() will
N * return immediately no matter what the value of xBlockTime.
N *
N * @return pdTRUE if the semaphore was obtained.  pdFALSE if xBlockTime
N * expired without the semaphore becoming available.
N *
N * Example usage:
N <pre>
N SemaphoreHandle_t xMutex = NULL;
N
N // A task that creates a mutex.
N void vATask( void * pvParameters )
N {
N    // Create the mutex to guard a shared resource.
N    xMutex = xSemaphoreCreateRecursiveMutex();
N }
N
N // A task that uses the mutex.
N void vAnotherTask( void * pvParameters )
N {
N    // ... Do other things.
N
N    if( xMutex != NULL )
N    {
N        // See if we can obtain the mutex.  If the mutex is not available
N        // wait 10 ticks to see if it becomes free.
N        if( xSemaphoreTakeRecursive( xSemaphore, ( TickType_t ) 10 ) == pdTRUE )
N        {
N            // We were able to obtain the mutex and can now access the
N            // shared resource.
N
N            // ...
N            // For some reason due to the nature of the code further calls to
N			// xSemaphoreTakeRecursive() are made on the same mutex.  In real
N			// code these would not be just sequential calls as this would make
N			// no sense.  Instead the calls are likely to be buried inside
N			// a more complex call structure.
N            xSemaphoreTakeRecursive( xMutex, ( TickType_t ) 10 );
N            xSemaphoreTakeRecursive( xMutex, ( TickType_t ) 10 );
N
N            // The mutex has now been 'taken' three times, so will not be
N			// available to another task until it has also been given back
N			// three times.  Again it is unlikely that real code would have
N			// these calls sequentially, but instead buried in a more complex
N			// call structure.  This is just for illustrative purposes.
N            xSemaphoreGiveRecursive( xMutex );
N			xSemaphoreGiveRecursive( xMutex );
N			xSemaphoreGiveRecursive( xMutex );
N
N			// Now the mutex can be taken by other tasks.
N        }
N        else
N        {
N            // We could not obtain the mutex and can therefore not access
N            // the shared resource safely.
N        }
N    }
N }
N </pre>
N * \defgroup xSemaphoreTakeRecursive xSemaphoreTakeRecursive
N * \ingroup Semaphores
N */
N#if( configUSE_RECURSIVE_MUTEXES == 1 )
X#if( 0 == 1 )
S	#define xSemaphoreTakeRecursive( xMutex, xBlockTime )	xQueueTakeMutexRecursive( ( xMutex ), ( xBlockTime ) )
N#endif
N
N/**
N * semphr. h
N * <pre>xSemaphoreGive( SemaphoreHandle_t xSemaphore )</pre>
N *
N * <i>Macro</i> to release a semaphore.  The semaphore must have previously been
N * created with a call to xSemaphoreCreateBinary(), xSemaphoreCreateMutex() or
N * xSemaphoreCreateCounting(). and obtained using sSemaphoreTake().
N *
N * This macro must not be used from an ISR.  See xSemaphoreGiveFromISR () for
N * an alternative which can be used from an ISR.
N *
N * This macro must also not be used on semaphores created using
N * xSemaphoreCreateRecursiveMutex().
N *
N * @param xSemaphore A handle to the semaphore being released.  This is the
N * handle returned when the semaphore was created.
N *
N * @return pdTRUE if the semaphore was released.  pdFALSE if an error occurred.
N * Semaphores are implemented using queues.  An error can occur if there is
N * no space on the queue to post a message - indicating that the
N * semaphore was not first obtained correctly.
N *
N * Example usage:
N <pre>
N SemaphoreHandle_t xSemaphore = NULL;
N
N void vATask( void * pvParameters )
N {
N    // Create the semaphore to guard a shared resource.
N    xSemaphore = vSemaphoreCreateBinary();
N
N    if( xSemaphore != NULL )
N    {
N        if( xSemaphoreGive( xSemaphore ) != pdTRUE )
N        {
N            // We would expect this call to fail because we cannot give
N            // a semaphore without first "taking" it!
N        }
N
N        // Obtain the semaphore - don't block if the semaphore is not
N        // immediately available.
N        if( xSemaphoreTake( xSemaphore, ( TickType_t ) 0 ) )
N        {
N            // We now have the semaphore and can access the shared resource.
N
N            // ...
N
N            // We have finished accessing the shared resource so can free the
N            // semaphore.
N            if( xSemaphoreGive( xSemaphore ) != pdTRUE )
N            {
N                // We would not expect this call to fail because we must have
N                // obtained the semaphore to get here.
N            }
N        }
N    }
N }
N </pre>
N * \defgroup xSemaphoreGive xSemaphoreGive
N * \ingroup Semaphores
N */
N#define xSemaphoreGive( xSemaphore )		xQueueGenericSend( ( QueueHandle_t ) ( xSemaphore ), NULL, semGIVE_BLOCK_TIME, queueSEND_TO_BACK )
N
N/**
N * semphr. h
N * <pre>xSemaphoreGiveRecursive( SemaphoreHandle_t xMutex )</pre>
N *
N * <i>Macro</i> to recursively release, or 'give', a mutex type semaphore.
N * The mutex must have previously been created using a call to
N * xSemaphoreCreateRecursiveMutex();
N *
N * configUSE_RECURSIVE_MUTEXES must be set to 1 in FreeRTOSConfig.h for this
N * macro to be available.
N *
N * This macro must not be used on mutexes created using xSemaphoreCreateMutex().
N *
N * A mutex used recursively can be 'taken' repeatedly by the owner. The mutex
N * doesn't become available again until the owner has called
N * xSemaphoreGiveRecursive() for each successful 'take' request.  For example,
N * if a task successfully 'takes' the same mutex 5 times then the mutex will
N * not be available to any other task until it has also  'given' the mutex back
N * exactly five times.
N *
N * @param xMutex A handle to the mutex being released, or 'given'.  This is the
N * handle returned by xSemaphoreCreateMutex();
N *
N * @return pdTRUE if the semaphore was given.
N *
N * Example usage:
N <pre>
N SemaphoreHandle_t xMutex = NULL;
N
N // A task that creates a mutex.
N void vATask( void * pvParameters )
N {
N    // Create the mutex to guard a shared resource.
N    xMutex = xSemaphoreCreateRecursiveMutex();
N }
N
N // A task that uses the mutex.
N void vAnotherTask( void * pvParameters )
N {
N    // ... Do other things.
N
N    if( xMutex != NULL )
N    {
N        // See if we can obtain the mutex.  If the mutex is not available
N        // wait 10 ticks to see if it becomes free.
N        if( xSemaphoreTakeRecursive( xMutex, ( TickType_t ) 10 ) == pdTRUE )
N        {
N            // We were able to obtain the mutex and can now access the
N            // shared resource.
N
N            // ...
N            // For some reason due to the nature of the code further calls to
N			// xSemaphoreTakeRecursive() are made on the same mutex.  In real
N			// code these would not be just sequential calls as this would make
N			// no sense.  Instead the calls are likely to be buried inside
N			// a more complex call structure.
N            xSemaphoreTakeRecursive( xMutex, ( TickType_t ) 10 );
N            xSemaphoreTakeRecursive( xMutex, ( TickType_t ) 10 );
N
N            // The mutex has now been 'taken' three times, so will not be
N			// available to another task until it has also been given back
N			// three times.  Again it is unlikely that real code would have
N			// these calls sequentially, it would be more likely that the calls
N			// to xSemaphoreGiveRecursive() would be called as a call stack
N			// unwound.  This is just for demonstrative purposes.
N            xSemaphoreGiveRecursive( xMutex );
N			xSemaphoreGiveRecursive( xMutex );
N			xSemaphoreGiveRecursive( xMutex );
N
N			// Now the mutex can be taken by other tasks.
N        }
N        else
N        {
N            // We could not obtain the mutex and can therefore not access
N            // the shared resource safely.
N        }
N    }
N }
N </pre>
N * \defgroup xSemaphoreGiveRecursive xSemaphoreGiveRecursive
N * \ingroup Semaphores
N */
N#if( configUSE_RECURSIVE_MUTEXES == 1 )
X#if( 0 == 1 )
S	#define xSemaphoreGiveRecursive( xMutex )	xQueueGiveMutexRecursive( ( xMutex ) )
N#endif
N
N/**
N * semphr. h
N * <pre>
N xSemaphoreGiveFromISR(
N                          SemaphoreHandle_t xSemaphore,
N                          BaseType_t *pxHigherPriorityTaskWoken
N                      )</pre>
N *
N * <i>Macro</i> to  release a semaphore.  The semaphore must have previously been
N * created with a call to xSemaphoreCreateBinary() or xSemaphoreCreateCounting().
N *
N * Mutex type semaphores (those created using a call to xSemaphoreCreateMutex())
N * must not be used with this macro.
N *
N * This macro can be used from an ISR.
N *
N * @param xSemaphore A handle to the semaphore being released.  This is the
N * handle returned when the semaphore was created.
N *
N * @param pxHigherPriorityTaskWoken xSemaphoreGiveFromISR() will set
N * *pxHigherPriorityTaskWoken to pdTRUE if giving the semaphore caused a task
N * to unblock, and the unblocked task has a priority higher than the currently
N * running task.  If xSemaphoreGiveFromISR() sets this value to pdTRUE then
N * a context switch should be requested before the interrupt is exited.
N *
N * @return pdTRUE if the semaphore was successfully given, otherwise errQUEUE_FULL.
N *
N * Example usage:
N <pre>
N \#define LONG_TIME 0xffff
N \#define TICKS_TO_WAIT	10
N SemaphoreHandle_t xSemaphore = NULL;
N
N // Repetitive task.
N void vATask( void * pvParameters )
N {
N    for( ;; )
N    {
N        // We want this task to run every 10 ticks of a timer.  The semaphore
N        // was created before this task was started.
N
N        // Block waiting for the semaphore to become available.
N        if( xSemaphoreTake( xSemaphore, LONG_TIME ) == pdTRUE )
N        {
N            // It is time to execute.
N
N            // ...
N
N            // We have finished our task.  Return to the top of the loop where
N            // we will block on the semaphore until it is time to execute
N            // again.  Note when using the semaphore for synchronisation with an
N			// ISR in this manner there is no need to 'give' the semaphore back.
N        }
N    }
N }
N
N // Timer ISR
N void vTimerISR( void * pvParameters )
N {
N static uint8_t ucLocalTickCount = 0;
N static BaseType_t xHigherPriorityTaskWoken;
N
N    // A timer tick has occurred.
N
N    // ... Do other time functions.
N
N    // Is it time for vATask () to run?
N	xHigherPriorityTaskWoken = pdFALSE;
N    ucLocalTickCount++;
N    if( ucLocalTickCount >= TICKS_TO_WAIT )
N    {
N        // Unblock the task by releasing the semaphore.
N        xSemaphoreGiveFromISR( xSemaphore, &xHigherPriorityTaskWoken );
N
N        // Reset the count so we release the semaphore again in 10 ticks time.
N        ucLocalTickCount = 0;
N    }
N
N    if( xHigherPriorityTaskWoken != pdFALSE )
N    {
N        // We can force a context switch here.  Context switching from an
N        // ISR uses port specific syntax.  Check the demo task for your port
N        // to find the syntax required.
N    }
N }
N </pre>
N * \defgroup xSemaphoreGiveFromISR xSemaphoreGiveFromISR
N * \ingroup Semaphores
N */
N#define xSemaphoreGiveFromISR( xSemaphore, pxHigherPriorityTaskWoken )	xQueueGiveFromISR( ( QueueHandle_t ) ( xSemaphore ), ( pxHigherPriorityTaskWoken ) )
N
N/**
N * semphr. h
N * <pre>
N xSemaphoreTakeFromISR(
N                          SemaphoreHandle_t xSemaphore,
N                          BaseType_t *pxHigherPriorityTaskWoken
N                      )</pre>
N *
N * <i>Macro</i> to  take a semaphore from an ISR.  The semaphore must have
N * previously been created with a call to xSemaphoreCreateBinary() or
N * xSemaphoreCreateCounting().
N *
N * Mutex type semaphores (those created using a call to xSemaphoreCreateMutex())
N * must not be used with this macro.
N *
N * This macro can be used from an ISR, however taking a semaphore from an ISR
N * is not a common operation.  It is likely to only be useful when taking a
N * counting semaphore when an interrupt is obtaining an object from a resource
N * pool (when the semaphore count indicates the number of resources available).
N *
N * @param xSemaphore A handle to the semaphore being taken.  This is the
N * handle returned when the semaphore was created.
N *
N * @param pxHigherPriorityTaskWoken xSemaphoreTakeFromISR() will set
N * *pxHigherPriorityTaskWoken to pdTRUE if taking the semaphore caused a task
N * to unblock, and the unblocked task has a priority higher than the currently
N * running task.  If xSemaphoreTakeFromISR() sets this value to pdTRUE then
N * a context switch should be requested before the interrupt is exited.
N *
N * @return pdTRUE if the semaphore was successfully taken, otherwise
N * pdFALSE
N */
N#define xSemaphoreTakeFromISR( xSemaphore, pxHigherPriorityTaskWoken )	xQueueReceiveFromISR( ( QueueHandle_t ) ( xSemaphore ), NULL, ( pxHigherPriorityTaskWoken ) )
N
N/**
N * semphr. h
N * <pre>SemaphoreHandle_t xSemaphoreCreateMutex( void )</pre>
N *
N * Creates a new mutex type semaphore instance, and returns a handle by which
N * the new mutex can be referenced.
N *
N * Internally, within the FreeRTOS implementation, mutex semaphores use a block
N * of memory, in which the mutex structure is stored.  If a mutex is created
N * using xSemaphoreCreateMutex() then the required memory is automatically
N * dynamically allocated inside the xSemaphoreCreateMutex() function.  (see
N * http://www.freertos.org/a00111.html).  If a mutex is created using
N * xSemaphoreCreateMutexStatic() then the application writer must provided the
N * memory.  xSemaphoreCreateMutexStatic() therefore allows a mutex to be created
N * without using any dynamic memory allocation.
N *
N * Mutexes created using this function can be accessed using the xSemaphoreTake()
N * and xSemaphoreGive() macros.  The xSemaphoreTakeRecursive() and
N * xSemaphoreGiveRecursive() macros must not be used.
N *
N * This type of semaphore uses a priority inheritance mechanism so a task
N * 'taking' a semaphore MUST ALWAYS 'give' the semaphore back once the
N * semaphore it is no longer required.
N *
N * Mutex type semaphores cannot be used from within interrupt service routines.
N *
N * See xSemaphoreCreateBinary() for an alternative implementation that can be
N * used for pure synchronisation (where one task or interrupt always 'gives' the
N * semaphore and another always 'takes' the semaphore) and from within interrupt
N * service routines.
N *
N * @return If the mutex was successfully created then a handle to the created
N * semaphore is returned.  If there was not enough heap to allocate the mutex
N * data structures then NULL is returned.
N *
N * Example usage:
N <pre>
N SemaphoreHandle_t xSemaphore;
N
N void vATask( void * pvParameters )
N {
N    // Semaphore cannot be used before a call to xSemaphoreCreateMutex().
N    // This is a macro so pass the variable in directly.
N    xSemaphore = xSemaphoreCreateMutex();
N
N    if( xSemaphore != NULL )
N    {
N        // The semaphore was created successfully.
N        // The semaphore can now be used.
N    }
N }
N </pre>
N * \defgroup xSemaphoreCreateMutex xSemaphoreCreateMutex
N * \ingroup Semaphores
N */
N#if( configSUPPORT_DYNAMIC_ALLOCATION == 1 )
X#if( 1 == 1 )
N	#define xSemaphoreCreateMutex() xQueueCreateMutex( queueQUEUE_TYPE_MUTEX )
N#endif
N
N/**
N * semphr. h
N * <pre>SemaphoreHandle_t xSemaphoreCreateMutexStatic( StaticSemaphore_t *pxMutexBuffer )</pre>
N *
N * Creates a new mutex type semaphore instance, and returns a handle by which
N * the new mutex can be referenced.
N *
N * Internally, within the FreeRTOS implementation, mutex semaphores use a block
N * of memory, in which the mutex structure is stored.  If a mutex is created
N * using xSemaphoreCreateMutex() then the required memory is automatically
N * dynamically allocated inside the xSemaphoreCreateMutex() function.  (see
N * http://www.freertos.org/a00111.html).  If a mutex is created using
N * xSemaphoreCreateMutexStatic() then the application writer must provided the
N * memory.  xSemaphoreCreateMutexStatic() therefore allows a mutex to be created
N * without using any dynamic memory allocation.
N *
N * Mutexes created using this function can be accessed using the xSemaphoreTake()
N * and xSemaphoreGive() macros.  The xSemaphoreTakeRecursive() and
N * xSemaphoreGiveRecursive() macros must not be used.
N *
N * This type of semaphore uses a priority inheritance mechanism so a task
N * 'taking' a semaphore MUST ALWAYS 'give' the semaphore back once the
N * semaphore it is no longer required.
N *
N * Mutex type semaphores cannot be used from within interrupt service routines.
N *
N * See xSemaphoreCreateBinary() for an alternative implementation that can be
N * used for pure synchronisation (where one task or interrupt always 'gives' the
N * semaphore and another always 'takes' the semaphore) and from within interrupt
N * service routines.
N *
N * @param pxMutexBuffer Must point to a variable of type StaticSemaphore_t,
N * which will be used to hold the mutex's data structure, removing the need for
N * the memory to be allocated dynamically.
N *
N * @return If the mutex was successfully created then a handle to the created
N * mutex is returned.  If pxMutexBuffer was NULL then NULL is returned.
N *
N * Example usage:
N <pre>
N SemaphoreHandle_t xSemaphore;
N StaticSemaphore_t xMutexBuffer;
N
N void vATask( void * pvParameters )
N {
N    // A mutex cannot be used before it has been created.  xMutexBuffer is
N    // into xSemaphoreCreateMutexStatic() so no dynamic memory allocation is
N    // attempted.
N    xSemaphore = xSemaphoreCreateMutexStatic( &xMutexBuffer );
N
N    // As no dynamic memory allocation was performed, xSemaphore cannot be NULL,
N    // so there is no need to check it.
N }
N </pre>
N * \defgroup xSemaphoreCreateMutexStatic xSemaphoreCreateMutexStatic
N * \ingroup Semaphores
N */
N #if( configSUPPORT_STATIC_ALLOCATION == 1 )
X #if( 0 == 1 )
S	#define xSemaphoreCreateMutexStatic( pxMutexBuffer ) xQueueCreateMutexStatic( queueQUEUE_TYPE_MUTEX, ( pxMutexBuffer ) )
N#endif /* configSUPPORT_STATIC_ALLOCATION */
N
N
N/**
N * semphr. h
N * <pre>SemaphoreHandle_t xSemaphoreCreateRecursiveMutex( void )</pre>
N *
N * Creates a new recursive mutex type semaphore instance, and returns a handle
N * by which the new recursive mutex can be referenced.
N *
N * Internally, within the FreeRTOS implementation, recursive mutexs use a block
N * of memory, in which the mutex structure is stored.  If a recursive mutex is
N * created using xSemaphoreCreateRecursiveMutex() then the required memory is
N * automatically dynamically allocated inside the
N * xSemaphoreCreateRecursiveMutex() function.  (see
N * http://www.freertos.org/a00111.html).  If a recursive mutex is created using
N * xSemaphoreCreateRecursiveMutexStatic() then the application writer must
N * provide the memory that will get used by the mutex.
N * xSemaphoreCreateRecursiveMutexStatic() therefore allows a recursive mutex to
N * be created without using any dynamic memory allocation.
N *
N * Mutexes created using this macro can be accessed using the
N * xSemaphoreTakeRecursive() and xSemaphoreGiveRecursive() macros.  The
N * xSemaphoreTake() and xSemaphoreGive() macros must not be used.
N *
N * A mutex used recursively can be 'taken' repeatedly by the owner. The mutex
N * doesn't become available again until the owner has called
N * xSemaphoreGiveRecursive() for each successful 'take' request.  For example,
N * if a task successfully 'takes' the same mutex 5 times then the mutex will
N * not be available to any other task until it has also  'given' the mutex back
N * exactly five times.
N *
N * This type of semaphore uses a priority inheritance mechanism so a task
N * 'taking' a semaphore MUST ALWAYS 'give' the semaphore back once the
N * semaphore it is no longer required.
N *
N * Mutex type semaphores cannot be used from within interrupt service routines.
N *
N * See xSemaphoreCreateBinary() for an alternative implementation that can be
N * used for pure synchronisation (where one task or interrupt always 'gives' the
N * semaphore and another always 'takes' the semaphore) and from within interrupt
N * service routines.
N *
N * @return xSemaphore Handle to the created mutex semaphore.  Should be of type
N * SemaphoreHandle_t.
N *
N * Example usage:
N <pre>
N SemaphoreHandle_t xSemaphore;
N
N void vATask( void * pvParameters )
N {
N    // Semaphore cannot be used before a call to xSemaphoreCreateMutex().
N    // This is a macro so pass the variable in directly.
N    xSemaphore = xSemaphoreCreateRecursiveMutex();
N
N    if( xSemaphore != NULL )
N    {
N        // The semaphore was created successfully.
N        // The semaphore can now be used.
N    }
N }
N </pre>
N * \defgroup xSemaphoreCreateRecursiveMutex xSemaphoreCreateRecursiveMutex
N * \ingroup Semaphores
N */
N#if( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configUSE_RECURSIVE_MUTEXES == 1 ) )
X#if( ( 1 == 1 ) && ( 0 == 1 ) )
S	#define xSemaphoreCreateRecursiveMutex() xQueueCreateMutex( queueQUEUE_TYPE_RECURSIVE_MUTEX )
N#endif
N
N/**
N * semphr. h
N * <pre>SemaphoreHandle_t xSemaphoreCreateRecursiveMutexStatic( StaticSemaphore_t *pxMutexBuffer )</pre>
N *
N * Creates a new recursive mutex type semaphore instance, and returns a handle
N * by which the new recursive mutex can be referenced.
N *
N * Internally, within the FreeRTOS implementation, recursive mutexs use a block
N * of memory, in which the mutex structure is stored.  If a recursive mutex is
N * created using xSemaphoreCreateRecursiveMutex() then the required memory is
N * automatically dynamically allocated inside the
N * xSemaphoreCreateRecursiveMutex() function.  (see
N * http://www.freertos.org/a00111.html).  If a recursive mutex is created using
N * xSemaphoreCreateRecursiveMutexStatic() then the application writer must
N * provide the memory that will get used by the mutex.
N * xSemaphoreCreateRecursiveMutexStatic() therefore allows a recursive mutex to
N * be created without using any dynamic memory allocation.
N *
N * Mutexes created using this macro can be accessed using the
N * xSemaphoreTakeRecursive() and xSemaphoreGiveRecursive() macros.  The
N * xSemaphoreTake() and xSemaphoreGive() macros must not be used.
N *
N * A mutex used recursively can be 'taken' repeatedly by the owner. The mutex
N * doesn't become available again until the owner has called
N * xSemaphoreGiveRecursive() for each successful 'take' request.  For example,
N * if a task successfully 'takes' the same mutex 5 times then the mutex will
N * not be available to any other task until it has also  'given' the mutex back
N * exactly five times.
N *
N * This type of semaphore uses a priority inheritance mechanism so a task
N * 'taking' a semaphore MUST ALWAYS 'give' the semaphore back once the
N * semaphore it is no longer required.
N *
N * Mutex type semaphores cannot be used from within interrupt service routines.
N *
N * See xSemaphoreCreateBinary() for an alternative implementation that can be
N * used for pure synchronisation (where one task or interrupt always 'gives' the
N * semaphore and another always 'takes' the semaphore) and from within interrupt
N * service routines.
N *
N * @param pxMutexBuffer Must point to a variable of type StaticSemaphore_t,
N * which will then be used to hold the recursive mutex's data structure,
N * removing the need for the memory to be allocated dynamically.
N *
N * @return If the recursive mutex was successfully created then a handle to the
N * created recursive mutex is returned.  If pxMutexBuffer was NULL then NULL is
N * returned.
N *
N * Example usage:
N <pre>
N SemaphoreHandle_t xSemaphore;
N StaticSemaphore_t xMutexBuffer;
N
N void vATask( void * pvParameters )
N {
N    // A recursive semaphore cannot be used before it is created.  Here a
N    // recursive mutex is created using xSemaphoreCreateRecursiveMutexStatic().
N    // The address of xMutexBuffer is passed into the function, and will hold
N    // the mutexes data structures - so no dynamic memory allocation will be
N    // attempted.
N    xSemaphore = xSemaphoreCreateRecursiveMutexStatic( &xMutexBuffer );
N
N    // As no dynamic memory allocation was performed, xSemaphore cannot be NULL,
N    // so there is no need to check it.
N }
N </pre>
N * \defgroup xSemaphoreCreateRecursiveMutexStatic xSemaphoreCreateRecursiveMutexStatic
N * \ingroup Semaphores
N */
N#if( ( configSUPPORT_STATIC_ALLOCATION == 1 ) && ( configUSE_RECURSIVE_MUTEXES == 1 ) )
X#if( ( 0 == 1 ) && ( 0 == 1 ) )
S	#define xSemaphoreCreateRecursiveMutexStatic( pxStaticSemaphore ) xQueueCreateMutexStatic( queueQUEUE_TYPE_RECURSIVE_MUTEX, pxStaticSemaphore )
N#endif /* configSUPPORT_STATIC_ALLOCATION */
N
N/**
N * semphr. h
N * <pre>SemaphoreHandle_t xSemaphoreCreateCounting( UBaseType_t uxMaxCount, UBaseType_t uxInitialCount )</pre>
N *
N * Creates a new counting semaphore instance, and returns a handle by which the
N * new counting semaphore can be referenced.
N *
N * In many usage scenarios it is faster and more memory efficient to use a
N * direct to task notification in place of a counting semaphore!
N * http://www.freertos.org/RTOS-task-notifications.html
N *
N * Internally, within the FreeRTOS implementation, counting semaphores use a
N * block of memory, in which the counting semaphore structure is stored.  If a
N * counting semaphore is created using xSemaphoreCreateCounting() then the
N * required memory is automatically dynamically allocated inside the
N * xSemaphoreCreateCounting() function.  (see
N * http://www.freertos.org/a00111.html).  If a counting semaphore is created
N * using xSemaphoreCreateCountingStatic() then the application writer can
N * instead optionally provide the memory that will get used by the counting
N * semaphore.  xSemaphoreCreateCountingStatic() therefore allows a counting
N * semaphore to be created without using any dynamic memory allocation.
N *
N * Counting semaphores are typically used for two things:
N *
N * 1) Counting events.
N *
N *    In this usage scenario an event handler will 'give' a semaphore each time
N *    an event occurs (incrementing the semaphore count value), and a handler
N *    task will 'take' a semaphore each time it processes an event
N *    (decrementing the semaphore count value).  The count value is therefore
N *    the difference between the number of events that have occurred and the
N *    number that have been processed.  In this case it is desirable for the
N *    initial count value to be zero.
N *
N * 2) Resource management.
N *
N *    In this usage scenario the count value indicates the number of resources
N *    available.  To obtain control of a resource a task must first obtain a
N *    semaphore - decrementing the semaphore count value.  When the count value
N *    reaches zero there are no free resources.  When a task finishes with the
N *    resource it 'gives' the semaphore back - incrementing the semaphore count
N *    value.  In this case it is desirable for the initial count value to be
N *    equal to the maximum count value, indicating that all resources are free.
N *
N * @param uxMaxCount The maximum count value that can be reached.  When the
N *        semaphore reaches this value it can no longer be 'given'.
N *
N * @param uxInitialCount The count value assigned to the semaphore when it is
N *        created.
N *
N * @return Handle to the created semaphore.  Null if the semaphore could not be
N *         created.
N *
N * Example usage:
N <pre>
N SemaphoreHandle_t xSemaphore;
N
N void vATask( void * pvParameters )
N {
N SemaphoreHandle_t xSemaphore = NULL;
N
N    // Semaphore cannot be used before a call to xSemaphoreCreateCounting().
N    // The max value to which the semaphore can count should be 10, and the
N    // initial value assigned to the count should be 0.
N    xSemaphore = xSemaphoreCreateCounting( 10, 0 );
N
N    if( xSemaphore != NULL )
N    {
N        // The semaphore was created successfully.
N        // The semaphore can now be used.
N    }
N }
N </pre>
N * \defgroup xSemaphoreCreateCounting xSemaphoreCreateCounting
N * \ingroup Semaphores
N */
N #define configSUPPORT_DYNAMIC_ALLOCATION 1 
N#if( configSUPPORT_DYNAMIC_ALLOCATION == 1 )
X#if( 1 == 1 )
N	#define xSemaphoreCreateCounting( uxMaxCount, uxInitialCount ) xQueueCreateCountingSemaphore( ( uxMaxCount ), ( uxInitialCount ) )
N#endif
N
N/**
N * semphr. h
N * <pre>SemaphoreHandle_t xSemaphoreCreateCountingStatic( UBaseType_t uxMaxCount, UBaseType_t uxInitialCount, StaticSemaphore_t *pxSemaphoreBuffer )</pre>
N *
N * Creates a new counting semaphore instance, and returns a handle by which the
N * new counting semaphore can be referenced.
N *
N * In many usage scenarios it is faster and more memory efficient to use a
N * direct to task notification in place of a counting semaphore!
N * http://www.freertos.org/RTOS-task-notifications.html
N *
N * Internally, within the FreeRTOS implementation, counting semaphores use a
N * block of memory, in which the counting semaphore structure is stored.  If a
N * counting semaphore is created using xSemaphoreCreateCounting() then the
N * required memory is automatically dynamically allocated inside the
N * xSemaphoreCreateCounting() function.  (see
N * http://www.freertos.org/a00111.html).  If a counting semaphore is created
N * using xSemaphoreCreateCountingStatic() then the application writer must
N * provide the memory.  xSemaphoreCreateCountingStatic() therefore allows a
N * counting semaphore to be created without using any dynamic memory allocation.
N *
N * Counting semaphores are typically used for two things:
N *
N * 1) Counting events.
N *
N *    In this usage scenario an event handler will 'give' a semaphore each time
N *    an event occurs (incrementing the semaphore count value), and a handler
N *    task will 'take' a semaphore each time it processes an event
N *    (decrementing the semaphore count value).  The count value is therefore
N *    the difference between the number of events that have occurred and the
N *    number that have been processed.  In this case it is desirable for the
N *    initial count value to be zero.
N *
N * 2) Resource management.
N *
N *    In this usage scenario the count value indicates the number of resources
N *    available.  To obtain control of a resource a task must first obtain a
N *    semaphore - decrementing the semaphore count value.  When the count value
N *    reaches zero there are no free resources.  When a task finishes with the
N *    resource it 'gives' the semaphore back - incrementing the semaphore count
N *    value.  In this case it is desirable for the initial count value to be
N *    equal to the maximum count value, indicating that all resources are free.
N *
N * @param uxMaxCount The maximum count value that can be reached.  When the
N *        semaphore reaches this value it can no longer be 'given'.
N *
N * @param uxInitialCount The count value assigned to the semaphore when it is
N *        created.
N *
N * @param pxSemaphoreBuffer Must point to a variable of type StaticSemaphore_t,
N * which will then be used to hold the semaphore's data structure, removing the
N * need for the memory to be allocated dynamically.
N *
N * @return If the counting semaphore was successfully created then a handle to
N * the created counting semaphore is returned.  If pxSemaphoreBuffer was NULL
N * then NULL is returned.
N *
N * Example usage:
N <pre>
N SemaphoreHandle_t xSemaphore;
N StaticSemaphore_t xSemaphoreBuffer;
N
N void vATask( void * pvParameters )
N {
N SemaphoreHandle_t xSemaphore = NULL;
N
N    // Counting semaphore cannot be used before they have been created.  Create
N    // a counting semaphore using xSemaphoreCreateCountingStatic().  The max
N    // value to which the semaphore can count is 10, and the initial value
N    // assigned to the count will be 0.  The address of xSemaphoreBuffer is
N    // passed in and will be used to hold the semaphore structure, so no dynamic
N    // memory allocation will be used.
N    xSemaphore = xSemaphoreCreateCounting( 10, 0, &xSemaphoreBuffer );
N
N    // No memory allocation was attempted so xSemaphore cannot be NULL, so there
N    // is no need to check its value.
N }
N </pre>
N * \defgroup xSemaphoreCreateCountingStatic xSemaphoreCreateCountingStatic
N * \ingroup Semaphores
N */
N#if( configSUPPORT_STATIC_ALLOCATION == 1 )
X#if( 0 == 1 )
S	#define xSemaphoreCreateCountingStatic( uxMaxCount, uxInitialCount, pxSemaphoreBuffer ) xQueueCreateCountingSemaphoreStatic( ( uxMaxCount ), ( uxInitialCount ), ( pxSemaphoreBuffer ) )
N#endif /* configSUPPORT_STATIC_ALLOCATION */
N
N/**
N * semphr. h
N * <pre>void vSemaphoreDelete( SemaphoreHandle_t xSemaphore );</pre>
N *
N * Delete a semaphore.  This function must be used with care.  For example,
N * do not delete a mutex type semaphore if the mutex is held by a task.
N *
N * @param xSemaphore A handle to the semaphore to be deleted.
N *
N * \defgroup vSemaphoreDelete vSemaphoreDelete
N * \ingroup Semaphores
N */
N#define vSemaphoreDelete( xSemaphore ) vQueueDelete( ( QueueHandle_t ) ( xSemaphore ) )
N
N/**
N * semphr.h
N * <pre>TaskHandle_t xSemaphoreGetMutexHolder( SemaphoreHandle_t xMutex );</pre>
N *
N * If xMutex is indeed a mutex type semaphore, return the current mutex holder.
N * If xMutex is not a mutex type semaphore, or the mutex is available (not held
N * by a task), return NULL.
N *
N * Note: This is a good way of determining if the calling task is the mutex
N * holder, but not a good way of determining the identity of the mutex holder as
N * the holder may change between the function exiting and the returned value
N * being tested.
N */
N#define xSemaphoreGetMutexHolder( xSemaphore ) xQueueGetMutexHolder( ( xSemaphore ) )
N
N/**
N * semphr.h
N * <pre>UBaseType_t uxSemaphoreGetCount( SemaphoreHandle_t xSemaphore );</pre>
N *
N * If the semaphore is a counting semaphore then uxSemaphoreGetCount() returns
N * its current count value.  If the semaphore is a binary semaphore then
N * uxSemaphoreGetCount() returns 1 if the semaphore is available, and 0 if the
N * semaphore is not available.
N *
N */
N#define uxSemaphoreGetCount( xSemaphore ) uxQueueMessagesWaiting( ( QueueHandle_t ) ( xSemaphore ) )
N
N#endif /* SEMAPHORE_H */
N
N
L 39 "..\..\User\main.c" 2
N//C¿â
N#include <string.h>
N#include <stdio.h>
N//#define heap_size_check 
Nenum net_status Net_status;
Nextern uint8_t Ov7725_vsync;
Nextern _Bool photo;
Nvolatile data_Stream data_value;
Nu16 time_count=60;
Nu32 time_secend=0;
N
N///////////////////
NTaskHandle_t NetTask_Handler;
NTaskHandle_t ReceiveCmdTask_Handler;
NTaskHandle_t CheckSensor_Handler;
N
N//////////////////ÈÎÎñÒª·ÖÅäÕ»¿Õ¼ä
N#define Net_Task_Stack 1024//500+
N#define ReceiveCmd_Stack 256//54
N#define CheckSensor_Stack     512
N/////////////////
N#define Net_Task_Prioruty 6
N#define ReceiveCMd_Priority 5
N#define Display_Prioruty   2
N#define CheckSensor_Priority     5
N////////////////////////
Nstatic void ReceiveCmdTask(void *pvParameters);
Nstatic void CheckSensorTask(void *pvParameters);
Nstatic void Net_Task(void *pvParameters);
N
N
Nvoid Hardware_Init()
N{
N	
N	NVIC_PriorityGroupConfig(NVIC_PriorityGroup_2);	//ÖÐ¶Ï¿ØÖÆÆ÷·Ö×éÉèÖÃ
X	NVIC_PriorityGroupConfig(((uint32_t)0x500));	
N	LED_GPIO_Config();
N	OV7725_GPIO_Config();
N	Door_GPIO_Config();
N  //TIM4_PWM_Init();
N  ILI9341_Init();
N	USART_Config();  //µ÷ÊÔ´®¿Ú
N	
N	
N  Camera_Init();
N	M8266_init();//SPI-wifiÄ£¿é
N	printf("wifi init \r\n");
N	Fatfs_Init();  
N	DHT11_Init();
N	Fire_Init();	/*FAtFs¹ÒÔØ*/
N	
N	printf("Hardware init ok\r\n");
N}
N
N
N/**
N  * @brief  Ö÷º¯Êý
N  * @param  ÎÞ  
N  * @retval ÎÞ
N  */
Nint main(void) 	
N{		
N	Hardware_Init();
N		
N	
N	/* Òº¾§³õÊ¼»¯ */
N	while(OneNet_DevLink())			//½ÓÈëOneNET
N	mDelay(500);
N	Net_status=Conneted;
N	LED_BLUE;  
X	{((GPIO_TypeDef *) ((((uint32_t)0x40000000) + 0x10000) + 0x0C00))->BSRR=((uint16_t)0x0020);}; {((GPIO_TypeDef *) ((((uint32_t)0x40000000) + 0x10000) + 0x0C00))->BSRR=((uint16_t)0x0001);} {((GPIO_TypeDef *) ((((uint32_t)0x40000000) + 0x10000) + 0x0C00))->BRR=((uint16_t)0x0002);};  
N  Camera_Set_Test();
N	CameraFous();	
N	Camera_Set();
N	ILI9341_DispStringLine_EN(LINE(0),"      Intelligent-Security-System");
X	ILI9341_DispStringLine_EN(((0) * (((sFONT *)LCD_GetFont())->Height)),"      Intelligent-Security-System");
N	printf("start TASK\r\n");
N	xTaskCreate((TaskFunction_t)ReceiveCmdTask,"ReceiveCmdTask",ReceiveCmd_Stack,"ReceiveCmdTask",ReceiveCMd_Priority,&ReceiveCmdTask_Handler);
X	xTaskCreate((TaskFunction_t)ReceiveCmdTask,"ReceiveCmdTask",256,"ReceiveCmdTask",5,&ReceiveCmdTask_Handler);
N	xTaskCreate((TaskFunction_t)Net_Task,"Net_Task",Net_Task_Stack,"Net_Task",Net_Task_Prioruty,&NetTask_Handler);
X	xTaskCreate((TaskFunction_t)Net_Task,"Net_Task",1024,"Net_Task",6,&NetTask_Handler);
N	xTaskCreate((TaskFunction_t)CheckSensorTask,"Check_Task",CheckSensor_Stack,"Check_Task",CheckSensor_Priority,&CheckSensor_Handler);
X	xTaskCreate((TaskFunction_t)CheckSensorTask,"Check_Task",512,"Check_Task",5,&CheckSensor_Handler);
N
N	//     xTaskCreate((TaskFunction_t)DisplayTask,"Display",Display_Stack,"Display",Display_Prioruty,&Display_Handler);
N	vTaskStartScheduler();
N
N}
N
N///////////////////////////////////////////////////////////////
N//
N//
N//ÈÎÎñ´´½¨
N///////////////////////////
N
N//¼ì²éÍøÂç
Nvoid CheckNetWork_Task()
N{			  
N	Net_status=(enum net_status)M8266_NetCheck(); //¼ì²éwifiÄ£¿éµÄÍøÂç×´Ì¬
N
N
N			if( Net_status!=Conneted)
N			{
N				M8266_ReLink(Net_status);		
N			}
N	
N}
N
N
N//´¦ÀíÏÂ·¢µÄÃüÁî
Nstatic void ReceiveCmdTask(void *pvParameters) 
N{
N	while(1)
N	{			
N		if(OneNET_CmdHandle())
N		{
N		//	NET_Event_CallBack(NET_EVENT_Send_Data);//¸üÐÂÆ½Ì¨Êý¾Ý
N		}
N	
N		vTaskDelay(400/portTICK_RATE_MS);
X		vTaskDelay(400/( ( TickType_t ) 1000 / ( ( TickType_t ) 1000 ) ));
N	}
N}
N
Nstatic void CheckSensorTask(void *pvParameters) 
N{
N	while(1)
N	{
N		char display[10];
N		taskENTER_CRITICAL(); //½ûÖ¹ÖÐ¶Ï
X		vPortEnterCritical(); 
N		time_secend++;		
N		Check_sensor(&data_value);
N		taskEXIT_CRITICAL();	
X		vPortExitCritical();	
N		
N		if(Net_status==Conneted)
N		ILI9341_DispStringLine_EN(LINE(3),"Online!");
X		ILI9341_DispStringLine_EN(((3) * (((sFONT *)LCD_GetFont())->Height)),"Online!");
N		else if(Net_status==Closed)
N		{
N		ILI9341_DispStringLine_EN(LINE(3),"Check wifi!");
X		ILI9341_DispStringLine_EN(((3) * (((sFONT *)LCD_GetFont())->Height)),"Check wifi!");
N		}
N		else if(Net_status==Lost)
N		{
N		ILI9341_DispStringLine_EN(LINE(3),"Check service!");
X		ILI9341_DispStringLine_EN(((3) * (((sFONT *)LCD_GetFont())->Height)),"Check service!");
N
N		}
N		sprintf(display,"hour:%d:min:%d:sec:%d",time_secend/3600,(time_secend/60)%60,time_secend%60);
N		ILI9341_DispStringLine_EN(LINE(2),display);	
X		ILI9341_DispStringLine_EN(((2) * (((sFONT *)LCD_GetFont())->Height)),display);	
N		sprintf(display,"HUM:%d",data_value.humidit);
N		ILI9341_DispStringLine_EN(LINE(4),display);	
X		ILI9341_DispStringLine_EN(((4) * (((sFONT *)LCD_GetFont())->Height)),display);	
N		sprintf(display,"TMP:%d",data_value.temp);
N		ILI9341_DispStringLine_EN(LINE(5),display);
X		ILI9341_DispStringLine_EN(((5) * (((sFONT *)LCD_GetFont())->Height)),display);
N		#ifdef heap_size_check
S		printf(" sensor the min free stack size is %d \r\n",(int32_t)uxTaskGetStackHighWaterMark(NULL));
S		printf(" hole free stack size is %d \r\n",(int32_t)xPortGetMinimumEverFreeHeapSize());
N		#endif
N		vTaskDelay(1000/portTICK_RATE_MS);
X		vTaskDelay(1000/( ( TickType_t ) 1000 / ( ( TickType_t ) 1000 ) ));
N	}
N}
N
N
N
Nstatic void DisplayTask(void *pvParameters) 
N{
N	while(1)
N	{
N		
N		vTaskDelay(1000/portTICK_RATE_MS);
X		vTaskDelay(1000/( ( TickType_t ) 1000 / ( ( TickType_t ) 1000 ) ));
N	}
N		
N}
N
N
Nstatic void Net_Task(void *pvParameters)
N{
N	unsigned short data_count=0,photo_count=0,check_count=0;
N	
N	while(1)
N	{
N		
N#ifdef heap_size_check
S		printf(" NET the min free stack size is %d \r\n",(int32_t)uxTaskGetStackHighWaterMark(NULL));
N#endif
N		if(Net_status==Conneted)
N		{
N
N		if(++data_count>=12)   //60s·¢ËÍÒ»´ÎÊý¾Ý
N		{
N			data_count=0;
N			printf("send data");
N			OneNet_SendData(&data_value);
N		}
N	
N		else if(photo==1||photo_count++>=time_count)
N		{
N			photo_count=0;
N			taskENTER_CRITICAL(); //½ûÖ¹ÖÐ¶Ï
X			vPortEnterCritical(); 
N			OneNet_SendPhoto();
N			photo=0;
N			taskEXIT_CRITICAL();			
X			vPortExitCritical();			
N		}
N		else if(++check_count>=20)
N		{			
N			check_count=0;
N			CheckNetWork_Task();
N
N		}
N		
N  }
N	else
N	{
N		M8266_ReLink(Net_status);
N		
N		
N	}
N	vTaskDelay(1000/portTICK_RATE_MS);
X	vTaskDelay(1000/( ( TickType_t ) 1000 / ( ( TickType_t ) 1000 ) ));
N	
N}
N}
N
N
N
N	
N
N
N
N
N/*********************************************END OF FILE**********************/
N
W "..\..\User\main.c" 193 13 function "DisplayTask"  was declared but never referenced
